{"id": "cvdp_agentic_starlight_phoenix_comet_6246", "categories": ["cid016", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "The `aes128_encrypt` module in `rtl` folder performs **AES-128 encryption** by first generating **11 round keys** (one for the initial state and 10 rounds) from the **128-bit cipher key** using a **recursive key expansion process**. It begins by treating the key as **four 32-bit words** (`W[0]` to `W[3]`) and deriving new words using the **previously generated ones**. Every **fourth word (`W[i]`)** undergoes the **key schedule core transformation**, which includes a **byte-wise left rotation (`RotWord`)**, substitution via the **S-box (`SubWord`)**, and XOR of the left-most byte of `SubWord` with a **round constant (`Rcon`)**. The transformed word is XORed with the word from **four positions earlier (`W[i-4]`)** to produce the next word. Each remaining word is generated by XORing the previous word with the word four positions earlier. The key expansion process does not run serially; instead, it **generates the first necessary round keys, allowing encryption to start in parallel** while the remaining keys continue to be derived. This process continues until all **44 words (`W[0]` to `W[43]`)** are generated and grouped into **11 round keys**.\n\n# AES-128 Encryption Overview\n\nThe encryption process begins by **loading the 128-bit plaintext block** into a **4\u00d74 state matrix**, which undergoes **11 transformations** (one for the initial round and 10 for encryption rounds). In the **initial round**, the state is XORed with the first round key.  \n\nEach of the **10 encryption rounds** consists of four main transformations:  \n\n- **SubBytes** \u2013 Replaces each byte using the **AES S-box** to introduce non-linearity.  \n- **ShiftRows** \u2013 Cyclically shifts the rows of the state matrix to introduce diffusion.  \n- **MixColumns** \u2013 Transforms each column of the state matrix by multiplying it with a fixed **GF(2\u2078) polynomial matrix** (over **Rijndael\u2019s finite field**) to diffuse data across bytes. This operation ensures that changes in one byte affect all four bytes of a column.  \n\n  The transformation is defined as a **matrix multiplication** where each column of the state is multiplied by the following constant matrix:\n\n     |  8'h02  |  8'h03  |  8'h01  |  8'h01  |\n     |:-------:|:-------:|:-------:|:-------:|\n     |  8'h01  |  8'h02  |  8'h03  |  8'h01  |\n     |  8'h01  |  8'h01  |  8'h02  |  8'h03  |\n     |  8'h03  |  8'h01  |  8'h01  |  8'h02  |\n\n  ## **Mathematical Basis in GF(2\u2078)**\n  - **Rijndael\u2019s finite field (GF(2\u2078))** is defined by the **irreducible polynomial**: $`x^8 + x^4 + x^3 + x + 1`$ **or** `0x11B` in hexadecimal. This polynomial is used for modular reduction when performing field operations.  \n  - **Addition in GF(2\u2078)** is simply **bitwise XOR**.  \n  - **Multiplication in GF(2\u2078)** follows standard polynomial multiplication, but results are reduced **modulo ($`x^8 + x^4 + x^3 + x + 1`$)** to ensure results stay within the field.  \n  - To implement multiplication by `{02}` (0x02) in hardware, a left shift (`x << 1`) is used, followed by XOR with `0x1B` if the most significant bit was set (to ensure modular reduction).  \n  - Multiplication by `{03}` (0x03) is computed as `{02} \u2295 {01}`, This is expressed as `{03} * x = ({02} * x) \u2295 x`.\n\n  This operation is **skipped in the final round** to maintain proper decryption symmetry.  \n\n- **AddRoundKey** \u2013 XORs the state matrix with the corresponding round key.  \n\nAfter **10 rounds**, the final state matrix is transformed into the **128-bit ciphertext output**, completing the AES-128 encryption process.\n\n\nThe key expansion and the encryption can happen simultaneously, by asserting both `i_start` and `i_update_key`. Also, if the stored expanded key is the one that should be used for the encryption, only an `i_start` signal may be asserted and the key will not be updated.\n\nDuring testing, the module failed to produce the expected output, leading to incorrect results. The `sbox_enc` module and the `Rcon` values were previously tested, and they have no errors.\nThe module and its testbench are available in the current working directory for debugging, and the expected output is available in the testbench. Could you help debug and fix the RTL to ensure correct functionality?\n", "context": {"rtl/aes128_encrypt.sv": "module aes128_encrypt #(\n    parameter NBW_KEY  = 'd128,\n    parameter NBW_DATA = 'd128\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_data,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE   = 'd8;\nlocalparam STEPS      = 'd10;\nlocalparam NBW_WORD   = 'd32;\nlocalparam NBW_EX_KEY = 'd1408;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   Rcon   [STEPS];\nlogic [NBW_KEY-1:0]    valid_key;\nlogic [NBW_KEY-1:0]    step_key[STEPS];\nlogic [NBW_EX_KEY-1:0] expanded_key_nx;\nlogic [NBW_EX_KEY-1:0] expanded_key_ff;\nlogic [NBW_BYTE-1:0]   current_data_nx[4][4];\nlogic [NBW_BYTE-1:0]   current_data_ff[4][4];\nlogic [NBW_BYTE-1:0]   SubBytes[4][4];\nlogic [NBW_BYTE-1:0]   ShiftRows[4][4];\nlogic [NBW_BYTE-1:0]   xtimes02[4][4];\nlogic [NBW_BYTE-1:0]   xtimes03[4][4];\nlogic [NBW_BYTE-1:0]   MixColumns[4][4];\nlogic [3:0] round_ff;\n\nassign o_done = (round_ff == 4'd0);\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : out_row\n        for(genvar j = 0; j < 4; j++) begin : out_col\n            assign o_data[NBW_DATA-(4*i+j)*NBW_BYTE-1-:NBW_BYTE] = current_data_ff[i][j];\n        end\n    end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : cypher_regs\n    if(!rst_async_n) begin\n        round_ff <= 4'd0;\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= 8'd0;\n            end\n        end\n    end else begin\n        if(i_start & o_done || (round_ff > 4'd0 && round_ff < 4'd11)) begin\n            round_ff <= round_ff + 1'b1;\n        end else begin\n            round_ff <= 4'd0;\n        end\n\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= current_data_nx[i][j];\n            end\n        end\n    end\nend\n\nalways_comb begin : next_data\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(i_start & o_done) begin\n                current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] ^ expanded_key_ff[NBW_EX_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n            end else begin\n                if(round_ff > 4'd1) begin\n                    current_data_nx[i][j] = ShiftRows[i][j] + expanded_key_ff[NBW_EX_KEY-(round_ff-1)*NBW_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                end else begin\n                    current_data_nx[i][j] = current_data_ff[i][j];\n                end\n            end\n        end\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : row\n        for(genvar j = 0; j < 4; j++) begin : col\n            sbox_enc uu_sbox_enc0 (\n                .i_data(current_data_ff[i][j]),\n                .o_data(SubBytes[i][j])\n            );\n        end\n    end\nendgenerate\n\nalways_comb begin : cypher_logic\n    // Shift Rows logic\n    // Line 0: No shift\n    ShiftRows[0][0] = SubBytes[0][0];\n    ShiftRows[0][1] = SubBytes[0][1];\n    ShiftRows[0][2] = SubBytes[0][2];\n    ShiftRows[0][3] = SubBytes[0][3];\n\n    // Line 1: Shift 1 left\n    ShiftRows[1][0] = SubBytes[1][1];\n    ShiftRows[1][1] = SubBytes[1][2];\n    ShiftRows[1][2] = SubBytes[1][3];\n    ShiftRows[1][3] = SubBytes[1][0];\n\n    // Line 2: Shift 2 left\n    ShiftRows[2][0] = SubBytes[2][2];\n    ShiftRows[2][1] = SubBytes[2][3];\n    ShiftRows[2][2] = SubBytes[2][0];\n    ShiftRows[2][3] = SubBytes[2][1];\n\n    // Line 3: Shift 3 left\n    ShiftRows[3][0] = SubBytes[3][3];\n    ShiftRows[3][1] = SubBytes[3][0];\n    ShiftRows[3][2] = SubBytes[3][1];\n    ShiftRows[3][3] = SubBytes[3][2];\n\n    // Mix Columns logic\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            xtimes02[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} + 8'h1B;\n            xtimes03[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} + 8'h1B + ShiftRows[i][j];\n        end\n\n        MixColumns[0][i] = xtimes02[0][i] + xtimes03[1][i] + ShiftRows[2][i] + ShiftRows[3][i];\n        MixColumns[1][i] = xtimes02[1][i] + xtimes03[2][i] + ShiftRows[3][i] + ShiftRows[0][i];\n        MixColumns[2][i] = xtimes02[2][i] + xtimes03[3][i] + ShiftRows[0][i] + ShiftRows[1][i];\n        MixColumns[3][i] = xtimes02[3][i] + xtimes03[0][i] + ShiftRows[1][i] + ShiftRows[2][i];\n    end\nend\n\n// ****************************************\n// - Key Expansion logic\n// ****************************************\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        expanded_key_ff <= {NBW_EX_KEY{1'b0}};\n    end else begin\n        expanded_key_ff <= expanded_key_nx;\n    end\nend\n\n// ----------------------------------------\n// - Operation logic\n// ----------------------------------------\nassign Rcon[0] = 8'h01;\nassign Rcon[1] = 8'h02;\nassign Rcon[2] = 8'h04;\nassign Rcon[3] = 8'h08;\nassign Rcon[4] = 8'h10;\nassign Rcon[5] = 8'h20;\nassign Rcon[6] = 8'h40;\nassign Rcon[7] = 8'h80;\nassign Rcon[8] = 8'h1b;\nassign Rcon[9] = 8'h36;\n\ngenerate\n    for(genvar i = 0; i < STEPS; i++) begin : steps\n        logic [NBW_WORD-1:0] RotWord;\n        logic [NBW_WORD-1:0] SubWord;\n        logic [NBW_WORD-1:0] RconXor;\n\n        sbox_enc uu_sbox_enc0 (\n            .i_data(RotWord[NBW_WORD-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        sbox_enc uu_sbox_enc1 (\n            .i_data(RotWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        sbox_enc uu_sbox_enc2 (\n            .i_data(RotWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        sbox_enc uu_sbox_enc3 (\n            .i_data(RotWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n        );\n\n        always_comb begin : main_operation\n            RotWord = {expanded_key_ff[NBW_EX_KEY-(i+1)*NBW_KEY+NBW_WORD-1-:NBW_BYTE], expanded_key_ff[NBW_EX_KEY-(i+1)*NBW_KEY+NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)]};\n            RconXor = {SubWord[NBW_WORD-1-:(NBW_WORD-NBW_BYTE)], SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE] ^ Rcon[i]};\n\n            step_key[i][NBW_KEY-1-:NBW_WORD]            = expanded_key_ff[NBW_EX_KEY-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ RconXor;\n            step_key[i][NBW_KEY-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_EX_KEY-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-1-:NBW_WORD];\n            step_key[i][NBW_KEY-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-NBW_WORD-1-:NBW_WORD];\n            step_key[i][NBW_KEY-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-2*NBW_WORD-1-:NBW_WORD];\n        end\n    end\nendgenerate\n\nassign expanded_key_nx = {valid_key  , step_key[0], step_key[1], step_key[2],\n                          step_key[3], step_key[4], step_key[5], step_key[6],\n                          step_key[7], step_key[8], step_key[9]};\n\nalways_comb begin : input_data\n    if (i_update_key & o_done) begin\n        valid_key = i_key;\n    end else begin\n        valid_key = expanded_key_ff[NBW_KEY-1:0];\n    end\nend\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\n\nendmodule : aes128_encrypt\n\nmodule sbox_enc (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h63;\n        8'h01: o_data = 8'h7C;\n        8'h02: o_data = 8'h77;\n        8'h03: o_data = 8'h7B;\n        8'h04: o_data = 8'hF2;\n        8'h05: o_data = 8'h6B;\n        8'h06: o_data = 8'h6F;\n        8'h07: o_data = 8'hC5;\n        8'h08: o_data = 8'h30;\n        8'h09: o_data = 8'h01;\n        8'h0A: o_data = 8'h67;\n        8'h0B: o_data = 8'h2B;\n        8'h0C: o_data = 8'hFE;\n        8'h0D: o_data = 8'hD7;\n        8'h0E: o_data = 8'hAB;\n        8'h0F: o_data = 8'h76;\n        8'h10: o_data = 8'hCA;\n        8'h11: o_data = 8'h82;\n        8'h12: o_data = 8'hC9;\n        8'h13: o_data = 8'h7D;\n        8'h14: o_data = 8'hFA;\n        8'h15: o_data = 8'h59;\n        8'h16: o_data = 8'h47;\n        8'h17: o_data = 8'hF0;\n        8'h18: o_data = 8'hAD;\n        8'h19: o_data = 8'hD4;\n        8'h1A: o_data = 8'hA2;\n        8'h1B: o_data = 8'hAF;\n        8'h1C: o_data = 8'h9C;\n        8'h1D: o_data = 8'hA4;\n        8'h1E: o_data = 8'h72;\n        8'h1F: o_data = 8'hC0;\n        8'h20: o_data = 8'hB7;\n        8'h21: o_data = 8'hFD;\n        8'h22: o_data = 8'h93;\n        8'h23: o_data = 8'h26;\n        8'h24: o_data = 8'h36;\n        8'h25: o_data = 8'h3F;\n        8'h26: o_data = 8'hF7;\n        8'h27: o_data = 8'hCC;\n        8'h28: o_data = 8'h34;\n        8'h29: o_data = 8'hA5;\n        8'h2A: o_data = 8'hE5;\n        8'h2B: o_data = 8'hF1;\n        8'h2C: o_data = 8'h71;\n        8'h2D: o_data = 8'hD8;\n        8'h2E: o_data = 8'h31;\n        8'h2F: o_data = 8'h15;\n        8'h30: o_data = 8'h04;\n        8'h31: o_data = 8'hC7;\n        8'h32: o_data = 8'h23;\n        8'h33: o_data = 8'hC3;\n        8'h34: o_data = 8'h18;\n        8'h35: o_data = 8'h96;\n        8'h36: o_data = 8'h05;\n        8'h37: o_data = 8'h9A;\n        8'h38: o_data = 8'h07;\n        8'h39: o_data = 8'h12;\n        8'h3A: o_data = 8'h80;\n        8'h3B: o_data = 8'hE2;\n        8'h3C: o_data = 8'hEB;\n        8'h3D: o_data = 8'h27;\n        8'h3E: o_data = 8'hB2;\n        8'h3F: o_data = 8'h75;\n        8'h40: o_data = 8'h09;\n        8'h41: o_data = 8'h83;\n        8'h42: o_data = 8'h2C;\n        8'h43: o_data = 8'h1A;\n        8'h44: o_data = 8'h1B;\n        8'h45: o_data = 8'h6E;\n        8'h46: o_data = 8'h5A;\n        8'h47: o_data = 8'hA0;\n        8'h48: o_data = 8'h52;\n        8'h49: o_data = 8'h3B;\n        8'h4A: o_data = 8'hD6;\n        8'h4B: o_data = 8'hB3;\n        8'h4C: o_data = 8'h29;\n        8'h4D: o_data = 8'hE3;\n        8'h4E: o_data = 8'h2F;\n        8'h4F: o_data = 8'h84;\n        8'h50: o_data = 8'h53;\n        8'h51: o_data = 8'hD1;\n        8'h52: o_data = 8'h00;\n        8'h53: o_data = 8'hED;\n        8'h54: o_data = 8'h20;\n        8'h55: o_data = 8'hFC;\n        8'h56: o_data = 8'hB1;\n        8'h57: o_data = 8'h5B;\n        8'h58: o_data = 8'h6A;\n        8'h59: o_data = 8'hCB;\n        8'h5A: o_data = 8'hBE;\n        8'h5B: o_data = 8'h39;\n        8'h5C: o_data = 8'h4A;\n        8'h5D: o_data = 8'h4C;\n        8'h5E: o_data = 8'h58;\n        8'h5F: o_data = 8'hCF;\n        8'h60: o_data = 8'hD0;\n        8'h61: o_data = 8'hEF;\n        8'h62: o_data = 8'hAA;\n        8'h63: o_data = 8'hFB;\n        8'h64: o_data = 8'h43;\n        8'h65: o_data = 8'h4D;\n        8'h66: o_data = 8'h33;\n        8'h67: o_data = 8'h85;\n        8'h68: o_data = 8'h45;\n        8'h69: o_data = 8'hF9;\n        8'h6A: o_data = 8'h02;\n        8'h6B: o_data = 8'h7F;\n        8'h6C: o_data = 8'h50;\n        8'h6D: o_data = 8'h3C;\n        8'h6E: o_data = 8'h9F;\n        8'h6F: o_data = 8'hA8;\n        8'h70: o_data = 8'h51;\n        8'h71: o_data = 8'hA3;\n        8'h72: o_data = 8'h40;\n        8'h73: o_data = 8'h8F;\n        8'h74: o_data = 8'h92;\n        8'h75: o_data = 8'h9D;\n        8'h76: o_data = 8'h38;\n        8'h77: o_data = 8'hF5;\n        8'h78: o_data = 8'hBC;\n        8'h79: o_data = 8'hB6;\n        8'h7A: o_data = 8'hDA;\n        8'h7B: o_data = 8'h21;\n        8'h7C: o_data = 8'h10;\n        8'h7D: o_data = 8'hFF;\n        8'h7E: o_data = 8'hF3;\n        8'h7F: o_data = 8'hD2;\n        8'h80: o_data = 8'hCD;\n        8'h81: o_data = 8'h0C;\n        8'h82: o_data = 8'h13;\n        8'h83: o_data = 8'hEC;\n        8'h84: o_data = 8'h5F;\n        8'h85: o_data = 8'h97;\n        8'h86: o_data = 8'h44;\n        8'h87: o_data = 8'h17;\n        8'h88: o_data = 8'hC4;\n        8'h89: o_data = 8'hA7;\n        8'h8A: o_data = 8'h7E;\n        8'h8B: o_data = 8'h3D;\n        8'h8C: o_data = 8'h64;\n        8'h8D: o_data = 8'h5D;\n        8'h8E: o_data = 8'h19;\n        8'h8F: o_data = 8'h73;\n        8'h90: o_data = 8'h60;\n        8'h91: o_data = 8'h81;\n        8'h92: o_data = 8'h4F;\n        8'h93: o_data = 8'hDC;\n        8'h94: o_data = 8'h22;\n        8'h95: o_data = 8'h2A;\n        8'h96: o_data = 8'h90;\n        8'h97: o_data = 8'h88;\n        8'h98: o_data = 8'h46;\n        8'h99: o_data = 8'hEE;\n        8'h9A: o_data = 8'hB8;\n        8'h9B: o_data = 8'h14;\n        8'h9C: o_data = 8'hDE;\n        8'h9D: o_data = 8'h5E;\n        8'h9E: o_data = 8'h0B;\n        8'h9F: o_data = 8'hDB;\n        8'hA0: o_data = 8'hE0;\n        8'hA1: o_data = 8'h32;\n        8'hA2: o_data = 8'h3A;\n        8'hA3: o_data = 8'h0A;\n        8'hA4: o_data = 8'h49;\n        8'hA5: o_data = 8'h06;\n        8'hA6: o_data = 8'h24;\n        8'hA7: o_data = 8'h5C;\n        8'hA8: o_data = 8'hC2;\n        8'hA9: o_data = 8'hD3;\n        8'hAA: o_data = 8'hAC;\n        8'hAB: o_data = 8'h62;\n        8'hAC: o_data = 8'h91;\n        8'hAD: o_data = 8'h95;\n        8'hAE: o_data = 8'hE4;\n        8'hAF: o_data = 8'h79;\n        8'hB0: o_data = 8'hE7;\n        8'hB1: o_data = 8'hC8;\n        8'hB2: o_data = 8'h37;\n        8'hB3: o_data = 8'h6D;\n        8'hB4: o_data = 8'h8D;\n        8'hB5: o_data = 8'hD5;\n        8'hB6: o_data = 8'h4E;\n        8'hB7: o_data = 8'hA9;\n        8'hB8: o_data = 8'h6C;\n        8'hB9: o_data = 8'h56;\n        8'hBA: o_data = 8'hF4;\n        8'hBB: o_data = 8'hEA;\n        8'hBC: o_data = 8'h65;\n        8'hBD: o_data = 8'h7A;\n        8'hBE: o_data = 8'hAE;\n        8'hBF: o_data = 8'h08;\n        8'hC0: o_data = 8'hBA;\n        8'hC1: o_data = 8'h78;\n        8'hC2: o_data = 8'h25;\n        8'hC3: o_data = 8'h2E;\n        8'hC4: o_data = 8'h1C;\n        8'hC5: o_data = 8'hA6;\n        8'hC6: o_data = 8'hB4;\n        8'hC7: o_data = 8'hC6;\n        8'hC8: o_data = 8'hE8;\n        8'hC9: o_data = 8'hDD;\n        8'hCA: o_data = 8'h74;\n        8'hCB: o_data = 8'h1F;\n        8'hCC: o_data = 8'h4B;\n        8'hCD: o_data = 8'hBD;\n        8'hCE: o_data = 8'h8B;\n        8'hCF: o_data = 8'h8A;\n        8'hD0: o_data = 8'h70;\n        8'hD1: o_data = 8'h3E;\n        8'hD2: o_data = 8'hB5;\n        8'hD3: o_data = 8'h66;\n        8'hD4: o_data = 8'h48;\n        8'hD5: o_data = 8'h03;\n        8'hD6: o_data = 8'hF6;\n        8'hD7: o_data = 8'h0E;\n        8'hD8: o_data = 8'h61;\n        8'hD9: o_data = 8'h35;\n        8'hDA: o_data = 8'h57;\n        8'hDB: o_data = 8'hB9;\n        8'hDC: o_data = 8'h86;\n        8'hDD: o_data = 8'hC1;\n        8'hDE: o_data = 8'h1D;\n        8'hDF: o_data = 8'h9E;\n        8'hE0: o_data = 8'hE1;\n        8'hE1: o_data = 8'hF8;\n        8'hE2: o_data = 8'h98;\n        8'hE3: o_data = 8'h11;\n        8'hE4: o_data = 8'h69;\n        8'hE5: o_data = 8'hD9;\n        8'hE6: o_data = 8'h8E;\n        8'hE7: o_data = 8'h94;\n        8'hE8: o_data = 8'h9B;\n        8'hE9: o_data = 8'h1E;\n        8'hEA: o_data = 8'h87;\n        8'hEB: o_data = 8'hE9;\n        8'hEC: o_data = 8'hCE;\n        8'hED: o_data = 8'h55;\n        8'hEE: o_data = 8'h28;\n        8'hEF: o_data = 8'hDF;\n        8'hF0: o_data = 8'h8C;\n        8'hF1: o_data = 8'hA1;\n        8'hF2: o_data = 8'h89;\n        8'hF3: o_data = 8'h0D;\n        8'hF4: o_data = 8'hBF;\n        8'hF5: o_data = 8'hE6;\n        8'hF6: o_data = 8'h42;\n        8'hF7: o_data = 8'h68;\n        8'hF8: o_data = 8'h41;\n        8'hF9: o_data = 8'h99;\n        8'hFA: o_data = 8'h2D;\n        8'hFB: o_data = 8'h0F;\n        8'hFC: o_data = 8'hB0;\n        8'hFD: o_data = 8'h54;\n        8'hFE: o_data = 8'hBB;\n        8'hFF: o_data = 8'h16;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : sbox_enc\n", "verif/tb_aes128_enc.sv": "module tb_aes128_enc;\n\nlocalparam NBW_KEY  = 'd128;\nlocalparam NBW_DATA = 'd128;\n\nlogic                clk;\nlogic                rst_async_n;\nlogic                i_update_key;\nlogic [NBW_KEY-1:0]  i_key;\nlogic                i_start;\nlogic [NBW_DATA-1:0] i_data;\nlogic                o_done;\nlogic [NBW_DATA-1:0] o_data;\n\naes128_encrypt #(\n    .NBW_KEY(NBW_KEY),\n    .NBW_DATA(NBW_DATA)\n) uu_aes128_encrypt (\n    .clk(clk),\n    .rst_async_n(rst_async_n),\n    .i_update_key(i_update_key),\n    .i_key(i_key),\n    .i_start(i_start),\n    .i_data(i_data),\n    .o_done(o_done),\n    .o_data(o_data)\n);\n\ntask Simple_test(logic update_key);\n    @(negedge clk);\n    i_key = 128'h2b7e151628aed2a6abf7158809cf4f3c;\n    i_data = 128'h3243f6a8885a308d313198a2e0370734;\n    i_update_key = update_key;\n    i_start = 1;\n\n    @(negedge clk);\n    i_start = 0;\n    i_update_key = 0;\n    i_key = 0;\n\n    @(posedge o_done);\n    @(negedge clk);\n\n    if(o_data == 128'h3925841d02dc09fbdc118597196a0b32) begin\n        $display(\"PASS\");\n    end else begin\n        $display(\"FAIL\");\n        $display(\"Expected output: %h\", 128'h3925841d02dc09fbdc118597196a0b32);\n        $display(\"Observed output: %h\", o_data);\n    end\nendtask\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb_aes128_enc);\nend\n\nalways #5 clk = ~clk;\n\ninitial begin\n    clk = 0;\n    i_start = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    // Tasks go here\n    Simple_test(1'b1);\n    Simple_test(1'b0);\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/aes128_encrypt.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n", "src/.env": "VERILOG_SOURCES = /code/rtl/aes128_encrypt.sv \nTOPLEVEL        = aes128_encrypt\nMODULE          = test_aes128_encrypt\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 3-debug-and-fix-aes128_encrypt\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass aes128_encrypt:\n    # AES S-Box\n    S_BOX = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n    \n    # AES Rcon (Round constants)\n    RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]\n\n    def __init__(self):\n        self.expanded_key = [0] * 44\n        self.data = 0\n    \n    def reset(self):\n        self.expanded_key = [0] * 44\n        self.data = 0\n\n    def sub_word(self, word):\n        return (self.S_BOX[(word >> 24) & 0xFF] << 24) |\\\n               (self.S_BOX[(word >> 16) & 0xFF] << 16) |\\\n               (self.S_BOX[(word >> 8) & 0xFF] << 8) |\\\n               (self.S_BOX[word & 0xFF])\n\n    def rot_word(self, word):\n        return ((word << 8) & 0xFFFFFFFF) | (word >> 24)\n\n    def update_key(self, key):\n        assert 0 <= key < (1 << 128), \"Key must be a 128-bit integer.\"\n        \n        for i in range(4):\n            self.expanded_key[i] = (key >> (96 - i * 32)) & 0xFFFFFFFF\n        \n        for i in range(4, 44):\n            temp = self.expanded_key[i - 1]\n            if i % 4 == 0:\n                temp = self.sub_word(self.rot_word(temp)) ^ (self.RCON[i // 4] << 24)\n            self.expanded_key[i] = self.expanded_key[i - 4] ^ temp\n\n    def update(self, data):\n        assert 0 <= data < (1 << 128), \"Data must be a 128-bit integer.\"\n        \n        # Convert data to 4x4 state matrix (column-major order)\n        state = [[(data >> (120 - 8 * (i + 4 * j))) & 0xFF for j in range(4)] for i in range(4)]\n\n        # Initial AddRoundKey\n        self.add_round_key(state, 0)\n\n        # 9 main rounds\n        for round in range(1, 10):\n            self.sub_bytes(state)\n            self.shift_rows(state)\n            self.mix_columns(state)\n            self.add_round_key(state, round)\n\n        # Final round (no MixColumns)\n        self.sub_bytes(state)\n        self.shift_rows(state)\n        self.add_round_key(state, 10)\n\n        # Convert state matrix back to 128-bit integer\n        encrypted_data = 0\n        for j in range(4):\n            for i in range(4):\n                encrypted_data = (encrypted_data << 8) | state[i][j]\n        \n        self.data = encrypted_data\n\n    def add_round_key(self, state, round):\n        for j in range(4):\n            word = self.expanded_key[round * 4 + j]\n            for i in range(4):\n                state[i][j] ^= (word >> (24 - 8 * i)) & 0xFF\n\n    def sub_bytes(self, state):\n        for i in range(4):\n            for j in range(4):\n                state[i][j] = self.S_BOX[state[i][j]]\n\n    def shift_rows(self, state):\n        state[1][0], state[1][1], state[1][2], state[1][3] = state[1][1], state[1][2], state[1][3], state[1][0]\n        state[2][0], state[2][1], state[2][2], state[2][3] = state[2][2], state[2][3], state[2][0], state[2][1]\n        state[3][0], state[3][1], state[3][2], state[3][3] = state[3][3], state[3][0], state[3][1], state[3][2]\n\n    def mix_columns(self, state):\n        for j in range(4):\n            a = state[0][j], state[1][j], state[2][j], state[3][j]\n            t = a[0] ^ a[1] ^ a[2] ^ a[3]\n            u = a[0]\n            state[0][j] ^= t ^ self.xtime(a[0] ^ a[1])\n            state[1][j] ^= t ^ self.xtime(a[1] ^ a[2])\n            state[2][j] ^= t ^ self.xtime(a[2] ^ a[3])\n            state[3][j] ^= t ^ self.xtime(a[3] ^ u)\n\n    def xtime(self, x):\n        return ((x << 1) ^ 0x1B) & 0xFF if x & 0x80 else x << 1\n", "src/test_aes128_encrypt.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_data.value.to_unsigned()\n\n    model_data = model.data\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_aes128_encrypt(dut):\n    \"\"\"Test the aes128_encrypt module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.aes128_encrypt()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**128 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_start.value      = 0\n        dut.i_update_key.value = 0\n        dut.i_key.value        = 0\n        dut.i_data.value       = 0\n        dut.rst_async_n.value  = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value  = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        for j in range(runs):\n            key = random.randint(data_min, data_max)\n            data = random.randint(data_min, data_max)\n            if j == 0:\n                update_key = 1\n            else:\n                update_key = random.randint(0,1)\n\n            dut.i_update_key.value = update_key\n            dut.i_key.value        = key\n            dut.i_data.value       = data\n            dut.i_start.value      = 1\n\n            if update_key:\n                model.update_key(key)\n            \n            model.update(data)\n\n            await RisingEdge(dut.clk)\n            dut.i_start.value = 0\n            dut.i_key.value   = 0\n            dut.i_update_key.value = 0\n            dut.i_data.value       = 0\n            await RisingEdge(dut.clk)\n            while dut.o_done.value == 0:\n                await RisingEdge(dut.clk)\n\n            compare_values(dut, model)\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()"}}
{"id": "cvdp_agentic_glacier_amber_cosmic_3144", "categories": ["cid016", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "The `aes128_decrypt` module in the `rtl` folder performs **AES-128 decryption** by first using the `aes128_key_expansion` module to generate **11 round keys** (one for the initial state and 10 rounds) from the **128-bit cipher key** using a **recursive key expansion process**. It begins by treating the key as **four 32-bit words** (`W[0]` to `W[3]`) and deriving new words using the **previously generated ones**. Every **fourth word (`W[i]`)** undergoes the **key schedule core transformation**, which includes a **byte-wise left rotation (`RotWord`)**, substitution via the **S-box (`SubWord`)**, and XOR of the left-most byte of `SubWord` with a **round constant (`Rcon`)**. The transformed word is XORed with the word from **four positions earlier (`W[i-4]`)** to produce the next word. Each remaining word is generated by XORing the previous word with the word four positions earlier. The key expansion process runs serially, that is, if a key update is required, it first needs to expand it so only then can it perform the decryption operation. This process continues until all **44 words (`W[0]` to `W[43]`)** are generated and grouped into **11 round keys**.\n\n# AES-128 Decryption Overview\n\nAES-128 decryption operation is done in the `aes128_decrypt` module and it is a process that **recovers the original plaintext** from a **128-bit ciphertext** by applying a series of transformations. The **ciphertext** is loaded into a **4\u00d74 state matrix**, which undergoes **11 transformations** (one initial AddRoundKey step and 10 decryption rounds).  \n\n## **Decryption Process**\n\n1. **Initial Step**:  \n   - **AddRoundKey** \u2013 The state matrix is XORed with a round key derived from the original secret key (cipher key).  \n\n2. **9 Main Decryption Rounds** (Repeated 9 times):  \n   - **InvShiftRows** \u2013 The last three rows of the state matrix are **cyclically shifted to the right** by 1, 2, and 3 bytes, respectively, keeping the first row unchanged.  \n   - **InvSubBytes** \u2013 Each byte in the state is replaced using a **fixed substitution table** known as the **inverse AES S-box**, which maps each byte to a new value in a non-linear way.  \n   - **AddRoundKey** \u2013 The state matrix is XORed with a round key derived from the original secret key.  \n   - **InvMixColumns** \u2013 A mathematical transformation that modifies each column of the state by multiplying it with a fixed **4\u00d74 matrix** in **GF(2\u2078)**, ensuring that the data is spread across multiple bytes.  \n\n3. **Final Round** (10th Round, Without InvMixColumns):  \n   - **InvShiftRows**  \n   - **InvSubBytes**  \n   - **AddRoundKey**  \n\n## **Mathematical Basis of InvMixColumns in GF(2\u2078)**  \n\nTo apply **InvMixColumns**, each column of the state matrix is multiplied by the following **fixed matrix**:\n\n|  8'h0E  |  8'h0B  |  8'h0D  |  8'h09  |\n|:-------:|:-------:|:-------:|:-------:|\n|  8'h09  |  8'h0E  |  8'h0B  |  8'h0D  |\n|  8'h0D  |  8'h09  |  8'h0E  |  8'h0B  |\n|  8'h0B  |  8'h0D  |  8'h09  |  8'h0E  |\n\nThis multiplication follows special rules defined in **GF(2\u2078)** (Galois Field of 256 elements), a mathematical structure that allows modular arithmetic on 8-bit values.\n\n  ## **Mathematical Basis in GF(2\u2078)**\n  - **Rijndael\u2019s finite field (GF(2\u2078))** is defined by the **irreducible polynomial**: $`x^8 + x^4 + x^3 + x + 1`$ **or** `0x11B` in hexadecimal. This polynomial is used for modular reduction when performing field operations.  \n  - **Addition in GF(2\u2078)** is simply **bitwise XOR**.  \n  - **Multiplication in GF(2\u2078)** follows standard polynomial multiplication, but results are reduced **modulo ($`x^8 + x^4 + x^3 + x + 1`$)** to ensure results stay within the field.  \n  - To implement multiplication by `{02}` (0x02) in hardware, a left shift (`x << 1`) is used, followed by XOR with `0x1B` if the most significant bit was set (to ensure modular reduction).  \n  - **Multiplication by constants** follows these rules:  \n    - Multiplication by `{0E}` (0x0E) is computed as `{02} \u2295 {04} \u2295 {08}`  \n    - Multiplication by `{0B}` (0x0B) is computed as `{02} \u2295 {08} \u2295 1`  \n    - Multiplication by `{0D}` (0x0D) is computed as `{04} \u2295 {08} \u2295 1`  \n    - Multiplication by `{09}` (0x09) is computed as `{08} \u2295 1`  \n\n  This operation is **skipped in the final round** to maintain proper decryption symmetry.  \n\n- **AddRoundKey** \u2013 XORs the state matrix with the corresponding round key.  \n\nThese rules ensure that **InvMixColumns** correctly modifies the state matrix so that information from each byte is distributed across multiple columns.\n\n## **Final Decryption Steps**\nAfter **10 decryption rounds**, the state matrix is transformed back into the **128-bit plaintext**, completing the AES-128 decryption process.\n\n---\n\nThe key expansion, when asserted by `i_update_key` and `i_start`, must happen before the decryption algorithm, so the proper key is used in the operation. If the stored expanded key is the one that should be used for the decryption, only an `i_start` signal may be asserted and the key will not be updated.\n\nDuring testing, the module failed to produce the expected output, leading to incorrect results. The `sbox`, `inv_sbox` modules and the `Rcon` values were previously tested, and they have no errors.\nThe modules and the testbench are available in the current working directory for debugging, and the expected output is available in the testbench. Could you help debug and fix the RTL to ensure correct functionality? You can change the interface of internal blocks as you see fit, but you may not change the interface from `aes128_decrypt`.\n", "context": {"rtl/aes128_decrypt.sv": "module aes128_decrypt #(\n    parameter NBW_KEY  = 'd128,\n    parameter NBW_DATA = 'd128\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_data,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE   = 'd8;\nlocalparam NBW_EX_KEY = 'd1408;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   current_data_nx[4][4];\nlogic [NBW_BYTE-1:0]   current_data_ff[4][4];\nlogic [NBW_BYTE-1:0]   AddRoundKey[4][4];\nlogic [NBW_BYTE-1:0]   SubBytes[4][4];\nlogic [NBW_BYTE-1:0]   ShiftRows[4][4];\nlogic [NBW_BYTE-1:0]   xtimes02[4][4];\nlogic [NBW_BYTE-1:0]   xtimes04[4][4];\nlogic [NBW_BYTE-1:0]   xtimes08[4][4];\nlogic [NBW_BYTE-1:0]   xtimes09[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0b[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0d[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0e[4][4];\nlogic [NBW_BYTE-1:0]   MixColumns[4][4];\nlogic                  key_done;\nlogic [3:0]            round_ff;\nlogic [NBW_EX_KEY-1:0] expanded_key;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nassign o_done = (round_ff == 4'd0);\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : out_row\n        for(genvar j = 0; j < 4; j++) begin : out_col\n            assign o_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] = current_data_ff[i][j];\n        end\n    end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : inv_cypher_regs\n    if(!rst_async_n) begin\n        round_ff <= 4'd0;\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= 8'd0;\n            end\n        end\n    end else begin\n        if(i_start & o_done) begin\n            round_ff <= 4'd1;\n        end else if((round_ff > 4'd1 && round_ff < 4'd12) || key_done) begin\n            round_ff <= round_ff + 1'b1;\n        end else begin\n            if(round_ff >= 4'd12) begin\n                round_ff <= 4'd0;\n            end else begin\n                round_ff <= 4'd2;\n            end\n        end\n\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= current_data_nx[i][j];\n            end\n        end\n    end\nend\n\nalways_comb begin : next_data\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(i_start & o_done) begin\n                current_data_nx[i][j] = i_data[NBW_DATA-(4*i+j)*NBW_BYTE-1-:NBW_BYTE];\n            end else begin\n                if(round_ff != 0) begin\n                    if(round_ff != 11) begin\n                        current_data_nx[i][j] = SubBytes[i][j];\n                    end else begin\n                        current_data_nx[i][j] = AddRoundKey[i][j];\n                    end\n                end else begin\n                    current_data_nx[i][j] = current_data_ff[i][j];\n                end\n            end\n        end\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : row\n        for(genvar j = 0; j < 4; j++) begin : col\n            inv_sbox uu_inv_sbox0 (\n                .i_data(ShiftRows[i][j]),\n                .o_data(SubBytes[i][j])\n            );\n        end\n    end\nendgenerate\n\nalways_comb begin : decypher_logic\n    // Add Round Key logic\n    for(int i = 0; i < 4; i++) begin : row_key\n        for(int j = 0; j < 4; j++) begin : col_key\n            if(round_ff > 4'd0) begin\n                AddRoundKey[i][j] = current_data_ff[i][j] ^ expanded_key[NBW_EX_KEY-(11-round_ff)*NBW_KEY-(4*i+j)*NBW_BYTE-1-:NBW_BYTE];\n            end else begin\n                AddRoundKey[i][j] = 0;\n            end\n        end\n    end\n\n    // Mix Columns logic\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(AddRoundKey[i][j][NBW_BYTE-1]) begin\n                xtimes02[i][j] = {AddRoundKey[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n            end else begin\n                xtimes02[i][j] = {AddRoundKey[i][j][NBW_BYTE-2:0], 1'b0};\n                xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0};\n                xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n            end\n\n            xtimes0e[i][j] = xtimes08[i][j] ^ xtimes04[i][j] ^ xtimes02[i][j];\n            xtimes0b[i][j] = xtimes08[i][j] ^ xtimes02[i][j] ^ AddRoundKey[i][j];\n            xtimes0d[i][j] = xtimes08[i][j] ^ xtimes04[i][j] ^ AddRoundKey[i][j];\n            xtimes09[i][j] = xtimes08[i][j] ^ AddRoundKey[i][j];\n        end\n\n        MixColumns[0][i] = xtimes0e[0][i] ^ xtimes0b[2][i] ^ xtimes0d[3][i] ^ xtimes09[0][i];\n        MixColumns[1][i] = xtimes0e[1][i] ^ xtimes0b[3][i] ^ xtimes0d[0][i] ^ xtimes09[1][i];\n        MixColumns[2][i] = xtimes0e[2][i] ^ xtimes0b[0][i] ^ xtimes0d[1][i] ^ xtimes09[2][i];\n        MixColumns[3][i] = xtimes0e[3][i] ^ xtimes0b[1][i] ^ xtimes0d[2][i] ^ xtimes09[3][i];\n    end\n\n    // Shift Rows logic\n    // Line 0: No shift\n    ShiftRows[0][0] = MixColumns[0][0];\n    ShiftRows[0][1] = MixColumns[0][1];\n    ShiftRows[0][2] = MixColumns[0][2];\n    ShiftRows[0][3] = MixColumns[0][3];\n\n    // Line 1: Shift 1 right\n    ShiftRows[1][0] = MixColumns[1][1];\n    ShiftRows[1][1] = MixColumns[1][2];\n    ShiftRows[1][2] = MixColumns[1][3];\n    ShiftRows[1][3] = MixColumns[1][0];\n\n    // Line 2: Shift 2 right\n    ShiftRows[2][0] = MixColumns[2][2];\n    ShiftRows[2][1] = MixColumns[2][3];\n    ShiftRows[2][2] = MixColumns[2][0];\n    ShiftRows[2][3] = MixColumns[2][1];\n\n    // Line 3: Shift 3 right\n    ShiftRows[3][0] = MixColumns[3][3];\n    ShiftRows[3][1] = MixColumns[3][0];\n    ShiftRows[3][2] = MixColumns[3][1];\n    ShiftRows[3][3] = MixColumns[3][2];\nend\n\naes128_key_expansion uu_aes128_key_expansion (\n    .clk           (clk                            ),\n    .rst_async_n   (rst_async_n                    ),\n    .i_start       (i_start & i_update_key & o_done),\n    .i_key         (i_key                          ),\n    .o_done        (key_done                       ),\n    .o_expanded_key(expanded_key                   )\n);\n\nendmodule : aes128_decrypt", "rtl/aes128_key_expansion.sv": "module aes128_key_expansion #(\n    parameter NBW_KEY = 'd128,\n    parameter NBW_OUT = 'd1408\n) (\n    input  logic               clk,\n    input  logic               rst_async_n,\n    input  logic               i_start,\n    input  logic [NBW_KEY-1:0] i_key,\n    output logic               o_done,\n    output logic [NBW_OUT-1:0] o_expanded_key\n);\n\n// ----------------------------------------\n// - Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE = 'd8;\nlocalparam NBW_WORD = 'd32;\nlocalparam STEPS    = 'd10;\n\n// ----------------------------------------\n// - Wires/registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0] Rcon   [STEPS];\nlogic [NBW_OUT-1:0]  expanded_key_nx;\nlogic [NBW_OUT-1:0]  expanded_key_ff;\nlogic [NBW_KEY-1:0]  step_key[STEPS];\nlogic [NBW_KEY-1:0]  valid_key;\nlogic [STEPS:0]      key_exp_steps_ff;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nassign o_expanded_key = expanded_key_ff;\nassign o_done = key_exp_steps_ff[STEPS];\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        expanded_key_ff  <= {NBW_OUT{1'b0}};\n        key_exp_steps_ff <= 0;\n    end else begin\n        expanded_key_ff <= expanded_key_nx;\n\n        if(i_start) begin\n            key_exp_steps_ff <= {{(STEPS-2){1'b0}}, 1'b1};\n        end else begin\n            if(key_exp_steps_ff[STEPS-1]) begin\n                key_exp_steps_ff <= 0;\n            end else begin\n                key_exp_steps_ff <= key_exp_steps_ff << 1;\n            end\n        end\n    end\nend\n\n\n// ----------------------------------------\n// - Operation logic\n// ----------------------------------------\nassign Rcon[0] = 8'h01;\nassign Rcon[1] = 8'h02;\nassign Rcon[2] = 8'h04;\nassign Rcon[3] = 8'h08;\nassign Rcon[4] = 8'h10;\nassign Rcon[5] = 8'h20;\nassign Rcon[6] = 8'h40;\nassign Rcon[7] = 8'h80;\nassign Rcon[8] = 8'h1b;\nassign Rcon[9] = 8'h36;\n\ngenerate\n    for(genvar i = 0; i < STEPS; i++) begin : steps\n        logic [NBW_WORD-1:0] RotWord;\n        logic [NBW_WORD-1:0] SubWord;\n        logic [NBW_WORD-1:0] RconXor;\n\n        sbox uu_sbox0 (\n            .i_data(RotWord[NBW_WORD-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n        );\n\n        sbox uu_sbox1 (\n            .i_data(RotWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        sbox uu_sbox2 (\n            .i_data(RotWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        sbox uu_sbox3 (\n            .i_data(RotWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        always_comb begin : main_operation\n            RotWord = {expanded_key_ff[NBW_OUT-(i+1)*NBW_KEY+NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)], expanded_key_ff[NBW_OUT-(i+1)*NBW_KEY+NBW_WORD-1-:NBW_BYTE]};\n            RconXor = {SubWord[NBW_WORD-1-:NBW_BYTE]^Rcon[i], SubWord[NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)]};\n\n            step_key[i][NBW_KEY-1-:NBW_WORD]            = expanded_key_ff[NBW_OUT-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ RconXor;\n            step_key[i][NBW_KEY-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_OUT-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-1-:NBW_WORD];\n            step_key[i][NBW_KEY-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-NBW_WORD-1-:NBW_WORD];\n            step_key[i][NBW_KEY-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-2*NBW_WORD-1-:NBW_WORD];\n        end\n    end\nendgenerate\n\nassign expanded_key_nx = {valid_key  , step_key[0], step_key[1], step_key[2],\n                          step_key[3], step_key[4], step_key[5], step_key[6],\n                          step_key[7], step_key[8], step_key[9]};\n\nalways_comb begin : input_data\n    if (i_start) begin\n        valid_key = i_key;\n    end else begin\n        valid_key = expanded_key_ff[NBW_OUT-1-:NBW_KEY];\n    end\nend\n\nendmodule : aes128_key_expansion", "rtl/inv_sbox.sv": "module inv_sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h52;\n        8'h01: o_data = 8'h09;\n        8'h02: o_data = 8'h6a;\n        8'h03: o_data = 8'hd5;\n        8'h04: o_data = 8'h30;\n        8'h05: o_data = 8'h36;\n        8'h06: o_data = 8'ha5;\n        8'h07: o_data = 8'h38;\n        8'h08: o_data = 8'hbf;\n        8'h09: o_data = 8'h40;\n        8'h0a: o_data = 8'ha3;\n        8'h0b: o_data = 8'h9e;\n        8'h0c: o_data = 8'h81;\n        8'h0d: o_data = 8'hf3;\n        8'h0e: o_data = 8'hd7;\n        8'h0f: o_data = 8'hfb;\n        8'h10: o_data = 8'h7c;\n        8'h11: o_data = 8'he3;\n        8'h12: o_data = 8'h39;\n        8'h13: o_data = 8'h82;\n        8'h14: o_data = 8'h9b;\n        8'h15: o_data = 8'h2f;\n        8'h16: o_data = 8'hff;\n        8'h17: o_data = 8'h87;\n        8'h18: o_data = 8'h34;\n        8'h19: o_data = 8'h8e;\n        8'h1a: o_data = 8'h43;\n        8'h1b: o_data = 8'h44;\n        8'h1c: o_data = 8'hc4;\n        8'h1d: o_data = 8'hde;\n        8'h1e: o_data = 8'he9;\n        8'h1f: o_data = 8'hcb;\n        8'h20: o_data = 8'h54;\n        8'h21: o_data = 8'h7b;\n        8'h22: o_data = 8'h94;\n        8'h23: o_data = 8'h32;\n        8'h24: o_data = 8'ha6;\n        8'h25: o_data = 8'hc2;\n        8'h26: o_data = 8'h23;\n        8'h27: o_data = 8'h3d;\n        8'h28: o_data = 8'hee;\n        8'h29: o_data = 8'h4c;\n        8'h2a: o_data = 8'h95;\n        8'h2b: o_data = 8'h0b;\n        8'h2c: o_data = 8'h42;\n        8'h2d: o_data = 8'hfa;\n        8'h2e: o_data = 8'hc3;\n        8'h2f: o_data = 8'h4e;\n        8'h30: o_data = 8'h08;\n        8'h31: o_data = 8'h2e;\n        8'h32: o_data = 8'ha1;\n        8'h33: o_data = 8'h66;\n        8'h34: o_data = 8'h28;\n        8'h35: o_data = 8'hd9;\n        8'h36: o_data = 8'h24;\n        8'h37: o_data = 8'hb2;\n        8'h38: o_data = 8'h76;\n        8'h39: o_data = 8'h5b;\n        8'h3a: o_data = 8'ha2;\n        8'h3b: o_data = 8'h49;\n        8'h3c: o_data = 8'h6d;\n        8'h3d: o_data = 8'h8b;\n        8'h3e: o_data = 8'hd1;\n        8'h3f: o_data = 8'h25;\n        8'h40: o_data = 8'h72;\n        8'h41: o_data = 8'hf8;\n        8'h42: o_data = 8'hf6;\n        8'h43: o_data = 8'h64;\n        8'h44: o_data = 8'h86;\n        8'h45: o_data = 8'h68;\n        8'h46: o_data = 8'h98;\n        8'h47: o_data = 8'h16;\n        8'h48: o_data = 8'hd4;\n        8'h49: o_data = 8'ha4;\n        8'h4a: o_data = 8'h5c;\n        8'h4b: o_data = 8'hcc;\n        8'h4c: o_data = 8'h5d;\n        8'h4d: o_data = 8'h65;\n        8'h4e: o_data = 8'hb6;\n        8'h4f: o_data = 8'h92;\n        8'h50: o_data = 8'h6c;\n        8'h51: o_data = 8'h70;\n        8'h52: o_data = 8'h48;\n        8'h53: o_data = 8'h50;\n        8'h54: o_data = 8'hfd;\n        8'h55: o_data = 8'hed;\n        8'h56: o_data = 8'hb9;\n        8'h57: o_data = 8'hda;\n        8'h58: o_data = 8'h5e;\n        8'h59: o_data = 8'h15;\n        8'h5a: o_data = 8'h46;\n        8'h5b: o_data = 8'h57;\n        8'h5c: o_data = 8'ha7;\n        8'h5d: o_data = 8'h8d;\n        8'h5e: o_data = 8'h9d;\n        8'h5f: o_data = 8'h84;\n        8'h60: o_data = 8'h90;\n        8'h61: o_data = 8'hd8;\n        8'h62: o_data = 8'hab;\n        8'h63: o_data = 8'h00;\n        8'h64: o_data = 8'h8c;\n        8'h65: o_data = 8'hbc;\n        8'h66: o_data = 8'hd3;\n        8'h67: o_data = 8'h0a;\n        8'h68: o_data = 8'hf7;\n        8'h69: o_data = 8'he4;\n        8'h6a: o_data = 8'h58;\n        8'h6b: o_data = 8'h05;\n        8'h6c: o_data = 8'hb8;\n        8'h6d: o_data = 8'hb3;\n        8'h6e: o_data = 8'h45;\n        8'h6f: o_data = 8'h06;\n        8'h70: o_data = 8'hd0;\n        8'h71: o_data = 8'h2c;\n        8'h72: o_data = 8'h1e;\n        8'h73: o_data = 8'h8f;\n        8'h74: o_data = 8'hca;\n        8'h75: o_data = 8'h3f;\n        8'h76: o_data = 8'h0f;\n        8'h77: o_data = 8'h02;\n        8'h78: o_data = 8'hc1;\n        8'h79: o_data = 8'haf;\n        8'h7a: o_data = 8'hbd;\n        8'h7b: o_data = 8'h03;\n        8'h7c: o_data = 8'h01;\n        8'h7d: o_data = 8'h13;\n        8'h7e: o_data = 8'h8a;\n        8'h7f: o_data = 8'h6b;\n        8'h80: o_data = 8'h3a;\n        8'h81: o_data = 8'h91;\n        8'h82: o_data = 8'h11;\n        8'h83: o_data = 8'h41;\n        8'h84: o_data = 8'h4f;\n        8'h85: o_data = 8'h67;\n        8'h86: o_data = 8'hdc;\n        8'h87: o_data = 8'hea;\n        8'h88: o_data = 8'h97;\n        8'h89: o_data = 8'hf2;\n        8'h8a: o_data = 8'hcf;\n        8'h8b: o_data = 8'hce;\n        8'h8c: o_data = 8'hf0;\n        8'h8d: o_data = 8'hb4;\n        8'h8e: o_data = 8'he6;\n        8'h8f: o_data = 8'h73;\n        8'h90: o_data = 8'h96;\n        8'h91: o_data = 8'hac;\n        8'h92: o_data = 8'h74;\n        8'h93: o_data = 8'h22;\n        8'h94: o_data = 8'he7;\n        8'h95: o_data = 8'had;\n        8'h96: o_data = 8'h35;\n        8'h97: o_data = 8'h85;\n        8'h98: o_data = 8'he2;\n        8'h99: o_data = 8'hf9;\n        8'h9a: o_data = 8'h37;\n        8'h9b: o_data = 8'he8;\n        8'h9c: o_data = 8'h1c;\n        8'h9d: o_data = 8'h75;\n        8'h9e: o_data = 8'hdf;\n        8'h9f: o_data = 8'h6e;\n        8'ha0: o_data = 8'h47;\n        8'ha1: o_data = 8'hf1;\n        8'ha2: o_data = 8'h1a;\n        8'ha3: o_data = 8'h71;\n        8'ha4: o_data = 8'h1d;\n        8'ha5: o_data = 8'h29;\n        8'ha6: o_data = 8'hc5;\n        8'ha7: o_data = 8'h89;\n        8'ha8: o_data = 8'h6f;\n        8'ha9: o_data = 8'hb7;\n        8'haa: o_data = 8'h62;\n        8'hab: o_data = 8'h0e;\n        8'hac: o_data = 8'haa;\n        8'had: o_data = 8'h18;\n        8'hae: o_data = 8'hbe;\n        8'haf: o_data = 8'h1b;\n        8'hb0: o_data = 8'hfc;\n        8'hb1: o_data = 8'h56;\n        8'hb2: o_data = 8'h3e;\n        8'hb3: o_data = 8'h4b;\n        8'hb4: o_data = 8'hc6;\n        8'hb5: o_data = 8'hd2;\n        8'hb6: o_data = 8'h79;\n        8'hb7: o_data = 8'h20;\n        8'hb8: o_data = 8'h9a;\n        8'hb9: o_data = 8'hdb;\n        8'hba: o_data = 8'hc0;\n        8'hbb: o_data = 8'hfe;\n        8'hbc: o_data = 8'h78;\n        8'hbd: o_data = 8'hcd;\n        8'hbe: o_data = 8'h5a;\n        8'hbf: o_data = 8'hf4;\n        8'hc0: o_data = 8'h1f;\n        8'hc1: o_data = 8'hdd;\n        8'hc2: o_data = 8'ha8;\n        8'hc3: o_data = 8'h33;\n        8'hc4: o_data = 8'h88;\n        8'hc5: o_data = 8'h07;\n        8'hc6: o_data = 8'hc7;\n        8'hc7: o_data = 8'h31;\n        8'hc8: o_data = 8'hb1;\n        8'hc9: o_data = 8'h12;\n        8'hca: o_data = 8'h10;\n        8'hcb: o_data = 8'h59;\n        8'hcc: o_data = 8'h27;\n        8'hcd: o_data = 8'h80;\n        8'hce: o_data = 8'hec;\n        8'hcf: o_data = 8'h5f;\n        8'hd0: o_data = 8'h60;\n        8'hd1: o_data = 8'h51;\n        8'hd2: o_data = 8'h7f;\n        8'hd3: o_data = 8'ha9;\n        8'hd4: o_data = 8'h19;\n        8'hd5: o_data = 8'hb5;\n        8'hd6: o_data = 8'h4a;\n        8'hd7: o_data = 8'h0d;\n        8'hd8: o_data = 8'h2d;\n        8'hd9: o_data = 8'he5;\n        8'hda: o_data = 8'h7a;\n        8'hdb: o_data = 8'h9f;\n        8'hdc: o_data = 8'h93;\n        8'hdd: o_data = 8'hc9;\n        8'hde: o_data = 8'h9c;\n        8'hdf: o_data = 8'hef;\n        8'he0: o_data = 8'ha0;\n        8'he1: o_data = 8'he0;\n        8'he2: o_data = 8'h3b;\n        8'he3: o_data = 8'h4d;\n        8'he4: o_data = 8'hae;\n        8'he5: o_data = 8'h2a;\n        8'he6: o_data = 8'hf5;\n        8'he7: o_data = 8'hb0;\n        8'he8: o_data = 8'hc8;\n        8'he9: o_data = 8'heb;\n        8'hea: o_data = 8'hbb;\n        8'heb: o_data = 8'h3c;\n        8'hec: o_data = 8'h83;\n        8'hed: o_data = 8'h53;\n        8'hee: o_data = 8'h99;\n        8'hef: o_data = 8'h61;\n        8'hf0: o_data = 8'h17;\n        8'hf1: o_data = 8'h2b;\n        8'hf2: o_data = 8'h04;\n        8'hf3: o_data = 8'h7e;\n        8'hf4: o_data = 8'hba;\n        8'hf5: o_data = 8'h77;\n        8'hf6: o_data = 8'hd6;\n        8'hf7: o_data = 8'h26;\n        8'hf8: o_data = 8'he1;\n        8'hf9: o_data = 8'h69;\n        8'hfa: o_data = 8'h14;\n        8'hfb: o_data = 8'h63;\n        8'hfc: o_data = 8'h55;\n        8'hfd: o_data = 8'h21;\n        8'hfe: o_data = 8'h0c;\n        8'hff: o_data = 8'h7d;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : inv_sbox", "rtl/sbox.sv": "module sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h63;\n        8'h01: o_data = 8'h7C;\n        8'h02: o_data = 8'h77;\n        8'h03: o_data = 8'h7B;\n        8'h04: o_data = 8'hF2;\n        8'h05: o_data = 8'h6B;\n        8'h06: o_data = 8'h6F;\n        8'h07: o_data = 8'hC5;\n        8'h08: o_data = 8'h30;\n        8'h09: o_data = 8'h01;\n        8'h0A: o_data = 8'h67;\n        8'h0B: o_data = 8'h2B;\n        8'h0C: o_data = 8'hFE;\n        8'h0D: o_data = 8'hD7;\n        8'h0E: o_data = 8'hAB;\n        8'h0F: o_data = 8'h76;\n        8'h10: o_data = 8'hCA;\n        8'h11: o_data = 8'h82;\n        8'h12: o_data = 8'hC9;\n        8'h13: o_data = 8'h7D;\n        8'h14: o_data = 8'hFA;\n        8'h15: o_data = 8'h59;\n        8'h16: o_data = 8'h47;\n        8'h17: o_data = 8'hF0;\n        8'h18: o_data = 8'hAD;\n        8'h19: o_data = 8'hD4;\n        8'h1A: o_data = 8'hA2;\n        8'h1B: o_data = 8'hAF;\n        8'h1C: o_data = 8'h9C;\n        8'h1D: o_data = 8'hA4;\n        8'h1E: o_data = 8'h72;\n        8'h1F: o_data = 8'hC0;\n        8'h20: o_data = 8'hB7;\n        8'h21: o_data = 8'hFD;\n        8'h22: o_data = 8'h93;\n        8'h23: o_data = 8'h26;\n        8'h24: o_data = 8'h36;\n        8'h25: o_data = 8'h3F;\n        8'h26: o_data = 8'hF7;\n        8'h27: o_data = 8'hCC;\n        8'h28: o_data = 8'h34;\n        8'h29: o_data = 8'hA5;\n        8'h2A: o_data = 8'hE5;\n        8'h2B: o_data = 8'hF1;\n        8'h2C: o_data = 8'h71;\n        8'h2D: o_data = 8'hD8;\n        8'h2E: o_data = 8'h31;\n        8'h2F: o_data = 8'h15;\n        8'h30: o_data = 8'h04;\n        8'h31: o_data = 8'hC7;\n        8'h32: o_data = 8'h23;\n        8'h33: o_data = 8'hC3;\n        8'h34: o_data = 8'h18;\n        8'h35: o_data = 8'h96;\n        8'h36: o_data = 8'h05;\n        8'h37: o_data = 8'h9A;\n        8'h38: o_data = 8'h07;\n        8'h39: o_data = 8'h12;\n        8'h3A: o_data = 8'h80;\n        8'h3B: o_data = 8'hE2;\n        8'h3C: o_data = 8'hEB;\n        8'h3D: o_data = 8'h27;\n        8'h3E: o_data = 8'hB2;\n        8'h3F: o_data = 8'h75;\n        8'h40: o_data = 8'h09;\n        8'h41: o_data = 8'h83;\n        8'h42: o_data = 8'h2C;\n        8'h43: o_data = 8'h1A;\n        8'h44: o_data = 8'h1B;\n        8'h45: o_data = 8'h6E;\n        8'h46: o_data = 8'h5A;\n        8'h47: o_data = 8'hA0;\n        8'h48: o_data = 8'h52;\n        8'h49: o_data = 8'h3B;\n        8'h4A: o_data = 8'hD6;\n        8'h4B: o_data = 8'hB3;\n        8'h4C: o_data = 8'h29;\n        8'h4D: o_data = 8'hE3;\n        8'h4E: o_data = 8'h2F;\n        8'h4F: o_data = 8'h84;\n        8'h50: o_data = 8'h53;\n        8'h51: o_data = 8'hD1;\n        8'h52: o_data = 8'h00;\n        8'h53: o_data = 8'hED;\n        8'h54: o_data = 8'h20;\n        8'h55: o_data = 8'hFC;\n        8'h56: o_data = 8'hB1;\n        8'h57: o_data = 8'h5B;\n        8'h58: o_data = 8'h6A;\n        8'h59: o_data = 8'hCB;\n        8'h5A: o_data = 8'hBE;\n        8'h5B: o_data = 8'h39;\n        8'h5C: o_data = 8'h4A;\n        8'h5D: o_data = 8'h4C;\n        8'h5E: o_data = 8'h58;\n        8'h5F: o_data = 8'hCF;\n        8'h60: o_data = 8'hD0;\n        8'h61: o_data = 8'hEF;\n        8'h62: o_data = 8'hAA;\n        8'h63: o_data = 8'hFB;\n        8'h64: o_data = 8'h43;\n        8'h65: o_data = 8'h4D;\n        8'h66: o_data = 8'h33;\n        8'h67: o_data = 8'h85;\n        8'h68: o_data = 8'h45;\n        8'h69: o_data = 8'hF9;\n        8'h6A: o_data = 8'h02;\n        8'h6B: o_data = 8'h7F;\n        8'h6C: o_data = 8'h50;\n        8'h6D: o_data = 8'h3C;\n        8'h6E: o_data = 8'h9F;\n        8'h6F: o_data = 8'hA8;\n        8'h70: o_data = 8'h51;\n        8'h71: o_data = 8'hA3;\n        8'h72: o_data = 8'h40;\n        8'h73: o_data = 8'h8F;\n        8'h74: o_data = 8'h92;\n        8'h75: o_data = 8'h9D;\n        8'h76: o_data = 8'h38;\n        8'h77: o_data = 8'hF5;\n        8'h78: o_data = 8'hBC;\n        8'h79: o_data = 8'hB6;\n        8'h7A: o_data = 8'hDA;\n        8'h7B: o_data = 8'h21;\n        8'h7C: o_data = 8'h10;\n        8'h7D: o_data = 8'hFF;\n        8'h7E: o_data = 8'hF3;\n        8'h7F: o_data = 8'hD2;\n        8'h80: o_data = 8'hCD;\n        8'h81: o_data = 8'h0C;\n        8'h82: o_data = 8'h13;\n        8'h83: o_data = 8'hEC;\n        8'h84: o_data = 8'h5F;\n        8'h85: o_data = 8'h97;\n        8'h86: o_data = 8'h44;\n        8'h87: o_data = 8'h17;\n        8'h88: o_data = 8'hC4;\n        8'h89: o_data = 8'hA7;\n        8'h8A: o_data = 8'h7E;\n        8'h8B: o_data = 8'h3D;\n        8'h8C: o_data = 8'h64;\n        8'h8D: o_data = 8'h5D;\n        8'h8E: o_data = 8'h19;\n        8'h8F: o_data = 8'h73;\n        8'h90: o_data = 8'h60;\n        8'h91: o_data = 8'h81;\n        8'h92: o_data = 8'h4F;\n        8'h93: o_data = 8'hDC;\n        8'h94: o_data = 8'h22;\n        8'h95: o_data = 8'h2A;\n        8'h96: o_data = 8'h90;\n        8'h97: o_data = 8'h88;\n        8'h98: o_data = 8'h46;\n        8'h99: o_data = 8'hEE;\n        8'h9A: o_data = 8'hB8;\n        8'h9B: o_data = 8'h14;\n        8'h9C: o_data = 8'hDE;\n        8'h9D: o_data = 8'h5E;\n        8'h9E: o_data = 8'h0B;\n        8'h9F: o_data = 8'hDB;\n        8'hA0: o_data = 8'hE0;\n        8'hA1: o_data = 8'h32;\n        8'hA2: o_data = 8'h3A;\n        8'hA3: o_data = 8'h0A;\n        8'hA4: o_data = 8'h49;\n        8'hA5: o_data = 8'h06;\n        8'hA6: o_data = 8'h24;\n        8'hA7: o_data = 8'h5C;\n        8'hA8: o_data = 8'hC2;\n        8'hA9: o_data = 8'hD3;\n        8'hAA: o_data = 8'hAC;\n        8'hAB: o_data = 8'h62;\n        8'hAC: o_data = 8'h91;\n        8'hAD: o_data = 8'h95;\n        8'hAE: o_data = 8'hE4;\n        8'hAF: o_data = 8'h79;\n        8'hB0: o_data = 8'hE7;\n        8'hB1: o_data = 8'hC8;\n        8'hB2: o_data = 8'h37;\n        8'hB3: o_data = 8'h6D;\n        8'hB4: o_data = 8'h8D;\n        8'hB5: o_data = 8'hD5;\n        8'hB6: o_data = 8'h4E;\n        8'hB7: o_data = 8'hA9;\n        8'hB8: o_data = 8'h6C;\n        8'hB9: o_data = 8'h56;\n        8'hBA: o_data = 8'hF4;\n        8'hBB: o_data = 8'hEA;\n        8'hBC: o_data = 8'h65;\n        8'hBD: o_data = 8'h7A;\n        8'hBE: o_data = 8'hAE;\n        8'hBF: o_data = 8'h08;\n        8'hC0: o_data = 8'hBA;\n        8'hC1: o_data = 8'h78;\n        8'hC2: o_data = 8'h25;\n        8'hC3: o_data = 8'h2E;\n        8'hC4: o_data = 8'h1C;\n        8'hC5: o_data = 8'hA6;\n        8'hC6: o_data = 8'hB4;\n        8'hC7: o_data = 8'hC6;\n        8'hC8: o_data = 8'hE8;\n        8'hC9: o_data = 8'hDD;\n        8'hCA: o_data = 8'h74;\n        8'hCB: o_data = 8'h1F;\n        8'hCC: o_data = 8'h4B;\n        8'hCD: o_data = 8'hBD;\n        8'hCE: o_data = 8'h8B;\n        8'hCF: o_data = 8'h8A;\n        8'hD0: o_data = 8'h70;\n        8'hD1: o_data = 8'h3E;\n        8'hD2: o_data = 8'hB5;\n        8'hD3: o_data = 8'h66;\n        8'hD4: o_data = 8'h48;\n        8'hD5: o_data = 8'h03;\n        8'hD6: o_data = 8'hF6;\n        8'hD7: o_data = 8'h0E;\n        8'hD8: o_data = 8'h61;\n        8'hD9: o_data = 8'h35;\n        8'hDA: o_data = 8'h57;\n        8'hDB: o_data = 8'hB9;\n        8'hDC: o_data = 8'h86;\n        8'hDD: o_data = 8'hC1;\n        8'hDE: o_data = 8'h1D;\n        8'hDF: o_data = 8'h9E;\n        8'hE0: o_data = 8'hE1;\n        8'hE1: o_data = 8'hF8;\n        8'hE2: o_data = 8'h98;\n        8'hE3: o_data = 8'h11;\n        8'hE4: o_data = 8'h69;\n        8'hE5: o_data = 8'hD9;\n        8'hE6: o_data = 8'h8E;\n        8'hE7: o_data = 8'h94;\n        8'hE8: o_data = 8'h9B;\n        8'hE9: o_data = 8'h1E;\n        8'hEA: o_data = 8'h87;\n        8'hEB: o_data = 8'hE9;\n        8'hEC: o_data = 8'hCE;\n        8'hED: o_data = 8'h55;\n        8'hEE: o_data = 8'h28;\n        8'hEF: o_data = 8'hDF;\n        8'hF0: o_data = 8'h8C;\n        8'hF1: o_data = 8'hA1;\n        8'hF2: o_data = 8'h89;\n        8'hF3: o_data = 8'h0D;\n        8'hF4: o_data = 8'hBF;\n        8'hF5: o_data = 8'hE6;\n        8'hF6: o_data = 8'h42;\n        8'hF7: o_data = 8'h68;\n        8'hF8: o_data = 8'h41;\n        8'hF9: o_data = 8'h99;\n        8'hFA: o_data = 8'h2D;\n        8'hFB: o_data = 8'h0F;\n        8'hFC: o_data = 8'hB0;\n        8'hFD: o_data = 8'h54;\n        8'hFE: o_data = 8'hBB;\n        8'hFF: o_data = 8'h16;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : sbox", "verif/tb_aes128_dec.sv": "module tb_aes128_dec;\n\nlocalparam NBW_KEY  = 'd128;\nlocalparam NBW_DATA = 'd128;\n\nlogic                clk;\nlogic                rst_async_n;\nlogic                i_update_key;\nlogic [NBW_KEY-1:0]  i_key;\nlogic                i_start;\nlogic [NBW_DATA-1:0] i_data;\nlogic                o_done;\nlogic [NBW_DATA-1:0] o_data;\n\naes128_decrypt #(\n    .NBW_KEY (NBW_KEY),\n    .NBW_DATA(NBW_DATA)\n) uu_aes128_decrypt (\n    .clk(clk),\n    .rst_async_n(rst_async_n),\n    .i_update_key(i_update_key),\n    .i_key(i_key),\n    .i_start(i_start),\n    .i_data(i_data),\n    .o_done(o_done),\n    .o_data(o_data)\n);\n\ntask Simple_test(logic update_key);\n    @(negedge clk);\n    i_key = 128'h2b7e151628aed2a6abf7158809cf4f3c;\n    i_data = 128'h3925841d02dc09fbdc118597196a0b32;\n    // Data is stored in the RTL as a 4x4 matrix. With this i_data, the matrix should be:\n    // Col  : 0  | 1  | 2  | 3\n    //       -------------------\n    // Row 0: 39 | 02 | dc | 19\n    //       -------------------\n    // Row 1: 25 | dc | 11 | 6a\n    //       -------------------\n    // Row 2: 84 | 09 | 85 | 0b\n    //       -------------------\n    // Row 3: 1d | fb | 97 | 32\n    //       -------------------\n\n    i_update_key = update_key;\n    i_start = 1;\n\n    @(negedge clk);\n    i_start = 0;\n    i_update_key = 0;\n    i_key = 0;\n    i_data = 0;\n\n    @(posedge o_done);\n    @(negedge clk);\n\n    if(o_data == 128'h3243f6a8885a308d313198a2e0370734) begin\n        $display(\"PASS\");\n    end else begin\n        $display(\"FAIL\");\n        $display(\"Expected output: %h\", 128'h3243f6a8885a308d313198a2e0370734);\n        $display(\"Observed output: %h\", o_data);\n    end\nendtask\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb_aes128_dec);\nend\n\nalways #5 clk = ~clk;\n\ninitial begin\n    clk = 0;\n    i_start = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    // Tasks go here\n    Simple_test(1'b1);\n    Simple_test(1'b0);\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/aes128_decrypt.sv": "", "rtl/aes128_key_expansion.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n", "src/.env": "VERILOG_SOURCES = /code/rtl/aes128_decrypt.sv /code/rtl/aes128_key_expansion.sv /code/rtl/sbox.sv /code/rtl/inv_sbox.sv \nTOPLEVEL        = aes128_decrypt\nMODULE          = test_aes128_decrypt\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 5-debug-and-fix-aes128_decrypt\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass aes128_decrypt:\n    # AES S-Box\n    S_BOX = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n    \n    # AES Rcon (Round constants)\n    RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]\n\n    def __init__(self):\n        self.expanded_key = [0] * 44\n        self.decrypted_data = 0\n        self.inv_s_box = [self.S_BOX.index(i) for i in range(256)]\n    \n    def reset(self):\n        self.expanded_key = [0] * 44\n        self.decrypted_data = 0\n\n    def sub_word(self, word):\n        return (self.S_BOX[(word >> 24) & 0xFF] << 24) |\\\n               (self.S_BOX[(word >> 16) & 0xFF] << 16) |\\\n               (self.S_BOX[(word >> 8) & 0xFF] << 8) |\\\n               (self.S_BOX[word & 0xFF])\n\n    def rot_word(self, word):\n        return ((word << 8) & 0xFFFFFFFF) | (word >> 24)\n\n    def update_key(self, key):\n        assert 0 <= key < (1 << 128), \"Key must be a 128-bit integer.\"\n        \n        for i in range(4):\n            self.expanded_key[i] = (key >> (96 - i * 32)) & 0xFFFFFFFF\n        \n        for i in range(4, 44):\n            temp = self.expanded_key[i - 1]\n            if i % 4 == 0:\n                temp = self.sub_word(self.rot_word(temp)) ^ (self.RCON[i // 4] << 24)\n            self.expanded_key[i] = self.expanded_key[i - 4] ^ temp\n\n    def get_key(self):\n        return sum(self.expanded_key[i] << (32 * (43 - i)) for i in range(44))\n    \n    def decrypt(self, ciphertext):\n        assert 0 <= ciphertext < (1 << 128), \"Ciphertext must be a 128-bit integer.\"\n\n        # Convert ciphertext to 4x4 state matrix (column-major order)\n        state = [[(ciphertext >> (120 - 8 * (i + 4 * j))) & 0xFF for j in range(4)] for i in range(4)]\n\n        # Initial AddRoundKey\n        self.add_round_key(state, 10)\n\n        # 9 main rounds (reverse order)\n        for round in range(9, 0, -1):\n            self.inv_shift_rows(state)\n            self.inv_sub_bytes(state)\n            self.add_round_key(state, round)\n            self.inv_mix_columns(state)\n\n        # Final round (no MixColumns)\n        self.inv_shift_rows(state)\n        self.inv_sub_bytes(state)\n        self.add_round_key(state, 0)\n\n        # Convert state matrix back to 128-bit integer\n        self.decrypted_data = 0\n        for j in range(4):\n            for i in range(4):\n                self.decrypted_data = (self.decrypted_data << 8) | state[i][j]\n    \n    def add_round_key(self, state, round):\n        for j in range(4):\n            word = self.expanded_key[round * 4 + j]\n            for i in range(4):\n                state[i][j] ^= (word >> (24 - 8 * i)) & 0xFF\n\n    def inv_sub_bytes(self, state):\n        for i in range(4):\n            for j in range(4):\n                state[i][j] = self.inv_s_box[state[i][j]]\n\n    def inv_shift_rows(self, state):\n        state[1][0], state[1][1], state[1][2], state[1][3] = state[1][3], state[1][0], state[1][1], state[1][2]\n        state[2][0], state[2][1], state[2][2], state[2][3] = state[2][2], state[2][3], state[2][0], state[2][1]\n        state[3][0], state[3][1], state[3][2], state[3][3] = state[3][1], state[3][2], state[3][3], state[3][0]\n\n    def inv_mix_columns(self, state):\n        for j in range(4):\n            a = state[0][j], state[1][j], state[2][j], state[3][j]\n            state[0][j] = self.gmul(a[0], 0x0E) ^ self.gmul(a[1], 0x0B) ^ self.gmul(a[2], 0x0D) ^ self.gmul(a[3], 0x09)\n            state[1][j] = self.gmul(a[0], 0x09) ^ self.gmul(a[1], 0x0E) ^ self.gmul(a[2], 0x0B) ^ self.gmul(a[3], 0x0D)\n            state[2][j] = self.gmul(a[0], 0x0D) ^ self.gmul(a[1], 0x09) ^ self.gmul(a[2], 0x0E) ^ self.gmul(a[3], 0x0B)\n            state[3][j] = self.gmul(a[0], 0x0B) ^ self.gmul(a[1], 0x0D) ^ self.gmul(a[2], 0x09) ^ self.gmul(a[3], 0x0E)\n\n    def gmul(self, a, b):\n        \"\"\"Galois Field multiplication of two bytes\"\"\"\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi_bit_set = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi_bit_set:\n                a ^= 0x1B\n            b >>= 1\n        return p\n", "src/test_aes128_decrypt.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_data.value.to_unsigned()\n\n    model_data = model.decrypted_data\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_aes128_decrypt(dut):\n    \"\"\"Test the aes128_decrypt module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.aes128_decrypt()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**128 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_update_key.value = 0\n        dut.i_start.value      = 0\n        dut.i_key.value        = 0\n        dut.i_data.value       = 0\n        dut.rst_async_n.value  = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        for j in range(runs):\n            if j % 100 == 0:\n                print(f\"Reset {i}, Run {j}\")\n\n            key = random.randint(data_min, data_max)\n            data = random.randint(data_min, data_max)\n\n            dut.i_key.value        = key\n            dut.i_data.value       = data\n            if j == 0:\n                update_key = 1\n            else:\n                update_key = random.randint(0,1)\n            dut.i_update_key.value = update_key\n            dut.i_start.value = 1\n            \n            if update_key:\n                model.update_key(key)\n            \n            model.decrypt(data)\n\n            await RisingEdge(dut.clk)\n            dut.i_update_key.value = 0\n            dut.i_start.value      = 0\n            dut.i_key.value        = 0\n            dut.i_data.value       = 0\n            await RisingEdge(dut.clk)\n            while dut.o_done.value == 0:\n                await RisingEdge(dut.clk)\n            \n            compare_values(dut, model)\n            ", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()"}}
{"id": "cvdp_agentic_diamond_dolphin_whisper_4792", "categories": ["cid004", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "Modify the `aes_encrypt` module in the `rtl` directory, which originally performs an AES-128 encryption, to perform only an AES-256 encryption. A testbench to test the updated design is provided in `verif` directory, and the `sbox` module does not need to be changed. The AES-128 version takes a 128-bit key and a 128-bit data and encrypts it, while the AES-256 version receives a 256-bit key and a 128-bit data and encrypts it. Below is a description of the changes that need to be made:\n\n### 1. **Update Interface Parameters**\n\n- Change the key input size from 128 to 256 bits: Instead of copying 4 32-bit words into the first part of the expanded key, copy 8 32-bit words from the 256-bit input key.\n\n### 2. **Modify Key Expansion Loop**\n\n- In AES-128, for each 32-bit word `w[i]` where `i` is a multiple of `4`, you apply:\n  - For each `i >= 4`:\n    - `Temp = RotWord(w[i-1])`\n    - `Temp = SubWord(Temp)`\n    - `Temp = Temp XOR Rcon[i/4 - 1]`\n    - `w[i] = w[i - 4] XOR Temp`\n\n(`Temp` is used to demonstrate intermediate calculation storage during each step of calculation)\n\n- In **AES-256**, the logic changes:\n  - For each `i >= 8`:\n    - If `i % 8 == 0`:\n      - `Temp = RotWord(w[i-1])`\n      - `Temp = SubWord(Temp)`\n      - `Temp = Temp XOR Rcon[i/8 - 1]`\n    - Else if `i % 8 == 4`:\n      - `Temp = SubWord(w[i-1])`\n      - **No rotation, no Rcon**\n    - Else:\n      - `Temp = w[i-1]`\n    - Then:\n      - `w[i] = w[i - 8] XOR Temp`\n\nMake sure to implement this conditional branching properly in the loop.\n\n### 3. **Rcon Handling**\n\n- Rcon is only applied when `i % 8 == 0` (i.e., every 8 words in AES-256).\n- Do **not** apply Rcon when `i % 8 == 4`.\n- **If any Rcon value is not needed, remove it from the code**.\n\n### 4. **Update Encryption Flow**\n\n- **Increase round counter** to go up to 14.\n- **Expand the key schedule** to generate and store **15 round keys**, each 128 bits (i.e., 240 bytes or 60 words of 32 bits total).\n- Update loops that iterate over rounds so they only use 128 bits of the expanded key for each round.\n\n### 5. **Initial Round Key Addition**\n- Ensure the first round key is generated correctly from the first 128 bits of the expanded 256-bit key.\n\n### 6. **Internal Buffers and Registers**\n- Update the size of any registers or memory arrays that store round keys from 44 32-bit words (AES-128) to 60 32-bit words (AES-256)\n\n", "context": {"rtl/aes_encrypt.sv": "module aes_encrypt #(\n    parameter NBW_KEY  = 'd128,\n    parameter NBW_DATA = 'd128\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_data,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE   = 'd8;\nlocalparam STEPS      = 'd10;\nlocalparam NBW_WORD   = 'd32;\nlocalparam NBW_EX_KEY = 'd1408;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   Rcon   [STEPS];\nlogic [NBW_KEY-1:0]    valid_key;\nlogic [NBW_KEY-1:0]    step_key[STEPS];\nlogic [NBW_EX_KEY-1:0] expanded_key_nx;\nlogic [NBW_EX_KEY-1:0] expanded_key_ff;\nlogic [NBW_BYTE-1:0]   current_data_nx[4][4];\nlogic [NBW_BYTE-1:0]   current_data_ff[4][4];\nlogic [NBW_BYTE-1:0]   SubBytes[4][4];\nlogic [NBW_BYTE-1:0]   ShiftRows[4][4];\nlogic [NBW_BYTE-1:0]   xtimes02[4][4];\nlogic [NBW_BYTE-1:0]   xtimes03[4][4];\nlogic [NBW_BYTE-1:0]   MixColumns[4][4];\nlogic [3:0] round_ff;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nassign o_done = (round_ff == 4'd0);\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : out_row\n        for(genvar j = 0; j < 4; j++) begin : out_col\n            assign o_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] = current_data_ff[i][j];\n        end\n    end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : cypher_regs\n    if(!rst_async_n) begin\n        round_ff <= 4'd0;\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= 8'd0;\n            end\n        end\n    end else begin\n        if(i_start & o_done || (round_ff > 4'd0 && round_ff < 4'd11)) begin\n            round_ff <= round_ff + 1'b1;\n        end else begin\n            round_ff <= 4'd0;\n        end\n\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= current_data_nx[i][j];\n            end\n        end\n    end\nend\n\nalways_comb begin : next_data\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(i_start & o_done) begin\n                if(i_update_key) begin\n                    current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] ^ i_key[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                end else begin\n                    current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] ^ expanded_key_ff[NBW_EX_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                end\n            end else begin\n                if(round_ff > 4'd1) begin\n                    if(round_ff != 11) begin\n                        current_data_nx[i][j] = MixColumns[i][j] ^ expanded_key_ff[NBW_EX_KEY-(round_ff-1)*NBW_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                    end else begin\n                        current_data_nx[i][j] = ShiftRows[i][j] ^ expanded_key_ff[NBW_EX_KEY-(round_ff-1)*NBW_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                    end\n                end else begin\n                    current_data_nx[i][j] = current_data_ff[i][j];\n                end\n            end\n        end\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : row\n        for(genvar j = 0; j < 4; j++) begin : col\n            sbox uu_sbox0 (\n                .i_data(current_data_ff[i][j]),\n                .o_data(SubBytes[i][j])\n            );\n        end\n    end\nendgenerate\n\nalways_comb begin : cypher_logic\n    // Shift Rows logic\n    // Line 0: No shift\n    ShiftRows[0][0] = SubBytes[0][0];\n    ShiftRows[0][1] = SubBytes[0][1];\n    ShiftRows[0][2] = SubBytes[0][2];\n    ShiftRows[0][3] = SubBytes[0][3];\n\n    // Line 1: Shift 1 left\n    ShiftRows[1][0] = SubBytes[1][1];\n    ShiftRows[1][1] = SubBytes[1][2];\n    ShiftRows[1][2] = SubBytes[1][3];\n    ShiftRows[1][3] = SubBytes[1][0];\n\n    // Line 2: Shift 2 left\n    ShiftRows[2][0] = SubBytes[2][2];\n    ShiftRows[2][1] = SubBytes[2][3];\n    ShiftRows[2][2] = SubBytes[2][0];\n    ShiftRows[2][3] = SubBytes[2][1];\n\n    // Line 3: Shift 3 left\n    ShiftRows[3][0] = SubBytes[3][3];\n    ShiftRows[3][1] = SubBytes[3][0];\n    ShiftRows[3][2] = SubBytes[3][1];\n    ShiftRows[3][3] = SubBytes[3][2];\n\n    // Mix Columns logic\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(ShiftRows[i][j][NBW_BYTE-1]) begin\n                xtimes02[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                xtimes03[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B ^ ShiftRows[i][j];\n            end else begin\n                xtimes02[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0};\n                xtimes03[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ ShiftRows[i][j];\n            end\n        end\n    end\n\n    for(int i = 0; i < 4; i++) begin\n        MixColumns[0][i] = xtimes02[0][i] ^ xtimes03[1][i] ^ ShiftRows[2][i] ^ ShiftRows[3][i];\n        MixColumns[1][i] = xtimes02[1][i] ^ xtimes03[2][i] ^ ShiftRows[3][i] ^ ShiftRows[0][i];\n        MixColumns[2][i] = xtimes02[2][i] ^ xtimes03[3][i] ^ ShiftRows[0][i] ^ ShiftRows[1][i];\n        MixColumns[3][i] = xtimes02[3][i] ^ xtimes03[0][i] ^ ShiftRows[1][i] ^ ShiftRows[2][i];\n    end\nend\n\n// ****************************************\n// - Key Expansion logic\n// ****************************************\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        expanded_key_ff <= {NBW_EX_KEY{1'b0}};\n    end else begin\n        expanded_key_ff <= expanded_key_nx;\n    end\nend\n\n\n// ----------------------------------------\n// - Operation logic\n// ----------------------------------------\nassign Rcon[0] = 8'h01;\nassign Rcon[1] = 8'h02;\nassign Rcon[2] = 8'h04;\nassign Rcon[3] = 8'h08;\nassign Rcon[4] = 8'h10;\nassign Rcon[5] = 8'h20;\nassign Rcon[6] = 8'h40;\nassign Rcon[7] = 8'h80;\nassign Rcon[8] = 8'h1b;\nassign Rcon[9] = 8'h36;\n\ngenerate\n    for(genvar i = 0; i < STEPS; i++) begin : steps\n        logic [NBW_WORD-1:0] RotWord;\n        logic [NBW_WORD-1:0] SubWord;\n        logic [NBW_WORD-1:0] RconXor;\n\n        sbox uu_sbox0 (\n            .i_data(RotWord[NBW_WORD-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n        );\n\n        sbox uu_sbox1 (\n            .i_data(RotWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        sbox uu_sbox2 (\n            .i_data(RotWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        sbox uu_sbox3 (\n            .i_data(RotWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        always_comb begin : main_operation\n            RotWord = {expanded_key_ff[NBW_EX_KEY-(i+1)*NBW_KEY+NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)], expanded_key_ff[NBW_EX_KEY-(i+1)*NBW_KEY+NBW_WORD-1-:NBW_BYTE]};\n            RconXor = {SubWord[NBW_WORD-1-:NBW_BYTE]^Rcon[i], SubWord[NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)]};\n\n            step_key[i][NBW_KEY-1-:NBW_WORD]            = expanded_key_ff[NBW_EX_KEY-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ RconXor;\n            step_key[i][NBW_KEY-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_EX_KEY-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-1-:NBW_WORD];\n            step_key[i][NBW_KEY-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-NBW_WORD-1-:NBW_WORD];\n            step_key[i][NBW_KEY-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-2*NBW_WORD-1-:NBW_WORD];\n        end\n    end\nendgenerate\n\nassign expanded_key_nx = {valid_key  , step_key[0], step_key[1], step_key[2],\n                          step_key[3], step_key[4], step_key[5], step_key[6],\n                          step_key[7], step_key[8], step_key[9]};\n\nalways_comb begin : input_data\n    if (i_update_key & o_done) begin\n        valid_key = i_key;\n    end else begin\n        valid_key = expanded_key_ff[NBW_EX_KEY-1-:NBW_KEY];\n    end\nend\n\nendmodule : aes_encrypt", "rtl/sbox.sv": "module sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h63;\n        8'h01: o_data = 8'h7C;\n        8'h02: o_data = 8'h77;\n        8'h03: o_data = 8'h7B;\n        8'h04: o_data = 8'hF2;\n        8'h05: o_data = 8'h6B;\n        8'h06: o_data = 8'h6F;\n        8'h07: o_data = 8'hC5;\n        8'h08: o_data = 8'h30;\n        8'h09: o_data = 8'h01;\n        8'h0A: o_data = 8'h67;\n        8'h0B: o_data = 8'h2B;\n        8'h0C: o_data = 8'hFE;\n        8'h0D: o_data = 8'hD7;\n        8'h0E: o_data = 8'hAB;\n        8'h0F: o_data = 8'h76;\n        8'h10: o_data = 8'hCA;\n        8'h11: o_data = 8'h82;\n        8'h12: o_data = 8'hC9;\n        8'h13: o_data = 8'h7D;\n        8'h14: o_data = 8'hFA;\n        8'h15: o_data = 8'h59;\n        8'h16: o_data = 8'h47;\n        8'h17: o_data = 8'hF0;\n        8'h18: o_data = 8'hAD;\n        8'h19: o_data = 8'hD4;\n        8'h1A: o_data = 8'hA2;\n        8'h1B: o_data = 8'hAF;\n        8'h1C: o_data = 8'h9C;\n        8'h1D: o_data = 8'hA4;\n        8'h1E: o_data = 8'h72;\n        8'h1F: o_data = 8'hC0;\n        8'h20: o_data = 8'hB7;\n        8'h21: o_data = 8'hFD;\n        8'h22: o_data = 8'h93;\n        8'h23: o_data = 8'h26;\n        8'h24: o_data = 8'h36;\n        8'h25: o_data = 8'h3F;\n        8'h26: o_data = 8'hF7;\n        8'h27: o_data = 8'hCC;\n        8'h28: o_data = 8'h34;\n        8'h29: o_data = 8'hA5;\n        8'h2A: o_data = 8'hE5;\n        8'h2B: o_data = 8'hF1;\n        8'h2C: o_data = 8'h71;\n        8'h2D: o_data = 8'hD8;\n        8'h2E: o_data = 8'h31;\n        8'h2F: o_data = 8'h15;\n        8'h30: o_data = 8'h04;\n        8'h31: o_data = 8'hC7;\n        8'h32: o_data = 8'h23;\n        8'h33: o_data = 8'hC3;\n        8'h34: o_data = 8'h18;\n        8'h35: o_data = 8'h96;\n        8'h36: o_data = 8'h05;\n        8'h37: o_data = 8'h9A;\n        8'h38: o_data = 8'h07;\n        8'h39: o_data = 8'h12;\n        8'h3A: o_data = 8'h80;\n        8'h3B: o_data = 8'hE2;\n        8'h3C: o_data = 8'hEB;\n        8'h3D: o_data = 8'h27;\n        8'h3E: o_data = 8'hB2;\n        8'h3F: o_data = 8'h75;\n        8'h40: o_data = 8'h09;\n        8'h41: o_data = 8'h83;\n        8'h42: o_data = 8'h2C;\n        8'h43: o_data = 8'h1A;\n        8'h44: o_data = 8'h1B;\n        8'h45: o_data = 8'h6E;\n        8'h46: o_data = 8'h5A;\n        8'h47: o_data = 8'hA0;\n        8'h48: o_data = 8'h52;\n        8'h49: o_data = 8'h3B;\n        8'h4A: o_data = 8'hD6;\n        8'h4B: o_data = 8'hB3;\n        8'h4C: o_data = 8'h29;\n        8'h4D: o_data = 8'hE3;\n        8'h4E: o_data = 8'h2F;\n        8'h4F: o_data = 8'h84;\n        8'h50: o_data = 8'h53;\n        8'h51: o_data = 8'hD1;\n        8'h52: o_data = 8'h00;\n        8'h53: o_data = 8'hED;\n        8'h54: o_data = 8'h20;\n        8'h55: o_data = 8'hFC;\n        8'h56: o_data = 8'hB1;\n        8'h57: o_data = 8'h5B;\n        8'h58: o_data = 8'h6A;\n        8'h59: o_data = 8'hCB;\n        8'h5A: o_data = 8'hBE;\n        8'h5B: o_data = 8'h39;\n        8'h5C: o_data = 8'h4A;\n        8'h5D: o_data = 8'h4C;\n        8'h5E: o_data = 8'h58;\n        8'h5F: o_data = 8'hCF;\n        8'h60: o_data = 8'hD0;\n        8'h61: o_data = 8'hEF;\n        8'h62: o_data = 8'hAA;\n        8'h63: o_data = 8'hFB;\n        8'h64: o_data = 8'h43;\n        8'h65: o_data = 8'h4D;\n        8'h66: o_data = 8'h33;\n        8'h67: o_data = 8'h85;\n        8'h68: o_data = 8'h45;\n        8'h69: o_data = 8'hF9;\n        8'h6A: o_data = 8'h02;\n        8'h6B: o_data = 8'h7F;\n        8'h6C: o_data = 8'h50;\n        8'h6D: o_data = 8'h3C;\n        8'h6E: o_data = 8'h9F;\n        8'h6F: o_data = 8'hA8;\n        8'h70: o_data = 8'h51;\n        8'h71: o_data = 8'hA3;\n        8'h72: o_data = 8'h40;\n        8'h73: o_data = 8'h8F;\n        8'h74: o_data = 8'h92;\n        8'h75: o_data = 8'h9D;\n        8'h76: o_data = 8'h38;\n        8'h77: o_data = 8'hF5;\n        8'h78: o_data = 8'hBC;\n        8'h79: o_data = 8'hB6;\n        8'h7A: o_data = 8'hDA;\n        8'h7B: o_data = 8'h21;\n        8'h7C: o_data = 8'h10;\n        8'h7D: o_data = 8'hFF;\n        8'h7E: o_data = 8'hF3;\n        8'h7F: o_data = 8'hD2;\n        8'h80: o_data = 8'hCD;\n        8'h81: o_data = 8'h0C;\n        8'h82: o_data = 8'h13;\n        8'h83: o_data = 8'hEC;\n        8'h84: o_data = 8'h5F;\n        8'h85: o_data = 8'h97;\n        8'h86: o_data = 8'h44;\n        8'h87: o_data = 8'h17;\n        8'h88: o_data = 8'hC4;\n        8'h89: o_data = 8'hA7;\n        8'h8A: o_data = 8'h7E;\n        8'h8B: o_data = 8'h3D;\n        8'h8C: o_data = 8'h64;\n        8'h8D: o_data = 8'h5D;\n        8'h8E: o_data = 8'h19;\n        8'h8F: o_data = 8'h73;\n        8'h90: o_data = 8'h60;\n        8'h91: o_data = 8'h81;\n        8'h92: o_data = 8'h4F;\n        8'h93: o_data = 8'hDC;\n        8'h94: o_data = 8'h22;\n        8'h95: o_data = 8'h2A;\n        8'h96: o_data = 8'h90;\n        8'h97: o_data = 8'h88;\n        8'h98: o_data = 8'h46;\n        8'h99: o_data = 8'hEE;\n        8'h9A: o_data = 8'hB8;\n        8'h9B: o_data = 8'h14;\n        8'h9C: o_data = 8'hDE;\n        8'h9D: o_data = 8'h5E;\n        8'h9E: o_data = 8'h0B;\n        8'h9F: o_data = 8'hDB;\n        8'hA0: o_data = 8'hE0;\n        8'hA1: o_data = 8'h32;\n        8'hA2: o_data = 8'h3A;\n        8'hA3: o_data = 8'h0A;\n        8'hA4: o_data = 8'h49;\n        8'hA5: o_data = 8'h06;\n        8'hA6: o_data = 8'h24;\n        8'hA7: o_data = 8'h5C;\n        8'hA8: o_data = 8'hC2;\n        8'hA9: o_data = 8'hD3;\n        8'hAA: o_data = 8'hAC;\n        8'hAB: o_data = 8'h62;\n        8'hAC: o_data = 8'h91;\n        8'hAD: o_data = 8'h95;\n        8'hAE: o_data = 8'hE4;\n        8'hAF: o_data = 8'h79;\n        8'hB0: o_data = 8'hE7;\n        8'hB1: o_data = 8'hC8;\n        8'hB2: o_data = 8'h37;\n        8'hB3: o_data = 8'h6D;\n        8'hB4: o_data = 8'h8D;\n        8'hB5: o_data = 8'hD5;\n        8'hB6: o_data = 8'h4E;\n        8'hB7: o_data = 8'hA9;\n        8'hB8: o_data = 8'h6C;\n        8'hB9: o_data = 8'h56;\n        8'hBA: o_data = 8'hF4;\n        8'hBB: o_data = 8'hEA;\n        8'hBC: o_data = 8'h65;\n        8'hBD: o_data = 8'h7A;\n        8'hBE: o_data = 8'hAE;\n        8'hBF: o_data = 8'h08;\n        8'hC0: o_data = 8'hBA;\n        8'hC1: o_data = 8'h78;\n        8'hC2: o_data = 8'h25;\n        8'hC3: o_data = 8'h2E;\n        8'hC4: o_data = 8'h1C;\n        8'hC5: o_data = 8'hA6;\n        8'hC6: o_data = 8'hB4;\n        8'hC7: o_data = 8'hC6;\n        8'hC8: o_data = 8'hE8;\n        8'hC9: o_data = 8'hDD;\n        8'hCA: o_data = 8'h74;\n        8'hCB: o_data = 8'h1F;\n        8'hCC: o_data = 8'h4B;\n        8'hCD: o_data = 8'hBD;\n        8'hCE: o_data = 8'h8B;\n        8'hCF: o_data = 8'h8A;\n        8'hD0: o_data = 8'h70;\n        8'hD1: o_data = 8'h3E;\n        8'hD2: o_data = 8'hB5;\n        8'hD3: o_data = 8'h66;\n        8'hD4: o_data = 8'h48;\n        8'hD5: o_data = 8'h03;\n        8'hD6: o_data = 8'hF6;\n        8'hD7: o_data = 8'h0E;\n        8'hD8: o_data = 8'h61;\n        8'hD9: o_data = 8'h35;\n        8'hDA: o_data = 8'h57;\n        8'hDB: o_data = 8'hB9;\n        8'hDC: o_data = 8'h86;\n        8'hDD: o_data = 8'hC1;\n        8'hDE: o_data = 8'h1D;\n        8'hDF: o_data = 8'h9E;\n        8'hE0: o_data = 8'hE1;\n        8'hE1: o_data = 8'hF8;\n        8'hE2: o_data = 8'h98;\n        8'hE3: o_data = 8'h11;\n        8'hE4: o_data = 8'h69;\n        8'hE5: o_data = 8'hD9;\n        8'hE6: o_data = 8'h8E;\n        8'hE7: o_data = 8'h94;\n        8'hE8: o_data = 8'h9B;\n        8'hE9: o_data = 8'h1E;\n        8'hEA: o_data = 8'h87;\n        8'hEB: o_data = 8'hE9;\n        8'hEC: o_data = 8'hCE;\n        8'hED: o_data = 8'h55;\n        8'hEE: o_data = 8'h28;\n        8'hEF: o_data = 8'hDF;\n        8'hF0: o_data = 8'h8C;\n        8'hF1: o_data = 8'hA1;\n        8'hF2: o_data = 8'h89;\n        8'hF3: o_data = 8'h0D;\n        8'hF4: o_data = 8'hBF;\n        8'hF5: o_data = 8'hE6;\n        8'hF6: o_data = 8'h42;\n        8'hF7: o_data = 8'h68;\n        8'hF8: o_data = 8'h41;\n        8'hF9: o_data = 8'h99;\n        8'hFA: o_data = 8'h2D;\n        8'hFB: o_data = 8'h0F;\n        8'hFC: o_data = 8'hB0;\n        8'hFD: o_data = 8'h54;\n        8'hFE: o_data = 8'hBB;\n        8'hFF: o_data = 8'h16;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : sbox", "verif/tb_aes_encrypt.sv": "module tb_aes_encrypt;\n\nlocalparam NBW_KEY  = 'd256;\nlocalparam NBW_DATA = 'd128;\n\nlogic                clk;\nlogic                rst_async_n;\nlogic                i_update_key;\nlogic [NBW_KEY-1:0]  i_key;\nlogic                i_start;\nlogic [NBW_DATA-1:0] i_data;\nlogic                o_done;\nlogic [NBW_DATA-1:0] o_data;\n\naes_encrypt #(\n    .NBW_KEY(NBW_KEY),\n    .NBW_DATA(NBW_DATA)\n) uu_aes_encrypt (\n    .clk(clk),\n    .rst_async_n(rst_async_n),\n    .i_update_key(i_update_key),\n    .i_key(i_key),\n    .i_start(i_start),\n    .i_data(i_data),\n    .o_done(o_done),\n    .o_data(o_data)\n);\n\ntask Simple_test(logic update_key);\n    @(negedge clk);\n    i_key  = 256'h000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;\n    i_data = 128'h00112233445566778899aabbccddeeff;\n    i_update_key = update_key;\n    i_start = 1;\n\n    @(negedge clk);\n    i_start = 0;\n    i_update_key = 0;\n    i_key = 0;\n\n    @(posedge o_done);\n    @(negedge clk);\n\n    if(o_data == 128'h8ea2b7ca516745bfeafc49904b496089) begin\n        $display(\"PASS\");\n    end else begin\n        $display(\"FAIL\");\n        $display(\"Expected output: %h\", 128'h8ea2b7ca516745bfeafc49904b496089);\n        $display(\"Observed output: %h\", o_data);\n    end\nendtask\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb_aes_encrypt);\nend\n\nalways #5 clk = ~clk;\n\ninitial begin\n    clk = 0;\n    i_start = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    // Tasks go here\n    Simple_test(1'b1);\n    Simple_test(1'b0);\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/aes_encrypt.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n", "src/.env": "VERILOG_SOURCES = /code/rtl/aes_encrypt.sv /code/rtl/sbox.sv\nTOPLEVEL        = aes_encrypt\nMODULE          = test_aes_encrypt\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 9-modify-aes-encrypt-to-256\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass aes_encrypt:\n    RCON = [\n        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n    ]\n    \n    SBOX = [\n        # S-box table used in AES\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n    \n    def __init__(self):\n        self.expanded_key = 0\n        self.data_out = 0\n    \n    def reset(self):\n        self.expanded_key = 0\n        self.data_out = 0\n    \n    def update_key(self, key):\n        key_bytes = key.to_bytes(32, 'big')  # Convert 256-bit key to bytes\n        self.expanded_key = self.expand_key(key_bytes)\n    \n    def expand_key(self, key):\n        words = [list(key[i:i+4]) for i in range(0, 32, 4)]\n        \n        for i in range(8, 60):\n            temp = words[i - 1]\n            \n            if i % 8 == 0:\n                temp = self.sub_word(self.rot_word(temp))\n                temp[0] ^= self.RCON[i // 8 - 1]\n            elif i % 8 == 4:\n                temp = self.sub_word(temp)\n            \n            words.append([words[i - 8][j] ^ temp[j] for j in range(4)])\n        \n        expanded_key_bytes = b''.join(bytes(word) for word in words)\n        return int.from_bytes(expanded_key_bytes, 'big')\n    \n    def sub_word(self, word):\n        return [self.SBOX[b] for b in word]\n    \n    def rot_word(self, word):\n        return word[1:] + word[:1]\n    \n    def gmul(self, a, b):\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.SBOX[state[i]]\n\n    def shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[5], state[9], state[13], state[1]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[15], state[3], state[7], state[11]\n\n    def mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],2)^self.gmul(a[1],3)^a[2]^a[3]\n            s[i*4+1] = a[0]^self.gmul(a[1],2)^self.gmul(a[2],3)^a[3]\n            s[i*4+2] = a[0]^a[1]^self.gmul(a[2],2)^self.gmul(a[3],3)\n            s[i*4+3] = self.gmul(a[0],3)^a[1]^a[2]^self.gmul(a[3],2)\n\n    def add_round_key(self, state, round_key_words):\n        for col in range(4):\n            word = round_key_words[col]\n            for row in range(4):\n                state[col * 4 + row] ^= (word >> (24 - 8 * row)) & 0xFF\n\n    def get_round_keys(self):\n        expanded_bytes = self.expanded_key.to_bytes(240, 'big')\n        round_keys = []\n        for i in range(0, 240, 16):  # Each round key is 16 bytes (4 words)\n            words = [int.from_bytes(expanded_bytes[i + j*4 : i + (j+1)*4], 'big') for j in range(4)]\n            round_keys.append(words)\n        return round_keys\n\n    def encrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n        \n        self.add_round_key(state, round_keys[0])\n\n        for rnd in range(1, 14):\n            self.sub_bytes(state)\n            self.shift_rows(state)\n            self.mix_columns(state)\n            self.add_round_key(state, round_keys[rnd])\n\n        self.sub_bytes(state)\n        self.shift_rows(state)\n        self.add_round_key(state, round_keys[14])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b\n", "src/test_aes_encrypt.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_data.value.to_unsigned()\n\n    model_data = model.data_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_aes_encrypt(dut):\n    \"\"\"Test the aes_encrypt module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.aes_encrypt()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**128 - 1\n\n    key_min = 0\n    key_max = 2**256 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_update_key.value = 0\n        dut.i_key.value        = 0\n        dut.i_start.value      = 0\n        dut.i_data.value       = 0\n        dut.rst_async_n.value  = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value  = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        for j in range(runs):\n            if j%100 == 0:\n                print(f'Reset {i}, run {j}')\n                \n            data = random.randint(data_min, data_max)\n            key = random.randint(key_min, key_max)\n            if j == 0:\n                update_key = 1\n            else:\n                update_key = random.randint(0,1)\n            \n            dut.i_update_key.value = update_key\n            dut.i_start.value      = 1\n            dut.i_key.value        = key\n            dut.i_data.value       = data\n\n            if update_key == 1:\n                model.update_key(key)\n            \n            model.encrypt(data)\n\n            await RisingEdge(dut.clk)\n            dut.i_update_key.value = 0\n            dut.i_start.value      = 0\n            dut.i_data.value       = 0\n            dut.i_key.value        = 0\n            await RisingEdge(dut.clk)\n            while dut.o_done.value == 0:\n                await RisingEdge(dut.clk)\n            \n            compare_values(dut, model)\n            ", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()"}}
{"id": "cvdp_agentic_amber_prism_tiger_1687", "categories": ["cid004", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "Modify the `aes_decrypt` and `aes_ke` modules in the `rtl` directory, which originally perform an AES-128 decryption and AES-128 key expansion, to perform an AES-256 decryption and an AES-256 key expansion. A testbench to test the updated design is provided in the `verif` directory, and the `sbox` and `inv_sbox` modules do not need to be changed. The AES-128 version takes a 128-bit key and a 128-bit data and decrypts it, while the AES-256 version receives a 256-bit key and a 128-bit data and decrypts it. Below is a description of the changes that need to be made:\n\n### 1. **Update Interface Parameters**\n\n- Change the key input size from 128 to 256 bits: Instead of copying 4 32-bit words into the first part of the expanded key, copy 8 32-bit words from the 256-bit input key.\n\n### 2. **Modify Key Expansion Loop**\n\n- In AES-128, for each 32-bit word `w[i]` where `i` is a multiple of `4`, you apply:\n  - For each `i >= 4`:\n    - `Temp = RotWord(w[i-1])`\n    - `Temp = SubWord(Temp)`\n    - `Temp = Temp XOR Rcon[i/4 - 1]`\n    - `w[i] = w[i - 4] XOR Temp`\n\n(`Temp` is used to demonstrate intermediate calculation storage during each step of calculation)\n\n- In **AES-256**, the logic changes:\n  - For each `i >= 8`:\n    - If `i % 8 == 0`:\n      - `Temp = RotWord(w[i-1])`\n      - `Temp = SubWord(Temp)`\n      - `Temp = Temp XOR Rcon[i/8 - 1]`\n    - Else if `i % 8 == 4`:\n      - `Temp = SubWord(w[i-1])`\n      - **No rotation, no Rcon**\n    - Else:\n      - `Temp = w[i-1]`\n    - Then:\n      - `w[i] = w[i - 8] XOR Temp`\n\nMake sure to implement this conditional branching properly in the loop.\n\n### 3. **Rcon Handling**\n\n- Rcon is only applied when `i % 8 == 0` (i.e., every 8 words in AES-256).\n- Do **not** apply Rcon when `i % 8 == 4`.\n- **If any Rcon value is not needed, remove it from the code**.\n\n### 4. **Update Decryption Flow**\n\n- **Increase round counter** of the decryption operation to go up to 14. Make sure to wait while the key is being expanded.\n- **Expand the key schedule** to generate and store **15 round keys**, each 128 bits (i.e., 240 bytes or 60 words of 32 bits total).\n- Update loops that iterate over rounds so they use the appropriate 128-bit portion of the expanded key in **reverse order**, starting from the last round and moving toward the first.\n- Ensure the decryption steps are correctly sequenced:\n  - Initial AddRoundKey\n  - 13 rounds of: ShiftRows \u2192 SubBytes \u2192 AddRoundKey \u2192 MixColumns\n  - Final round: ShiftRows \u2192 SubBytes \u2192 AddRoundKey (no MixColumns)\n\n### 5. **Initial Round Key Addition**\n- Ensure the first round key added corresponds to the last round key from the AES-256 key schedule.\n\n### 6. **Internal Buffers and Registers**\n- Update the size of any registers or memory arrays that store round keys from 44 32-bit words (AES-128) to 60 32-bit words (AES-256)\n", "context": {"rtl/aes_decrypt.sv": "module aes_decrypt #(\n    parameter NBW_KEY  = 'd128,\n    parameter NBW_DATA = 'd128\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_data,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE   = 'd8;\nlocalparam NBW_EX_KEY = 'd1408;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   current_data_nx[4][4];\nlogic [NBW_BYTE-1:0]   current_data_ff[4][4];\nlogic [NBW_BYTE-1:0]   AddRoundKey[4][4];\nlogic [NBW_BYTE-1:0]   SubBytes[4][4];\nlogic [NBW_BYTE-1:0]   ShiftRows[4][4];\nlogic [NBW_BYTE-1:0]   xtimes02[4][4];\nlogic [NBW_BYTE-1:0]   xtimes04[4][4];\nlogic [NBW_BYTE-1:0]   xtimes08[4][4];\nlogic [NBW_BYTE-1:0]   xtimes09[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0b[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0d[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0e[4][4];\nlogic [NBW_BYTE-1:0]   MixColumns[4][4];\nlogic [3:0]            round_ff;\nlogic                  key_done;\nlogic                  key_idle;\nlogic [NBW_EX_KEY-1:0] expanded_key;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nassign o_done = (round_ff == 4'd0 && key_idle);\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : out_row\n        for(genvar j = 0; j < 4; j++) begin : out_col\n            assign o_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] = current_data_ff[i][j];\n        end\n    end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : inv_cypher_regs\n    if(!rst_async_n) begin\n        round_ff <= 4'd0;\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= 8'd0;\n            end\n        end\n    end else begin\n        if(i_start & o_done) begin\n            if(i_update_key) begin\n                round_ff <= 4'd0;\n            end else begin\n                round_ff <= 4'd1;\n            end\n        end else if((round_ff > 4'd0 && round_ff < 4'd11) || key_done) begin\n            round_ff <= round_ff + 1'b1;\n        end else begin\n            round_ff <= 4'd0;\n        end\n\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= current_data_nx[i][j];\n            end\n        end\n    end\nend\n\nalways_comb begin : next_data\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(i_start & o_done) begin\n                current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n            end else begin\n                if(round_ff != 0) begin\n                    if(round_ff != 11) begin\n                        current_data_nx[i][j] = SubBytes[i][j];\n                    end else begin\n                        current_data_nx[i][j] = AddRoundKey[i][j];\n                    end\n                end else begin\n                    current_data_nx[i][j] = current_data_ff[i][j];\n                end\n            end\n        end\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : row\n        for(genvar j = 0; j < 4; j++) begin : col\n            inv_sbox uu_inv_sbox0 (\n                .i_data(ShiftRows[i][j]),\n                .o_data(SubBytes[i][j])\n            );\n        end\n    end\nendgenerate\n\nalways_comb begin : decypher_logic\n    // Add Round Key logic\n    for(int i = 0; i < 4; i++) begin : row_key\n        for(int j = 0; j < 4; j++) begin : col_key\n            if(round_ff > 4'd0) begin\n                AddRoundKey[i][j] = current_data_ff[i][j] ^ expanded_key[NBW_EX_KEY-(11-round_ff)*NBW_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n            end else begin\n                AddRoundKey[i][j] = 0;\n            end\n        end\n    end\n\n    // Mix Columns logic\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(AddRoundKey[i][j][NBW_BYTE-1]) begin\n                xtimes02[i][j] = {AddRoundKey[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                if(AddRoundKey[i][j][NBW_BYTE-2]) begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end else begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0};\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end\n            end else begin\n                xtimes02[i][j] = {AddRoundKey[i][j][NBW_BYTE-2:0], 1'b0};\n                if(AddRoundKey[i][j][NBW_BYTE-2]) begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end else begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0};\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end\n            end\n\n            xtimes0e[i][j] = xtimes08[i][j] ^ xtimes04[i][j] ^ xtimes02[i][j];\n            xtimes0b[i][j] = xtimes08[i][j] ^ xtimes02[i][j] ^ AddRoundKey[i][j];\n            xtimes0d[i][j] = xtimes08[i][j] ^ xtimes04[i][j] ^ AddRoundKey[i][j];\n            xtimes09[i][j] = xtimes08[i][j] ^ AddRoundKey[i][j];\n        end\n    end\n\n    for(int i = 0; i < 4; i++) begin\n        MixColumns[0][i] = xtimes0e[0][i] ^ xtimes0b[1][i] ^ xtimes0d[2][i] ^ xtimes09[3][i];\n        MixColumns[1][i] = xtimes0e[1][i] ^ xtimes0b[2][i] ^ xtimes0d[3][i] ^ xtimes09[0][i];\n        MixColumns[2][i] = xtimes0e[2][i] ^ xtimes0b[3][i] ^ xtimes0d[0][i] ^ xtimes09[1][i];\n        MixColumns[3][i] = xtimes0e[3][i] ^ xtimes0b[0][i] ^ xtimes0d[1][i] ^ xtimes09[2][i];\n    end\n\n    // Shift Rows logic\n    if(round_ff == 4'd1) begin\n        // Line 0: No shift\n        ShiftRows[0][0] = AddRoundKey[0][0];\n        ShiftRows[0][1] = AddRoundKey[0][1];\n        ShiftRows[0][2] = AddRoundKey[0][2];\n        ShiftRows[0][3] = AddRoundKey[0][3];\n\n        // Line 1: Shift 1 right\n        ShiftRows[1][0] = AddRoundKey[1][3];\n        ShiftRows[1][1] = AddRoundKey[1][0];\n        ShiftRows[1][2] = AddRoundKey[1][1];\n        ShiftRows[1][3] = AddRoundKey[1][2];\n\n        // Line 2: Shift 2 right\n        ShiftRows[2][0] = AddRoundKey[2][2];\n        ShiftRows[2][1] = AddRoundKey[2][3];\n        ShiftRows[2][2] = AddRoundKey[2][0];\n        ShiftRows[2][3] = AddRoundKey[2][1];\n\n        // Line 3: Shift 3 right\n        ShiftRows[3][0] = AddRoundKey[3][1];\n        ShiftRows[3][1] = AddRoundKey[3][2];\n        ShiftRows[3][2] = AddRoundKey[3][3];\n        ShiftRows[3][3] = AddRoundKey[3][0];\n    end else begin\n        // Line 0: No shift\n        ShiftRows[0][0] = MixColumns[0][0];\n        ShiftRows[0][1] = MixColumns[0][1];\n        ShiftRows[0][2] = MixColumns[0][2];\n        ShiftRows[0][3] = MixColumns[0][3];\n\n        // Line 1: Shift 1 right\n        ShiftRows[1][0] = MixColumns[1][3];\n        ShiftRows[1][1] = MixColumns[1][0];\n        ShiftRows[1][2] = MixColumns[1][1];\n        ShiftRows[1][3] = MixColumns[1][2];\n\n        // Line 2: Shift 2 right\n        ShiftRows[2][0] = MixColumns[2][2];\n        ShiftRows[2][1] = MixColumns[2][3];\n        ShiftRows[2][2] = MixColumns[2][0];\n        ShiftRows[2][3] = MixColumns[2][1];\n\n        // Line 3: Shift 3 right\n        ShiftRows[3][0] = MixColumns[3][1];\n        ShiftRows[3][1] = MixColumns[3][2];\n        ShiftRows[3][2] = MixColumns[3][3];\n        ShiftRows[3][3] = MixColumns[3][0];\n    end\n\nend\n\naes_ke uu_aes_ke (\n    .clk           (clk                            ),\n    .rst_async_n   (rst_async_n                    ),\n    .i_start       (i_start & i_update_key & o_done),\n    .i_key         (i_key                          ),\n    .o_idle        (key_idle                       ),\n    .o_done        (key_done                       ),\n    .o_expanded_key(expanded_key                   )\n);\n\nendmodule : aes_decrypt", "rtl/aes_ke.sv": "module aes_ke #(\n    parameter NBW_KEY = 'd128,\n    parameter NBW_OUT = 'd1408\n) (\n    input  logic               clk,\n    input  logic               rst_async_n,\n    input  logic               i_start,\n    input  logic [NBW_KEY-1:0] i_key,\n    output logic               o_idle,\n    output logic               o_done,\n    output logic [NBW_OUT-1:0] o_expanded_key\n);\n\n// ----------------------------------------\n// - Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE = 'd8;\nlocalparam NBW_WORD = 'd32;\nlocalparam STEPS    = 'd10;\n\n// ----------------------------------------\n// - Wires/registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0] Rcon   [STEPS];\nlogic [NBW_OUT-1:0]  expanded_key_nx;\nlogic [NBW_OUT-1:0]  expanded_key_ff;\nlogic [NBW_KEY-1:0]  step_key[STEPS];\nlogic [NBW_KEY-1:0]  valid_key;\nlogic [STEPS:0]      key_exp_steps_ff;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nassign o_expanded_key = expanded_key_ff;\nassign o_done = key_exp_steps_ff[STEPS];\nassign o_idle = ~(|key_exp_steps_ff);\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        expanded_key_ff  <= {NBW_OUT{1'b0}};\n        key_exp_steps_ff <= 0;\n    end else begin\n        expanded_key_ff <= expanded_key_nx;\n\n        key_exp_steps_ff <= {key_exp_steps_ff[STEPS-1:0], i_start};\n    end\nend\n\n\n// ----------------------------------------\n// - Operation logic\n// ----------------------------------------\nassign Rcon[0] = 8'h01;\nassign Rcon[1] = 8'h02;\nassign Rcon[2] = 8'h04;\nassign Rcon[3] = 8'h08;\nassign Rcon[4] = 8'h10;\nassign Rcon[5] = 8'h20;\nassign Rcon[6] = 8'h40;\nassign Rcon[7] = 8'h80;\nassign Rcon[8] = 8'h1b;\nassign Rcon[9] = 8'h36;\n\ngenerate\n    for(genvar i = 0; i < STEPS; i++) begin : steps\n        logic [NBW_WORD-1:0] RotWord;\n        logic [NBW_WORD-1:0] SubWord;\n        logic [NBW_WORD-1:0] RconXor;\n\n        sbox uu_sbox0 (\n            .i_data(RotWord[NBW_WORD-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n        );\n\n        sbox uu_sbox1 (\n            .i_data(RotWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        sbox uu_sbox2 (\n            .i_data(RotWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        sbox uu_sbox3 (\n            .i_data(RotWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE]),\n            .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n        );\n\n        always_comb begin : main_operation\n            RotWord = {expanded_key_ff[NBW_OUT-(i+1)*NBW_KEY+NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)], expanded_key_ff[NBW_OUT-(i+1)*NBW_KEY+NBW_WORD-1-:NBW_BYTE]};\n            RconXor = {SubWord[NBW_WORD-1-:NBW_BYTE]^Rcon[i], SubWord[NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)]};\n\n            step_key[i][NBW_KEY-1-:NBW_WORD]            = expanded_key_ff[NBW_OUT-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ RconXor;\n            step_key[i][NBW_KEY-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_OUT-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-1-:NBW_WORD];\n            step_key[i][NBW_KEY-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-NBW_WORD-1-:NBW_WORD];\n            step_key[i][NBW_KEY-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_KEY-2*NBW_WORD-1-:NBW_WORD];\n        end\n    end\nendgenerate\n\nassign expanded_key_nx = {valid_key  , step_key[0], step_key[1], step_key[2],\n                          step_key[3], step_key[4], step_key[5], step_key[6],\n                          step_key[7], step_key[8], step_key[9]};\n\nalways_comb begin : input_data\n    if (i_start) begin\n        valid_key = i_key;\n    end else begin\n        valid_key = expanded_key_ff[NBW_OUT-1-:NBW_KEY];\n    end\nend\n\nendmodule : aes_ke", "rtl/inv_sbox.sv": "module inv_sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h52;\n        8'h01: o_data = 8'h09;\n        8'h02: o_data = 8'h6a;\n        8'h03: o_data = 8'hd5;\n        8'h04: o_data = 8'h30;\n        8'h05: o_data = 8'h36;\n        8'h06: o_data = 8'ha5;\n        8'h07: o_data = 8'h38;\n        8'h08: o_data = 8'hbf;\n        8'h09: o_data = 8'h40;\n        8'h0a: o_data = 8'ha3;\n        8'h0b: o_data = 8'h9e;\n        8'h0c: o_data = 8'h81;\n        8'h0d: o_data = 8'hf3;\n        8'h0e: o_data = 8'hd7;\n        8'h0f: o_data = 8'hfb;\n        8'h10: o_data = 8'h7c;\n        8'h11: o_data = 8'he3;\n        8'h12: o_data = 8'h39;\n        8'h13: o_data = 8'h82;\n        8'h14: o_data = 8'h9b;\n        8'h15: o_data = 8'h2f;\n        8'h16: o_data = 8'hff;\n        8'h17: o_data = 8'h87;\n        8'h18: o_data = 8'h34;\n        8'h19: o_data = 8'h8e;\n        8'h1a: o_data = 8'h43;\n        8'h1b: o_data = 8'h44;\n        8'h1c: o_data = 8'hc4;\n        8'h1d: o_data = 8'hde;\n        8'h1e: o_data = 8'he9;\n        8'h1f: o_data = 8'hcb;\n        8'h20: o_data = 8'h54;\n        8'h21: o_data = 8'h7b;\n        8'h22: o_data = 8'h94;\n        8'h23: o_data = 8'h32;\n        8'h24: o_data = 8'ha6;\n        8'h25: o_data = 8'hc2;\n        8'h26: o_data = 8'h23;\n        8'h27: o_data = 8'h3d;\n        8'h28: o_data = 8'hee;\n        8'h29: o_data = 8'h4c;\n        8'h2a: o_data = 8'h95;\n        8'h2b: o_data = 8'h0b;\n        8'h2c: o_data = 8'h42;\n        8'h2d: o_data = 8'hfa;\n        8'h2e: o_data = 8'hc3;\n        8'h2f: o_data = 8'h4e;\n        8'h30: o_data = 8'h08;\n        8'h31: o_data = 8'h2e;\n        8'h32: o_data = 8'ha1;\n        8'h33: o_data = 8'h66;\n        8'h34: o_data = 8'h28;\n        8'h35: o_data = 8'hd9;\n        8'h36: o_data = 8'h24;\n        8'h37: o_data = 8'hb2;\n        8'h38: o_data = 8'h76;\n        8'h39: o_data = 8'h5b;\n        8'h3a: o_data = 8'ha2;\n        8'h3b: o_data = 8'h49;\n        8'h3c: o_data = 8'h6d;\n        8'h3d: o_data = 8'h8b;\n        8'h3e: o_data = 8'hd1;\n        8'h3f: o_data = 8'h25;\n        8'h40: o_data = 8'h72;\n        8'h41: o_data = 8'hf8;\n        8'h42: o_data = 8'hf6;\n        8'h43: o_data = 8'h64;\n        8'h44: o_data = 8'h86;\n        8'h45: o_data = 8'h68;\n        8'h46: o_data = 8'h98;\n        8'h47: o_data = 8'h16;\n        8'h48: o_data = 8'hd4;\n        8'h49: o_data = 8'ha4;\n        8'h4a: o_data = 8'h5c;\n        8'h4b: o_data = 8'hcc;\n        8'h4c: o_data = 8'h5d;\n        8'h4d: o_data = 8'h65;\n        8'h4e: o_data = 8'hb6;\n        8'h4f: o_data = 8'h92;\n        8'h50: o_data = 8'h6c;\n        8'h51: o_data = 8'h70;\n        8'h52: o_data = 8'h48;\n        8'h53: o_data = 8'h50;\n        8'h54: o_data = 8'hfd;\n        8'h55: o_data = 8'hed;\n        8'h56: o_data = 8'hb9;\n        8'h57: o_data = 8'hda;\n        8'h58: o_data = 8'h5e;\n        8'h59: o_data = 8'h15;\n        8'h5a: o_data = 8'h46;\n        8'h5b: o_data = 8'h57;\n        8'h5c: o_data = 8'ha7;\n        8'h5d: o_data = 8'h8d;\n        8'h5e: o_data = 8'h9d;\n        8'h5f: o_data = 8'h84;\n        8'h60: o_data = 8'h90;\n        8'h61: o_data = 8'hd8;\n        8'h62: o_data = 8'hab;\n        8'h63: o_data = 8'h00;\n        8'h64: o_data = 8'h8c;\n        8'h65: o_data = 8'hbc;\n        8'h66: o_data = 8'hd3;\n        8'h67: o_data = 8'h0a;\n        8'h68: o_data = 8'hf7;\n        8'h69: o_data = 8'he4;\n        8'h6a: o_data = 8'h58;\n        8'h6b: o_data = 8'h05;\n        8'h6c: o_data = 8'hb8;\n        8'h6d: o_data = 8'hb3;\n        8'h6e: o_data = 8'h45;\n        8'h6f: o_data = 8'h06;\n        8'h70: o_data = 8'hd0;\n        8'h71: o_data = 8'h2c;\n        8'h72: o_data = 8'h1e;\n        8'h73: o_data = 8'h8f;\n        8'h74: o_data = 8'hca;\n        8'h75: o_data = 8'h3f;\n        8'h76: o_data = 8'h0f;\n        8'h77: o_data = 8'h02;\n        8'h78: o_data = 8'hc1;\n        8'h79: o_data = 8'haf;\n        8'h7a: o_data = 8'hbd;\n        8'h7b: o_data = 8'h03;\n        8'h7c: o_data = 8'h01;\n        8'h7d: o_data = 8'h13;\n        8'h7e: o_data = 8'h8a;\n        8'h7f: o_data = 8'h6b;\n        8'h80: o_data = 8'h3a;\n        8'h81: o_data = 8'h91;\n        8'h82: o_data = 8'h11;\n        8'h83: o_data = 8'h41;\n        8'h84: o_data = 8'h4f;\n        8'h85: o_data = 8'h67;\n        8'h86: o_data = 8'hdc;\n        8'h87: o_data = 8'hea;\n        8'h88: o_data = 8'h97;\n        8'h89: o_data = 8'hf2;\n        8'h8a: o_data = 8'hcf;\n        8'h8b: o_data = 8'hce;\n        8'h8c: o_data = 8'hf0;\n        8'h8d: o_data = 8'hb4;\n        8'h8e: o_data = 8'he6;\n        8'h8f: o_data = 8'h73;\n        8'h90: o_data = 8'h96;\n        8'h91: o_data = 8'hac;\n        8'h92: o_data = 8'h74;\n        8'h93: o_data = 8'h22;\n        8'h94: o_data = 8'he7;\n        8'h95: o_data = 8'had;\n        8'h96: o_data = 8'h35;\n        8'h97: o_data = 8'h85;\n        8'h98: o_data = 8'he2;\n        8'h99: o_data = 8'hf9;\n        8'h9a: o_data = 8'h37;\n        8'h9b: o_data = 8'he8;\n        8'h9c: o_data = 8'h1c;\n        8'h9d: o_data = 8'h75;\n        8'h9e: o_data = 8'hdf;\n        8'h9f: o_data = 8'h6e;\n        8'ha0: o_data = 8'h47;\n        8'ha1: o_data = 8'hf1;\n        8'ha2: o_data = 8'h1a;\n        8'ha3: o_data = 8'h71;\n        8'ha4: o_data = 8'h1d;\n        8'ha5: o_data = 8'h29;\n        8'ha6: o_data = 8'hc5;\n        8'ha7: o_data = 8'h89;\n        8'ha8: o_data = 8'h6f;\n        8'ha9: o_data = 8'hb7;\n        8'haa: o_data = 8'h62;\n        8'hab: o_data = 8'h0e;\n        8'hac: o_data = 8'haa;\n        8'had: o_data = 8'h18;\n        8'hae: o_data = 8'hbe;\n        8'haf: o_data = 8'h1b;\n        8'hb0: o_data = 8'hfc;\n        8'hb1: o_data = 8'h56;\n        8'hb2: o_data = 8'h3e;\n        8'hb3: o_data = 8'h4b;\n        8'hb4: o_data = 8'hc6;\n        8'hb5: o_data = 8'hd2;\n        8'hb6: o_data = 8'h79;\n        8'hb7: o_data = 8'h20;\n        8'hb8: o_data = 8'h9a;\n        8'hb9: o_data = 8'hdb;\n        8'hba: o_data = 8'hc0;\n        8'hbb: o_data = 8'hfe;\n        8'hbc: o_data = 8'h78;\n        8'hbd: o_data = 8'hcd;\n        8'hbe: o_data = 8'h5a;\n        8'hbf: o_data = 8'hf4;\n        8'hc0: o_data = 8'h1f;\n        8'hc1: o_data = 8'hdd;\n        8'hc2: o_data = 8'ha8;\n        8'hc3: o_data = 8'h33;\n        8'hc4: o_data = 8'h88;\n        8'hc5: o_data = 8'h07;\n        8'hc6: o_data = 8'hc7;\n        8'hc7: o_data = 8'h31;\n        8'hc8: o_data = 8'hb1;\n        8'hc9: o_data = 8'h12;\n        8'hca: o_data = 8'h10;\n        8'hcb: o_data = 8'h59;\n        8'hcc: o_data = 8'h27;\n        8'hcd: o_data = 8'h80;\n        8'hce: o_data = 8'hec;\n        8'hcf: o_data = 8'h5f;\n        8'hd0: o_data = 8'h60;\n        8'hd1: o_data = 8'h51;\n        8'hd2: o_data = 8'h7f;\n        8'hd3: o_data = 8'ha9;\n        8'hd4: o_data = 8'h19;\n        8'hd5: o_data = 8'hb5;\n        8'hd6: o_data = 8'h4a;\n        8'hd7: o_data = 8'h0d;\n        8'hd8: o_data = 8'h2d;\n        8'hd9: o_data = 8'he5;\n        8'hda: o_data = 8'h7a;\n        8'hdb: o_data = 8'h9f;\n        8'hdc: o_data = 8'h93;\n        8'hdd: o_data = 8'hc9;\n        8'hde: o_data = 8'h9c;\n        8'hdf: o_data = 8'hef;\n        8'he0: o_data = 8'ha0;\n        8'he1: o_data = 8'he0;\n        8'he2: o_data = 8'h3b;\n        8'he3: o_data = 8'h4d;\n        8'he4: o_data = 8'hae;\n        8'he5: o_data = 8'h2a;\n        8'he6: o_data = 8'hf5;\n        8'he7: o_data = 8'hb0;\n        8'he8: o_data = 8'hc8;\n        8'he9: o_data = 8'heb;\n        8'hea: o_data = 8'hbb;\n        8'heb: o_data = 8'h3c;\n        8'hec: o_data = 8'h83;\n        8'hed: o_data = 8'h53;\n        8'hee: o_data = 8'h99;\n        8'hef: o_data = 8'h61;\n        8'hf0: o_data = 8'h17;\n        8'hf1: o_data = 8'h2b;\n        8'hf2: o_data = 8'h04;\n        8'hf3: o_data = 8'h7e;\n        8'hf4: o_data = 8'hba;\n        8'hf5: o_data = 8'h77;\n        8'hf6: o_data = 8'hd6;\n        8'hf7: o_data = 8'h26;\n        8'hf8: o_data = 8'he1;\n        8'hf9: o_data = 8'h69;\n        8'hfa: o_data = 8'h14;\n        8'hfb: o_data = 8'h63;\n        8'hfc: o_data = 8'h55;\n        8'hfd: o_data = 8'h21;\n        8'hfe: o_data = 8'h0c;\n        8'hff: o_data = 8'h7d;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : inv_sbox", "rtl/sbox.sv": "module sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h63;\n        8'h01: o_data = 8'h7C;\n        8'h02: o_data = 8'h77;\n        8'h03: o_data = 8'h7B;\n        8'h04: o_data = 8'hF2;\n        8'h05: o_data = 8'h6B;\n        8'h06: o_data = 8'h6F;\n        8'h07: o_data = 8'hC5;\n        8'h08: o_data = 8'h30;\n        8'h09: o_data = 8'h01;\n        8'h0A: o_data = 8'h67;\n        8'h0B: o_data = 8'h2B;\n        8'h0C: o_data = 8'hFE;\n        8'h0D: o_data = 8'hD7;\n        8'h0E: o_data = 8'hAB;\n        8'h0F: o_data = 8'h76;\n        8'h10: o_data = 8'hCA;\n        8'h11: o_data = 8'h82;\n        8'h12: o_data = 8'hC9;\n        8'h13: o_data = 8'h7D;\n        8'h14: o_data = 8'hFA;\n        8'h15: o_data = 8'h59;\n        8'h16: o_data = 8'h47;\n        8'h17: o_data = 8'hF0;\n        8'h18: o_data = 8'hAD;\n        8'h19: o_data = 8'hD4;\n        8'h1A: o_data = 8'hA2;\n        8'h1B: o_data = 8'hAF;\n        8'h1C: o_data = 8'h9C;\n        8'h1D: o_data = 8'hA4;\n        8'h1E: o_data = 8'h72;\n        8'h1F: o_data = 8'hC0;\n        8'h20: o_data = 8'hB7;\n        8'h21: o_data = 8'hFD;\n        8'h22: o_data = 8'h93;\n        8'h23: o_data = 8'h26;\n        8'h24: o_data = 8'h36;\n        8'h25: o_data = 8'h3F;\n        8'h26: o_data = 8'hF7;\n        8'h27: o_data = 8'hCC;\n        8'h28: o_data = 8'h34;\n        8'h29: o_data = 8'hA5;\n        8'h2A: o_data = 8'hE5;\n        8'h2B: o_data = 8'hF1;\n        8'h2C: o_data = 8'h71;\n        8'h2D: o_data = 8'hD8;\n        8'h2E: o_data = 8'h31;\n        8'h2F: o_data = 8'h15;\n        8'h30: o_data = 8'h04;\n        8'h31: o_data = 8'hC7;\n        8'h32: o_data = 8'h23;\n        8'h33: o_data = 8'hC3;\n        8'h34: o_data = 8'h18;\n        8'h35: o_data = 8'h96;\n        8'h36: o_data = 8'h05;\n        8'h37: o_data = 8'h9A;\n        8'h38: o_data = 8'h07;\n        8'h39: o_data = 8'h12;\n        8'h3A: o_data = 8'h80;\n        8'h3B: o_data = 8'hE2;\n        8'h3C: o_data = 8'hEB;\n        8'h3D: o_data = 8'h27;\n        8'h3E: o_data = 8'hB2;\n        8'h3F: o_data = 8'h75;\n        8'h40: o_data = 8'h09;\n        8'h41: o_data = 8'h83;\n        8'h42: o_data = 8'h2C;\n        8'h43: o_data = 8'h1A;\n        8'h44: o_data = 8'h1B;\n        8'h45: o_data = 8'h6E;\n        8'h46: o_data = 8'h5A;\n        8'h47: o_data = 8'hA0;\n        8'h48: o_data = 8'h52;\n        8'h49: o_data = 8'h3B;\n        8'h4A: o_data = 8'hD6;\n        8'h4B: o_data = 8'hB3;\n        8'h4C: o_data = 8'h29;\n        8'h4D: o_data = 8'hE3;\n        8'h4E: o_data = 8'h2F;\n        8'h4F: o_data = 8'h84;\n        8'h50: o_data = 8'h53;\n        8'h51: o_data = 8'hD1;\n        8'h52: o_data = 8'h00;\n        8'h53: o_data = 8'hED;\n        8'h54: o_data = 8'h20;\n        8'h55: o_data = 8'hFC;\n        8'h56: o_data = 8'hB1;\n        8'h57: o_data = 8'h5B;\n        8'h58: o_data = 8'h6A;\n        8'h59: o_data = 8'hCB;\n        8'h5A: o_data = 8'hBE;\n        8'h5B: o_data = 8'h39;\n        8'h5C: o_data = 8'h4A;\n        8'h5D: o_data = 8'h4C;\n        8'h5E: o_data = 8'h58;\n        8'h5F: o_data = 8'hCF;\n        8'h60: o_data = 8'hD0;\n        8'h61: o_data = 8'hEF;\n        8'h62: o_data = 8'hAA;\n        8'h63: o_data = 8'hFB;\n        8'h64: o_data = 8'h43;\n        8'h65: o_data = 8'h4D;\n        8'h66: o_data = 8'h33;\n        8'h67: o_data = 8'h85;\n        8'h68: o_data = 8'h45;\n        8'h69: o_data = 8'hF9;\n        8'h6A: o_data = 8'h02;\n        8'h6B: o_data = 8'h7F;\n        8'h6C: o_data = 8'h50;\n        8'h6D: o_data = 8'h3C;\n        8'h6E: o_data = 8'h9F;\n        8'h6F: o_data = 8'hA8;\n        8'h70: o_data = 8'h51;\n        8'h71: o_data = 8'hA3;\n        8'h72: o_data = 8'h40;\n        8'h73: o_data = 8'h8F;\n        8'h74: o_data = 8'h92;\n        8'h75: o_data = 8'h9D;\n        8'h76: o_data = 8'h38;\n        8'h77: o_data = 8'hF5;\n        8'h78: o_data = 8'hBC;\n        8'h79: o_data = 8'hB6;\n        8'h7A: o_data = 8'hDA;\n        8'h7B: o_data = 8'h21;\n        8'h7C: o_data = 8'h10;\n        8'h7D: o_data = 8'hFF;\n        8'h7E: o_data = 8'hF3;\n        8'h7F: o_data = 8'hD2;\n        8'h80: o_data = 8'hCD;\n        8'h81: o_data = 8'h0C;\n        8'h82: o_data = 8'h13;\n        8'h83: o_data = 8'hEC;\n        8'h84: o_data = 8'h5F;\n        8'h85: o_data = 8'h97;\n        8'h86: o_data = 8'h44;\n        8'h87: o_data = 8'h17;\n        8'h88: o_data = 8'hC4;\n        8'h89: o_data = 8'hA7;\n        8'h8A: o_data = 8'h7E;\n        8'h8B: o_data = 8'h3D;\n        8'h8C: o_data = 8'h64;\n        8'h8D: o_data = 8'h5D;\n        8'h8E: o_data = 8'h19;\n        8'h8F: o_data = 8'h73;\n        8'h90: o_data = 8'h60;\n        8'h91: o_data = 8'h81;\n        8'h92: o_data = 8'h4F;\n        8'h93: o_data = 8'hDC;\n        8'h94: o_data = 8'h22;\n        8'h95: o_data = 8'h2A;\n        8'h96: o_data = 8'h90;\n        8'h97: o_data = 8'h88;\n        8'h98: o_data = 8'h46;\n        8'h99: o_data = 8'hEE;\n        8'h9A: o_data = 8'hB8;\n        8'h9B: o_data = 8'h14;\n        8'h9C: o_data = 8'hDE;\n        8'h9D: o_data = 8'h5E;\n        8'h9E: o_data = 8'h0B;\n        8'h9F: o_data = 8'hDB;\n        8'hA0: o_data = 8'hE0;\n        8'hA1: o_data = 8'h32;\n        8'hA2: o_data = 8'h3A;\n        8'hA3: o_data = 8'h0A;\n        8'hA4: o_data = 8'h49;\n        8'hA5: o_data = 8'h06;\n        8'hA6: o_data = 8'h24;\n        8'hA7: o_data = 8'h5C;\n        8'hA8: o_data = 8'hC2;\n        8'hA9: o_data = 8'hD3;\n        8'hAA: o_data = 8'hAC;\n        8'hAB: o_data = 8'h62;\n        8'hAC: o_data = 8'h91;\n        8'hAD: o_data = 8'h95;\n        8'hAE: o_data = 8'hE4;\n        8'hAF: o_data = 8'h79;\n        8'hB0: o_data = 8'hE7;\n        8'hB1: o_data = 8'hC8;\n        8'hB2: o_data = 8'h37;\n        8'hB3: o_data = 8'h6D;\n        8'hB4: o_data = 8'h8D;\n        8'hB5: o_data = 8'hD5;\n        8'hB6: o_data = 8'h4E;\n        8'hB7: o_data = 8'hA9;\n        8'hB8: o_data = 8'h6C;\n        8'hB9: o_data = 8'h56;\n        8'hBA: o_data = 8'hF4;\n        8'hBB: o_data = 8'hEA;\n        8'hBC: o_data = 8'h65;\n        8'hBD: o_data = 8'h7A;\n        8'hBE: o_data = 8'hAE;\n        8'hBF: o_data = 8'h08;\n        8'hC0: o_data = 8'hBA;\n        8'hC1: o_data = 8'h78;\n        8'hC2: o_data = 8'h25;\n        8'hC3: o_data = 8'h2E;\n        8'hC4: o_data = 8'h1C;\n        8'hC5: o_data = 8'hA6;\n        8'hC6: o_data = 8'hB4;\n        8'hC7: o_data = 8'hC6;\n        8'hC8: o_data = 8'hE8;\n        8'hC9: o_data = 8'hDD;\n        8'hCA: o_data = 8'h74;\n        8'hCB: o_data = 8'h1F;\n        8'hCC: o_data = 8'h4B;\n        8'hCD: o_data = 8'hBD;\n        8'hCE: o_data = 8'h8B;\n        8'hCF: o_data = 8'h8A;\n        8'hD0: o_data = 8'h70;\n        8'hD1: o_data = 8'h3E;\n        8'hD2: o_data = 8'hB5;\n        8'hD3: o_data = 8'h66;\n        8'hD4: o_data = 8'h48;\n        8'hD5: o_data = 8'h03;\n        8'hD6: o_data = 8'hF6;\n        8'hD7: o_data = 8'h0E;\n        8'hD8: o_data = 8'h61;\n        8'hD9: o_data = 8'h35;\n        8'hDA: o_data = 8'h57;\n        8'hDB: o_data = 8'hB9;\n        8'hDC: o_data = 8'h86;\n        8'hDD: o_data = 8'hC1;\n        8'hDE: o_data = 8'h1D;\n        8'hDF: o_data = 8'h9E;\n        8'hE0: o_data = 8'hE1;\n        8'hE1: o_data = 8'hF8;\n        8'hE2: o_data = 8'h98;\n        8'hE3: o_data = 8'h11;\n        8'hE4: o_data = 8'h69;\n        8'hE5: o_data = 8'hD9;\n        8'hE6: o_data = 8'h8E;\n        8'hE7: o_data = 8'h94;\n        8'hE8: o_data = 8'h9B;\n        8'hE9: o_data = 8'h1E;\n        8'hEA: o_data = 8'h87;\n        8'hEB: o_data = 8'hE9;\n        8'hEC: o_data = 8'hCE;\n        8'hED: o_data = 8'h55;\n        8'hEE: o_data = 8'h28;\n        8'hEF: o_data = 8'hDF;\n        8'hF0: o_data = 8'h8C;\n        8'hF1: o_data = 8'hA1;\n        8'hF2: o_data = 8'h89;\n        8'hF3: o_data = 8'h0D;\n        8'hF4: o_data = 8'hBF;\n        8'hF5: o_data = 8'hE6;\n        8'hF6: o_data = 8'h42;\n        8'hF7: o_data = 8'h68;\n        8'hF8: o_data = 8'h41;\n        8'hF9: o_data = 8'h99;\n        8'hFA: o_data = 8'h2D;\n        8'hFB: o_data = 8'h0F;\n        8'hFC: o_data = 8'hB0;\n        8'hFD: o_data = 8'h54;\n        8'hFE: o_data = 8'hBB;\n        8'hFF: o_data = 8'h16;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : sbox", "verif/tb_aes_decrypt.sv": "module tb_aes_decrypt;\n\nlocalparam NBW_KEY  = 'd256;\nlocalparam NBW_DATA = 'd128;\n\nlogic                clk;\nlogic                rst_async_n;\nlogic                i_update_key;\nlogic [NBW_KEY-1:0]  i_key;\nlogic                i_start;\nlogic [NBW_DATA-1:0] i_data;\nlogic                o_done;\nlogic [NBW_DATA-1:0] o_data;\n\naes_decrypt #(\n    .NBW_KEY (NBW_KEY),\n    .NBW_DATA(NBW_DATA)\n) uu_aes_decrypt (\n    .clk(clk),\n    .rst_async_n(rst_async_n),\n    .i_update_key(i_update_key),\n    .i_key(i_key),\n    .i_start(i_start),\n    .i_data(i_data),\n    .o_done(o_done),\n    .o_data(o_data)\n);\n\ntask Simple_test(logic update_key);\n    @(negedge clk);\n    i_key  = 256'h000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;\n    i_data = 128'h8ea2b7ca516745bfeafc49904b496089;\n    i_update_key = update_key;\n    i_start = 1;\n\n    @(negedge clk);\n    i_start = 0;\n    i_update_key = 0;\n    i_key = 0;\n\n    @(posedge o_done);\n    @(negedge clk);\n\n    if(o_data == 128'h00112233445566778899aabbccddeeff) begin\n        $display(\"PASS\");\n    end else begin\n        $display(\"FAIL\");\n        $display(\"Expected output: %h\", 128'h00112233445566778899aabbccddeeff);\n        $display(\"Observed output: %h\", o_data);\n    end\nendtask\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb_aes_decrypt);\nend\n\nalways #5 clk = ~clk;\n\ninitial begin\n    clk = 0;\n    i_start = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    // Tasks go here\n    Simple_test(1'b1);\n    Simple_test(1'b0);\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/aes_decrypt.sv": "", "rtl/aes_ke.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n", "src/.env": "VERILOG_SOURCES = /code/rtl/aes_decrypt.sv /code/rtl/aes_ke.sv /code/rtl/inv_sbox.sv /code/rtl/sbox.sv\nTOPLEVEL        = aes_decrypt\nMODULE          = test_aes_decrypt\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 12-modify-aes-decrypt-to-256\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass aes_decrypt:\n    RCON = [\n        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n    ]\n    \n    SBOX = [\n        # S-box table used in AES\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n    \n    def __init__(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        # Compute inverse S-Box\n        self.inv_s_box = [0] * 256\n        for i, val in enumerate(self.SBOX):\n            self.inv_s_box[val] = i\n    \n    def reset(self):\n        self.expanded_key = 0\n        self.data_out = 0\n    \n    def update_key(self, key):\n        key_bytes = key.to_bytes(32, 'big')  # Convert 256-bit key to bytes\n        self.expanded_key = self.expand_key(key_bytes)\n    \n    def expand_key(self, key):\n        words = [list(key[i:i+4]) for i in range(0, 32, 4)]\n        \n        for i in range(8, 60):\n            temp = words[i - 1]\n            \n            if i % 8 == 0:\n                temp = self.sub_word(self.rot_word(temp))\n                temp[0] ^= self.RCON[i // 8 - 1]\n            elif i % 8 == 4:\n                temp = self.sub_word(temp)\n            \n            words.append([words[i - 8][j] ^ temp[j] for j in range(4)])\n        \n        expanded_key_bytes = b''.join(bytes(word) for word in words)\n        return int.from_bytes(expanded_key_bytes, 'big')\n    \n    def sub_word(self, word):\n        return [self.SBOX[b] for b in word]\n    \n    def rot_word(self, word):\n        return word[1:] + word[:1]\n    \n    def gmul(self, a, b):\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def inv_sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.inv_s_box[state[i]]\n\n    def inv_shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[13], state[1], state[5], state[9]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[7], state[11], state[15], state[3]\n\n    def inv_mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],14)^self.gmul(a[1],11)^self.gmul(a[2],13)^self.gmul(a[3],9)\n            s[i*4+1] = self.gmul(a[0],9)^self.gmul(a[1],14)^self.gmul(a[2],11)^self.gmul(a[3],13)\n            s[i*4+2] = self.gmul(a[0],13)^self.gmul(a[1],9)^self.gmul(a[2],14)^self.gmul(a[3],11)\n            s[i*4+3] = self.gmul(a[0],11)^self.gmul(a[1],13)^self.gmul(a[2],9)^self.gmul(a[3],14)\n\n    def add_round_key(self, state, round_key_words):\n        for col in range(4):\n            rk = round_key_words[col]\n            for row in range(4):\n                state[col * 4 + row] ^= (rk >> (24 - 8 * row)) & 0xFF\n\n    def get_round_keys(self):\n        expanded_bytes = self.expanded_key.to_bytes(240, 'big')\n        round_keys = []\n        for i in range(0, 240, 16):  # Each round key is 16 bytes (4 words)\n            words = [int.from_bytes(expanded_bytes[i + j*4 : i + (j+1)*4], 'big') for j in range(4)]\n            round_keys.append(words)\n        return round_keys\n\n    def decrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n\n        self.add_round_key(state, round_keys[14])\n\n        for rnd in range(13, 0, -1):\n            self.inv_shift_rows(state)\n            self.inv_sub_bytes(state)\n            self.add_round_key(state, round_keys[rnd])\n            self.inv_mix_columns(state)\n\n        self.inv_shift_rows(state)\n        self.inv_sub_bytes(state)\n        self.add_round_key(state, round_keys[0])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b", "src/test_aes_decrypt.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_data.value.to_unsigned()\n\n    model_data = model.data_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_aes_decrypt(dut):\n    \"\"\"Test the aes_decrypt module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.aes_decrypt()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**128 - 1\n\n    key_min = 0\n    key_max = 2**256 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_update_key.value = 0\n        dut.i_key.value        = 0\n        dut.i_start.value      = 0\n        dut.i_data.value       = 0\n        dut.rst_async_n.value  = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value  = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        for j in range(runs):\n            if j%100 == 0:\n                print(f'Reset {i}, run {j}')\n                \n            data = random.randint(data_min, data_max)\n            key = random.randint(key_min, key_max)\n            if j == 0:\n                update_key = 1\n            else:\n                update_key = random.randint(0,1)\n            \n            dut.i_update_key.value = update_key\n            dut.i_start.value      = 1\n            dut.i_key.value        = key\n            dut.i_data.value       = data\n\n            if update_key == 1:\n                model.update_key(key)\n            \n            model.decrypt(data)\n\n            await RisingEdge(dut.clk)\n            dut.i_update_key.value = 0\n            dut.i_start.value      = 0\n            dut.i_data.value       = 0\n            dut.i_key.value        = 0\n            await RisingEdge(dut.clk)\n            while dut.o_done.value == 0:\n                await RisingEdge(dut.clk)\n            \n            compare_values(dut, model)\n            ", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()"}}
{"id": "cvdp_agentic_eagle_jade_forest_0681", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "Update `aes_enc_top` and `aes_dec_top` RTLs so that the CTR block cipher mode changes how it concatenates the IV with the counter. The first 16 bits should be the 16 MSB of the counter, the next 96 should be the bits [111:16] from the IV and the next 16 bits should be the 16 LSB from the counter. As an example:\n\n- `IV = 128'h00112233445566778899aabbccddeeff` and `counter = 32'h55443322`, the combination of them (used in the input of the encryption module in both `aes_dec_top` and `aes_enc_top`) should be `enc_in = 128'h55442233445566778899aabbccdd3322`.\n\nAlso, create a new module that instantiates both `aes_enc_top` and `aes_dec_top` modules and uses them to perform encryption or decryption depending on the `i_encrypt` control signal. This module should add support for four different padding modes used in block ciphers. The testbench to validate this functionality is provided in the `verif` directory, and no other changes, besides those described above, are required in any other RTL. This new module is described below:\n\n### Specifications\n\n- **Module Name**: `padding_top` (defined in `rtl/padding_top.sv`)\n- **Parameters**:\n    - `NBW_KEY`: Bit width of the encryption/decryption key.\n        - Default: 256.\n        - Related interface signals: `i_key`.\n    - `NBW_DATA`: Bit width of the input and output data blocks.\n        - Default: 128.\n        - Related interface signals: `i_data`, `o_data`, `i_iv`.\n    - `NBW_MODE`: Bit width for cipher mode selection.\n        - Default: 3.\n        - Related interface signals: `i_mode`.\n    - `NBW_CNTR`: Bit width of the counter (used in CTR mode).\n        - Default: 32.\n    - `NBW_PADD`: Bit width to represent padding length.\n        - Default: 4.\n        - Related interface signals: `i_padding_bytes`.\n    - `NBW_PMOD`: Bit width to represent padding mode.\n        - Default: 2.\n        - Related interface signals: `i_padding_mode`.\n    - `W3C_BYTE`: Byte used for W3C padding.\n        - Default: 8'hAF.\n\n### Interface signals\n\n- **Clock** (`clk`): Synchronizes operation on the rising edge.\n- **Asynchronous Reset** (`rst_async_n`): Active low. Resets internal registers including the padding mode.\n- **Encryption Mode** (`i_encrypt`): When high, the encryption path is selected; otherwise, the decryption path is selected. It should remain at the desired value while configuring the IV, mode and resetting the counter, until the operation is done.\n- **Padding Mode Update** (`i_update_padding_mode`): When high, updates the internal padding mode register with `i_padding_mode`.\n- **Padding Mode Selection** (`[NBW_PMOD-1:0] i_padding_mode`): Selects the padding logic to apply.\n- **Padding Byte Count** (`[NBW_PADD-1:0] i_padding_bytes`): Indicates how many bytes of the input should be padded.\n- **Reset Counter** (`i_reset_counter`): Reset signal for CTR mode. It resets the internal counter.\n- **IV Update** (`i_update_iv`): When high, updates internal IV register with `i_iv`.\n- **IV Data** (`[NBW_DATA-1:0] i_iv`): Input initialization vector.\n- **Mode Update** (`i_update_mode`): When high, updates the internal cipher mode register with `i_mode`.\n- **Mode** (`[NBW_MODE-1:0] i_mode`): Indicates which cipher mode to use (e.g., ECB, CBC, etc.).\n- **Key Update** (`i_update_key`): When high and `i_start` is asserted, updates the key.\n- **Key** (`[NBW_KEY-1:0] i_key`): Encryption/decryption key.\n- **Start Operation** (`i_start`): Triggers encryption or decryption depending on `i_encrypt`.\n- **Input Data** (`[NBW_DATA-1:0] i_data`): The plaintext or ciphertext block to be processed.\n- **Done** (`o_done`): Indicates operation completion.\n- **Output Data** (`[NBW_DATA-1:0] o_data`): The processed (encrypted or decrypted) data block.\n\n### Internal Behavior\n\n- The internal padding mode register is updated sequentially when `i_update_padding_mode` is high. It is cleared asynchronously when `rst_async_n` is low.\n- The padding logic is combinational and modifies the least significant bytes of the input data block according to the selected padding mode.\n- No padding is done when `i_padding_bytes == 0`, regardless of the selected padding mode.\n- Given that the **Input Data** `i_data` is a fixed size (16 bytes), the padding is done by replacing the least significant bytes, instead of adding them (assuming that those bytes marked for padding are invalid in the input data).\n- Since the **Padding Byte Count** is at most 15, the 16th byte of the **Input Data** will never be padded. The **Padding Byte Count** is limited to 15 given that for the 16th byte to be padded, the padding byte count should be 16 (which, again, is not allowed), and no data would be encrypted/decrypted, only the padding.\n- The `aes_enc_top` used only when `i_encrypt == 1`.\n- The `aes_dec_top` used only when `i_encrypt == 0`.\n- Control signals like `i_update_iv`, `i_update_mode`, `i_update_key`, `i_reset_counter`, and `i_start` are gated so only the selected AES module receives them.\n\n### Supported Padding Modes\n\n- **PKCS#7** (`PKCS = 2'b00`):\n    - Each padding byte is filled with the number of padding bytes.\n    - Example: If 2 bytes are padded, both are `8'h02`.\n\n- **One-And-Zeroes** (`ONEANDZEROES = 2'b01`):\n    - First padding byte(most significant) is `8'h80`, remaining padded bytes are `8'h00`.\n\n- **ANSI X9.23** (`ANSIX923 = 2'b10`):\n    - All padding bytes are `8'h00`, except the last one(least significant), which contains the number of padded bytes.\n\n- **W3C** (`W3C = 2'b11`):\n    - All padding bytes are filled with the `W3C_BYTE` parameter (default is `8'hAF`), except the last one which contains the number of padded bytes.\n", "context": {"rtl/aes_dec_top.sv": "module aes_dec_top #(\n    parameter NBW_KEY  = 'd256,\n    parameter NBW_DATA = 'd128,\n    parameter NBW_MODE = 'd3,\n    parameter NBW_CNTR = 'd32\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_reset_counter,\n    input  logic                i_update_iv,\n    input  logic [NBW_DATA-1:0] i_iv,\n    input  logic                i_update_mode,\n    input  logic [NBW_MODE-1:0] i_mode,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_ciphertext,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_plaintext\n);\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_MODE-1:0] mode_ff;\nlogic [NBW_DATA-1:0] ciphertext_ff;\nlogic [NBW_DATA-1:0] iv_ff;\nlogic [NBW_DATA-1:0] iv_nx;\nlogic [NBW_DATA-1:0] plaintext;\nlogic [NBW_DATA-1:0] dec_in;\nlogic [NBW_DATA-1:0] dec_out;\nlogic                update_key_ff;\nlogic                start_dec_ff;\nlogic                start_enc_ff;\nlogic                dec_done;\nlogic [NBW_KEY-1:0]  key_ff;\nlogic [NBW_CNTR-1:0] counter_ff;\nlogic                dec_sel;\nlogic [NBW_DATA-1:0] enc_out;\nlogic                enc_done;\n\n// Possible operation modes\nlocalparam ECB  = 3'd0;\nlocalparam CBC  = 3'd1;\nlocalparam PCBC = 3'd2;\nlocalparam CFB  = 3'd3;\nlocalparam OFB  = 3'd4;\nlocalparam CTR  = 3'd5;\n\n// Operation modes logic\nalways_comb begin\n    case(mode_ff)\n        ECB: begin\n            dec_in    = ciphertext_ff;\n            iv_nx     = iv_ff;\n            plaintext = dec_out;\n            dec_sel   = 1'b1;\n        end\n        CBC: begin\n            dec_in    = ciphertext_ff;\n            iv_nx     = ciphertext_ff;\n            plaintext = dec_out ^ iv_ff;\n            dec_sel   = 1'b1;\n        end\n        PCBC: begin\n            dec_in    = ciphertext_ff;\n            iv_nx     = ciphertext_ff ^ dec_out ^ iv_ff;\n            plaintext = dec_out ^ iv_ff;\n            dec_sel   = 1'b1;\n        end\n        CFB: begin\n            dec_in    = iv_ff;\n            iv_nx     = ciphertext_ff;\n            plaintext = ciphertext_ff ^ enc_out;\n            dec_sel   = 1'b0;\n        end\n        OFB: begin\n            dec_in    = iv_ff;\n            iv_nx     = enc_out;\n            plaintext = ciphertext_ff ^ enc_out;\n            dec_sel   = 1'b0;\n        end\n        CTR: begin\n            dec_in    = {iv_ff[NBW_DATA-1:NBW_CNTR], counter_ff};\n            iv_nx     = iv_ff;\n            plaintext = ciphertext_ff ^ enc_out;\n            dec_sel   = 1'b0;\n        end\n        default: begin\n            dec_in    = ciphertext_ff;\n            iv_nx     = iv_ff;\n            plaintext = dec_out;\n            dec_sel   = 1'b1;\n        end\n    endcase\nend\n\nalways_ff @ (posedge clk) begin : data_regs\n    if(i_start & o_done) begin\n        ciphertext_ff <= i_ciphertext;\n    end\nend\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin : reset_regs\n    if(!rst_async_n) begin\n        iv_ff        <= 128'd0;\n        mode_ff      <= 3'd0;\n        o_done       <= 1'b1;\n        o_plaintext  <= 128'd0;\n        counter_ff   <= 0;\n        start_enc_ff <= 1'b0;\n        start_dec_ff <= 1'b0;\n    end else begin\n        if(i_update_iv) begin\n            iv_ff <= i_iv;\n        end else begin\n            if(dec_done | enc_done) begin\n                iv_ff <= iv_nx;\n            end\n        end\n\n        if(i_update_mode) begin\n            mode_ff <= i_mode;\n        end\n\n        if(dec_done | enc_done) begin\n            o_done <= 1'b1;\n        end else begin\n            if(i_start & o_done) begin\n                o_done <= 1'b0;\n            end\n        end\n\n        if(dec_done | enc_done) begin\n            o_plaintext <= plaintext;\n        end\n\n        if(i_reset_counter) begin\n            counter_ff <= 0;\n        end else if((dec_done | enc_done) & mode_ff == CTR) begin\n            counter_ff <= counter_ff + 1'b1;\n        end\n\n        start_enc_ff  <= (i_start & o_done & (~dec_sel));\n        start_dec_ff  <= (i_start & o_done & dec_sel);\n        update_key_ff <= (i_start & i_update_key & o_done);\n        if(i_start & i_update_key & o_done) begin\n            key_ff <= i_key;\n        end\n    end\nend\n\naes_decrypt #(\n    .NBW_KEY (NBW_KEY ),\n    .NBW_DATA(NBW_DATA)\n) uu_aes256_decrypt (\n    .clk         (clk          ),\n    .rst_async_n (rst_async_n  ),\n    .i_update_key(update_key_ff),\n    .i_key       (key_ff       ),\n    .i_start     (start_dec_ff ),\n    .i_data      (dec_in       ),\n    .o_done      (dec_done     ),\n    .o_data      (dec_out      )\n);\n\naes_encrypt #(\n    .NBW_KEY (NBW_KEY ),\n    .NBW_DATA(NBW_DATA)\n) uu_aes_encrypt (\n    .clk         (clk          ),\n    .rst_async_n (rst_async_n  ),\n    .i_update_key(update_key_ff),\n    .i_key       (key_ff       ),\n    .i_start     (start_enc_ff ),\n    .i_data      (dec_in       ),\n    .o_data      (enc_out      ),\n    .o_done      (enc_done     )\n);\n\nendmodule : aes_dec_top", "rtl/aes_decrypt.sv": "module aes_decrypt #(\n    parameter NBW_KEY  = 'd256,\n    parameter NBW_DATA = 'd128\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_data,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE   = 'd8;\nlocalparam NBW_EX_KEY = 'd1920;\nlocalparam NBW_STEP   = NBW_KEY/2;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   current_data_nx[4][4];\nlogic [NBW_BYTE-1:0]   current_data_ff[4][4];\nlogic [NBW_BYTE-1:0]   AddRoundKey[4][4];\nlogic [NBW_BYTE-1:0]   SubBytes[4][4];\nlogic [NBW_BYTE-1:0]   ShiftRows[4][4];\nlogic [NBW_BYTE-1:0]   xtimes02[4][4];\nlogic [NBW_BYTE-1:0]   xtimes04[4][4];\nlogic [NBW_BYTE-1:0]   xtimes08[4][4];\nlogic [NBW_BYTE-1:0]   xtimes09[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0b[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0d[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0e[4][4];\nlogic [NBW_BYTE-1:0]   MixColumns[4][4];\nlogic [3:0]            round_ff;\nlogic                  key_done;\nlogic                  key_idle;\nlogic [NBW_EX_KEY-1:0] expanded_key;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        o_done <= 1'b0;\n    end else begin\n        o_done <= (round_ff == 4'd15);\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : out_row\n        for(genvar j = 0; j < 4; j++) begin : out_col\n            assign o_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] = current_data_ff[i][j];\n        end\n    end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : inv_cypher_regs\n    if(!rst_async_n) begin\n        round_ff <= 4'd0;\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= 8'd0;\n            end\n        end\n    end else begin\n        if(i_start) begin\n            if(i_update_key) begin\n                round_ff <= 4'd0;\n            end else begin\n                round_ff <= 4'd1;\n            end\n        end else if((round_ff > 4'd0 && round_ff < 4'd15) || key_done) begin\n            round_ff <= round_ff + 1'b1;\n        end else begin\n            round_ff <= 4'd0;\n        end\n\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= current_data_nx[i][j];\n            end\n        end\n    end\nend\n\nalways_comb begin : next_data\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(i_start) begin\n                current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n            end else begin\n                if(round_ff != 0) begin\n                    if(round_ff != 15) begin\n                        current_data_nx[i][j] = SubBytes[i][j];\n                    end else begin\n                        current_data_nx[i][j] = AddRoundKey[i][j];\n                    end\n                end else begin\n                    current_data_nx[i][j] = current_data_ff[i][j];\n                end\n            end\n        end\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : row\n        for(genvar j = 0; j < 4; j++) begin : col\n            inv_sbox uu_inv_sbox0 (\n                .i_data(ShiftRows[i][j]),\n                .o_data(SubBytes[i][j])\n            );\n        end\n    end\nendgenerate\n\nalways_comb begin : decypher_logic\n    // Add Round Key logic\n    for(int i = 0; i < 4; i++) begin : row_key\n        for(int j = 0; j < 4; j++) begin : col_key\n            if(round_ff > 4'd0) begin\n                AddRoundKey[i][j] = current_data_ff[i][j] ^ expanded_key[NBW_EX_KEY-(15-round_ff)*NBW_STEP-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n            end else begin\n                AddRoundKey[i][j] = 0;\n            end\n        end\n    end\n\n    // Mix Columns logic\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(AddRoundKey[i][j][NBW_BYTE-1]) begin\n                xtimes02[i][j] = {AddRoundKey[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                if(AddRoundKey[i][j][NBW_BYTE-2]) begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end else begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0};\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end\n            end else begin\n                xtimes02[i][j] = {AddRoundKey[i][j][NBW_BYTE-2:0], 1'b0};\n                if(AddRoundKey[i][j][NBW_BYTE-2]) begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end else begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0};\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end\n            end\n\n            xtimes0e[i][j] = xtimes08[i][j] ^ xtimes04[i][j] ^ xtimes02[i][j];\n            xtimes0b[i][j] = xtimes08[i][j] ^ xtimes02[i][j] ^ AddRoundKey[i][j];\n            xtimes0d[i][j] = xtimes08[i][j] ^ xtimes04[i][j] ^ AddRoundKey[i][j];\n            xtimes09[i][j] = xtimes08[i][j] ^ AddRoundKey[i][j];\n        end\n    end\n\n    for(int i = 0; i < 4; i++) begin\n        MixColumns[0][i] = xtimes0e[0][i] ^ xtimes0b[1][i] ^ xtimes0d[2][i] ^ xtimes09[3][i];\n        MixColumns[1][i] = xtimes0e[1][i] ^ xtimes0b[2][i] ^ xtimes0d[3][i] ^ xtimes09[0][i];\n        MixColumns[2][i] = xtimes0e[2][i] ^ xtimes0b[3][i] ^ xtimes0d[0][i] ^ xtimes09[1][i];\n        MixColumns[3][i] = xtimes0e[3][i] ^ xtimes0b[0][i] ^ xtimes0d[1][i] ^ xtimes09[2][i];\n    end\n\n    // Shift Rows logic\n    if(round_ff == 4'd1) begin\n        // Line 0: No shift\n        ShiftRows[0][0] = AddRoundKey[0][0];\n        ShiftRows[0][1] = AddRoundKey[0][1];\n        ShiftRows[0][2] = AddRoundKey[0][2];\n        ShiftRows[0][3] = AddRoundKey[0][3];\n\n        // Line 1: Shift 1 right\n        ShiftRows[1][0] = AddRoundKey[1][3];\n        ShiftRows[1][1] = AddRoundKey[1][0];\n        ShiftRows[1][2] = AddRoundKey[1][1];\n        ShiftRows[1][3] = AddRoundKey[1][2];\n\n        // Line 2: Shift 2 right\n        ShiftRows[2][0] = AddRoundKey[2][2];\n        ShiftRows[2][1] = AddRoundKey[2][3];\n        ShiftRows[2][2] = AddRoundKey[2][0];\n        ShiftRows[2][3] = AddRoundKey[2][1];\n\n        // Line 3: Shift 3 right\n        ShiftRows[3][0] = AddRoundKey[3][1];\n        ShiftRows[3][1] = AddRoundKey[3][2];\n        ShiftRows[3][2] = AddRoundKey[3][3];\n        ShiftRows[3][3] = AddRoundKey[3][0];\n    end else begin\n        // Line 0: No shift\n        ShiftRows[0][0] = MixColumns[0][0];\n        ShiftRows[0][1] = MixColumns[0][1];\n        ShiftRows[0][2] = MixColumns[0][2];\n        ShiftRows[0][3] = MixColumns[0][3];\n\n        // Line 1: Shift 1 right\n        ShiftRows[1][0] = MixColumns[1][3];\n        ShiftRows[1][1] = MixColumns[1][0];\n        ShiftRows[1][2] = MixColumns[1][1];\n        ShiftRows[1][3] = MixColumns[1][2];\n\n        // Line 2: Shift 2 right\n        ShiftRows[2][0] = MixColumns[2][2];\n        ShiftRows[2][1] = MixColumns[2][3];\n        ShiftRows[2][2] = MixColumns[2][0];\n        ShiftRows[2][3] = MixColumns[2][1];\n\n        // Line 3: Shift 3 right\n        ShiftRows[3][0] = MixColumns[3][1];\n        ShiftRows[3][1] = MixColumns[3][2];\n        ShiftRows[3][2] = MixColumns[3][3];\n        ShiftRows[3][3] = MixColumns[3][0];\n    end\n\nend\n\naes_ke uu_aes_ke (\n    .clk           (clk                   ),\n    .rst_async_n   (rst_async_n           ),\n    .i_start       (i_start & i_update_key),\n    .i_key         (i_key                 ),\n    .o_idle        (key_idle              ),\n    .o_done        (key_done              ),\n    .o_expanded_key(expanded_key          )\n);\n\nendmodule : aes_decrypt", "rtl/aes_enc_top.sv": "module aes_enc_top #(\n    parameter NBW_KEY  = 'd256,\n    parameter NBW_DATA = 'd128,\n    parameter NBW_MODE = 'd3,\n    parameter NBW_CNTR = 'd32\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_reset_counter,\n    input  logic                i_update_iv,\n    input  logic [NBW_DATA-1:0] i_iv,\n    input  logic                i_update_mode,\n    input  logic [NBW_MODE-1:0] i_mode,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_plaintext,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_ciphertext\n);\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_MODE-1:0] mode_ff;\nlogic [NBW_DATA-1:0] plaintext_ff;\nlogic [NBW_DATA-1:0] iv_ff;\nlogic [NBW_DATA-1:0] iv_nx;\nlogic [NBW_DATA-1:0] ciphertext;\nlogic [NBW_DATA-1:0] enc_in;\nlogic [NBW_DATA-1:0] enc_out;\nlogic                update_key_ff;\nlogic                start_ff;\nlogic                enc_done;\nlogic [NBW_KEY-1:0]  key_ff;\nlogic [NBW_CNTR-1:0] counter_ff;\n\n// Possible operation modes\nlocalparam ECB  = 3'd0;\nlocalparam CBC  = 3'd1;\nlocalparam PCBC = 3'd2;\nlocalparam CFB  = 3'd3;\nlocalparam OFB  = 3'd4;\nlocalparam CTR  = 3'd5;\n\n// Operation modes logic\nalways_comb begin\n    case(mode_ff)\n        ECB: begin\n            enc_in     = plaintext_ff;\n            iv_nx      = iv_ff;\n            ciphertext = enc_out;\n        end\n        CBC: begin\n            enc_in     = plaintext_ff ^ iv_ff;\n            iv_nx      = enc_out;\n            ciphertext = enc_out;\n        end\n        PCBC: begin\n            enc_in     = plaintext_ff ^ iv_ff;\n            iv_nx      = plaintext_ff ^ enc_out;\n            ciphertext = enc_out;\n        end\n        CFB: begin\n            enc_in     = iv_ff;\n            iv_nx      = plaintext_ff ^ enc_out;\n            ciphertext = plaintext_ff ^ enc_out;\n        end\n        OFB: begin\n            enc_in     = iv_ff;\n            iv_nx      = enc_out;\n            ciphertext = plaintext_ff ^ enc_out;\n        end\n        CTR: begin\n            enc_in     = {iv_ff[NBW_DATA-1:NBW_CNTR], counter_ff};\n            iv_nx      = iv_ff;\n            ciphertext = plaintext_ff ^ enc_out;\n        end\n        default: begin\n            enc_in     = plaintext_ff;\n            iv_nx      = iv_ff;\n            ciphertext = enc_out;\n        end\n    endcase\nend\n\n// Registers\nalways_ff @ (posedge clk) begin : data_regs\n    if(i_start & o_done) begin\n        plaintext_ff <= i_plaintext;\n    end\nend\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin : reset_regs\n    if(!rst_async_n) begin\n        iv_ff        <= 128'd0;\n        mode_ff      <= 3'd0;\n        o_done       <= 1'b1;\n        o_ciphertext <= 128'd0;\n        counter_ff   <= 0;\n    end else begin\n        if(i_update_iv) begin\n            iv_ff <= i_iv;\n        end else begin\n            if(enc_done) begin\n                iv_ff <= iv_nx;\n            end\n        end\n\n        if(i_update_mode) begin\n            mode_ff <= i_mode;\n        end\n\n        if(enc_done) begin\n            o_done <= 1'b1;\n        end else begin\n            if(i_start & o_done) begin\n                o_done <= 1'b0;\n            end\n        end\n\n        if(enc_done) begin\n            o_ciphertext <= ciphertext;\n        end\n\n        if(i_reset_counter) begin\n            counter_ff <= 0;\n        end else if(enc_done & mode_ff == CTR) begin\n            counter_ff <= counter_ff + 1'b1;\n        end\n\n        start_ff <= (i_start & o_done);\n        update_key_ff <= (i_start & i_update_key & o_done);\n        if(i_start & i_update_key & o_done) begin\n            key_ff <= i_key;\n        end\n    end\nend\n\n// Encryption module instantiation\naes_encrypt #(\n    .NBW_KEY (NBW_KEY ),\n    .NBW_DATA(NBW_DATA)\n) uu_aes_encrypt (\n    .clk         (clk          ),\n    .rst_async_n (rst_async_n  ),\n    .i_update_key(update_key_ff),\n    .i_key       (key_ff       ),\n    .i_start     (start_ff     ),\n    .i_data      (enc_in       ),\n    .o_done      (enc_done     ),\n    .o_data      (enc_out      )\n);\n\nendmodule : aes_enc_top", "rtl/aes_encrypt.sv": "module aes_encrypt #(\n    parameter NBW_KEY  = 'd256,\n    parameter NBW_DATA = 'd128\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_data,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE   = 'd8;\nlocalparam STEPS      = 'd14;\nlocalparam NBW_WORD   = 'd32;\nlocalparam NBW_EX_KEY = 'd1920;\nlocalparam NBW_STEP   = NBW_KEY/2;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   Rcon   [STEPS/2];\nlogic [NBW_KEY-1:0]    valid_key;\nlogic [NBW_STEP-1:0]   step_key[STEPS];\nlogic [NBW_EX_KEY-1:0] expanded_key_nx;\nlogic [NBW_EX_KEY-1:0] expanded_key_ff;\nlogic [NBW_BYTE-1:0]   current_data_nx[4][4];\nlogic [NBW_BYTE-1:0]   current_data_ff[4][4];\nlogic [NBW_BYTE-1:0]   SubBytes[4][4];\nlogic [NBW_BYTE-1:0]   ShiftRows[4][4];\nlogic [NBW_BYTE-1:0]   xtimes02[4][4];\nlogic [NBW_BYTE-1:0]   xtimes03[4][4];\nlogic [NBW_BYTE-1:0]   MixColumns[4][4];\nlogic [3:0] round_ff;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nalways_ff @ (posedge clk or negedge rst_async_n) begin : done_assignment\n    if(!rst_async_n) begin\n        o_done <= 1'b0;\n    end else begin\n        o_done <= (round_ff == 4'd14);\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : out_row\n        for(genvar j = 0; j < 4; j++) begin : out_col\n            assign o_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] = current_data_ff[i][j];\n        end\n    end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : cypher_regs\n    if(!rst_async_n) begin\n        round_ff <= 4'd0;\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= 8'd0;\n            end\n        end\n    end else begin\n        if(i_start || (round_ff > 4'd0 && round_ff < 4'd14)) begin\n            round_ff <= round_ff + 1'b1;\n        end else begin\n            round_ff <= 4'd0;\n        end\n\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= current_data_nx[i][j];\n            end\n        end\n    end\nend\n\nalways_comb begin : next_data\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(i_start) begin\n                if(i_update_key) begin\n                    current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] ^ i_key[NBW_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                end else begin\n                    current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] ^ expanded_key_ff[NBW_EX_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                end\n            end else begin\n                if(round_ff != 4'd0) begin\n                    if(round_ff != 4'd14) begin\n                        current_data_nx[i][j] = MixColumns[i][j] ^ expanded_key_ff[NBW_EX_KEY-round_ff*NBW_STEP-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                    end else begin\n                        current_data_nx[i][j] = ShiftRows[i][j] ^ expanded_key_ff[NBW_EX_KEY-round_ff*NBW_STEP-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                    end\n                end else begin\n                    current_data_nx[i][j] = current_data_ff[i][j];\n                end\n            end\n        end\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : row\n        for(genvar j = 0; j < 4; j++) begin : col\n            sbox uu_sbox0 (\n                .i_data(current_data_ff[i][j]),\n                .o_data(SubBytes[i][j])\n            );\n        end\n    end\nendgenerate\n\nalways_comb begin : cypher_logic\n    // Shift Rows logic\n    // Line 0: No shift\n    ShiftRows[0][0] = SubBytes[0][0];\n    ShiftRows[0][1] = SubBytes[0][1];\n    ShiftRows[0][2] = SubBytes[0][2];\n    ShiftRows[0][3] = SubBytes[0][3];\n\n    // Line 1: Shift 1 left\n    ShiftRows[1][0] = SubBytes[1][1];\n    ShiftRows[1][1] = SubBytes[1][2];\n    ShiftRows[1][2] = SubBytes[1][3];\n    ShiftRows[1][3] = SubBytes[1][0];\n\n    // Line 2: Shift 2 left\n    ShiftRows[2][0] = SubBytes[2][2];\n    ShiftRows[2][1] = SubBytes[2][3];\n    ShiftRows[2][2] = SubBytes[2][0];\n    ShiftRows[2][3] = SubBytes[2][1];\n\n    // Line 3: Shift 3 left\n    ShiftRows[3][0] = SubBytes[3][3];\n    ShiftRows[3][1] = SubBytes[3][0];\n    ShiftRows[3][2] = SubBytes[3][1];\n    ShiftRows[3][3] = SubBytes[3][2];\n\n    // Mix Columns logic\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(ShiftRows[i][j][NBW_BYTE-1]) begin\n                xtimes02[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                xtimes03[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B ^ ShiftRows[i][j];\n            end else begin\n                xtimes02[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0};\n                xtimes03[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ ShiftRows[i][j];\n            end\n        end\n    end\n\n    for(int i = 0; i < 4; i++) begin\n        MixColumns[0][i] = xtimes02[0][i] ^ xtimes03[1][i] ^ ShiftRows[2][i] ^ ShiftRows[3][i];\n        MixColumns[1][i] = xtimes02[1][i] ^ xtimes03[2][i] ^ ShiftRows[3][i] ^ ShiftRows[0][i];\n        MixColumns[2][i] = xtimes02[2][i] ^ xtimes03[3][i] ^ ShiftRows[0][i] ^ ShiftRows[1][i];\n        MixColumns[3][i] = xtimes02[3][i] ^ xtimes03[0][i] ^ ShiftRows[1][i] ^ ShiftRows[2][i];\n    end\nend\n\n// ****************************************\n// - Key Expansion logic\n// ****************************************\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        expanded_key_ff <= {NBW_EX_KEY{1'b0}};\n    end else begin\n        expanded_key_ff <= expanded_key_nx;\n    end\nend\n\n\n// ----------------------------------------\n// - Operation logic\n// ----------------------------------------\nassign Rcon[0] = 8'h01;\nassign Rcon[1] = 8'h02;\nassign Rcon[2] = 8'h04;\nassign Rcon[3] = 8'h08;\nassign Rcon[4] = 8'h10;\nassign Rcon[5] = 8'h20;\nassign Rcon[6] = 8'h40;\n\ngenerate\n    for(genvar i = 0; i < STEPS; i++) begin : steps\n        if(i%2 == 0) begin\n            logic [NBW_WORD-1:0] RotWord;\n            logic [NBW_WORD-1:0] SubWord;\n            logic [NBW_WORD-1:0] RconXor;\n\n            sbox uu_sbox0 (\n                .i_data(RotWord[NBW_WORD-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox1 (\n                .i_data(RotWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox2 (\n                .i_data(RotWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox3 (\n                .i_data(RotWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            always_comb begin : main_operation\n                RotWord = {expanded_key_ff[NBW_EX_KEY-NBW_KEY-i*NBW_STEP+NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)], expanded_key_ff[NBW_EX_KEY-NBW_KEY-i*NBW_STEP+NBW_WORD-1-:NBW_BYTE]};\n                RconXor = {SubWord[NBW_WORD-1-:NBW_BYTE]^Rcon[i/2], SubWord[NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)]};\n\n                step_key[i][NBW_STEP-1-:NBW_WORD]            = expanded_key_ff[NBW_EX_KEY-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ RconXor;\n                step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_EX_KEY-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-1-:NBW_WORD];\n                step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD];\n                step_key[i][NBW_STEP-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD];\n            end\n        end else begin\n            logic [NBW_WORD-1:0] SubWord;\n\n            sbox uu_sbox0 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox1 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox2 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-2*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox3 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-3*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            always_comb begin : main_operation\n                step_key[i][NBW_STEP-1-:NBW_WORD]            = expanded_key_ff[NBW_EX_KEY-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ SubWord;\n                step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_EX_KEY-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-1-:NBW_WORD];\n                step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD];\n                step_key[i][NBW_STEP-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD];\n            end\n        end\n    end\nendgenerate\n\nassign expanded_key_nx = {valid_key   , step_key[0 ], step_key[1 ], step_key[2 ],\n                          step_key[3 ], step_key[4 ], step_key[5 ], step_key[6 ],\n                          step_key[7 ], step_key[8 ], step_key[9 ], step_key[10],\n                          step_key[11], step_key[12]};\n\nalways_comb begin : input_data\n    if (i_update_key) begin\n        valid_key = i_key;\n    end else begin\n        valid_key = expanded_key_ff[NBW_EX_KEY-1-:NBW_KEY];\n    end\nend\n\nendmodule : aes_encrypt", "rtl/aes_ke.sv": "module aes_ke #(\n    parameter NBW_KEY = 'd256,\n    parameter NBW_OUT = 'd1920\n) (\n    input  logic               clk,\n    input  logic               rst_async_n,\n    input  logic               i_start,\n    input  logic [NBW_KEY-1:0] i_key,\n    output logic               o_idle,\n    output logic               o_done,\n    output logic [NBW_OUT-1:0] o_expanded_key\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE = 'd8;\nlocalparam STEPS    = 'd14;\nlocalparam NBW_WORD = 'd32;\nlocalparam NBW_STEP = NBW_KEY/2;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   Rcon   [STEPS/2];\nlogic [NBW_KEY-1:0]    valid_key;\nlogic [NBW_STEP-1:0] step_key[STEPS];\nlogic [NBW_OUT-1:0] expanded_key_nx;\nlogic [NBW_OUT-1:0] expanded_key_ff;\nlogic [STEPS:0] key_exp_steps_ff;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nassign o_done = key_exp_steps_ff[STEPS];\nassign o_idle = ~(|key_exp_steps_ff);\nassign o_expanded_key = expanded_key_ff;\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : done_regs\n    if(!rst_async_n) begin\n        key_exp_steps_ff <= 0;\n    end else begin\n        key_exp_steps_ff <= {key_exp_steps_ff[STEPS-1:0], i_start};\n    end\nend\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : key_regs\n    if(~rst_async_n) begin\n        expanded_key_ff <= {NBW_OUT{1'b0}};\n    end else begin\n        expanded_key_ff <= expanded_key_nx;\n    end\nend\n\n\n// ----------------------------------------\n// - Operation logic\n// ----------------------------------------\nassign Rcon[0] = 8'h01;\nassign Rcon[1] = 8'h02;\nassign Rcon[2] = 8'h04;\nassign Rcon[3] = 8'h08;\nassign Rcon[4] = 8'h10;\nassign Rcon[5] = 8'h20;\nassign Rcon[6] = 8'h40;\n\ngenerate\n    for(genvar i = 0; i < STEPS; i++) begin : steps\n        if(i%2 == 0) begin\n            logic [NBW_WORD-1:0] RotWord;\n            logic [NBW_WORD-1:0] SubWord;\n            logic [NBW_WORD-1:0] RconXor;\n\n            sbox uu_sbox0 (\n                .i_data(RotWord[NBW_WORD-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox1 (\n                .i_data(RotWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox2 (\n                .i_data(RotWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox3 (\n                .i_data(RotWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            always_comb begin : main_operation\n                RotWord = {expanded_key_ff[NBW_OUT-NBW_KEY-i*NBW_STEP+NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)], expanded_key_ff[NBW_OUT-NBW_KEY-i*NBW_STEP+NBW_WORD-1-:NBW_BYTE]};\n                RconXor = {SubWord[NBW_WORD-1-:NBW_BYTE]^Rcon[i/2], SubWord[NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)]};\n\n                step_key[i][NBW_STEP-1-:NBW_WORD]            = expanded_key_ff[NBW_OUT-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ RconXor;\n                step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_OUT-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-1-:NBW_WORD];\n                step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD];\n                step_key[i][NBW_STEP-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD];\n            end\n        end else begin\n            logic [NBW_WORD-1:0] SubWord;\n\n            sbox uu_sbox0 (\n                .i_data(expanded_key_ff[NBW_OUT-NBW_KEY+NBW_WORD-i*NBW_STEP-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox1 (\n                .i_data(expanded_key_ff[NBW_OUT-NBW_KEY+NBW_WORD-i*NBW_STEP-NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox2 (\n                .i_data(expanded_key_ff[NBW_OUT-NBW_KEY+NBW_WORD-i*NBW_STEP-2*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox3 (\n                .i_data(expanded_key_ff[NBW_OUT-NBW_KEY+NBW_WORD-i*NBW_STEP-3*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            always_comb begin : main_operation\n                step_key[i][NBW_STEP-1-:NBW_WORD]            = expanded_key_ff[NBW_OUT-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ SubWord;\n                step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_OUT-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-1-:NBW_WORD];\n                step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD];\n                step_key[i][NBW_STEP-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD];\n            end\n        end\n    end\nendgenerate\n\nassign expanded_key_nx = {valid_key   , step_key[0 ], step_key[1 ], step_key[2 ],\n                          step_key[3 ], step_key[4 ], step_key[5 ], step_key[6 ],\n                          step_key[7 ], step_key[8 ], step_key[9 ], step_key[10],\n                          step_key[11], step_key[12]};\n\nalways_comb begin : input_data\n    if (i_start) begin\n        valid_key = i_key;\n    end else begin\n        valid_key = expanded_key_ff[NBW_OUT-1-:NBW_KEY];\n    end\nend\n\nendmodule : aes_ke", "rtl/inv_sbox.sv": "module inv_sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h52;\n        8'h01: o_data = 8'h09;\n        8'h02: o_data = 8'h6a;\n        8'h03: o_data = 8'hd5;\n        8'h04: o_data = 8'h30;\n        8'h05: o_data = 8'h36;\n        8'h06: o_data = 8'ha5;\n        8'h07: o_data = 8'h38;\n        8'h08: o_data = 8'hbf;\n        8'h09: o_data = 8'h40;\n        8'h0a: o_data = 8'ha3;\n        8'h0b: o_data = 8'h9e;\n        8'h0c: o_data = 8'h81;\n        8'h0d: o_data = 8'hf3;\n        8'h0e: o_data = 8'hd7;\n        8'h0f: o_data = 8'hfb;\n        8'h10: o_data = 8'h7c;\n        8'h11: o_data = 8'he3;\n        8'h12: o_data = 8'h39;\n        8'h13: o_data = 8'h82;\n        8'h14: o_data = 8'h9b;\n        8'h15: o_data = 8'h2f;\n        8'h16: o_data = 8'hff;\n        8'h17: o_data = 8'h87;\n        8'h18: o_data = 8'h34;\n        8'h19: o_data = 8'h8e;\n        8'h1a: o_data = 8'h43;\n        8'h1b: o_data = 8'h44;\n        8'h1c: o_data = 8'hc4;\n        8'h1d: o_data = 8'hde;\n        8'h1e: o_data = 8'he9;\n        8'h1f: o_data = 8'hcb;\n        8'h20: o_data = 8'h54;\n        8'h21: o_data = 8'h7b;\n        8'h22: o_data = 8'h94;\n        8'h23: o_data = 8'h32;\n        8'h24: o_data = 8'ha6;\n        8'h25: o_data = 8'hc2;\n        8'h26: o_data = 8'h23;\n        8'h27: o_data = 8'h3d;\n        8'h28: o_data = 8'hee;\n        8'h29: o_data = 8'h4c;\n        8'h2a: o_data = 8'h95;\n        8'h2b: o_data = 8'h0b;\n        8'h2c: o_data = 8'h42;\n        8'h2d: o_data = 8'hfa;\n        8'h2e: o_data = 8'hc3;\n        8'h2f: o_data = 8'h4e;\n        8'h30: o_data = 8'h08;\n        8'h31: o_data = 8'h2e;\n        8'h32: o_data = 8'ha1;\n        8'h33: o_data = 8'h66;\n        8'h34: o_data = 8'h28;\n        8'h35: o_data = 8'hd9;\n        8'h36: o_data = 8'h24;\n        8'h37: o_data = 8'hb2;\n        8'h38: o_data = 8'h76;\n        8'h39: o_data = 8'h5b;\n        8'h3a: o_data = 8'ha2;\n        8'h3b: o_data = 8'h49;\n        8'h3c: o_data = 8'h6d;\n        8'h3d: o_data = 8'h8b;\n        8'h3e: o_data = 8'hd1;\n        8'h3f: o_data = 8'h25;\n        8'h40: o_data = 8'h72;\n        8'h41: o_data = 8'hf8;\n        8'h42: o_data = 8'hf6;\n        8'h43: o_data = 8'h64;\n        8'h44: o_data = 8'h86;\n        8'h45: o_data = 8'h68;\n        8'h46: o_data = 8'h98;\n        8'h47: o_data = 8'h16;\n        8'h48: o_data = 8'hd4;\n        8'h49: o_data = 8'ha4;\n        8'h4a: o_data = 8'h5c;\n        8'h4b: o_data = 8'hcc;\n        8'h4c: o_data = 8'h5d;\n        8'h4d: o_data = 8'h65;\n        8'h4e: o_data = 8'hb6;\n        8'h4f: o_data = 8'h92;\n        8'h50: o_data = 8'h6c;\n        8'h51: o_data = 8'h70;\n        8'h52: o_data = 8'h48;\n        8'h53: o_data = 8'h50;\n        8'h54: o_data = 8'hfd;\n        8'h55: o_data = 8'hed;\n        8'h56: o_data = 8'hb9;\n        8'h57: o_data = 8'hda;\n        8'h58: o_data = 8'h5e;\n        8'h59: o_data = 8'h15;\n        8'h5a: o_data = 8'h46;\n        8'h5b: o_data = 8'h57;\n        8'h5c: o_data = 8'ha7;\n        8'h5d: o_data = 8'h8d;\n        8'h5e: o_data = 8'h9d;\n        8'h5f: o_data = 8'h84;\n        8'h60: o_data = 8'h90;\n        8'h61: o_data = 8'hd8;\n        8'h62: o_data = 8'hab;\n        8'h63: o_data = 8'h00;\n        8'h64: o_data = 8'h8c;\n        8'h65: o_data = 8'hbc;\n        8'h66: o_data = 8'hd3;\n        8'h67: o_data = 8'h0a;\n        8'h68: o_data = 8'hf7;\n        8'h69: o_data = 8'he4;\n        8'h6a: o_data = 8'h58;\n        8'h6b: o_data = 8'h05;\n        8'h6c: o_data = 8'hb8;\n        8'h6d: o_data = 8'hb3;\n        8'h6e: o_data = 8'h45;\n        8'h6f: o_data = 8'h06;\n        8'h70: o_data = 8'hd0;\n        8'h71: o_data = 8'h2c;\n        8'h72: o_data = 8'h1e;\n        8'h73: o_data = 8'h8f;\n        8'h74: o_data = 8'hca;\n        8'h75: o_data = 8'h3f;\n        8'h76: o_data = 8'h0f;\n        8'h77: o_data = 8'h02;\n        8'h78: o_data = 8'hc1;\n        8'h79: o_data = 8'haf;\n        8'h7a: o_data = 8'hbd;\n        8'h7b: o_data = 8'h03;\n        8'h7c: o_data = 8'h01;\n        8'h7d: o_data = 8'h13;\n        8'h7e: o_data = 8'h8a;\n        8'h7f: o_data = 8'h6b;\n        8'h80: o_data = 8'h3a;\n        8'h81: o_data = 8'h91;\n        8'h82: o_data = 8'h11;\n        8'h83: o_data = 8'h41;\n        8'h84: o_data = 8'h4f;\n        8'h85: o_data = 8'h67;\n        8'h86: o_data = 8'hdc;\n        8'h87: o_data = 8'hea;\n        8'h88: o_data = 8'h97;\n        8'h89: o_data = 8'hf2;\n        8'h8a: o_data = 8'hcf;\n        8'h8b: o_data = 8'hce;\n        8'h8c: o_data = 8'hf0;\n        8'h8d: o_data = 8'hb4;\n        8'h8e: o_data = 8'he6;\n        8'h8f: o_data = 8'h73;\n        8'h90: o_data = 8'h96;\n        8'h91: o_data = 8'hac;\n        8'h92: o_data = 8'h74;\n        8'h93: o_data = 8'h22;\n        8'h94: o_data = 8'he7;\n        8'h95: o_data = 8'had;\n        8'h96: o_data = 8'h35;\n        8'h97: o_data = 8'h85;\n        8'h98: o_data = 8'he2;\n        8'h99: o_data = 8'hf9;\n        8'h9a: o_data = 8'h37;\n        8'h9b: o_data = 8'he8;\n        8'h9c: o_data = 8'h1c;\n        8'h9d: o_data = 8'h75;\n        8'h9e: o_data = 8'hdf;\n        8'h9f: o_data = 8'h6e;\n        8'ha0: o_data = 8'h47;\n        8'ha1: o_data = 8'hf1;\n        8'ha2: o_data = 8'h1a;\n        8'ha3: o_data = 8'h71;\n        8'ha4: o_data = 8'h1d;\n        8'ha5: o_data = 8'h29;\n        8'ha6: o_data = 8'hc5;\n        8'ha7: o_data = 8'h89;\n        8'ha8: o_data = 8'h6f;\n        8'ha9: o_data = 8'hb7;\n        8'haa: o_data = 8'h62;\n        8'hab: o_data = 8'h0e;\n        8'hac: o_data = 8'haa;\n        8'had: o_data = 8'h18;\n        8'hae: o_data = 8'hbe;\n        8'haf: o_data = 8'h1b;\n        8'hb0: o_data = 8'hfc;\n        8'hb1: o_data = 8'h56;\n        8'hb2: o_data = 8'h3e;\n        8'hb3: o_data = 8'h4b;\n        8'hb4: o_data = 8'hc6;\n        8'hb5: o_data = 8'hd2;\n        8'hb6: o_data = 8'h79;\n        8'hb7: o_data = 8'h20;\n        8'hb8: o_data = 8'h9a;\n        8'hb9: o_data = 8'hdb;\n        8'hba: o_data = 8'hc0;\n        8'hbb: o_data = 8'hfe;\n        8'hbc: o_data = 8'h78;\n        8'hbd: o_data = 8'hcd;\n        8'hbe: o_data = 8'h5a;\n        8'hbf: o_data = 8'hf4;\n        8'hc0: o_data = 8'h1f;\n        8'hc1: o_data = 8'hdd;\n        8'hc2: o_data = 8'ha8;\n        8'hc3: o_data = 8'h33;\n        8'hc4: o_data = 8'h88;\n        8'hc5: o_data = 8'h07;\n        8'hc6: o_data = 8'hc7;\n        8'hc7: o_data = 8'h31;\n        8'hc8: o_data = 8'hb1;\n        8'hc9: o_data = 8'h12;\n        8'hca: o_data = 8'h10;\n        8'hcb: o_data = 8'h59;\n        8'hcc: o_data = 8'h27;\n        8'hcd: o_data = 8'h80;\n        8'hce: o_data = 8'hec;\n        8'hcf: o_data = 8'h5f;\n        8'hd0: o_data = 8'h60;\n        8'hd1: o_data = 8'h51;\n        8'hd2: o_data = 8'h7f;\n        8'hd3: o_data = 8'ha9;\n        8'hd4: o_data = 8'h19;\n        8'hd5: o_data = 8'hb5;\n        8'hd6: o_data = 8'h4a;\n        8'hd7: o_data = 8'h0d;\n        8'hd8: o_data = 8'h2d;\n        8'hd9: o_data = 8'he5;\n        8'hda: o_data = 8'h7a;\n        8'hdb: o_data = 8'h9f;\n        8'hdc: o_data = 8'h93;\n        8'hdd: o_data = 8'hc9;\n        8'hde: o_data = 8'h9c;\n        8'hdf: o_data = 8'hef;\n        8'he0: o_data = 8'ha0;\n        8'he1: o_data = 8'he0;\n        8'he2: o_data = 8'h3b;\n        8'he3: o_data = 8'h4d;\n        8'he4: o_data = 8'hae;\n        8'he5: o_data = 8'h2a;\n        8'he6: o_data = 8'hf5;\n        8'he7: o_data = 8'hb0;\n        8'he8: o_data = 8'hc8;\n        8'he9: o_data = 8'heb;\n        8'hea: o_data = 8'hbb;\n        8'heb: o_data = 8'h3c;\n        8'hec: o_data = 8'h83;\n        8'hed: o_data = 8'h53;\n        8'hee: o_data = 8'h99;\n        8'hef: o_data = 8'h61;\n        8'hf0: o_data = 8'h17;\n        8'hf1: o_data = 8'h2b;\n        8'hf2: o_data = 8'h04;\n        8'hf3: o_data = 8'h7e;\n        8'hf4: o_data = 8'hba;\n        8'hf5: o_data = 8'h77;\n        8'hf6: o_data = 8'hd6;\n        8'hf7: o_data = 8'h26;\n        8'hf8: o_data = 8'he1;\n        8'hf9: o_data = 8'h69;\n        8'hfa: o_data = 8'h14;\n        8'hfb: o_data = 8'h63;\n        8'hfc: o_data = 8'h55;\n        8'hfd: o_data = 8'h21;\n        8'hfe: o_data = 8'h0c;\n        8'hff: o_data = 8'h7d;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : inv_sbox", "rtl/sbox.sv": "module sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h63;\n        8'h01: o_data = 8'h7C;\n        8'h02: o_data = 8'h77;\n        8'h03: o_data = 8'h7B;\n        8'h04: o_data = 8'hF2;\n        8'h05: o_data = 8'h6B;\n        8'h06: o_data = 8'h6F;\n        8'h07: o_data = 8'hC5;\n        8'h08: o_data = 8'h30;\n        8'h09: o_data = 8'h01;\n        8'h0A: o_data = 8'h67;\n        8'h0B: o_data = 8'h2B;\n        8'h0C: o_data = 8'hFE;\n        8'h0D: o_data = 8'hD7;\n        8'h0E: o_data = 8'hAB;\n        8'h0F: o_data = 8'h76;\n        8'h10: o_data = 8'hCA;\n        8'h11: o_data = 8'h82;\n        8'h12: o_data = 8'hC9;\n        8'h13: o_data = 8'h7D;\n        8'h14: o_data = 8'hFA;\n        8'h15: o_data = 8'h59;\n        8'h16: o_data = 8'h47;\n        8'h17: o_data = 8'hF0;\n        8'h18: o_data = 8'hAD;\n        8'h19: o_data = 8'hD4;\n        8'h1A: o_data = 8'hA2;\n        8'h1B: o_data = 8'hAF;\n        8'h1C: o_data = 8'h9C;\n        8'h1D: o_data = 8'hA4;\n        8'h1E: o_data = 8'h72;\n        8'h1F: o_data = 8'hC0;\n        8'h20: o_data = 8'hB7;\n        8'h21: o_data = 8'hFD;\n        8'h22: o_data = 8'h93;\n        8'h23: o_data = 8'h26;\n        8'h24: o_data = 8'h36;\n        8'h25: o_data = 8'h3F;\n        8'h26: o_data = 8'hF7;\n        8'h27: o_data = 8'hCC;\n        8'h28: o_data = 8'h34;\n        8'h29: o_data = 8'hA5;\n        8'h2A: o_data = 8'hE5;\n        8'h2B: o_data = 8'hF1;\n        8'h2C: o_data = 8'h71;\n        8'h2D: o_data = 8'hD8;\n        8'h2E: o_data = 8'h31;\n        8'h2F: o_data = 8'h15;\n        8'h30: o_data = 8'h04;\n        8'h31: o_data = 8'hC7;\n        8'h32: o_data = 8'h23;\n        8'h33: o_data = 8'hC3;\n        8'h34: o_data = 8'h18;\n        8'h35: o_data = 8'h96;\n        8'h36: o_data = 8'h05;\n        8'h37: o_data = 8'h9A;\n        8'h38: o_data = 8'h07;\n        8'h39: o_data = 8'h12;\n        8'h3A: o_data = 8'h80;\n        8'h3B: o_data = 8'hE2;\n        8'h3C: o_data = 8'hEB;\n        8'h3D: o_data = 8'h27;\n        8'h3E: o_data = 8'hB2;\n        8'h3F: o_data = 8'h75;\n        8'h40: o_data = 8'h09;\n        8'h41: o_data = 8'h83;\n        8'h42: o_data = 8'h2C;\n        8'h43: o_data = 8'h1A;\n        8'h44: o_data = 8'h1B;\n        8'h45: o_data = 8'h6E;\n        8'h46: o_data = 8'h5A;\n        8'h47: o_data = 8'hA0;\n        8'h48: o_data = 8'h52;\n        8'h49: o_data = 8'h3B;\n        8'h4A: o_data = 8'hD6;\n        8'h4B: o_data = 8'hB3;\n        8'h4C: o_data = 8'h29;\n        8'h4D: o_data = 8'hE3;\n        8'h4E: o_data = 8'h2F;\n        8'h4F: o_data = 8'h84;\n        8'h50: o_data = 8'h53;\n        8'h51: o_data = 8'hD1;\n        8'h52: o_data = 8'h00;\n        8'h53: o_data = 8'hED;\n        8'h54: o_data = 8'h20;\n        8'h55: o_data = 8'hFC;\n        8'h56: o_data = 8'hB1;\n        8'h57: o_data = 8'h5B;\n        8'h58: o_data = 8'h6A;\n        8'h59: o_data = 8'hCB;\n        8'h5A: o_data = 8'hBE;\n        8'h5B: o_data = 8'h39;\n        8'h5C: o_data = 8'h4A;\n        8'h5D: o_data = 8'h4C;\n        8'h5E: o_data = 8'h58;\n        8'h5F: o_data = 8'hCF;\n        8'h60: o_data = 8'hD0;\n        8'h61: o_data = 8'hEF;\n        8'h62: o_data = 8'hAA;\n        8'h63: o_data = 8'hFB;\n        8'h64: o_data = 8'h43;\n        8'h65: o_data = 8'h4D;\n        8'h66: o_data = 8'h33;\n        8'h67: o_data = 8'h85;\n        8'h68: o_data = 8'h45;\n        8'h69: o_data = 8'hF9;\n        8'h6A: o_data = 8'h02;\n        8'h6B: o_data = 8'h7F;\n        8'h6C: o_data = 8'h50;\n        8'h6D: o_data = 8'h3C;\n        8'h6E: o_data = 8'h9F;\n        8'h6F: o_data = 8'hA8;\n        8'h70: o_data = 8'h51;\n        8'h71: o_data = 8'hA3;\n        8'h72: o_data = 8'h40;\n        8'h73: o_data = 8'h8F;\n        8'h74: o_data = 8'h92;\n        8'h75: o_data = 8'h9D;\n        8'h76: o_data = 8'h38;\n        8'h77: o_data = 8'hF5;\n        8'h78: o_data = 8'hBC;\n        8'h79: o_data = 8'hB6;\n        8'h7A: o_data = 8'hDA;\n        8'h7B: o_data = 8'h21;\n        8'h7C: o_data = 8'h10;\n        8'h7D: o_data = 8'hFF;\n        8'h7E: o_data = 8'hF3;\n        8'h7F: o_data = 8'hD2;\n        8'h80: o_data = 8'hCD;\n        8'h81: o_data = 8'h0C;\n        8'h82: o_data = 8'h13;\n        8'h83: o_data = 8'hEC;\n        8'h84: o_data = 8'h5F;\n        8'h85: o_data = 8'h97;\n        8'h86: o_data = 8'h44;\n        8'h87: o_data = 8'h17;\n        8'h88: o_data = 8'hC4;\n        8'h89: o_data = 8'hA7;\n        8'h8A: o_data = 8'h7E;\n        8'h8B: o_data = 8'h3D;\n        8'h8C: o_data = 8'h64;\n        8'h8D: o_data = 8'h5D;\n        8'h8E: o_data = 8'h19;\n        8'h8F: o_data = 8'h73;\n        8'h90: o_data = 8'h60;\n        8'h91: o_data = 8'h81;\n        8'h92: o_data = 8'h4F;\n        8'h93: o_data = 8'hDC;\n        8'h94: o_data = 8'h22;\n        8'h95: o_data = 8'h2A;\n        8'h96: o_data = 8'h90;\n        8'h97: o_data = 8'h88;\n        8'h98: o_data = 8'h46;\n        8'h99: o_data = 8'hEE;\n        8'h9A: o_data = 8'hB8;\n        8'h9B: o_data = 8'h14;\n        8'h9C: o_data = 8'hDE;\n        8'h9D: o_data = 8'h5E;\n        8'h9E: o_data = 8'h0B;\n        8'h9F: o_data = 8'hDB;\n        8'hA0: o_data = 8'hE0;\n        8'hA1: o_data = 8'h32;\n        8'hA2: o_data = 8'h3A;\n        8'hA3: o_data = 8'h0A;\n        8'hA4: o_data = 8'h49;\n        8'hA5: o_data = 8'h06;\n        8'hA6: o_data = 8'h24;\n        8'hA7: o_data = 8'h5C;\n        8'hA8: o_data = 8'hC2;\n        8'hA9: o_data = 8'hD3;\n        8'hAA: o_data = 8'hAC;\n        8'hAB: o_data = 8'h62;\n        8'hAC: o_data = 8'h91;\n        8'hAD: o_data = 8'h95;\n        8'hAE: o_data = 8'hE4;\n        8'hAF: o_data = 8'h79;\n        8'hB0: o_data = 8'hE7;\n        8'hB1: o_data = 8'hC8;\n        8'hB2: o_data = 8'h37;\n        8'hB3: o_data = 8'h6D;\n        8'hB4: o_data = 8'h8D;\n        8'hB5: o_data = 8'hD5;\n        8'hB6: o_data = 8'h4E;\n        8'hB7: o_data = 8'hA9;\n        8'hB8: o_data = 8'h6C;\n        8'hB9: o_data = 8'h56;\n        8'hBA: o_data = 8'hF4;\n        8'hBB: o_data = 8'hEA;\n        8'hBC: o_data = 8'h65;\n        8'hBD: o_data = 8'h7A;\n        8'hBE: o_data = 8'hAE;\n        8'hBF: o_data = 8'h08;\n        8'hC0: o_data = 8'hBA;\n        8'hC1: o_data = 8'h78;\n        8'hC2: o_data = 8'h25;\n        8'hC3: o_data = 8'h2E;\n        8'hC4: o_data = 8'h1C;\n        8'hC5: o_data = 8'hA6;\n        8'hC6: o_data = 8'hB4;\n        8'hC7: o_data = 8'hC6;\n        8'hC8: o_data = 8'hE8;\n        8'hC9: o_data = 8'hDD;\n        8'hCA: o_data = 8'h74;\n        8'hCB: o_data = 8'h1F;\n        8'hCC: o_data = 8'h4B;\n        8'hCD: o_data = 8'hBD;\n        8'hCE: o_data = 8'h8B;\n        8'hCF: o_data = 8'h8A;\n        8'hD0: o_data = 8'h70;\n        8'hD1: o_data = 8'h3E;\n        8'hD2: o_data = 8'hB5;\n        8'hD3: o_data = 8'h66;\n        8'hD4: o_data = 8'h48;\n        8'hD5: o_data = 8'h03;\n        8'hD6: o_data = 8'hF6;\n        8'hD7: o_data = 8'h0E;\n        8'hD8: o_data = 8'h61;\n        8'hD9: o_data = 8'h35;\n        8'hDA: o_data = 8'h57;\n        8'hDB: o_data = 8'hB9;\n        8'hDC: o_data = 8'h86;\n        8'hDD: o_data = 8'hC1;\n        8'hDE: o_data = 8'h1D;\n        8'hDF: o_data = 8'h9E;\n        8'hE0: o_data = 8'hE1;\n        8'hE1: o_data = 8'hF8;\n        8'hE2: o_data = 8'h98;\n        8'hE3: o_data = 8'h11;\n        8'hE4: o_data = 8'h69;\n        8'hE5: o_data = 8'hD9;\n        8'hE6: o_data = 8'h8E;\n        8'hE7: o_data = 8'h94;\n        8'hE8: o_data = 8'h9B;\n        8'hE9: o_data = 8'h1E;\n        8'hEA: o_data = 8'h87;\n        8'hEB: o_data = 8'hE9;\n        8'hEC: o_data = 8'hCE;\n        8'hED: o_data = 8'h55;\n        8'hEE: o_data = 8'h28;\n        8'hEF: o_data = 8'hDF;\n        8'hF0: o_data = 8'h8C;\n        8'hF1: o_data = 8'hA1;\n        8'hF2: o_data = 8'h89;\n        8'hF3: o_data = 8'h0D;\n        8'hF4: o_data = 8'hBF;\n        8'hF5: o_data = 8'hE6;\n        8'hF6: o_data = 8'h42;\n        8'hF7: o_data = 8'h68;\n        8'hF8: o_data = 8'h41;\n        8'hF9: o_data = 8'h99;\n        8'hFA: o_data = 8'h2D;\n        8'hFB: o_data = 8'h0F;\n        8'hFC: o_data = 8'hB0;\n        8'hFD: o_data = 8'h54;\n        8'hFE: o_data = 8'hBB;\n        8'hFF: o_data = 8'h16;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : sbox", "verif/tb_padding_top.sv": "module tb_padding_top;\n\n// Interface parameters\nlocalparam NBW_KEY  = 'd256;\nlocalparam NBW_DATA = 'd128;\nlocalparam NBW_MODE = 'd3;\nlocalparam NBW_CNTR = 'd32;\nlocalparam NBW_PADD = 'd4;\nlocalparam NBW_PMOD = 'd2;\nlocalparam W3C_BYTE = 8'hAF;\n\n// Possible operation modes\nlocalparam ECB  = 3'd0;\nlocalparam CBC  = 3'd1;\nlocalparam PCBC = 3'd2;\nlocalparam CFB  = 3'd3;\nlocalparam OFB  = 3'd4;\nlocalparam CTR  = 3'd5;\n\n// Interface signals\nlogic                clk;\nlogic                rst_async_n;\nlogic                i_encrypt;\nlogic                i_update_padding_mode;\nlogic [NBW_PMOD-1:0] i_padding_mode;\nlogic [NBW_PADD-1:0] i_padding_bytes;\nlogic                i_reset_counter;\nlogic                i_update_iv;\nlogic [NBW_DATA-1:0] i_iv;\nlogic                i_update_mode;\nlogic [NBW_MODE-1:0] i_mode;\nlogic                i_update_key;\nlogic [NBW_KEY-1:0]  i_key;\nlogic                i_start;\nlogic [NBW_DATA-1:0] i_data;\nlogic                o_done;\nlogic [NBW_DATA-1:0] o_data;\n\n// Module instantiation\npadding_top #(\n    .NBW_KEY (NBW_KEY ),\n    .NBW_DATA(NBW_DATA),\n    .NBW_MODE(NBW_MODE),\n    .NBW_CNTR(NBW_CNTR),\n    .NBW_PADD(NBW_PADD),\n    .NBW_PMOD(NBW_PMOD),\n    .W3C_BYTE(W3C_BYTE)\n) uu_padding_top (\n    .clk                  (clk                  ),\n    .rst_async_n          (rst_async_n          ),\n    .i_encrypt            (i_encrypt            ),\n    .i_update_padding_mode(i_update_padding_mode),\n    .i_padding_mode       (i_padding_mode       ),\n    .i_padding_bytes      (i_padding_bytes      ),\n    .i_reset_counter      (i_reset_counter      ),\n    .i_update_iv          (i_update_iv          ),\n    .i_iv                 (i_iv                 ),\n    .i_update_mode        (i_update_mode        ),\n    .i_mode               (i_mode               ),\n    .i_update_key         (i_update_key         ),\n    .i_key                (i_key                ),\n    .i_start              (i_start              ),\n    .i_data               (i_data               ),\n    .o_done               (o_done               ),\n    .o_data               (o_data               )\n);\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb_padding_top);\nend\n\ntask Compare (logic [NBW_DATA-1:0] compare_value);\n    if(o_data == compare_value) begin\n        $display(\"PASS\");\n    end else begin\n        $display(\"\\nFAIL:\");\n        $display(\" - Expected output: %h\", compare_value);\n        $display(\" - Observed output: %h\", o_data);\n    end\nendtask\n\ntask DriveInputs(logic update_key, logic [NBW_PADD-1:0] padding_bytes, logic [NBW_DATA-1:0] expected_output);\n    @(negedge clk);\n    i_key           = 256'h000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;\n    i_data          = 128'h00112233445566778899aabbccddeeff;\n    i_reset_counter = 0;\n    i_iv            = 0;\n    i_update_iv     = 0;\n    i_update_mode   = 0;\n    i_mode          = 0;\n    i_update_key    = update_key;\n    i_start         = 1;\n\n    i_padding_bytes = padding_bytes;\n\n    @(negedge clk);\n    i_start = 0;\n    i_update_key = 0;\n    i_key = 0;\n    i_data = 0;\n    i_padding_bytes = 0;\n\n    @(posedge o_done);\n    @(negedge clk);\n\n    Compare(expected_output);\nendtask\n\nalways #5 clk = ~clk;\n\ninitial begin\n    clk = 0;\n    i_update_padding_mode = 0;\n    i_start = 0;\n    i_update_iv = 0;\n    i_update_key = 0;\n    i_update_mode = 0;\n    i_reset_counter = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    // Udpate mode to CTR\n    i_update_mode = 1;\n    i_mode        = CTR;\n    // Add a \"random\" IV\n    i_update_iv   = 1;\n    i_iv          = 128'hffffffff_00000000_00000000_ffffffff;\n    // Set to encrypt\n    i_encrypt = 1;\n    $display(\"\\n================\");\n    $display(\"=   Encrypt    =\");\n    $display(\"================\");\n\n    // Set padding mode to PKCS\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b00;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=     PKCS     =\");\n    $display(\"================\");\n    \n    // Try all paddings for the PKCS mode\n    DriveInputs(1'b1, 4'h0, 128'hf1fa832efe2cceee4f06eda80718af1b);\n    DriveInputs(1'b0, 4'h1, 128'h9c9a150012f05c1db68aa6de49bc56f0);\n    DriveInputs(1'b0, 4'h2, 128'h7736fbfaeb7a413495e65b8a70779392);\n    DriveInputs(1'b0, 4'h3, 128'h85f263da7dea8bcc3883f2c312bccabb);\n    DriveInputs(1'b0, 4'h4, 128'h2c84695b539826d43818daddb1359610);\n    DriveInputs(1'b0, 4'h5, 128'h74b38b042a70078444e45c6cd62fe09f);\n    DriveInputs(1'b0, 4'h6, 128'h049d2c451606113d5c597fd47ed2ddc7);\n    DriveInputs(1'b0, 4'h7, 128'h58d05e0c92b12118eaf2ca738d2c7f06);\n    DriveInputs(1'b0, 4'h8, 128'h4e1d3f0d7dd4b629e291de8eb7520781);\n    DriveInputs(1'b0, 4'h9, 128'h7a3b7f71319b895fadc2c8cadbf3f511);\n    DriveInputs(1'b0, 4'ha, 128'h283873c17d3fac7e9057748dc5a0dc9a);\n    DriveInputs(1'b0, 4'hb, 128'hf1d4ec0c04533fb438681a866d6ceba2);\n    DriveInputs(1'b0, 4'hc, 128'h9e6a83f1871445ba974d9ea24deb2497);\n    DriveInputs(1'b0, 4'hd, 128'h3786b6f975e68cf93eb043f73b0930ec);\n    DriveInputs(1'b0, 4'he, 128'h7e9d6b0ad94e7cccda9b35c383f7639e);\n    DriveInputs(1'b0, 4'hf, 128'h9f6e010a5e695b284e5a8c4d8e8de1c5);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to OneAndZeroes\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b01;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"= OneAndZeroes =\");\n    $display(\"================\");\n    \n    // Try all paddings for the OneAndZeroes mode\n    DriveInputs(1'b0, 4'h0, 128'hf1fa832efe2cceee4f06eda80718af1b);\n    DriveInputs(1'b0, 4'h1, 128'h9c9a150012f05c1db68aa6de49bc5671);\n    DriveInputs(1'b0, 4'h2, 128'h7736fbfaeb7a413495e65b8a70771190);\n    DriveInputs(1'b0, 4'h3, 128'h85f263da7dea8bcc3883f2c3123fc9b8);\n    DriveInputs(1'b0, 4'h4, 128'h2c84695b539826d43818dadd35319214);\n    DriveInputs(1'b0, 4'h5, 128'h74b38b042a70078444e45ce9d32ae59a);\n    DriveInputs(1'b0, 4'h6, 128'h049d2c451606113d5c59f9d278d4dbc1);\n    DriveInputs(1'b0, 4'h7, 128'h58d05e0c92b12118ea75cd748a2b7801);\n    DriveInputs(1'b0, 4'h8, 128'h4e1d3f0d7dd4b6296a99d686bf5a0f89);\n    DriveInputs(1'b0, 4'h9, 128'h7a3b7f71319b89d6a4cbc1c3d2fafc18);\n    DriveInputs(1'b0, 4'ha, 128'h283873c17d3f26749a5d7e87cfaad690);\n    DriveInputs(1'b0, 4'hb, 128'hf1d4ec0c04d834bf3363118d6667e0a9);\n    DriveInputs(1'b0, 4'hc, 128'h9e6a83f10b1849b69b4192ae41e7289b);\n    DriveInputs(1'b0, 4'hd, 128'h3786b67478eb81f433bd4efa36043de1);\n    DriveInputs(1'b0, 4'he, 128'h7e9de504d74072c2d4953bcd8df96d90);\n    DriveInputs(1'b0, 4'hf, 128'h9fe10e0551665427415583428182eeca);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to ANSIX923\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b10;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=   ANSIX923   =\");\n    $display(\"================\");\n    \n    // Try all paddings for the ANSIX923 mode\n    DriveInputs(1'b0, 4'h0, 128'hf1fa832efe2cceee4f06eda80718af1b);\n    DriveInputs(1'b0, 4'h1, 128'h9c9a150012f05c1db68aa6de49bc56f0);\n    DriveInputs(1'b0, 4'h2, 128'h7736fbfaeb7a413495e65b8a70779192);\n    DriveInputs(1'b0, 4'h3, 128'h85f263da7dea8bcc3883f2c312bfc9bb);\n    DriveInputs(1'b0, 4'h4, 128'h2c84695b539826d43818daddb5319210);\n    DriveInputs(1'b0, 4'h5, 128'h74b38b042a70078444e45c69d32ae59f);\n    DriveInputs(1'b0, 4'h6, 128'h049d2c451606113d5c5979d278d4dbc7);\n    DriveInputs(1'b0, 4'h7, 128'h58d05e0c92b12118eaf5cd748a2b7806);\n    DriveInputs(1'b0, 4'h8, 128'h4e1d3f0d7dd4b629ea99d686bf5a0f81);\n    DriveInputs(1'b0, 4'h9, 128'h7a3b7f71319b8956a4cbc1c3d2fafc11);\n    DriveInputs(1'b0, 4'ha, 128'h283873c17d3fa6749a5d7e87cfaad69a);\n    DriveInputs(1'b0, 4'hb, 128'hf1d4ec0c045834bf3363118d6667e0a2);\n    DriveInputs(1'b0, 4'hc, 128'h9e6a83f18b1849b69b4192ae41e72897);\n    DriveInputs(1'b0, 4'hd, 128'h3786b6f478eb81f433bd4efa36043dec);\n    DriveInputs(1'b0, 4'he, 128'h7e9d6504d74072c2d4953bcd8df96d9e);\n    DriveInputs(1'b0, 4'hf, 128'h9f610e0551665427415583428182eec5);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to W3C\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b11;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=     W3C      =\");\n    $display(\"================\");\n    \n    // Try all paddings for the W3C mode\n    DriveInputs(1'b0, 4'h0, 128'hf1fa832efe2cceee4f06eda80718af1b);\n    DriveInputs(1'b0, 4'h1, 128'h9c9a150012f05c1db68aa6de49bc56f0);\n    DriveInputs(1'b0, 4'h2, 128'h7736fbfaeb7a413495e65b8a70773e92);\n    DriveInputs(1'b0, 4'h3, 128'h85f263da7dea8bcc3883f2c3121066bb);\n    DriveInputs(1'b0, 4'h4, 128'h2c84695b539826d43818dadd1a9e3d10);\n    DriveInputs(1'b0, 4'h5, 128'h74b38b042a70078444e45cc67c854a9f);\n    DriveInputs(1'b0, 4'h6, 128'h049d2c451606113d5c59d67dd77b74c7);\n    DriveInputs(1'b0, 4'h7, 128'h58d05e0c92b12118ea5a62db2584d706);\n    DriveInputs(1'b0, 4'h8, 128'h4e1d3f0d7dd4b6294536792910f5a081);\n    DriveInputs(1'b0, 4'h9, 128'h7a3b7f71319b89f90b646e6c7d555311);\n    DriveInputs(1'b0, 4'ha, 128'h283873c17d3f09db35f2d1286005799a);\n    DriveInputs(1'b0, 4'hb, 128'hf1d4ec0c04f79b109cccbe22c9c84fa2);\n    DriveInputs(1'b0, 4'hc, 128'h9e6a83f124b7e61934ee3d01ee488797);\n    DriveInputs(1'b0, 4'hd, 128'h3786b65bd7442e5b9c12e15599ab92ec);\n    DriveInputs(1'b0, 4'he, 128'h7e9dcaab78efdd6d7b3a94622256c29e);\n    DriveInputs(1'b0, 4'hf, 128'h9fcea1aafec9fb88eefa2ced2e2d41c5);\n\n    // Set to decrypt\n    i_encrypt = 0;\n\n    $display(\"\\n================\");\n    $display(\"=   Decrypt    =\");\n    $display(\"================\");\n\n    // Set padding mode to PKCS\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b00;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=     PKCS     =\");\n    $display(\"================\");\n    \n    // Try all paddings for the PKCS mode\n    DriveInputs(1'b1, 4'h0, 128'heab487e68ec92db4ac288a24757b0262);\n    DriveInputs(1'b0, 4'h1, 128'hf64d8192e294917701d3d70da384c8e0);\n    DriveInputs(1'b0, 4'h2, 128'h6ef961d86bfde1b7d9d37020f206f105);\n    DriveInputs(1'b0, 4'h3, 128'hb22dc55b0054fd0ad709cec19d083750);\n    DriveInputs(1'b0, 4'h4, 128'h95e72e8457f2a58a96b41bbccb6e0660);\n    DriveInputs(1'b0, 4'h5, 128'hdd67798259aa234a12d3b764459bfef2);\n    DriveInputs(1'b0, 4'h6, 128'hb98acf0a984284ae96b8bd07cc810ae4);\n    DriveInputs(1'b0, 4'h7, 128'h8265365ce045f9789243ce7b53188570);\n    DriveInputs(1'b0, 4'h8, 128'hee14dc243cab56a63ee686058db3a46d);\n    DriveInputs(1'b0, 4'h9, 128'h1e32eebda4b7878a8a36cb04c11b1983);\n    DriveInputs(1'b0, 4'ha, 128'h0b4dcae2cd918bafbb8bf32f8b05a9e0);\n    DriveInputs(1'b0, 4'hb, 128'hc4067f695b84b0c36c8b2a2ac39347ef);\n    DriveInputs(1'b0, 4'hc, 128'hf8d01782c0031d7555f230f917508c93);\n    DriveInputs(1'b0, 4'hd, 128'ha8a93b08d5b93ae809b78365a31dd1a8);\n    DriveInputs(1'b0, 4'he, 128'hac0cebdf2fae979c490695b48a33d1d5);\n    DriveInputs(1'b0, 4'hf, 128'h22619dbea37c0527210568174c69f3ad);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to OneAndZeroes\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b01;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"= OneAndZeroes =\");\n    $display(\"================\");\n    \n    // Try all paddings for the OneAndZeroes mode\n    DriveInputs(1'b0, 4'h0, 128'heab487e68ec92db4ac288a24757b0262);\n    DriveInputs(1'b0, 4'h1, 128'hc54a83e25ca56799a14ffd4bcaf3d1f5);\n    DriveInputs(1'b0, 4'h2, 128'h9f52e86b3dd2996b4ca0cc97d58b71d6);\n    DriveInputs(1'b0, 4'h3, 128'h2b66be0bf9e98b1cec49147b99b088e0);\n    DriveInputs(1'b0, 4'h4, 128'h577530ee4c2a45cb8a5e97d879468047);\n    DriveInputs(1'b0, 4'h5, 128'ha77b9e5ffc79e5e930495192f3242255);\n    DriveInputs(1'b0, 4'h6, 128'ha3a023dfdd23fc0410b7694c1b679046);\n    DriveInputs(1'b0, 4'h7, 128'h88f9321e73e273599a4d07874bd666a1);\n    DriveInputs(1'b0, 4'h8, 128'h74c452ff371e6849d6ed5d5335505e45);\n    DriveInputs(1'b0, 4'h9, 128'h0d169882051c4787e25a44b9f0628fd6);\n    DriveInputs(1'b0, 4'ha, 128'hae93a046915f6a4b08868fc5613dff94);\n    DriveInputs(1'b0, 4'hb, 128'hbc554067455fa678d3303a28f0a19cfa);\n    DriveInputs(1'b0, 4'hc, 128'hb7fb754b48f60052e0b10d2f8b32275c);\n    DriveInputs(1'b0, 4'hd, 128'h3f3aa4a7f7aa8342e474a34c5abe3f1a);\n    DriveInputs(1'b0, 4'he, 128'h5694bc221034dfc53b5ac47ee17fc98c);\n    DriveInputs(1'b0, 4'hf, 128'h4e6821cc1b5bc620050e2a6a40a605f6);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to ANSIX923\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b10;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=   ANSIX923   =\");\n    $display(\"================\");\n    \n    // Try all paddings for the ANSIX923 mode\n    DriveInputs(1'b0, 4'h0, 128'heab487e68ec92db4ac288a24757b0262);\n    DriveInputs(1'b0, 4'h1, 128'hf64d8192e294917701d3d70da384c8e0);\n    DriveInputs(1'b0, 4'h2, 128'h1fd077ebf6416f3c40bbed158ab717bc);\n    DriveInputs(1'b0, 4'h3, 128'h8479c1c2b5e323f09a8c6d24a123e877);\n    DriveInputs(1'b0, 4'h4, 128'h95dd5b8ea8eb4102cf0c3c7b3355b074);\n    DriveInputs(1'b0, 4'h5, 128'h853d05d712ab8e1122aef182fc9a6d0b);\n    DriveInputs(1'b0, 4'h6, 128'h5e3e77097905251a05af46092bddc94d);\n    DriveInputs(1'b0, 4'h7, 128'h6ac5d4bb95a0bb686f6fa70527030e62);\n    DriveInputs(1'b0, 4'h8, 128'h05474c6d864611bff5152b02bae22577);\n    DriveInputs(1'b0, 4'h9, 128'h1405a02698df01f1ea7c6df42ca32884);\n    DriveInputs(1'b0, 4'ha, 128'h6e088002346334f80f2f129a1d547aaa);\n    DriveInputs(1'b0, 4'hb, 128'h0a980602ad8dad88d6b00c713abea53b);\n    DriveInputs(1'b0, 4'hc, 128'hcd0c9deab70fd5328970a76fa0d1dc48);\n    DriveInputs(1'b0, 4'hd, 128'h9a25537211c82a59b7bdf9a1fbac1f98);\n    DriveInputs(1'b0, 4'he, 128'h195b50b81173a575df5ee29817936c81);\n    DriveInputs(1'b0, 4'hf, 128'h342e5b8715bbb0cc481365f92724c1ed);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to W3C\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b11;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=     W3C      =\");\n    $display(\"================\");\n    \n    // Try all paddings for the W3C mode\n    DriveInputs(1'b0, 4'h0, 128'heab487e68ec92db4ac288a24757b0262);\n    DriveInputs(1'b0, 4'h1, 128'hf64d8192e294917701d3d70da384c8e0);\n    DriveInputs(1'b0, 4'h2, 128'he1b1ea612690eb1620ed797170814e60);\n    DriveInputs(1'b0, 4'h3, 128'h98b896945ce882123e56e787f95857af);\n    DriveInputs(1'b0, 4'h4, 128'h1c4874b8899b6a08c8d6ba8a7c56af36);\n    DriveInputs(1'b0, 4'h5, 128'hdd573152aa7456e418848171a5a36917);\n    DriveInputs(1'b0, 4'h6, 128'h437a94424a9234574e880ded69169a89);\n    DriveInputs(1'b0, 4'h7, 128'h5ee7b24ddcd74217e700cfc4804d1d4f);\n    DriveInputs(1'b0, 4'h8, 128'hf97a9831c2690f65f60bfef87a095127);\n    DriveInputs(1'b0, 4'h9, 128'h7e00f194cdf6e8cea0673e04b679f596);\n    DriveInputs(1'b0, 4'ha, 128'h464bb36d1646eccb390c2697dbe980f4);\n    DriveInputs(1'b0, 4'hb, 128'h2f7eb1363120ab53ff3682cb37ca006b);\n    DriveInputs(1'b0, 4'hc, 128'h77e987e8bdb2a56cd90481a1f2232f4b);\n    DriveInputs(1'b0, 4'hd, 128'h70b8b2de66377852c1fa6090ffa5199a);\n    DriveInputs(1'b0, 4'he, 128'h9fcb5342ceeda9eb119a749e828953ac);\n    DriveInputs(1'b0, 4'hf, 128'h70063b648ddd4ec7ae5bfa7baae10919);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/aes_dec_top.sv": "", "rtl/aes_enc_top.sv": "", "rtl/padding_top.sv": ""}, "harness": {"docker-compose.yml": "services:\n  test_padding:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n\n  test_decrypt:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env_decrypt\n    command     : pytest /src/test_runner_dec_top.py -s -v -o cache_dir=/rundir/harness/.cache\n\n  test_encrypt:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env_encrypt\n    command     : pytest /src/test_runner_enc_top.py -s -v -o cache_dir=/rundir/harness/.cache", "src/.env": "VERILOG_SOURCES = /code/rtl/padding_top.sv /code/rtl/aes_dec_top.sv /code/rtl/aes_decrypt.sv /code/rtl/sbox.sv /code/rtl/aes_ke.sv /code/rtl/inv_sbox.sv /code/rtl/aes_encrypt.sv /code/rtl/aes_enc_top.sv\nTOPLEVEL        = padding_top\nMODULE          = test_padding_top\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 18-create-aes-padding\nWAVE            = true", "src/.env_decrypt": "VERILOG_SOURCES = /code/rtl/aes_dec_top.sv /code/rtl/aes_decrypt.sv /code/rtl/sbox.sv /code/rtl/aes_ke.sv /code/rtl/inv_sbox.sv /code/rtl/aes_encrypt.sv\nTOPLEVEL        = aes_dec_top\nMODULE          = test_aes_dec_top\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 18-create-aes-padding\nWAVE            = true", "src/.env_encrypt": "VERILOG_SOURCES = /code/rtl/aes_enc_top.sv /code/rtl/aes_encrypt.sv /code/rtl/sbox.sv\nTOPLEVEL        = aes_enc_top\nMODULE          = test_aes_enc_top\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 18-create-aes-padding\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\ndef PKCS(data, padding):\n    # Convert int to 16-byte array\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    # Trim the last `padding` bytes\n    trimmed = data_bytes[:16 - padding]\n\n    # Add padding bytes\n    pad_byte = padding.to_bytes(1, byteorder='big')\n    padded_bytes = trimmed + pad_byte * padding\n\n    # Convert back to integer\n    return int.from_bytes(padded_bytes, byteorder='big')\n\ndef OneAndZeroes(data, padding):\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    if padding == 0:\n        # No padding needed\n        padded_bytes = data_bytes\n    else:\n        trimmed = data_bytes[:16 - padding]\n        padded_bytes = trimmed + b'\\x80' + b'\\x00' * (padding - 1)\n\n    return int.from_bytes(padded_bytes, byteorder='big')\n\ndef ANSIX923(data, padding):\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    if padding == 0:\n        padded_bytes = data_bytes\n    else:\n        trimmed = data_bytes[:16 - padding]\n        pad_value = padding.to_bytes(1, byteorder='big')\n        padded_bytes = trimmed + b'\\x00' * (padding - 1) + pad_value\n\n    return int.from_bytes(padded_bytes, byteorder='big')\n\ndef W3C(data, padding, filler_byte=0xAF):\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    if padding == 0:\n        # No padding needed\n        padded_bytes = data_bytes\n    else:\n        trimmed = data_bytes[:16 - padding]\n        fill = bytes([filler_byte] * (padding - 1)) + bytes([padding])\n        padded_bytes = trimmed + fill\n\n    return int.from_bytes(padded_bytes, byteorder='big')\n\nclass aes_decrypt:\n    RCON = [\n        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n    ]\n    \n    SBOX = [\n        # S-box table used in AES\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n    \n    def __init__(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n        self.inv_s_box = [0] * 256\n        for i, val in enumerate(self.SBOX):\n            self.inv_s_box[val] = i\n    \n    def reset(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n    \n    def update_key(self, key):\n        key_bytes = key.to_bytes(32, 'big')  # Convert 256-bit key to bytes\n        self.expanded_key = self.expand_key(key_bytes)\n    \n    def expand_key(self, key):\n        words = [list(key[i:i+4]) for i in range(0, 32, 4)]\n        \n        for i in range(8, 60):\n            temp = words[i - 1]\n            \n            if i % 8 == 0:\n                temp = self.sub_word(self.rot_word(temp))\n                temp[0] ^= self.RCON[i // 8 - 1]\n            elif i % 8 == 4:\n                temp = self.sub_word(temp)\n            \n            words.append([words[i - 8][j] ^ temp[j] for j in range(4)])\n        \n        expanded_key_bytes = b''.join(bytes(word) for word in words)\n        return int.from_bytes(expanded_key_bytes, 'big')\n    \n    def sub_word(self, word):\n        return [self.SBOX[b] for b in word]\n    \n    def rot_word(self, word):\n        return word[1:] + word[:1]\n    \n    def gmul(self, a, b):\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.SBOX[state[i]]\n\n    def shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[5], state[9], state[13], state[1]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[15], state[3], state[7], state[11]\n\n    def mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],2)^self.gmul(a[1],3)^a[2]^a[3]\n            s[i*4+1] = a[0]^self.gmul(a[1],2)^self.gmul(a[2],3)^a[3]\n            s[i*4+2] = a[0]^a[1]^self.gmul(a[2],2)^self.gmul(a[3],3)\n            s[i*4+3] = self.gmul(a[0],3)^a[1]^a[2]^self.gmul(a[3],2)\n\n    def add_round_key(self, state, round_key_words):\n        for col in range(4):\n            word = round_key_words[col]\n            for row in range(4):\n                state[col * 4 + row] ^= (word >> (24 - 8 * row)) & 0xFF\n\n    def get_round_keys(self):\n        expanded_bytes = self.expanded_key.to_bytes(240, 'big')\n        round_keys = []\n        for i in range(0, 240, 16):  # Each round key is 16 bytes (4 words)\n            words = [int.from_bytes(expanded_bytes[i + j*4 : i + (j+1)*4], 'big') for j in range(4)]\n            round_keys.append(words)\n        return round_keys\n\n    def encrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n        \n        self.add_round_key(state, round_keys[0])\n\n        for rnd in range(1, 14):\n            self.sub_bytes(state)\n            self.shift_rows(state)\n            self.mix_columns(state)\n            self.add_round_key(state, round_keys[rnd])\n\n        self.sub_bytes(state)\n        self.shift_rows(state)\n        self.add_round_key(state, round_keys[14])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b\n        \n    def inv_sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.inv_s_box[state[i]]\n\n    def inv_shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[13], state[1], state[5], state[9]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[7], state[11], state[15], state[3]\n\n    def inv_mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],14)^self.gmul(a[1],11)^self.gmul(a[2],13)^self.gmul(a[3],9)\n            s[i*4+1] = self.gmul(a[0],9)^self.gmul(a[1],14)^self.gmul(a[2],11)^self.gmul(a[3],13)\n            s[i*4+2] = self.gmul(a[0],13)^self.gmul(a[1],9)^self.gmul(a[2],14)^self.gmul(a[3],11)\n            s[i*4+3] = self.gmul(a[0],11)^self.gmul(a[1],13)^self.gmul(a[2],9)^self.gmul(a[3],14)\n    \n    def decrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n\n        self.add_round_key(state, round_keys[14])\n\n        for rnd in range(13, 0, -1):\n            self.inv_shift_rows(state)\n            self.inv_sub_bytes(state)\n            self.add_round_key(state, round_keys[rnd])\n            self.inv_mix_columns(state)\n\n        self.inv_shift_rows(state)\n        self.inv_sub_bytes(state)\n        self.add_round_key(state, round_keys[0])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b\n    \n    def MODE(self, data, mode):\n        if mode == 0:\n            self.ECB(data)\n        elif mode == 1:\n            self.CBC(data)\n        elif mode == 2:\n            self.PCBC(data)\n        elif mode == 3:\n            self.CFB(data)\n        elif mode == 4:\n            self.OFB(data)\n        else:\n            self.CTR(data)\n\n    def ECB(self, data):\n        self.decrypt(data)\n    \n    def CBC(self, data):\n        self.decrypt(data)\n        self.data_out = self.data_out ^ self.iv\n        self.iv = data\n    \n    def PCBC(self, data):\n        self.decrypt(data)\n        self.data_out = self.data_out ^ self.iv\n        self.iv = data ^ self.data_out\n    \n    def CFB(self, data):\n        self.encrypt(self.iv)\n        self.data_out = self.data_out ^ data\n        self.iv = data\n    \n    def OFB(self, data):\n        self.encrypt(self.iv)\n        self.iv = self.data_out\n        self.data_out = self.data_out ^ data\n    \n    def CTR(self, data):\n        enc_in = (self.iv & 0x0000FFFFFFFFFFFFFFFFFFFFFFFF0000) + (self.counter & 0x0000FFFF) + ((self.counter & 0xFFFF0000) << 96)\n        self.encrypt(enc_in)\n        if self.counter < 2**32 - 1:\n            self.counter = self.counter + 1\n        else:\n            self.counter = 0\n        \n        self.data_out = self.data_out ^ data\n\nclass aes_encrypt:\n    RCON = [\n        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n    ]\n    \n    SBOX = [\n        # S-box table used in AES\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n    \n    def __init__(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n    \n    def reset(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n    \n    def update_key(self, key):\n        key_bytes = key.to_bytes(32, 'big')  # Convert 256-bit key to bytes\n        self.expanded_key = self.expand_key(key_bytes)\n    \n    def expand_key(self, key):\n        words = [list(key[i:i+4]) for i in range(0, 32, 4)]\n        \n        for i in range(8, 60):\n            temp = words[i - 1]\n            \n            if i % 8 == 0:\n                temp = self.sub_word(self.rot_word(temp))\n                temp[0] ^= self.RCON[i // 8 - 1]\n            elif i % 8 == 4:\n                temp = self.sub_word(temp)\n            \n            words.append([words[i - 8][j] ^ temp[j] for j in range(4)])\n        \n        expanded_key_bytes = b''.join(bytes(word) for word in words)\n        return int.from_bytes(expanded_key_bytes, 'big')\n    \n    def sub_word(self, word):\n        return [self.SBOX[b] for b in word]\n    \n    def rot_word(self, word):\n        return word[1:] + word[:1]\n    \n    def gmul(self, a, b):\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.SBOX[state[i]]\n\n    def shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[5], state[9], state[13], state[1]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[15], state[3], state[7], state[11]\n\n    def mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],2)^self.gmul(a[1],3)^a[2]^a[3]\n            s[i*4+1] = a[0]^self.gmul(a[1],2)^self.gmul(a[2],3)^a[3]\n            s[i*4+2] = a[0]^a[1]^self.gmul(a[2],2)^self.gmul(a[3],3)\n            s[i*4+3] = self.gmul(a[0],3)^a[1]^a[2]^self.gmul(a[3],2)\n\n    def add_round_key(self, state, round_key_words):\n        for col in range(4):\n            word = round_key_words[col]\n            for row in range(4):\n                state[col * 4 + row] ^= (word >> (24 - 8 * row)) & 0xFF\n\n    def get_round_keys(self):\n        expanded_bytes = self.expanded_key.to_bytes(240, 'big')\n        round_keys = []\n        for i in range(0, 240, 16):  # Each round key is 16 bytes (4 words)\n            words = [int.from_bytes(expanded_bytes[i + j*4 : i + (j+1)*4], 'big') for j in range(4)]\n            round_keys.append(words)\n        return round_keys\n\n    def encrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n        \n        self.add_round_key(state, round_keys[0])\n\n        for rnd in range(1, 14):\n            self.sub_bytes(state)\n            self.shift_rows(state)\n            self.mix_columns(state)\n            self.add_round_key(state, round_keys[rnd])\n\n        self.sub_bytes(state)\n        self.shift_rows(state)\n        self.add_round_key(state, round_keys[14])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b\n    \n    def MODE(self, data, mode):\n        if mode == 0:\n            self.ECB(data)\n        elif mode == 1:\n            self.CBC(data)\n        elif mode == 2:\n            self.PCBC(data)\n        elif mode == 3:\n            self.CFB(data)\n        elif mode == 4:\n            self.OFB(data)\n        else:\n            self.CTR(data)\n    \n    def ECB(self, data):\n        self.encrypt(data)\n    \n    def CBC(self, data):\n        enc_in = data ^ self.iv\n        self.encrypt(enc_in)\n        self.iv = self.data_out\n    \n    def PCBC(self, data):\n        enc_in = data ^ self.iv\n        self.encrypt(enc_in)\n        self.iv = data ^ self.data_out\n    \n    def CFB(self, data):\n        self.encrypt(self.iv)\n        self.iv = self.data_out ^ data\n        self.data_out = self.iv\n    \n    def OFB(self, data):\n        self.encrypt(self.iv)\n        self.iv = self.data_out\n        self.data_out = self.data_out ^ data\n    \n    def CTR(self, data):\n        enc_in = (self.iv & 0x0000FFFFFFFFFFFFFFFFFFFFFFFF0000) + (self.counter & 0x0000FFFF) + ((self.counter & 0xFFFF0000) << 96)\n        self.encrypt(enc_in)\n        if self.counter < 2**32 - 1:\n            self.counter = self.counter + 1\n        else:\n            self.counter = 0\n        \n        self.data_out = self.data_out ^ data\n", "src/test_aes_dec_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_plaintext.value.to_unsigned()\n\n    model_data = model.data_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_plaintext  = {hex(dut_data)} \\nMODEL o_plaintext  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_plaintext does not match model o_plaintext: {hex(dut_data)} != {hex(model_data)}\"\n\ndef set_inputs(dut, reset_counter, update_iv, update_mode, update_key, mode, iv, ciphertext, key, start):\n    dut.i_reset_counter.value = reset_counter\n    dut.i_update_iv.value     = update_iv\n    dut.i_update_mode.value   = update_mode\n    dut.i_update_key.value    = update_key\n    dut.i_mode.value          = mode\n    dut.i_iv.value            = iv\n    dut.i_ciphertext.value    = ciphertext\n    dut.i_key.value           = key\n    dut.i_start.value         = start\n\n@cocotb.test()\nasync def test_aes_dec_top(dut):\n    \"\"\"Test the aes_dec_top module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.aes_decrypt()\n\n    resets = 2\n    runs = 2\n    mode_runs = 200\n\n    data_min = 0\n    data_max = 2**128 - 1\n\n    key_min = 0\n    key_max = 2**256 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value  = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n        # After reset o_done must be 1\n        dut_done = dut.o_done.value\n        assert dut_done == 1,  f\"[ERROR] After reset, DUT o_done must be 1. The harness received o_done = {dut_done}\"\n\n        for j in range(runs):\n            print(f'\\n------ Reset {i}, run {j} ------')\n\n            print(\"ECB mode\")\n            mode       = 0\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.ECB(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CBC mode\")\n            mode       = 1\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.CBC(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"PCBC mode\")\n            mode       = 2\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.PCBC(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CFB mode\")\n            mode       = 3\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.CFB(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n\n            print(\"OFB mode\")\n            mode       = 4\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.OFB(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CTR mode\")\n            mode       = 5\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n            \n            model.iv      = iv\n            model.counter = 0\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.CTR(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            ", "src/test_aes_enc_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_ciphertext.value.to_unsigned()\n\n    model_data = model.data_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_ciphertext  = {hex(dut_data)} \\nMODEL o_ciphertext  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_ciphertext does not match model o_ciphertext: {hex(dut_data)} != {hex(model_data)}\"\n\ndef set_inputs(dut, reset_counter, update_iv, update_mode, update_key, mode, iv, plaintext, key, start):\n    dut.i_reset_counter.value = reset_counter\n    dut.i_update_iv.value     = update_iv\n    dut.i_update_mode.value   = update_mode\n    dut.i_update_key.value    = update_key\n    dut.i_mode.value          = mode\n    dut.i_iv.value            = iv\n    dut.i_plaintext.value     = plaintext\n    dut.i_key.value           = key\n    dut.i_start.value         = start\n\n@cocotb.test()\nasync def test_aes_enc_top(dut):\n    \"\"\"Test the aes_enc_top module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.aes_encrypt()\n\n    resets = 2\n    runs = 2\n    mode_runs = 200\n\n    data_min = 0\n    data_max = 2**128 - 1\n\n    key_min = 0\n    key_max = 2**256 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value  = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n        # After reset o_done must be 1\n        dut_done = dut.o_done.value\n        assert dut_done == 1,  f\"[ERROR] After reset, DUT o_done must be 1. The harness received o_done = {dut_done}\"\n\n        for j in range(runs):\n            print(f'\\n------ Reset {i}, run {j} ------')\n\n            print(\"ECB mode\")\n            mode      = 0\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.ECB(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CBC mode\")\n            mode      = 1\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.CBC(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"PCBC mode\")\n            mode      = 2\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.PCBC(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CFB mode\")\n            mode      = 3\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.CFB(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n\n            print(\"OFB mode\")\n            mode      = 4\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.OFB(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CTR mode\")\n            mode      = 5\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv      = iv\n            model.counter = 0\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.CTR(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            ", "src/test_padding_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_data.value.to_unsigned()\n\n    model_data = model.data_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\ndef set_inputs(dut, reset_counter, update_iv, update_mode, update_key, mode, iv, data, key, start, encrypt, update_padding, padding_mode, padding_bytes):\n    dut.i_reset_counter.value       = reset_counter\n    dut.i_update_iv.value           = update_iv\n    dut.i_update_mode.value         = update_mode\n    dut.i_update_key.value          = update_key\n    dut.i_mode.value                = mode\n    dut.i_iv.value                  = iv\n    dut.i_data.value                = data\n    dut.i_key.value                 = key\n    dut.i_start.value               = start\n    dut.i_encrypt.value             = encrypt\n    dut.i_update_padding_mode.value = update_padding\n    dut.i_padding_mode.value        = padding_mode\n    dut.i_padding_bytes.value       = padding_bytes\n\n@cocotb.test()\nasync def test_padding_top(dut):\n    \"\"\"Test the padding_top module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    W3C_BYTE = dut.W3C_BYTE.value.to_unsigned()\n\n    model_enc = hrs_lb.aes_encrypt()\n    model_dec = hrs_lb.aes_decrypt()\n\n    resets = 2\n    runs = 2\n    mode_runs = 200\n\n    data_min = 0\n    data_max = 2**128 - 1\n\n    key_min = 0\n    key_max = 2**256 - 1\n\n    padd_min = 0\n    padd_max = 15\n\n    mode_min = 0\n    mode_max = 5\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value  = 1\n        await RisingEdge(dut.clk)\n\n        model_enc.reset()\n        model_dec.reset()\n\n        compare_values(dut, model_enc)\n        compare_values(dut, model_dec)\n        # After reset o_done must be 1\n        dut_done = dut.o_done.value\n        assert dut_done == 1,  f\"[ERROR] After reset, DUT o_done must be 1. The harness received o_done = {dut_done}\"\n\n        for j in range(runs):\n            print(f'\\n------ Reset {i}, run {j} ------')\n\n            print(\"Padding PKCS\")\n            encrypt = random.randint(0,1)\n            padding = random.randint(padd_min, padd_max)\n            mode    = random.randint(mode_min, mode_max)\n            iv      = random.randint(data_min, data_max)\n            data    = random.randint(data_min, data_max)\n            key     = random.randint(key_min , key_max )\n\n            # Set Counter, IV, mode and padding mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0, encrypt, 1, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            model_enc.counter = 0\n            model_dec.counter = 0\n            model_enc.iv      = iv\n            model_dec.iv      = iv\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, data, key, 1, encrypt, 0, 0, padding)\n                    model_enc.update_key(key)\n                    model_dec.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, data, 0, 1, encrypt, 0, 0, padding)\n                \n                model_enc.MODE(hrs_lb.PKCS(data, padding), mode)\n                model_dec.MODE(hrs_lb.PKCS(data, padding), mode)\n\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                if encrypt == 1:\n                    compare_values(dut, model_enc)\n                else:\n                    compare_values(dut, model_dec)\n\n\n            print(\"Padding OneAndZeroes\")\n            encrypt = random.randint(0,1)\n            padding = random.randint(padd_min, padd_max)\n            mode    = random.randint(mode_min, mode_max)\n            iv      = random.randint(data_min, data_max)\n            data    = random.randint(data_min, data_max)\n            key     = random.randint(key_min , key_max )\n\n            # Set Counter, IV, mode and padding mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0, encrypt, 1, 1, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            model_enc.counter = 0\n            model_dec.counter = 0\n            model_enc.iv      = iv\n            model_dec.iv      = iv\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, data, key, 1, encrypt, 0, 0, padding)\n                    model_enc.update_key(key)\n                    model_dec.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, data, 0, 1, encrypt, 0, 0, padding)\n                \n                model_enc.MODE(hrs_lb.OneAndZeroes(data, padding), mode)\n                model_dec.MODE(hrs_lb.OneAndZeroes(data, padding), mode)\n\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                if encrypt == 1:\n                    compare_values(dut, model_enc)\n                else:\n                    compare_values(dut, model_dec)\n            \n\n            print(\"Padding ANSIX923\")\n            encrypt = random.randint(0,1)\n            padding = random.randint(padd_min, padd_max)\n            mode    = random.randint(mode_min, mode_max)\n            iv      = random.randint(data_min, data_max)\n            data    = random.randint(data_min, data_max)\n            key     = random.randint(key_min , key_max )\n\n            # Set Counter, IV, mode and padding mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0, encrypt, 1, 2, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            model_enc.counter = 0\n            model_dec.counter = 0\n            model_enc.iv      = iv\n            model_dec.iv      = iv\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, data, key, 1, encrypt, 0, 0, padding)\n                    model_enc.update_key(key)\n                    model_dec.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, data, 0, 1, encrypt, 0, 0, padding)\n                \n                model_enc.MODE(hrs_lb.ANSIX923(data, padding), mode)\n                model_dec.MODE(hrs_lb.ANSIX923(data, padding), mode)\n\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                if encrypt == 1:\n                    compare_values(dut, model_enc)\n                else:\n                    compare_values(dut, model_dec)\n\n            print(\"Padding W3C\")\n            encrypt = random.randint(0,1)\n            padding = random.randint(padd_min, padd_max)\n            mode    = random.randint(mode_min, mode_max)\n            iv      = random.randint(data_min, data_max)\n            data    = random.randint(data_min, data_max)\n            key     = random.randint(key_min , key_max )\n\n            # Set Counter, IV, mode and padding mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0, encrypt, 1, 3, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            model_enc.counter = 0\n            model_dec.counter = 0\n            model_enc.iv      = iv\n            model_dec.iv      = iv\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, data, key, 1, encrypt, 0, 0, padding)\n                    model_enc.update_key(key)\n                    model_dec.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, data, 0, 1, encrypt, 0, 0, padding)\n\n                model_enc.MODE(hrs_lb.W3C(data, padding, W3C_BYTE), mode)\n                model_dec.MODE(hrs_lb.W3C(data, padding, W3C_BYTE), mode)\n\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                if encrypt == 1:\n                    compare_values(dut, model_enc)\n                else:\n                    compare_values(dut, model_dec)", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()", "src/test_runner_dec_top.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()", "src/test_runner_enc_top.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()"}}
{"id": "cvdp_agentic_ivory_cloud_ocean_3516", "categories": ["cid003", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "Create a module that implements the **Data Encryption Standard (DES)** encryption algorithm. This module performs bit-accurate DES encryption on a 64-bit plaintext block using a 64-bit key. The module must support synchronous encryption with a valid interface. It must suport burst operation, where `i_valid` is asserted for multiple cycles in a row. A testbench, `tb_des_enc.sv`, file is provided to test this new module. The description and requirements for the module are provided below:\n\n---\n\n## Specifications\n\n- **Module Name**: `des_enc` (to be added in `rtl` directory)\n\n- **Parameters**:\n    - `NBW_DATA`: Bit width of the input and output data blocks.\n        - Default: 64.\n        - Related interface signals: `i_data`, `o_data`.\n    - `NBW_KEY`: Bit width of the key.\n        - Default: 64.\n        - Related interface signals: `i_key`.\n- **Latency**: The block's latency, from when `i_valid` is read until `o_valid` is asserted, must be equal to the number of rounds: 16 cycles.\n\n---\n\n## Interface Signals\n\n| Signal              | Direction | Width            | Description                                                                                                            |\n|---------------------|-----------|------------------|-------------------------------------------------------------------------------------------------------------------     |\n| `clk`               | Input     | 1                | Drives the sequential logic on the rising edge.                                                                        |\n| `rst_async_n`       | Input     | 1                | Active-low asynchronous reset; clears all internal registers and state.                                                |\n| `i_valid`           | Input     | 1                | Active high. Indicates that `i_data` and `i_key` are valid and can be processed.                                       |\n| `i_data`            | Input     | [1:NBW_DATA]     | 64-bit plaintext input block (MSB-first).                                                                              |\n| `i_key`             | Input     | [1:NBW_KEY]      | 64-bit encryption key.                                                                                                 |\n| `o_valid`           | Output    | 1                | Asserted high when `o_data` contains valid encrypted data. It is asserted for as many cycles as `i_valid` is asserted  |\n| `o_data`            | Output    | [1:NBW_DATA]     | 64-bit ciphertext output block (MSB-first).                                                                            |\n---\n\n## Internal Behavior\n\nIn this module description, the first `n` bits of a value declared as [1:NBW] are `1, 2, 3, ... , n-1, n`, and the last `n` bits are `NBW-(n-1), NBW-(n-2), ... , NBW-1, NBW`.\n\nThe `des_enc` module implements the standard **16-round Feistel structure** of DES. The process is divided into the following stages:\n\n### 1. Initial Permutation (IP)\n\nThe 64-bit input block undergoes a fixed initial permutation. The description for this step is available at the \"Permutations.md\" file.\n\nThe first 32 bits are stored in $`L_0`$ and the last 32 bits in $`R_0`$.\n\n---\n\n### 2. Key Schedule\n\n- The 64-bit input key is reduced to 56 bits via a **parity drop**.\n- It is then split into two 28-bit halves.\n- Each half is rotated left based on a fixed schedule per round.\n- A **PC-2** permutation compresses the result to 48-bit round keys (`K1` to `K16`).\n\nThe \"Key_schedule.md\" file describes this operation in more detail.\n\n---\n\n### 3. Feistel Rounds\n\nEach of the 16 rounds updates the left and right halves as follows:\n\n$`L_n = R_{n-1}`$\n\n$`R_n = L_{n-1} \u2295 F(R_{n-1}, K_n)`$\n\nWhere `F` is the round function consisting of:\n\n- **Expansion (E)**: Expands 32-bit R to 48 bits using a fixed table. Described in the \"Permutations.md\" file.\n- **Key Mixing**: Uses the expanded value from the **Expansion (E)** operation and XORs it with the 48-bit round key $`K_n`$.\n- **S-box Substitution**: 48 bits are split into 8 groups of 6 bits, passed through S-boxes S1\u2013S8. Each S-box is a 4x16 table (64 entries) mapping a 6-bit input to a 4-bit output. Those operations are described in the \"S_box_creation.md\" file.\n- **Permutation (P)**: 32-bit output of S-boxes is permuted via a fixed permutation. Described in the \"Permutations.md\" file.\n\n---\n\n### 4. Final Permutation (FP)\n\nAfter the 16th round, the L and R halves are concatenated in reverse order and passed through the **Final Permutation**, which is the inverse of IP. This concatenation is described in the \"Permutations.md\" file.\n\n---\n\n## Substitution box files\n\nTo perform the operations S1, S2, ... , S8 described in \"S_box_creation.md\"; create the files `S1.sv`, `S2.sv`, `S3.sv`, `S4.sv`, `S5.sv`, `S6.sv`, `S7.sv`, `S8.sv` and place them at the `rtl` directory.\n", "context": {"verif/tb_des_enc.sv": "module tb;\n\nparameter NBW_DATA = 'd64;\nparameter NBW_KEY  = 'd64;\n\nlogic                clk;\nlogic                rst_async_n;\nlogic                i_valid;\nlogic [1:NBW_DATA] i_data;\nlogic [1:NBW_KEY ] i_key;\nlogic                o_valid;\nlogic [1:NBW_DATA] o_data;\n\ndes_enc #(\n    .NBW_DATA(NBW_DATA),\n    .NBW_KEY (NBW_KEY )\n) uu_des_enc (\n    .clk        (clk        ),\n    .rst_async_n(rst_async_n),\n    .i_valid    (i_valid    ),\n    .i_data     (i_data     ),\n    .i_key      (i_key      ),\n    .o_valid    (o_valid    ),\n    .o_data     (o_data     )\n);\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb);\nend\n\nalways #5 clk = ~clk;\n\ntask Single_test(logic [1:NBW_KEY] key, logic [1:NBW_DATA] data, logic [1:NBW_DATA] expected);\n    i_key   = key;\n    i_data  = data;\n    i_valid = 1;\n\n    @(negedge clk);\n    i_valid = 0;\n\n    @(posedge o_valid);\n    @(negedge clk);\n    if(o_data != expected) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", expected, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\nendtask\n\ntask Burst_test();\n    i_key   = 64'hB1FECAFEBEBAB1FE;\n    i_data  = 64'h4321432143214321;\n    i_valid = 1;\n\n    @(negedge clk);\n    i_data  = 64'h123456789ABCDEF0;\n\n    @(negedge clk);\n    i_data  = 64'h1234123412341234;\n    i_key   = 64'hABCDABCDABCDABCD;\n\n    @(negedge clk);\n    i_valid = 0;\n\n    @(posedge o_valid);\n    @(negedge clk);\n    if(o_data != 64'h6B85F162427F0DC8) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h6B85F162427F0DC8, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n\n    @(negedge clk);\n    if(o_valid != 1) begin\n        $display(\"FAIL! o_valid should be asserted here.\");\n    end\n    if(o_data != 64'hB02273A3AD757BDA) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'hB02273A3AD757BDA, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n\n    @(negedge clk);\n    if(o_valid != 1) begin\n        $display(\"FAIL! o_valid should be asserted here.\");\n    end\n    if(o_data != 64'h87C952860A802C4B) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h87C952860A802C4B, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n    \nendtask\n\ninitial begin\n    clk = 0;\n    i_valid = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    $display(\"\\nSingle Tests\");\n    Single_test(64'h0123456789ABCDEF, 64'h0123456789ABCDEF, 64'h56CC09E7CFDC4CEF);\n    Single_test(64'h0123456789ABCDEF, 64'hFEDCBA9876543210, 64'h12C626AF058B433B);\n    Single_test(64'hBEBACAFE12345678, 64'hFEDCBA9876543210, 64'h00D97727C293BFAC);\n    Single_test(64'hBEBACAFE12345678, 64'hB1FECAFEBEBAB1FE, 64'h31F3FE80E9457BED);\n\n    $display(\"\\nBurst Test\");\n    Burst_test();\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule", "docs/Key_schedule.md": "# Key Schedule\n\nThe **parity drop** operation removes one bit in each 8-bit byte of the KEY. Those bits are 8, 16,..., 64.\n\nThe KEY is divided in two parts, the first one named $`C_0`$ and the second one $`D_0`$. They permutate the KEY following those tables:\n\n$`C_0`$:\n\n| 57 | 49 | 41 | 33 | 25 | 17 |  9 |\n|----|----|----|----|----|----|----|\n|  1 | 58 | 50 | 42 | 34 | 26 | 18 |\n| 10 |  2 | 59 | 51 | 43 | 35 | 27 |\n| 19 | 11 |  3 | 60 | 52 | 44 | 36 |\n\n$`D_0`$:\n\n| 63 | 55 | 47 | 39 | 31 | 23 | 15 |\n|----|----|----|----|----|----|----|\n|  7 | 62 | 54 | 46 | 38 | 30 | 22 |\n| 14 |  6 | 61 | 53 | 45 | 37 | 29 |\n| 21 | 13 |  5 | 28 | 20 | 12 |  4 |\n\nThe bits of KEY are numbered 1 through 64. The bits of $`C_0`$ are respectively bits 57, 49, 41,..., 44 and 36 of KEY, with the bits of $`D_0`$ being bits 63, 55, 47,..., 12 and 4 of KEY.\n\nEach pair of ($`C_n`$, $`D_n`$), with n ranging from 1 to 16, are obtained by one or two left rotation(s) of the bits of its previous pair ($`C_{n-1}`$, $`D_{n-1}`$). Each round has a required number of left rotations.\n\n**Rotation per round**:\n\n| Round | Shifts |\n|-------|--------|\n|   1   |   1    |\n|   2   |   1    |\n|   3   |   2    |\n|   4   |   2    |\n|   5   |   2    |\n|   6   |   2    |\n|   7   |   2    |\n|   8   |   2    |\n|   9   |   1    |\n|  10   |   2    |\n|  11   |   2    |\n|  12   |   2    |\n|  13   |   2    |\n|  14   |   2    |\n|  15   |   2    |\n|  16   |   1    |\n\nFor example, $`C_3`$ and $`D_3`$ are obtained from $`C2`$ and $`D2`$, respectively, by two left shifts, and $`C16`$ and $`D16`$ are obtained from $`C15`$ and $`D15`$, respectively, by one left shift. In all cases, by a single left shift is meant a rotation of the bits one place to the left, so that after one left shift the bits in the 28 positions are the bits that were previously in positions 2, 3,..., 28, 1.\n\n**Permuted choice 2 (PC-2)**\n\nDetermined by the following table:\n\n| 14 | 17 | 11 | 24 |  1 |  5 |\n|----|----|----|----|----|----|\n|  3 | 28 | 15 |  6 | 21 | 10 |\n| 23 | 19 | 12 |  4 | 26 |  8 |\n| 16 |  7 | 27 | 20 | 13 |  2 |\n| 41 | 52 | 31 | 37 | 47 | 55 |\n| 30 | 40 | 51 | 45 | 33 | 48 |\n| 44 | 49 | 39 | 56 | 34 | 53 |\n| 46 | 42 | 50 | 36 | 29 | 32 |\n\nTherefore, the first bit of $`K_n`$ is the 14th bit of $`C_nD_n`$, the second bit the 17th, and so on with the 47th bit the 29th, and the 48th bit the 32nd. This way, all $`K_n`$, with n ranging from 1 to 16 is generated and used in the **Feistel Rounds**", "docs/Permutations.md": "# Initial Permutation (IP)\n\nThe 64 bits of the input block to be enciphered are first subjected to the following permutation, called the initial permutation IP:\n\nIP:\n| 58 | 50 | 42 | 34 | 26 | 18 | 10 |  2 |\n|----|----|----|----|----|----|----|----|\n| 60 | 52 | 44 | 36 | 28 | 20 | 12 |  4 |\n| 62 | 54 | 46 | 38 | 30 | 22 | 14 |  6 |\n| 64 | 56 | 48 | 40 | 32 | 24 | 16 |  8 |\n| 57 | 49 | 41 | 33 | 25 | 17 |  9 |  1 |\n| 59 | 51 | 43 | 35 | 27 | 19 | 11 |  3 |\n| 61 | 53 | 45 | 37 | 29 | 21 | 13 |  5 |\n| 63 | 55 | 47 | 39 | 31 | 23 | 15 |  7 |\n\n\nThat is the permuted input has bit 58 of the input as its first bit, bit 50 as its second bit, and so on with bit 7 as its last bit.\n\n# Feistel Rounds\n\nLet **Expansion (E)** denote a function which takes a block of 32 bits as input and yields a block of 48 bits as output. E bits are obtained by selecting the bits in its inputs in order according to the following table:\n\n| 32 |  1 |  2 |  3 |  4 |  5 |\n|----|----|----|----|----|----|\n|  4 |  5 |  6 |  7 |  8 |  9 |\n|  8 |  9 | 10 | 11 | 12 | 13 |\n| 12 | 13 | 14 | 15 | 16 | 17 |\n| 16 | 17 | 18 | 19 | 20 | 21 |\n| 20 | 21 | 22 | 23 | 24 | 25 |\n| 24 | 25 | 26 | 27 | 28 | 29 |\n| 28 | 29 | 30 | 31 | 32 |  1 |\n\nThus the first three bits of E(R) are the bits in positions 32, 1 and 2 of R while the last 2 bits of E(R) are the bits in positions 32 and 1.\n\nThe **Permutation (P)** function yields a 32-bit output from a 32-bit input by permuting the bits of the input block. Such a function is defined by the following table:\n\n| 16 |  7 | 20 | 21 |\n|----|----|----|----|\n| 29 | 12 | 28 | 17 |\n|  1 | 15 | 23 | 26 |\n|  5 | 18 | 31 | 10 |\n|  2 |  8 | 24 | 14 |\n| 32 | 27 |  3 |  9 |\n| 19 | 13 | 30 |  6 |\n| 22 | 11 |  4 | 25 |\n\nThe output **P(L)** for the function **P** defined by this table is obtained from the input **L** by taking the 16th bit of **L** as the first bit of **P(L)**, the 7th bit as the second bit of **P(L)**, and so on until the 25th bit of **L** is taken as the 32nd bit of **P(L)**.\n\n# Final Permutation (FP)\n\nThe final permutation uses the 64 bits of the calculated operation and subjects it to the following permutation which is the inverse of the initial permutation:\n\n| 40 |  8 | 48 | 16 | 56 | 24 | 64 | 32 |\n|----|----|----|----|----|----|----|----|\n| 39 |  7 | 47 | 15 | 55 | 23 | 63 | 31 |\n| 38 |  6 | 46 | 14 | 54 | 22 | 62 | 30 |\n| 37 |  5 | 45 | 13 | 53 | 21 | 61 | 29 |\n| 36 |  4 | 44 | 12 | 52 | 20 | 60 | 28 |\n| 35 |  3 | 43 | 11 | 51 | 19 | 59 | 27 |\n| 34 |  2 | 42 | 10 | 50 | 18 | 58 | 26 |\n| 33 |  1 | 41 |  9 | 49 | 17 | 57 | 25 |", "docs/S_box_creation.md": "The `S1` substitution box should follow this rule:\n\n\"S1_Table\":\n\n\n| Row\\Column |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |\n|------------|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|\n|  0         | 14 |  4 | 13 |  1 |  2 | 15 | 11 |  8 |  3 | 10 |  6 | 12 |  5 |  9 |  0 |  7 |\n|  1         |  0 | 15 |  7 |  4 | 14 |  2 | 13 |  1 | 10 |  6 | 12 | 11 |  9 |  5 |  3 |  8 |\n|  2         |  4 |  1 | 14 |  8 | 13 |  6 |  2 | 11 | 15 | 12 |  9 |  7 |  3 | 10 |  5 |  0 |\n|  3         | 15 | 12 |  8 |  2 |  4 |  9 |  1 |  7 |  5 | 11 |  3 | 14 | 10 |  0 |  6 | 13 |\n\n\nIf `S1` is the function defined in the \"S1_Table\" and `B` is a block of 6 bits, then `S1(B)` is determined as\nfollows: The first and last bits of `B` represent in base 2 a number in the range 0 to 3. Let that\nnumber be i. The middle 4 bits of `B` represent in base 2 a number in the range 0 to 15. Let that\nnumber be j. Look up in the table the number in the i'th row and j'th column. It is a number in\nthe range 0 to 15 and is uniquely represented by a 4 bit block. That block is the output `S1(B)` of\n`S1` for the input `B`. For example, for input 011011 the row is 01, that is row 1, and the column is\ndetermined by 1101, that is column 13. In row 1 column 13 appears 5 so that the output is 0101.\n\nThis same procedure is done for all substitutions: `S1`, `S2`, `S3`, `S4`, `S5`, `S6`, `S7` and `S8`, with their corresponding tables: \"S1_Table\", \"S2_Table\", \"S3_Table\", \"S4_Table\", \"S5_Table\", \"S6_Table\", \"S7_Table\", \"S8_Table\".\n\n\"S2_Table\":\n\n| Row\\Column |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |\n|------------|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|\n|      0     | 15 |  1 |  8 | 14 |  6 | 11 |  3 |  4 |  9 |  7 |  2 | 13 | 12 |  0 |  5 | 10 |\n|      1     |  3 | 13 |  4 |  7 | 15 |  2 |  8 | 14 | 12 |  0 |  1 | 10 |  6 |  9 | 11 |  5 |\n|      2     |  0 | 14 |  7 | 11 | 10 |  4 | 13 |  1 |  5 |  8 | 12 |  6 |  9 |  3 |  2 | 15 |\n|      3     | 13 |  8 | 10 |  1 |  3 | 15 |  4 |  2 | 11 |  6 |  7 | 12 |  0 |  5 | 14 |  9 |\n\n\"S3_Table\":\n\n| Row\\Column |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |\n|------------|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|\n|      0     | 10 |  0 |  9 | 14 |  6 |  3 | 15 |  5 |  1 | 13 | 12 |  7 | 11 |  4 |  2 |  8 |\n|      1     | 13 |  7 |  0 |  9 |  3 |  4 |  6 | 10 |  2 |  8 |  5 | 14 | 12 | 11 | 15 |  1 |\n|      2     | 13 |  6 |  4 |  9 |  8 | 15 |  3 |  0 | 11 |  1 |  2 | 12 |  5 | 10 | 14 |  7 |\n|      3     |  1 | 10 | 13 |  0 |  6 |  9 |  8 |  7 |  4 | 15 | 14 |  3 | 11 |  5 |  2 | 12 |\n\n\n\"S4_Table\":\n\n| Row\\Column |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |\n|------------|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|\n|      0     |  7 | 13 | 14 |  3 |  0 |  6 |  9 | 10 |  1 |  2 |  8 |  5 | 11 | 12 |  4 | 15 |\n|      1     | 13 |  8 | 11 |  5 |  6 | 15 |  0 |  3 |  4 |  7 |  2 | 12 |  1 | 10 | 14 |  9 |\n|      2     | 10 |  6 |  9 |  0 | 12 | 11 |  7 | 13 | 15 |  1 |  3 | 14 |  5 |  2 |  8 |  4 |\n|      3     |  3 | 15 |  0 |  6 | 10 |  1 | 13 |  8 |  9 |  4 |  5 | 11 | 12 |  7 |  2 | 14 |\n\n\n\"S5_Table\":\n\n| Row\\Column |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |\n|------------|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|\n|      0     |  2 | 12 |  4 |  1 |  7 | 10 | 11 |  6 |  8 |  5 |  3 | 15 | 13 |  0 | 14 |  9 |\n|      1     | 14 | 11 |  2 | 12 |  4 |  7 | 13 |  1 |  5 |  0 | 15 | 10 |  3 |  9 |  8 |  6 |\n|      2     |  4 |  2 |  1 | 11 | 10 | 13 |  7 |  8 | 15 |  9 | 12 |  5 |  6 |  3 |  0 | 14 |\n|      3     | 11 |  8 | 12 |  7 |  1 | 14 |  2 | 13 |  6 | 15 |  0 |  9 | 10 |  4 |  5 |  3 |\n\n\n\"S6_Table\":\n\n| Row\\Column |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |\n|------------|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|\n|      0     | 12 |  1 | 10 | 15 |  9 |  2 |  6 |  8 |  0 | 13 |  3 |  4 | 14 |  7 |  5 | 11 |\n|      1     | 10 | 15 |  4 |  2 |  7 | 12 |  9 |  5 |  6 |  1 | 13 | 14 |  0 | 11 |  3 |  8 |\n|      2     |  9 | 14 | 15 |  5 |  2 |  8 | 12 |  3 |  7 |  0 |  4 | 10 |  1 | 13 | 11 |  6 |\n|      3     |  4 |  3 |  2 | 12 |  9 |  5 | 15 | 10 | 11 | 14 |  1 |  7 |  6 |  0 |  8 | 13 |\n\n\n\"S7_Table\":\n\n| Row\\Column |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |\n|------------|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|\n|      0     |  4 | 11 |  2 | 14 | 15 |  0 |  8 | 13 |  3 | 12 |  9 |  7 |  5 | 10 |  6 |  1 |\n|      1     | 13 |  0 | 11 |  7 |  4 |  9 |  1 | 10 | 14 |  3 |  5 | 12 |  2 | 15 |  8 |  6 |\n|      2     |  1 |  4 | 11 | 13 | 12 |  3 |  7 | 14 | 10 | 15 |  6 |  8 |  0 |  5 |  9 |  2 |\n|      3     |  6 | 11 | 13 |  8 |  1 |  4 | 10 |  7 |  9 |  5 |  0 | 15 | 14 |  2 |  3 | 12 |\n\n\n\"S8_Table\":\n\n| Row\\Column |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |\n|------------|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|\n|      0     | 13 |  2 |  8 |  4 |  6 | 15 | 11 |  1 | 10 |  9 |  3 | 14 |  5 |  0 | 12 |  7 |\n|      1     |  1 | 15 | 13 |  8 | 10 |  3 |  7 |  4 | 12 |  5 |  6 | 11 |  0 | 14 |  9 |  2 |\n|      2     |  7 | 11 |  4 |  1 |  9 | 12 | 14 |  2 |  0 |  6 | 10 | 13 | 15 |  3 |  5 |  8 |\n|      3     |  2 |  1 | 14 |  7 |  4 | 10 |  8 | 13 | 15 | 12 |  9 |  0 |  3 |  5 |  6 | 11 |"}, "patch": {"rtl/S1.sv": "", "rtl/S2.sv": "", "rtl/S3.sv": "", "rtl/S4.sv": "", "rtl/S5.sv": "", "rtl/S6.sv": "", "rtl/S7.sv": "", "rtl/S8.sv": "", "rtl/des_enc.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n", "src/.env": "VERILOG_SOURCES = /code/rtl/des_enc.sv /code/rtl/S1.sv /code/rtl/S2.sv /code/rtl/S3.sv /code/rtl/S4.sv /code/rtl/S5.sv /code/rtl/S6.sv /code/rtl/S7.sv /code/rtl/S8.sv\nTOPLEVEL        = des_enc\nMODULE          = test_des_enc\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 1-create-des-enc\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass des_enc:\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.data_out = 0\n        self.fifo = []\n\n    def permute(self, block, table, n):\n        result = 0\n        for i in range(len(table)):\n            bit = (block >> (n - table[i])) & 1\n            result |= (bit << (len(table) - 1 - i))\n        return result\n\n    def left_rotate(self, val, n):\n        return ((val << n) & 0x0FFFFFFF) | (val >> (28 - n))\n\n    def sbox(self, box, val):\n        row = ((val >> 5) & 1) * 2 + (val & 1)\n        col = (val >> 1) & 0xF\n        return box[row][col]\n\n    def f(self, R, subkey):\n        E = [32,1,2,3,4,5,4,5,6,7,8,9,\n             8,9,10,11,12,13,12,13,14,15,16,17,\n             16,17,18,19,20,21,20,21,22,23,24,25,\n             24,25,26,27,28,29,28,29,30,31,32,1]\n\n        P = [16,7,20,21,29,12,28,17,\n             1,15,23,26,5,18,31,10,\n             2,8,24,14,32,27,3,9,\n             19,13,30,6,22,11,4,25]\n\n        SBOXES = self.sboxes\n\n        expanded = self.permute(R << 32, E, 64)\n        xored = expanded ^ subkey\n\n        output = 0\n        for i in range(8):\n            chunk = (xored >> (42 - i*6)) & 0x3F\n            sbox_val = self.sbox(SBOXES[i], chunk)\n            output = (output << 4) | sbox_val\n\n        return self.permute(output << 32, P, 64)\n\n    def generate_subkeys(self, key):\n        PC1 = [57,49,41,33,25,17,9,\n               1,58,50,42,34,26,18,\n               10,2,59,51,43,35,27,\n               19,11,3,60,52,44,36,\n               63,55,47,39,31,23,15,\n               7,62,54,46,38,30,22,\n               14,6,61,53,45,37,29,\n               21,13,5,28,20,12,4]\n\n        PC2 = [14,17,11,24,1,5,\n               3,28,15,6,21,10,\n               23,19,12,4,26,8,\n               16,7,27,20,13,2,\n               41,52,31,37,47,55,\n               30,40,51,45,33,48,\n               44,49,39,56,34,53,\n               46,42,50,36,29,32]\n\n        rotations = [1, 1, 2, 2, 2, 2, 2, 2,\n                     1, 2, 2, 2, 2, 2, 2, 1]\n\n        key56 = self.permute(key, PC1, 64)\n        C = (key56 >> 28) & 0xFFFFFFF\n        D = key56 & 0xFFFFFFF\n\n        subkeys = []\n        for rot in rotations:\n            C = self.left_rotate(C, rot)\n            D = self.left_rotate(D, rot)\n            CD = (C << 28) | D\n            subkey = self.permute(CD, PC2, 56)\n            subkeys.append(subkey)\n        return subkeys\n\n    def encrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.data_out = self.permute(pre_output, FP, 64)\n        self.fifo.append(self.data_out)\n    \n    def read_data(self):\n        if self.fifo:\n            return self.fifo.pop(0)\n        return 0\n\n    # Full DES S-box definitions\n    sboxes = [\n        [\n            [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n            [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n            [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n            [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13]\n        ],\n        [\n            [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10],\n            [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5],\n            [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15],\n            [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9]\n        ],\n        [\n            [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8],\n            [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1],\n            [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7],\n            [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12]\n        ],\n        [\n            [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15],\n            [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9],\n            [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4],\n            [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14]\n        ],\n        [\n            [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9],\n            [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6],\n            [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14],\n            [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3]\n        ],\n        [\n            [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11],\n            [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8],\n            [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6],\n            [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13]\n        ],\n        [\n            [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1],\n            [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6],\n            [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2],\n            [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12]\n        ],\n        [\n            [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7],\n            [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2],\n            [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8],\n            [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]\n        ]\n    ]\n", "src/test_des_enc.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data   = dut.o_data.value.to_unsigned()\n    model_data = model.read_data()\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_des_enc(dut):\n    \"\"\"Test the des_enc module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n\n    model = hrs_lb.des_enc()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**64 - 1\n\n    key_min  = 0\n    key_max  = 2**64 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_valid.value     = 0\n        dut.i_data.value      = 0\n        dut.i_key.value       = 0\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        # Latency check\n        key   = random.randint(key_min , key_max )\n        data  = random.randint(data_min, data_max)\n        valid = 1\n\n        await FallingEdge(dut.clk)\n        dut.i_data.value  = data\n        dut.i_key.value   = key\n        dut.i_valid.value = valid\n\n        model.encrypt(data, key)\n        await FallingEdge(dut.clk)\n        latency_counter = 1\n        dut.i_valid.value = 0\n\n        while dut.o_valid.value == 0:\n            latency_counter = latency_counter + 1\n            await FallingEdge(dut.clk)\n        \n        assert latency_counter == 16, f\"[ERROR] DUT latency must be 16 clock cycles\"\n        \n        compare_values(dut, model)\n\n        for j in range(runs):\n            if (j+1)%500 == 0:\n                print(f'\\n------ Reset {i}, run {j+1} ------')\n\n            key   = random.randint(key_min , key_max )\n            data  = random.randint(data_min, data_max)\n            valid = random.randint(0,1)\n\n            await FallingEdge(dut.clk)\n\n            dut.i_data.value  = data\n            dut.i_key.value   = key\n            dut.i_valid.value = valid\n            if valid:\n                model.encrypt(data, key)\n\n            if dut.o_valid.value == 1:\n                compare_values(dut, model)\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()"}}
{"id": "cvdp_agentic_meadow_river_prism_8091", "categories": ["cid004", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "The module `des_enc` performs the **Data Encryption Standard (DES)** encryption. Use it as a reference to create a new module that performs the inverse operation, the **DES** decryption. The module should be defined as `des_dec` and placed in the `rtl` directory as `des_dec.sv`.\n\nThe new module must perform bit-accurate DES decryption on a 64-bit plaintext block using a 64-bit key. The module must support synchronous decryption with a valid interface. It must support burst operation, where `i_valid` is asserted for multiple cycles in a row. A testbench, `tb_des_dec.sv`, file is provided to test this new module. No changes to the substitution boxes `S1`, `S2`, `S3`, `S4`, `S5`, `S6`, `S7`, and `S8` are required.\n\n- The module's interface must not be changed.\n- The module's latency must not be changed. \n- The files in `docs` folder describe the encryption process, and the changes required from the encryption algorithm to the decryption algorithm are described below.\n\n---\n\n## DES Decryption\n\nTo decipher it is only necessary to apply the very same algorithm 'f' of the encryption to an enciphered message block, taking care that at each iteration of the computation, the same block of key bits `K_n` is used during decipherment as was used during the encipherment of the block. Since the encryption uses:\n\n$`L_n = R_{n-1}`$\n$`R_n = L_{n-1} \u2295 f(R_{n-1},K_n)`$\n\nBy setting the `R_{n-1}` and `L_{n-1}` as the value that is being calculated, this equation can be expressed as:\n\n$`R_{n-1} = L_n`$\n$`L_{n-1} = R_n \u2295 f(L_n,K_n)`$\n\nWhere now the concatenation of `R_{16}` and `L_{16}` is the permuted, following **IP** permutation, input block for the deciphering calculation and the concatenation of `L_0` and `R_0` is the 'last_perm' wire, that is permutated following the **FP** permutation. \n\nAfter applying the initial permutation (IP) to the input, the encrypted data is arranged so that its first 32 bits are `R_{16}` and its last 32 bits are `L_{16}`. This concatenated block (`R_{16}`\u2016`L_{16}`) serves as the starting, permuted input for decryption. For the decipherment calculation with `R_{16}L_{16}` as the permuted input, `K_{16}` is used in the first iteration, `K_{15}` in the second, and so on, with `K_{1}` used in the 16th iteration. After the decryption rounds, the two halves `L_{0}` and `R_{0}` are concatenated into the wire called `last_perm`({`L_{0}`, `R_{0}`}),  which is then processed by the final permutation (FP) to yield the correct plaintext output. \n\nThe DES encryption algorithm description is available in the `Encryption.md` file and other supporting documentation, and a testbench to verify the expected behavior of the decryption design is available.\n", "context": {"docs/Key_schedule.md": "# Key Schedule\n\nThe **parity drop** operation removes one bit in each 8-bit byte of the KEY. Those bits are 8, 16,..., 64.\n\nThe KEY is divided in two parts, the first one named $`C_0`$ and the second one $`D_0`$. They permutate the KEY following those tables:\n\n$`C_0`$:\n\n| 57 | 49 | 41 | 33 | 25 | 17 |  9 |\n|----|----|----|----|----|----|----|\n|  1 | 58 | 50 | 42 | 34 | 26 | 18 |\n| 10 |  2 | 59 | 51 | 43 | 35 | 27 |\n| 19 | 11 |  3 | 60 | 52 | 44 | 36 |\n\n$`D_0`$:\n\n| 63 | 55 | 47 | 39 | 31 | 23 | 15 |\n|----|----|----|----|----|----|----|\n|  7 | 62 | 54 | 46 | 38 | 30 | 22 |\n| 14 |  6 | 61 | 53 | 45 | 37 | 29 |\n| 21 | 13 |  5 | 28 | 20 | 12 |  4 |\n\nThe bits of KEY are numbered 1 through 64. The bits of $`C_0`$ are respectively bits 57, 49, 41,..., 44 and 36 of KEY, with the bits of $`D_0`$ being bits 63, 55, 47,..., 12 and 4 of KEY.\n\nEach pair of ($`C_n`$, $`D_n`$), with n ranging from 1 to 16, are obtained by one or two left rotation(s) of the bits of its previous pair ($`C_{n-1}`$, $`D_{n-1}`$). Each round has a required number of left rotations.\n\n**Rotation per round**:\n\n| Round | Shifts |\n|-------|--------|\n|   1   |   1    |\n|   2   |   1    |\n|   3   |   2    |\n|   4   |   2    |\n|   5   |   2    |\n|   6   |   2    |\n|   7   |   2    |\n|   8   |   2    |\n|   9   |   1    |\n|  10   |   2    |\n|  11   |   2    |\n|  12   |   2    |\n|  13   |   2    |\n|  14   |   2    |\n|  15   |   2    |\n|  16   |   1    |\n\nFor example, $`C_3`$ and $`D_3`$ are obtained from $`C2`$ and $`D2`$, respectively, by two left shifts, and $`C16`$ and $`D16`$ are obtained from $`C15`$ and $`D15`$, respectively, by one left shift. In all cases, by a single left shift is meant a rotation of the bits one place to the left, so that after one left shift the bits in the 28 positions are the bits that were previously in positions 2, 3,..., 28, 1.\n\n**Permuted choice 2 (PC-2)**\n\nDetermined by the following table:\n\n| 14 | 17 | 11 | 24 |  1 |  5 |\n|----|----|----|----|----|----|\n|  3 | 28 | 15 |  6 | 21 | 10 |\n| 23 | 19 | 12 |  4 | 26 |  8 |\n| 16 |  7 | 27 | 20 | 13 |  2 |\n| 41 | 52 | 31 | 37 | 47 | 55 |\n| 30 | 40 | 51 | 45 | 33 | 48 |\n| 44 | 49 | 39 | 56 | 34 | 53 |\n| 46 | 42 | 50 | 36 | 29 | 32 |\n\nTherefore, the first bit of $`K_n`$ is the 14th bit of $`C_nD_n`$, the second bit the 17th, and so on with the 47th bit the 29th, and the 48th bit the 32nd. This way, all $`K_n`$, with n ranging from 1 to 16 is generated and used in the **Feistel Rounds**", "docs/Permutations.md": "# Initial Permutation (IP)\n\nThe 64 bits of the input block to be enciphered are first subjected to the following permutation, called the initial permutation IP:\n\nIP:\n| 58 | 50 | 42 | 34 | 26 | 18 | 10 |  2 |\n|----|----|----|----|----|----|----|----|\n| 60 | 52 | 44 | 36 | 28 | 20 | 12 |  4 |\n| 62 | 54 | 46 | 38 | 30 | 22 | 14 |  6 |\n| 64 | 56 | 48 | 40 | 32 | 24 | 16 |  8 |\n| 57 | 49 | 41 | 33 | 25 | 17 |  9 |  1 |\n| 59 | 51 | 43 | 35 | 27 | 19 | 11 |  3 |\n| 61 | 53 | 45 | 37 | 29 | 21 | 13 |  5 |\n| 63 | 55 | 47 | 39 | 31 | 23 | 15 |  7 |\n\n\nThat is the permuted input has bit 58 of the input as its first bit, bit 50 as its second bit, and so on with bit 7 as its last bit.\n\n# Feistel Rounds\n\nLet **Expansion (E)** denote a function which takes a block of 32 bits as input and yields a block of 48 bits as output. E bits are obtained by selecting the bits in its inputs in order according to the following table:\n\n| 32 |  1 |  2 |  3 |  4 |  5 |\n|----|----|----|----|----|----|\n|  4 |  5 |  6 |  7 |  8 |  9 |\n|  8 |  9 | 10 | 11 | 12 | 13 |\n| 12 | 13 | 14 | 15 | 16 | 17 |\n| 16 | 17 | 18 | 19 | 20 | 21 |\n| 20 | 21 | 22 | 23 | 24 | 25 |\n| 24 | 25 | 26 | 27 | 28 | 29 |\n| 28 | 29 | 30 | 31 | 32 |  1 |\n\nThus the first three bits of E(R) are the bits in positions 32, 1 and 2 of R while the last 2 bits of E(R) are the bits in positions 32 and 1.\n\nThe **Permutation (P)** function yields a 32-bit output from a 32-bit input by permuting the bits of the input block. Such a function is defined by the following table:\n\n| 16 |  7 | 20 | 21 |\n|----|----|----|----|\n| 29 | 12 | 28 | 17 |\n|  1 | 15 | 23 | 26 |\n|  5 | 18 | 31 | 10 |\n|  2 |  8 | 24 | 14 |\n| 32 | 27 |  3 |  9 |\n| 19 | 13 | 30 |  6 |\n| 22 | 11 |  4 | 25 |\n\nThe output **P(L)** for the function **P** defined by this table is obtained from the input **L** by taking the 16th bit of **L** as the first bit of **P(L)**, the 7th bit as the second bit of **P(L)**, and so on until the 25th bit of **L** is taken as the 32nd bit of **P(L)**.\n\n# Final Permutation (FP)\n\nThe final permutation uses the 64 bits of the calculated operation and subjects it to the following permutation which is the inverse of the initial permutation:\n\n| 40 |  8 | 48 | 16 | 56 | 24 | 64 | 32 |\n|----|----|----|----|----|----|----|----|\n| 39 |  7 | 47 | 15 | 55 | 23 | 63 | 31 |\n| 38 |  6 | 46 | 14 | 54 | 22 | 62 | 30 |\n| 37 |  5 | 45 | 13 | 53 | 21 | 61 | 29 |\n| 36 |  4 | 44 | 12 | 52 | 20 | 60 | 28 |\n| 35 |  3 | 43 | 11 | 51 | 19 | 59 | 27 |\n| 34 |  2 | 42 | 10 | 50 | 18 | 58 | 26 |\n| 33 |  1 | 41 |  9 | 49 | 17 | 57 | 25 |", "rtl/S1.sv": "module S1(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd14;\n        6'b0_0001_0 : o_data = 4'd4;\n        6'b0_0010_0 : o_data = 4'd13;\n        6'b0_0011_0 : o_data = 4'd1;\n        6'b0_0100_0 : o_data = 4'd2;\n        6'b0_0101_0 : o_data = 4'd15;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd8;\n        6'b0_1000_0 : o_data = 4'd3;\n        6'b0_1001_0 : o_data = 4'd10;\n        6'b0_1010_0 : o_data = 4'd6;\n        6'b0_1011_0 : o_data = 4'd12;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd9;\n        6'b0_1110_0 : o_data = 4'd0;\n        6'b0_1111_0 : o_data = 4'd7;\n        6'b0_0000_1 : o_data = 4'd0;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd7;\n        6'b0_0011_1 : o_data = 4'd4;\n        6'b0_0100_1 : o_data = 4'd14;\n        6'b0_0101_1 : o_data = 4'd2;\n        6'b0_0110_1 : o_data = 4'd13;\n        6'b0_0111_1 : o_data = 4'd1;\n        6'b0_1000_1 : o_data = 4'd10;\n        6'b0_1001_1 : o_data = 4'd6;\n        6'b0_1010_1 : o_data = 4'd12;\n        6'b0_1011_1 : o_data = 4'd11;\n        6'b0_1100_1 : o_data = 4'd9;\n        6'b0_1101_1 : o_data = 4'd5;\n        6'b0_1110_1 : o_data = 4'd3;\n        6'b0_1111_1 : o_data = 4'd8;\n        6'b1_0000_0 : o_data = 4'd4;\n        6'b1_0001_0 : o_data = 4'd1;\n        6'b1_0010_0 : o_data = 4'd14;\n        6'b1_0011_0 : o_data = 4'd8;\n        6'b1_0100_0 : o_data = 4'd13;\n        6'b1_0101_0 : o_data = 4'd6;\n        6'b1_0110_0 : o_data = 4'd2;\n        6'b1_0111_0 : o_data = 4'd11;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd12;\n        6'b1_1010_0 : o_data = 4'd9;\n        6'b1_1011_0 : o_data = 4'd7;\n        6'b1_1100_0 : o_data = 4'd3;\n        6'b1_1101_0 : o_data = 4'd10;\n        6'b1_1110_0 : o_data = 4'd5;\n        6'b1_1111_0 : o_data = 4'd0;\n        6'b1_0000_1 : o_data = 4'd15;\n        6'b1_0001_1 : o_data = 4'd12;\n        6'b1_0010_1 : o_data = 4'd8;\n        6'b1_0011_1 : o_data = 4'd2;\n        6'b1_0100_1 : o_data = 4'd4;\n        6'b1_0101_1 : o_data = 4'd9;\n        6'b1_0110_1 : o_data = 4'd1;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd5;\n        6'b1_1001_1 : o_data = 4'd11;\n        6'b1_1010_1 : o_data = 4'd3;\n        6'b1_1011_1 : o_data = 4'd14;\n        6'b1_1100_1 : o_data = 4'd10;\n        6'b1_1101_1 : o_data = 4'd0;\n        6'b1_1110_1 : o_data = 4'd6;\n        6'b1_1111_1 : o_data = 4'd13;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S1", "rtl/S2.sv": "module S2(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd15;\n        6'b0_0001_0 : o_data = 4'd1;\n        6'b0_0010_0 : o_data = 4'd8;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd11;\n        6'b0_0110_0 : o_data = 4'd3;\n        6'b0_0111_0 : o_data = 4'd4;\n        6'b0_1000_0 : o_data = 4'd9;\n        6'b0_1001_0 : o_data = 4'd7;\n        6'b0_1010_0 : o_data = 4'd2;\n        6'b0_1011_0 : o_data = 4'd13;\n        6'b0_1100_0 : o_data = 4'd12;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd5;\n        6'b0_1111_0 : o_data = 4'd10;\n        6'b0_0000_1 : o_data = 4'd3;\n        6'b0_0001_1 : o_data = 4'd13;\n        6'b0_0010_1 : o_data = 4'd4;\n        6'b0_0011_1 : o_data = 4'd7;\n        6'b0_0100_1 : o_data = 4'd15;\n        6'b0_0101_1 : o_data = 4'd2;\n        6'b0_0110_1 : o_data = 4'd8;\n        6'b0_0111_1 : o_data = 4'd14;\n        6'b0_1000_1 : o_data = 4'd12;\n        6'b0_1001_1 : o_data = 4'd0;\n        6'b0_1010_1 : o_data = 4'd1;\n        6'b0_1011_1 : o_data = 4'd10;\n        6'b0_1100_1 : o_data = 4'd6;\n        6'b0_1101_1 : o_data = 4'd9;\n        6'b0_1110_1 : o_data = 4'd11;\n        6'b0_1111_1 : o_data = 4'd5;\n        6'b1_0000_0 : o_data = 4'd0;\n        6'b1_0001_0 : o_data = 4'd14;\n        6'b1_0010_0 : o_data = 4'd7;\n        6'b1_0011_0 : o_data = 4'd11;\n        6'b1_0100_0 : o_data = 4'd10;\n        6'b1_0101_0 : o_data = 4'd4;\n        6'b1_0110_0 : o_data = 4'd13;\n        6'b1_0111_0 : o_data = 4'd1;\n        6'b1_1000_0 : o_data = 4'd5;\n        6'b1_1001_0 : o_data = 4'd8;\n        6'b1_1010_0 : o_data = 4'd12;\n        6'b1_1011_0 : o_data = 4'd6;\n        6'b1_1100_0 : o_data = 4'd9;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd2;\n        6'b1_1111_0 : o_data = 4'd15;\n        6'b1_0000_1 : o_data = 4'd13;\n        6'b1_0001_1 : o_data = 4'd8;\n        6'b1_0010_1 : o_data = 4'd10;\n        6'b1_0011_1 : o_data = 4'd1;\n        6'b1_0100_1 : o_data = 4'd3;\n        6'b1_0101_1 : o_data = 4'd15;\n        6'b1_0110_1 : o_data = 4'd4;\n        6'b1_0111_1 : o_data = 4'd2;\n        6'b1_1000_1 : o_data = 4'd11;\n        6'b1_1001_1 : o_data = 4'd6;\n        6'b1_1010_1 : o_data = 4'd7;\n        6'b1_1011_1 : o_data = 4'd12;\n        6'b1_1100_1 : o_data = 4'd0;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd14;\n        6'b1_1111_1 : o_data = 4'd9;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S2", "rtl/S3.sv": "module S3(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd10;\n        6'b0_0001_0 : o_data = 4'd0;\n        6'b0_0010_0 : o_data = 4'd9;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd3;\n        6'b0_0110_0 : o_data = 4'd15;\n        6'b0_0111_0 : o_data = 4'd5;\n        6'b0_1000_0 : o_data = 4'd1;\n        6'b0_1001_0 : o_data = 4'd13;\n        6'b0_1010_0 : o_data = 4'd12;\n        6'b0_1011_0 : o_data = 4'd7;\n        6'b0_1100_0 : o_data = 4'd11;\n        6'b0_1101_0 : o_data = 4'd4;\n        6'b0_1110_0 : o_data = 4'd2;\n        6'b0_1111_0 : o_data = 4'd8;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd7;\n        6'b0_0010_1 : o_data = 4'd0;\n        6'b0_0011_1 : o_data = 4'd9;\n        6'b0_0100_1 : o_data = 4'd3;\n        6'b0_0101_1 : o_data = 4'd4;\n        6'b0_0110_1 : o_data = 4'd6;\n        6'b0_0111_1 : o_data = 4'd10;\n        6'b0_1000_1 : o_data = 4'd2;\n        6'b0_1001_1 : o_data = 4'd8;\n        6'b0_1010_1 : o_data = 4'd5;\n        6'b0_1011_1 : o_data = 4'd14;\n        6'b0_1100_1 : o_data = 4'd12;\n        6'b0_1101_1 : o_data = 4'd11;\n        6'b0_1110_1 : o_data = 4'd15;\n        6'b0_1111_1 : o_data = 4'd1;\n        6'b1_0000_0 : o_data = 4'd13;\n        6'b1_0001_0 : o_data = 4'd6;\n        6'b1_0010_0 : o_data = 4'd4;\n        6'b1_0011_0 : o_data = 4'd9;\n        6'b1_0100_0 : o_data = 4'd8;\n        6'b1_0101_0 : o_data = 4'd15;\n        6'b1_0110_0 : o_data = 4'd3;\n        6'b1_0111_0 : o_data = 4'd0;\n        6'b1_1000_0 : o_data = 4'd11;\n        6'b1_1001_0 : o_data = 4'd1;\n        6'b1_1010_0 : o_data = 4'd2;\n        6'b1_1011_0 : o_data = 4'd12;\n        6'b1_1100_0 : o_data = 4'd5;\n        6'b1_1101_0 : o_data = 4'd10;\n        6'b1_1110_0 : o_data = 4'd14;\n        6'b1_1111_0 : o_data = 4'd7;\n        6'b1_0000_1 : o_data = 4'd1;\n        6'b1_0001_1 : o_data = 4'd10;\n        6'b1_0010_1 : o_data = 4'd13;\n        6'b1_0011_1 : o_data = 4'd0;\n        6'b1_0100_1 : o_data = 4'd6;\n        6'b1_0101_1 : o_data = 4'd9;\n        6'b1_0110_1 : o_data = 4'd8;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd4;\n        6'b1_1001_1 : o_data = 4'd15;\n        6'b1_1010_1 : o_data = 4'd14;\n        6'b1_1011_1 : o_data = 4'd3;\n        6'b1_1100_1 : o_data = 4'd11;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd2;\n        6'b1_1111_1 : o_data = 4'd12;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S3", "rtl/S4.sv": "module S4(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd7;\n        6'b0_0001_0 : o_data = 4'd13;\n        6'b0_0010_0 : o_data = 4'd14;\n        6'b0_0011_0 : o_data = 4'd3;\n        6'b0_0100_0 : o_data = 4'd0;\n        6'b0_0101_0 : o_data = 4'd6;\n        6'b0_0110_0 : o_data = 4'd9;\n        6'b0_0111_0 : o_data = 4'd10;\n        6'b0_1000_0 : o_data = 4'd1;\n        6'b0_1001_0 : o_data = 4'd2;\n        6'b0_1010_0 : o_data = 4'd8;\n        6'b0_1011_0 : o_data = 4'd5;\n        6'b0_1100_0 : o_data = 4'd11;\n        6'b0_1101_0 : o_data = 4'd12;\n        6'b0_1110_0 : o_data = 4'd4;\n        6'b0_1111_0 : o_data = 4'd15;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd8;\n        6'b0_0010_1 : o_data = 4'd11;\n        6'b0_0011_1 : o_data = 4'd5;\n        6'b0_0100_1 : o_data = 4'd6;\n        6'b0_0101_1 : o_data = 4'd15;\n        6'b0_0110_1 : o_data = 4'd0;\n        6'b0_0111_1 : o_data = 4'd3;\n        6'b0_1000_1 : o_data = 4'd4;\n        6'b0_1001_1 : o_data = 4'd7;\n        6'b0_1010_1 : o_data = 4'd2;\n        6'b0_1011_1 : o_data = 4'd12;\n        6'b0_1100_1 : o_data = 4'd1;\n        6'b0_1101_1 : o_data = 4'd10;\n        6'b0_1110_1 : o_data = 4'd14;\n        6'b0_1111_1 : o_data = 4'd9;\n        6'b1_0000_0 : o_data = 4'd10;\n        6'b1_0001_0 : o_data = 4'd6;\n        6'b1_0010_0 : o_data = 4'd9;\n        6'b1_0011_0 : o_data = 4'd0;\n        6'b1_0100_0 : o_data = 4'd12;\n        6'b1_0101_0 : o_data = 4'd11;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd13;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd1;\n        6'b1_1010_0 : o_data = 4'd3;\n        6'b1_1011_0 : o_data = 4'd14;\n        6'b1_1100_0 : o_data = 4'd5;\n        6'b1_1101_0 : o_data = 4'd2;\n        6'b1_1110_0 : o_data = 4'd8;\n        6'b1_1111_0 : o_data = 4'd4;\n        6'b1_0000_1 : o_data = 4'd3;\n        6'b1_0001_1 : o_data = 4'd15;\n        6'b1_0010_1 : o_data = 4'd0;\n        6'b1_0011_1 : o_data = 4'd6;\n        6'b1_0100_1 : o_data = 4'd10;\n        6'b1_0101_1 : o_data = 4'd1;\n        6'b1_0110_1 : o_data = 4'd13;\n        6'b1_0111_1 : o_data = 4'd8;\n        6'b1_1000_1 : o_data = 4'd9;\n        6'b1_1001_1 : o_data = 4'd4;\n        6'b1_1010_1 : o_data = 4'd5;\n        6'b1_1011_1 : o_data = 4'd11;\n        6'b1_1100_1 : o_data = 4'd12;\n        6'b1_1101_1 : o_data = 4'd7;\n        6'b1_1110_1 : o_data = 4'd2;\n        6'b1_1111_1 : o_data = 4'd14;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S4", "rtl/S5.sv": "module S5(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd2;\n        6'b0_0001_0 : o_data = 4'd12;\n        6'b0_0010_0 : o_data = 4'd4;\n        6'b0_0011_0 : o_data = 4'd1;\n        6'b0_0100_0 : o_data = 4'd7;\n        6'b0_0101_0 : o_data = 4'd10;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd6;\n        6'b0_1000_0 : o_data = 4'd8;\n        6'b0_1001_0 : o_data = 4'd5;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd15;\n        6'b0_1100_0 : o_data = 4'd13;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd14;\n        6'b0_1111_0 : o_data = 4'd9;\n        6'b0_0000_1 : o_data = 4'd14;\n        6'b0_0001_1 : o_data = 4'd11;\n        6'b0_0010_1 : o_data = 4'd2;\n        6'b0_0011_1 : o_data = 4'd12;\n        6'b0_0100_1 : o_data = 4'd4;\n        6'b0_0101_1 : o_data = 4'd7;\n        6'b0_0110_1 : o_data = 4'd13;\n        6'b0_0111_1 : o_data = 4'd1;\n        6'b0_1000_1 : o_data = 4'd5;\n        6'b0_1001_1 : o_data = 4'd0;\n        6'b0_1010_1 : o_data = 4'd15;\n        6'b0_1011_1 : o_data = 4'd10;\n        6'b0_1100_1 : o_data = 4'd3;\n        6'b0_1101_1 : o_data = 4'd9;\n        6'b0_1110_1 : o_data = 4'd8;\n        6'b0_1111_1 : o_data = 4'd6;\n        6'b1_0000_0 : o_data = 4'd4;\n        6'b1_0001_0 : o_data = 4'd2;\n        6'b1_0010_0 : o_data = 4'd1;\n        6'b1_0011_0 : o_data = 4'd11;\n        6'b1_0100_0 : o_data = 4'd10;\n        6'b1_0101_0 : o_data = 4'd13;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd8;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd9;\n        6'b1_1010_0 : o_data = 4'd12;\n        6'b1_1011_0 : o_data = 4'd5;\n        6'b1_1100_0 : o_data = 4'd6;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd0;\n        6'b1_1111_0 : o_data = 4'd14;\n        6'b1_0000_1 : o_data = 4'd11;\n        6'b1_0001_1 : o_data = 4'd8;\n        6'b1_0010_1 : o_data = 4'd12;\n        6'b1_0011_1 : o_data = 4'd7;\n        6'b1_0100_1 : o_data = 4'd1;\n        6'b1_0101_1 : o_data = 4'd14;\n        6'b1_0110_1 : o_data = 4'd2;\n        6'b1_0111_1 : o_data = 4'd13;\n        6'b1_1000_1 : o_data = 4'd6;\n        6'b1_1001_1 : o_data = 4'd15;\n        6'b1_1010_1 : o_data = 4'd0;\n        6'b1_1011_1 : o_data = 4'd9;\n        6'b1_1100_1 : o_data = 4'd10;\n        6'b1_1101_1 : o_data = 4'd4;\n        6'b1_1110_1 : o_data = 4'd5;\n        6'b1_1111_1 : o_data = 4'd3;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S5", "rtl/S6.sv": "module S6(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd12;\n        6'b0_0001_0 : o_data = 4'd1;\n        6'b0_0010_0 : o_data = 4'd10;\n        6'b0_0011_0 : o_data = 4'd15;\n        6'b0_0100_0 : o_data = 4'd9;\n        6'b0_0101_0 : o_data = 4'd2;\n        6'b0_0110_0 : o_data = 4'd6;\n        6'b0_0111_0 : o_data = 4'd8;\n        6'b0_1000_0 : o_data = 4'd0;\n        6'b0_1001_0 : o_data = 4'd13;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd4;\n        6'b0_1100_0 : o_data = 4'd14;\n        6'b0_1101_0 : o_data = 4'd7;\n        6'b0_1110_0 : o_data = 4'd5;\n        6'b0_1111_0 : o_data = 4'd11;\n        6'b0_0000_1 : o_data = 4'd10;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd4;\n        6'b0_0011_1 : o_data = 4'd2;\n        6'b0_0100_1 : o_data = 4'd7;\n        6'b0_0101_1 : o_data = 4'd12;\n        6'b0_0110_1 : o_data = 4'd9;\n        6'b0_0111_1 : o_data = 4'd5;\n        6'b0_1000_1 : o_data = 4'd6;\n        6'b0_1001_1 : o_data = 4'd1;\n        6'b0_1010_1 : o_data = 4'd13;\n        6'b0_1011_1 : o_data = 4'd14;\n        6'b0_1100_1 : o_data = 4'd0;\n        6'b0_1101_1 : o_data = 4'd11;\n        6'b0_1110_1 : o_data = 4'd3;\n        6'b0_1111_1 : o_data = 4'd8;\n        6'b1_0000_0 : o_data = 4'd9;\n        6'b1_0001_0 : o_data = 4'd14;\n        6'b1_0010_0 : o_data = 4'd15;\n        6'b1_0011_0 : o_data = 4'd5;\n        6'b1_0100_0 : o_data = 4'd2;\n        6'b1_0101_0 : o_data = 4'd8;\n        6'b1_0110_0 : o_data = 4'd12;\n        6'b1_0111_0 : o_data = 4'd3;\n        6'b1_1000_0 : o_data = 4'd7;\n        6'b1_1001_0 : o_data = 4'd0;\n        6'b1_1010_0 : o_data = 4'd4;\n        6'b1_1011_0 : o_data = 4'd10;\n        6'b1_1100_0 : o_data = 4'd1;\n        6'b1_1101_0 : o_data = 4'd13;\n        6'b1_1110_0 : o_data = 4'd11;\n        6'b1_1111_0 : o_data = 4'd6;\n        6'b1_0000_1 : o_data = 4'd4;\n        6'b1_0001_1 : o_data = 4'd3;\n        6'b1_0010_1 : o_data = 4'd2;\n        6'b1_0011_1 : o_data = 4'd12;\n        6'b1_0100_1 : o_data = 4'd9;\n        6'b1_0101_1 : o_data = 4'd5;\n        6'b1_0110_1 : o_data = 4'd15;\n        6'b1_0111_1 : o_data = 4'd10;\n        6'b1_1000_1 : o_data = 4'd11;\n        6'b1_1001_1 : o_data = 4'd14;\n        6'b1_1010_1 : o_data = 4'd1;\n        6'b1_1011_1 : o_data = 4'd7;\n        6'b1_1100_1 : o_data = 4'd6;\n        6'b1_1101_1 : o_data = 4'd0;\n        6'b1_1110_1 : o_data = 4'd8;\n        6'b1_1111_1 : o_data = 4'd13;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S6", "rtl/S7.sv": "module S7(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd4;\n        6'b0_0001_0 : o_data = 4'd11;\n        6'b0_0010_0 : o_data = 4'd2;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd15;\n        6'b0_0101_0 : o_data = 4'd0;\n        6'b0_0110_0 : o_data = 4'd8;\n        6'b0_0111_0 : o_data = 4'd13;\n        6'b0_1000_0 : o_data = 4'd3;\n        6'b0_1001_0 : o_data = 4'd12;\n        6'b0_1010_0 : o_data = 4'd9;\n        6'b0_1011_0 : o_data = 4'd7;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd10;\n        6'b0_1110_0 : o_data = 4'd6;\n        6'b0_1111_0 : o_data = 4'd1;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd0;\n        6'b0_0010_1 : o_data = 4'd11;\n        6'b0_0011_1 : o_data = 4'd7;\n        6'b0_0100_1 : o_data = 4'd4;\n        6'b0_0101_1 : o_data = 4'd9;\n        6'b0_0110_1 : o_data = 4'd1;\n        6'b0_0111_1 : o_data = 4'd10;\n        6'b0_1000_1 : o_data = 4'd14;\n        6'b0_1001_1 : o_data = 4'd3;\n        6'b0_1010_1 : o_data = 4'd5;\n        6'b0_1011_1 : o_data = 4'd12;\n        6'b0_1100_1 : o_data = 4'd2;\n        6'b0_1101_1 : o_data = 4'd15;\n        6'b0_1110_1 : o_data = 4'd8;\n        6'b0_1111_1 : o_data = 4'd6;\n        6'b1_0000_0 : o_data = 4'd1;\n        6'b1_0001_0 : o_data = 4'd4;\n        6'b1_0010_0 : o_data = 4'd11;\n        6'b1_0011_0 : o_data = 4'd13;\n        6'b1_0100_0 : o_data = 4'd12;\n        6'b1_0101_0 : o_data = 4'd3;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd14;\n        6'b1_1000_0 : o_data = 4'd10;\n        6'b1_1001_0 : o_data = 4'd15;\n        6'b1_1010_0 : o_data = 4'd6;\n        6'b1_1011_0 : o_data = 4'd8;\n        6'b1_1100_0 : o_data = 4'd0;\n        6'b1_1101_0 : o_data = 4'd5;\n        6'b1_1110_0 : o_data = 4'd9;\n        6'b1_1111_0 : o_data = 4'd2;\n        6'b1_0000_1 : o_data = 4'd6;\n        6'b1_0001_1 : o_data = 4'd11;\n        6'b1_0010_1 : o_data = 4'd13;\n        6'b1_0011_1 : o_data = 4'd8;\n        6'b1_0100_1 : o_data = 4'd1;\n        6'b1_0101_1 : o_data = 4'd4;\n        6'b1_0110_1 : o_data = 4'd10;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd9;\n        6'b1_1001_1 : o_data = 4'd5;\n        6'b1_1010_1 : o_data = 4'd0;\n        6'b1_1011_1 : o_data = 4'd15;\n        6'b1_1100_1 : o_data = 4'd14;\n        6'b1_1101_1 : o_data = 4'd2;\n        6'b1_1110_1 : o_data = 4'd3;\n        6'b1_1111_1 : o_data = 4'd12;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S7", "rtl/S8.sv": "module S8(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd13;\n        6'b0_0001_0 : o_data = 4'd2;\n        6'b0_0010_0 : o_data = 4'd8;\n        6'b0_0011_0 : o_data = 4'd4;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd15;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd1;\n        6'b0_1000_0 : o_data = 4'd10;\n        6'b0_1001_0 : o_data = 4'd9;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd14;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd12;\n        6'b0_1111_0 : o_data = 4'd7;\n        6'b0_0000_1 : o_data = 4'd1;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd13;\n        6'b0_0011_1 : o_data = 4'd8;\n        6'b0_0100_1 : o_data = 4'd10;\n        6'b0_0101_1 : o_data = 4'd3;\n        6'b0_0110_1 : o_data = 4'd7;\n        6'b0_0111_1 : o_data = 4'd4;\n        6'b0_1000_1 : o_data = 4'd12;\n        6'b0_1001_1 : o_data = 4'd5;\n        6'b0_1010_1 : o_data = 4'd6;\n        6'b0_1011_1 : o_data = 4'd11;\n        6'b0_1100_1 : o_data = 4'd0;\n        6'b0_1101_1 : o_data = 4'd14;\n        6'b0_1110_1 : o_data = 4'd9;\n        6'b0_1111_1 : o_data = 4'd2;\n        6'b1_0000_0 : o_data = 4'd7;\n        6'b1_0001_0 : o_data = 4'd11;\n        6'b1_0010_0 : o_data = 4'd4;\n        6'b1_0011_0 : o_data = 4'd1;\n        6'b1_0100_0 : o_data = 4'd9;\n        6'b1_0101_0 : o_data = 4'd12;\n        6'b1_0110_0 : o_data = 4'd14;\n        6'b1_0111_0 : o_data = 4'd2;\n        6'b1_1000_0 : o_data = 4'd0;\n        6'b1_1001_0 : o_data = 4'd6;\n        6'b1_1010_0 : o_data = 4'd10;\n        6'b1_1011_0 : o_data = 4'd13;\n        6'b1_1100_0 : o_data = 4'd15;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd5;\n        6'b1_1111_0 : o_data = 4'd8;\n        6'b1_0000_1 : o_data = 4'd2;\n        6'b1_0001_1 : o_data = 4'd1;\n        6'b1_0010_1 : o_data = 4'd14;\n        6'b1_0011_1 : o_data = 4'd7;\n        6'b1_0100_1 : o_data = 4'd4;\n        6'b1_0101_1 : o_data = 4'd10;\n        6'b1_0110_1 : o_data = 4'd8;\n        6'b1_0111_1 : o_data = 4'd13;\n        6'b1_1000_1 : o_data = 4'd15;\n        6'b1_1001_1 : o_data = 4'd12;\n        6'b1_1010_1 : o_data = 4'd9;\n        6'b1_1011_1 : o_data = 4'd0;\n        6'b1_1100_1 : o_data = 4'd3;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd6;\n        6'b1_1111_1 : o_data = 4'd11;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S8", "rtl/des_enc.sv": "module des_enc #(\n    parameter NBW_DATA = 'd64,\n    parameter NBW_KEY  = 'd64\n) (\n    input  logic              clk,\n    input  logic              rst_async_n,\n    input  logic              i_valid,\n    input  logic [1:NBW_DATA] i_data,\n    input  logic [1:NBW_KEY]  i_key,\n    output logic              o_valid,\n    output logic [1:NBW_DATA] o_data\n);\n\nlocalparam ROUNDS = 'd16;\nlocalparam EXPANDED_BLOCK = 'd48;\nlocalparam USED_KEY = 'd56;\n\nlogic [1:NBW_DATA]     IP;\nlogic [1:(NBW_DATA/2)] L0;\nlogic [1:(NBW_DATA/2)] R0;\nlogic [1:(NBW_DATA/2)] L_ff [1:ROUNDS];\nlogic [1:(NBW_DATA/2)] R_ff [1:ROUNDS];\nlogic [1:(USED_KEY/2)] C0;\nlogic [1:(USED_KEY/2)] D0;\nlogic [1:(USED_KEY/2)] C_ff [1:ROUNDS];\nlogic [1:(USED_KEY/2)] D_ff [1:ROUNDS];\nlogic [1:NBW_DATA]     last_perm;\nlogic [ROUNDS-1:0]     valid_ff;\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        valid_ff <= 0;\n    end else begin\n        valid_ff <= {valid_ff[ROUNDS-2:0], i_valid};\n    end\nend\n\nassign o_valid = valid_ff[ROUNDS-1];\n\nassign IP = {i_data[58], i_data[50], i_data[42], i_data[34], i_data[26], i_data[18], i_data[10], i_data[2],\n             i_data[60], i_data[52], i_data[44], i_data[36], i_data[28], i_data[20], i_data[12], i_data[4],\n             i_data[62], i_data[54], i_data[46], i_data[38], i_data[30], i_data[22], i_data[14], i_data[6],\n             i_data[64], i_data[56], i_data[48], i_data[40], i_data[32], i_data[24], i_data[16], i_data[8],\n             i_data[57], i_data[49], i_data[41], i_data[33], i_data[25], i_data[17], i_data[ 9], i_data[1],\n             i_data[59], i_data[51], i_data[43], i_data[35], i_data[27], i_data[19], i_data[11], i_data[3],\n             i_data[61], i_data[53], i_data[45], i_data[37], i_data[29], i_data[21], i_data[13], i_data[5],\n             i_data[63], i_data[55], i_data[47], i_data[39], i_data[31], i_data[23], i_data[15], i_data[7]};\n\nassign L0 = IP[1:NBW_DATA/2];\nassign R0 = IP[(NBW_DATA/2)+1:NBW_DATA];\n\nassign C0 = {i_key[57], i_key[49], i_key[41], i_key[33], i_key[25], i_key[17], i_key[ 9],\n             i_key[ 1], i_key[58], i_key[50], i_key[42], i_key[34], i_key[26], i_key[18],\n             i_key[10], i_key[ 2], i_key[59], i_key[51], i_key[43], i_key[35], i_key[27],\n             i_key[19], i_key[11], i_key[ 3], i_key[60], i_key[52], i_key[44], i_key[36]};\n\nassign D0 = {i_key[63], i_key[55], i_key[47], i_key[39], i_key[31], i_key[23], i_key[15],\n             i_key[ 7], i_key[62], i_key[54], i_key[46], i_key[38], i_key[30], i_key[22],\n             i_key[14], i_key[ 6], i_key[61], i_key[53], i_key[45], i_key[37], i_key[29],\n             i_key[21], i_key[13], i_key[ 5], i_key[28], i_key[20], i_key[12], i_key[ 4]};\n\ngenerate\n    for (genvar i = 1; i <= ROUNDS; i++) begin : rounds\n        logic [1:EXPANDED_BLOCK] round_key;\n        logic [1:(USED_KEY/2)]    C_nx;\n        logic [1:(USED_KEY/2)]    D_nx;\n        logic [1:USED_KEY]        perm_ch;\n        logic [1:(NBW_DATA/2)] R_nx;\n        logic [1:EXPANDED_BLOCK] R_expanded;\n        logic [1:6] Primitive_input  [1:8];\n        logic [1:4] Primitive_output [1:8];\n        logic [1:(NBW_DATA/2)] perm_in;\n\n        assign perm_ch = {C_nx, D_nx};\n        assign round_key = {perm_ch[14], perm_ch[17], perm_ch[11], perm_ch[24], perm_ch[ 1], perm_ch[ 5],\n                            perm_ch[ 3], perm_ch[28], perm_ch[15], perm_ch[ 6], perm_ch[21], perm_ch[10],\n                            perm_ch[23], perm_ch[19], perm_ch[12], perm_ch[ 4], perm_ch[26], perm_ch[ 8],\n                            perm_ch[16], perm_ch[ 7], perm_ch[27], perm_ch[20], perm_ch[13], perm_ch[ 2],\n                            perm_ch[41], perm_ch[52], perm_ch[31], perm_ch[37], perm_ch[47], perm_ch[55],\n                            perm_ch[30], perm_ch[40], perm_ch[51], perm_ch[45], perm_ch[33], perm_ch[48],\n                            perm_ch[44], perm_ch[49], perm_ch[39], perm_ch[56], perm_ch[34], perm_ch[53],\n                            perm_ch[46], perm_ch[42], perm_ch[50], perm_ch[36], perm_ch[29], perm_ch[32]};\n\n        if(i == 1 || i == 2 || i == 9 || i == 16) begin\n            if(i == 1) begin\n                assign C_nx = {C0[2:(USED_KEY/2)], C0[1]};\n                assign D_nx = {D0[2:(USED_KEY/2)], D0[1]};\n            end else begin\n                assign C_nx = {C_ff[i-1][2:(USED_KEY/2)], C_ff[i-1][1]};\n                assign D_nx = {D_ff[i-1][2:(USED_KEY/2)], D_ff[i-1][1]};\n            end\n        end else begin\n            assign C_nx = {C_ff[i-1][3:(USED_KEY/2)], C_ff[i-1][1:2]};\n            assign D_nx = {D_ff[i-1][3:(USED_KEY/2)], D_ff[i-1][1:2]};\n        end\n\n        assign Primitive_input[1] = R_expanded[ 1:6 ] ^ round_key[ 1:6 ];\n        assign Primitive_input[2] = R_expanded[ 7:12] ^ round_key[ 7:12];\n        assign Primitive_input[3] = R_expanded[13:18] ^ round_key[13:18];\n        assign Primitive_input[4] = R_expanded[19:24] ^ round_key[19:24];\n        assign Primitive_input[5] = R_expanded[25:30] ^ round_key[25:30];\n        assign Primitive_input[6] = R_expanded[31:36] ^ round_key[31:36];\n        assign Primitive_input[7] = R_expanded[37:42] ^ round_key[37:42];\n        assign Primitive_input[8] = R_expanded[43:48] ^ round_key[43:48];\n\n        S1 uu_S1 (\n            .i_data(Primitive_input [1]),\n            .o_data(Primitive_output[1])\n        );\n\n        S2 uu_S2 (\n            .i_data(Primitive_input [2]),\n            .o_data(Primitive_output[2])\n        );\n\n        S3 uu_S3 (\n            .i_data(Primitive_input [3]),\n            .o_data(Primitive_output[3])\n        );\n\n        S4 uu_S4 (\n            .i_data(Primitive_input [4]),\n            .o_data(Primitive_output[4])\n        );\n\n        S5 uu_S5 (\n            .i_data(Primitive_input [5]),\n            .o_data(Primitive_output[5])\n        );\n\n        S6 uu_S6 (\n            .i_data(Primitive_input [6]),\n            .o_data(Primitive_output[6])\n        );\n\n        S7 uu_S7 (\n            .i_data(Primitive_input [7]),\n            .o_data(Primitive_output[7])\n        );\n\n        S8 uu_S8 (\n            .i_data(Primitive_input [8]),\n            .o_data(Primitive_output[8])\n        );\n\n        assign perm_in = {Primitive_output[1], Primitive_output[2], Primitive_output[3], Primitive_output[4],\n                          Primitive_output[5], Primitive_output[6], Primitive_output[7], Primitive_output[8]};\n\n        assign R_nx = {perm_in[16], perm_in[ 7], perm_in[20], perm_in[21],\n                       perm_in[29], perm_in[12], perm_in[28], perm_in[17],\n                       perm_in[ 1], perm_in[15], perm_in[23], perm_in[26],\n                       perm_in[ 5], perm_in[18], perm_in[31], perm_in[10],\n                       perm_in[ 2], perm_in[ 8], perm_in[24], perm_in[14],\n                       perm_in[32], perm_in[27], perm_in[ 3], perm_in[ 9],\n                       perm_in[19], perm_in[13], perm_in[30], perm_in[ 6],\n                       perm_in[22], perm_in[11], perm_in[ 4], perm_in[25]};\n\n        if(i == 1) begin\n            assign R_expanded = {R0[32], R0[ 1], R0[ 2], R0[ 3], R0[ 4], R0[ 5],\n                                 R0[ 4], R0[ 5], R0[ 6], R0[ 7], R0[ 8], R0[ 9],\n                                 R0[ 8], R0[ 9], R0[10], R0[11], R0[12], R0[13],\n                                 R0[12], R0[13], R0[14], R0[15], R0[16], R0[17],\n                                 R0[16], R0[17], R0[18], R0[19], R0[20], R0[21],\n                                 R0[20], R0[21], R0[22], R0[23], R0[24], R0[25],\n                                 R0[24], R0[25], R0[26], R0[27], R0[28], R0[29],\n                                 R0[28], R0[29], R0[30], R0[31], R0[32], R0[ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    if(i_valid) begin\n                        L_ff[i] <= R0;\n                        R_ff[i] <= R_nx ^ L0;\n                        C_ff[i] <= C_nx;\n                        D_ff[i] <= D_nx;\n                    end\n                end\n            end\n        end else begin\n            assign R_expanded = {R_ff[i-1][32], R_ff[i-1][ 1], R_ff[i-1][ 2], R_ff[i-1][ 3], R_ff[i-1][ 4], R_ff[i-1][ 5],\n                                 R_ff[i-1][ 4], R_ff[i-1][ 5], R_ff[i-1][ 6], R_ff[i-1][ 7], R_ff[i-1][ 8], R_ff[i-1][ 9],\n                                 R_ff[i-1][ 8], R_ff[i-1][ 9], R_ff[i-1][10], R_ff[i-1][11], R_ff[i-1][12], R_ff[i-1][13],\n                                 R_ff[i-1][12], R_ff[i-1][13], R_ff[i-1][14], R_ff[i-1][15], R_ff[i-1][16], R_ff[i-1][17],\n                                 R_ff[i-1][16], R_ff[i-1][17], R_ff[i-1][18], R_ff[i-1][19], R_ff[i-1][20], R_ff[i-1][21],\n                                 R_ff[i-1][20], R_ff[i-1][21], R_ff[i-1][22], R_ff[i-1][23], R_ff[i-1][24], R_ff[i-1][25],\n                                 R_ff[i-1][24], R_ff[i-1][25], R_ff[i-1][26], R_ff[i-1][27], R_ff[i-1][28], R_ff[i-1][29],\n                                 R_ff[i-1][28], R_ff[i-1][29], R_ff[i-1][30], R_ff[i-1][31], R_ff[i-1][32], R_ff[i-1][ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    L_ff[i] <= R_ff[i-1];\n                    R_ff[i] <= R_nx ^ L_ff[i-1];\n                    C_ff[i] <= C_nx;\n                    D_ff[i] <= D_nx;\n                end\n            end\n        end\n    end\nendgenerate\n\nassign last_perm = {R_ff[ROUNDS], L_ff[ROUNDS]};\n\nassign o_data = {last_perm[40], last_perm[8], last_perm[48], last_perm[16], last_perm[56], last_perm[24], last_perm[64], last_perm[32],\n                 last_perm[39], last_perm[7], last_perm[47], last_perm[15], last_perm[55], last_perm[23], last_perm[63], last_perm[31],\n                 last_perm[38], last_perm[6], last_perm[46], last_perm[14], last_perm[54], last_perm[22], last_perm[62], last_perm[30],\n                 last_perm[37], last_perm[5], last_perm[45], last_perm[13], last_perm[53], last_perm[21], last_perm[61], last_perm[29],\n                 last_perm[36], last_perm[4], last_perm[44], last_perm[12], last_perm[52], last_perm[20], last_perm[60], last_perm[28],\n                 last_perm[35], last_perm[3], last_perm[43], last_perm[11], last_perm[51], last_perm[19], last_perm[59], last_perm[27],\n                 last_perm[34], last_perm[2], last_perm[42], last_perm[10], last_perm[50], last_perm[18], last_perm[58], last_perm[26],\n                 last_perm[33], last_perm[1], last_perm[41], last_perm[ 9], last_perm[49], last_perm[17], last_perm[57], last_perm[25]};\n\nendmodule : des_enc", "verif/tb_des_dec.sv": "module tb;\n\nparameter NBW_DATA = 'd64;\nparameter NBW_KEY  = 'd64;\n\nlogic              clk;\nlogic              rst_async_n;\nlogic              i_valid;\nlogic [1:NBW_DATA] i_data;\nlogic [1:NBW_KEY ] i_key;\nlogic              o_valid;\nlogic [1:NBW_DATA] o_data;\n\ndes_dec #(\n    .NBW_DATA(NBW_DATA),\n    .NBW_KEY (NBW_KEY )\n) uu_des_dec (\n    .clk        (clk        ),\n    .rst_async_n(rst_async_n),\n    .i_valid    (i_valid    ),\n    .i_data     (i_data     ),\n    .i_key      (i_key      ),\n    .o_valid    (o_valid    ),\n    .o_data     (o_data     )\n);\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb);\nend\n\nalways #5 clk = ~clk;\n\ntask Single_test(logic [1:NBW_KEY] key, logic [1:NBW_DATA] data, logic [1:NBW_DATA] expected);\n    i_key   = key;\n    i_data  = data;\n    i_valid = 1;\n\n    @(negedge clk);\n    i_valid = 0;\n\n    @(posedge o_valid);\n    @(negedge clk);\n    if(o_data != expected) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", expected, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\nendtask\n\ntask Burst_test();\n    i_key   = 64'hB1FECAFEBEBAB1FE;\n    i_data  = 64'h6B85F162427F0DC8;\n    i_valid = 1;\n\n    @(negedge clk);\n    i_data  = 64'hB02273A3AD757BDA;\n\n    @(negedge clk);\n    i_data  = 64'h87C952860A802C4B;\n    i_key   = 64'hABCDABCDABCDABCD;\n\n    @(negedge clk);\n    i_valid = 0;\n\n    @(posedge o_valid);\n    @(negedge clk);\n    if(o_data != 64'h4321432143214321) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h4321432143214321, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n\n    @(negedge clk);\n    if(o_valid != 1) begin\n        $display(\"FAIL! o_valid should be asserted here.\");\n    end\n    if(o_data != 64'h123456789ABCDEF0) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h123456789ABCDEF0, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n\n    @(negedge clk);\n    if(o_valid != 1) begin\n        $display(\"FAIL! o_valid should be asserted here.\");\n    end\n    if(o_data != 64'h1234123412341234) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h1234123412341234, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n    \nendtask\n\ninitial begin\n    clk = 0;\n    i_valid = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    $display(\"\\nSingle Tests\");\n    Single_test(64'h0123456789ABCDEF, 64'h56CC09E7CFDC4CEF, 64'h0123456789ABCDEF);\n    Single_test(64'h0123456789ABCDEF, 64'h12C626AF058B433B, 64'hFEDCBA9876543210);\n    Single_test(64'hBEBACAFE12345678, 64'h00D97727C293BFAC, 64'hFEDCBA9876543210);\n    Single_test(64'hBEBACAFE12345678, 64'h31F3FE80E9457BED, 64'hB1FECAFEBEBAB1FE);\n\n    $display(\"\\nBurst Test\");\n    Burst_test();\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule", "docs/Encryption.md": "## DES Encryption\n\nIn the description of this algorithm, the first `n` bits of a value declared as [1:NBW] are `1, 2, 3, ... , n-1, n`, and the last `n` bits are `NBW-(n-1), NBW-(n-2), ... , NBW-1, NBW`.\n\nThe **DES** encryption operation is divided in four steps:\n\n### 1. Initial Permutation (IP)\n\nThe 64-bit input block undergoes a fixed initial permutation. The description for this step is available at the \"Permutations.md\" file.\n\nThe first 32 bits are stored in $`L_0`$ and the last 32 bits in $`R_0`$.\n\n### 2. Key Schedule\n\n- The 64-bit input key is reduced to 56 bits via a **parity drop**.\n- It is then split into two 28-bit halves.\n- Each half is rotated left based on a fixed schedule per round.\n- A **PC-2** permutation compresses the result to 48-bit round keys (`K1` to `K16`).\n\nThe \"Key_schedule.md\" file describes this operation in more detail.\n\n### 3. Feistel Rounds\n\nEach of the 16 rounds updates the left and right halves as follows:\n\n$`L_n = R_{n-1}`$\n\n$`R_n = L_{n-1} \u2295 F(R_{n-1}, K_n)`$\n\nWhere `F` is the round function consisting of:\n\n- **Expansion (E)**: Expands 32-bit R to 48 bits using a fixed table. Described in the \"Permutations.md\" file.\n- **Key Mixing**: Uses the expanded value from the **Expansion (E)** operation and XORs it with the 48-bit round key $`K_n`$.\n- **S-box Substitution**: 48 bits are split into 8 groups of 6 bits, passed through S-boxes S1\u2013S8. Each S-box is a 4x16 table (64 entries) mapping a 6-bit input to a 4-bit output.\n- **Permutation (P)**: 32-bit output of S-boxes is permuted via a fixed permutation. Described in the \"Permutations.md\" file.\n\n### 4. Final Permutation (FP)\n\nAfter the 16th round, the L and R halves are concatenated in reverse order and passed through the **Final Permutation**, which is the inverse of IP. This concatenation is described in the \"Permutations.md\" file."}, "patch": {"rtl/des_dec.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n", "src/.env": "VERILOG_SOURCES = /code/rtl/des_dec.sv /code/rtl/S1.sv /code/rtl/S2.sv /code/rtl/S3.sv /code/rtl/S4.sv /code/rtl/S5.sv /code/rtl/S6.sv /code/rtl/S7.sv /code/rtl/S8.sv\nTOPLEVEL        = des_dec\nMODULE          = test_des_dec\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 3-create-des-dec\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass des:\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.data_out = 0\n        self.fifo = []\n\n    def permute(self, block, table, n):\n        result = 0\n        for i in range(len(table)):\n            bit = (block >> (n - table[i])) & 1\n            result |= (bit << (len(table) - 1 - i))\n        return result\n\n    def left_rotate(self, val, n):\n        return ((val << n) & 0x0FFFFFFF) | (val >> (28 - n))\n\n    def sbox(self, box, val):\n        row = ((val >> 5) & 1) * 2 + (val & 1)\n        col = (val >> 1) & 0xF\n        return box[row][col]\n\n    def f(self, R, subkey):\n        E = [32,1,2,3,4,5,4,5,6,7,8,9,\n             8,9,10,11,12,13,12,13,14,15,16,17,\n             16,17,18,19,20,21,20,21,22,23,24,25,\n             24,25,26,27,28,29,28,29,30,31,32,1]\n\n        P = [16,7,20,21,29,12,28,17,\n             1,15,23,26,5,18,31,10,\n             2,8,24,14,32,27,3,9,\n             19,13,30,6,22,11,4,25]\n\n        SBOXES = self.sboxes\n\n        expanded = self.permute(R << 32, E, 64)\n        xored = expanded ^ subkey\n\n        output = 0\n        for i in range(8):\n            chunk = (xored >> (42 - i*6)) & 0x3F\n            sbox_val = self.sbox(SBOXES[i], chunk)\n            output = (output << 4) | sbox_val\n\n        return self.permute(output << 32, P, 64)\n\n    def generate_subkeys(self, key):\n        PC1 = [57,49,41,33,25,17,9,\n               1,58,50,42,34,26,18,\n               10,2,59,51,43,35,27,\n               19,11,3,60,52,44,36,\n               63,55,47,39,31,23,15,\n               7,62,54,46,38,30,22,\n               14,6,61,53,45,37,29,\n               21,13,5,28,20,12,4]\n\n        PC2 = [14,17,11,24,1,5,\n               3,28,15,6,21,10,\n               23,19,12,4,26,8,\n               16,7,27,20,13,2,\n               41,52,31,37,47,55,\n               30,40,51,45,33,48,\n               44,49,39,56,34,53,\n               46,42,50,36,29,32]\n\n        rotations = [1, 1, 2, 2, 2, 2, 2, 2,\n                     1, 2, 2, 2, 2, 2, 2, 1]\n\n        key56 = self.permute(key, PC1, 64)\n        C = (key56 >> 28) & 0xFFFFFFF\n        D = key56 & 0xFFFFFFF\n\n        subkeys = []\n        for rot in rotations:\n            C = self.left_rotate(C, rot)\n            D = self.left_rotate(D, rot)\n            CD = (C << 28) | D\n            subkey = self.permute(CD, PC2, 56)\n            subkeys.append(subkey)\n        return subkeys\n    \n    def decrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)[::-1]  # Reverse subkeys for decryption\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.data_out = self.permute(pre_output, FP, 64)\n        self.fifo.append(self.data_out)\n\n    def encrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.data_out = self.permute(pre_output, FP, 64)\n        self.fifo.append(self.data_out)\n    \n    def read_data(self):\n        if self.fifo:\n            return self.fifo.pop(0)\n        return 0\n\n    # Full DES S-box definitions\n    sboxes = [\n        [\n            [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n            [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n            [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n            [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13]\n        ],\n        [\n            [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10],\n            [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5],\n            [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15],\n            [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9]\n        ],\n        [\n            [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8],\n            [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1],\n            [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7],\n            [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12]\n        ],\n        [\n            [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15],\n            [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9],\n            [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4],\n            [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14]\n        ],\n        [\n            [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9],\n            [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6],\n            [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14],\n            [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3]\n        ],\n        [\n            [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11],\n            [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8],\n            [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6],\n            [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13]\n        ],\n        [\n            [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1],\n            [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6],\n            [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2],\n            [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12]\n        ],\n        [\n            [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7],\n            [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2],\n            [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8],\n            [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]\n        ]\n    ]\n", "src/test_des_dec.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data   = dut.o_data.value.to_unsigned()\n    model_data = model.read_data()\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_des_dec(dut):\n    \"\"\"Test the des_dec module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n\n    model = hrs_lb.des()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**64 - 1\n\n    key_min  = 0\n    key_max  = 2**64 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_valid.value     = 0\n        dut.i_data.value      = 0\n        dut.i_key.value       = 0\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        # Latency check\n        key   = random.randint(key_min , key_max )\n        data  = random.randint(data_min, data_max)\n        valid = 1\n\n        await FallingEdge(dut.clk)\n        dut.i_data.value  = data\n        dut.i_key.value   = key\n        dut.i_valid.value = valid\n\n        model.decrypt(data, key)\n        await FallingEdge(dut.clk)\n        latency_counter = 1\n        dut.i_valid.value = 0\n\n        while dut.o_valid.value == 0:\n            latency_counter = latency_counter + 1\n            await FallingEdge(dut.clk)\n        \n        assert latency_counter == 16, f\"[ERROR] DUT latency must be 16 clock cycles\"\n        \n        compare_values(dut, model)\n\n        for j in range(runs):\n            if (j+1)%500 == 0:\n                print(f'\\n------ Reset {i}, run {j+1} ------')\n\n            key   = random.randint(key_min , key_max )\n            data  = random.randint(data_min, data_max)\n            valid = random.randint(0,1)\n\n            await FallingEdge(dut.clk)\n\n            dut.i_data.value  = data\n            dut.i_key.value   = key\n            dut.i_valid.value = valid\n            if valid:\n                model.decrypt(data, key)\n\n            if dut.o_valid.value == 1:\n                compare_values(dut, model)\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()"}}
{"id": "cvdp_agentic_meadow_marble_castle_0301", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "Integrate the `des_enc` and `des_dec` modules to perform the Triple Data Encryption Standard (TDES) encryption. This new module must allow burst operation, where in multiple cycles in a row the valid signal can be asserted with a new data and a new key. No changes are required in any of the RTLs provided. A testbench for this module is available at `verif/tb_3des_enc.sv`.\n\n---\n\n## Specifications\n\n- **Module Name**: `des3_enc`\n\n- **File Name**: `des3_enc.sv` (to be added in `rtl` directory)\n\n- **Parameters**:\n    - `NBW_DATA`: Bit width of the input and output data blocks.\n        - Default: 64.\n        - Related interface signals: `i_data`, `o_data`.\n    - `NBW_KEY`: Bit width of the key.\n        - Default: 192.\n        - Related interface signal: `i_key`.  \n        - The 192-bit key is interpreted as three concatenated 64-bit DES keys (K1, K2, K3) used for Triple DES encryption, where `K1 = i_key[1:64]`, K2 = `i_key[65:128]`, and `K3 = i_key[129:192]`.\n\n- **Functionality**: Implements 3DES encryption in EDE (Encrypt-Decrypt-Encrypt) mode using three 64-bit keys (K1, K2, K3). The input plaintext is encrypted with K1, decrypted with K2, and encrypted again with K3.\n\n- **Latency**: The block's latency, from when `i_valid` is read until `o_valid` is asserted, is **48 cycles**, where each DES stage takes 16 cycles and the process is fully pipelined.\n\n---\n\n## Interface Signals\n\n  | Signal              | Direction | Width            | Description                                                                                                              |\n  |---------------------|-----------|------------------|---------------------------------------------------------------------------------------------------------------------     |\n  | `clk`               | Input     | 1                | Drives the sequential logic on the rising edge.                                                                          |\n  | `rst_async_n`       | Input     | 1                | Active-low asynchronous reset; clears all internal registers and state.                                                  |\n  | `i_valid`           | Input     | 1                | Active high. Indicates that `i_data` and `i_key` are valid and ready to be processed.                                    |\n  | `i_data`            | Input     | [1:NBW_DATA]     | 64-bit plaintext input block (MSB-first).                                                                                |\n  | `i_key`             | Input     | [1:NBW_KEY]      | 192-bit 3DES key, treated as three concatenated 64-bit keys: `{K1, K2, K3}`.                                             |\n  | `o_valid`           | Output    | 1                | Asserted high when `o_data` contains valid encrypted data. It is asserted for as many cycles as `i_valid` is asserted.   |\n  | `o_data`            | Output    | [1:NBW_DATA]     | 64-bit ciphertext output block (MSB-first).                                                                              |\n\n", "context": {"rtl/S1.sv": "module S1(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd14;\n        6'b0_0001_0 : o_data = 4'd4;\n        6'b0_0010_0 : o_data = 4'd13;\n        6'b0_0011_0 : o_data = 4'd1;\n        6'b0_0100_0 : o_data = 4'd2;\n        6'b0_0101_0 : o_data = 4'd15;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd8;\n        6'b0_1000_0 : o_data = 4'd3;\n        6'b0_1001_0 : o_data = 4'd10;\n        6'b0_1010_0 : o_data = 4'd6;\n        6'b0_1011_0 : o_data = 4'd12;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd9;\n        6'b0_1110_0 : o_data = 4'd0;\n        6'b0_1111_0 : o_data = 4'd7;\n        6'b0_0000_1 : o_data = 4'd0;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd7;\n        6'b0_0011_1 : o_data = 4'd4;\n        6'b0_0100_1 : o_data = 4'd14;\n        6'b0_0101_1 : o_data = 4'd2;\n        6'b0_0110_1 : o_data = 4'd13;\n        6'b0_0111_1 : o_data = 4'd1;\n        6'b0_1000_1 : o_data = 4'd10;\n        6'b0_1001_1 : o_data = 4'd6;\n        6'b0_1010_1 : o_data = 4'd12;\n        6'b0_1011_1 : o_data = 4'd11;\n        6'b0_1100_1 : o_data = 4'd9;\n        6'b0_1101_1 : o_data = 4'd5;\n        6'b0_1110_1 : o_data = 4'd3;\n        6'b0_1111_1 : o_data = 4'd8;\n        6'b1_0000_0 : o_data = 4'd4;\n        6'b1_0001_0 : o_data = 4'd1;\n        6'b1_0010_0 : o_data = 4'd14;\n        6'b1_0011_0 : o_data = 4'd8;\n        6'b1_0100_0 : o_data = 4'd13;\n        6'b1_0101_0 : o_data = 4'd6;\n        6'b1_0110_0 : o_data = 4'd2;\n        6'b1_0111_0 : o_data = 4'd11;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd12;\n        6'b1_1010_0 : o_data = 4'd9;\n        6'b1_1011_0 : o_data = 4'd7;\n        6'b1_1100_0 : o_data = 4'd3;\n        6'b1_1101_0 : o_data = 4'd10;\n        6'b1_1110_0 : o_data = 4'd5;\n        6'b1_1111_0 : o_data = 4'd0;\n        6'b1_0000_1 : o_data = 4'd15;\n        6'b1_0001_1 : o_data = 4'd12;\n        6'b1_0010_1 : o_data = 4'd8;\n        6'b1_0011_1 : o_data = 4'd2;\n        6'b1_0100_1 : o_data = 4'd4;\n        6'b1_0101_1 : o_data = 4'd9;\n        6'b1_0110_1 : o_data = 4'd1;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd5;\n        6'b1_1001_1 : o_data = 4'd11;\n        6'b1_1010_1 : o_data = 4'd3;\n        6'b1_1011_1 : o_data = 4'd14;\n        6'b1_1100_1 : o_data = 4'd10;\n        6'b1_1101_1 : o_data = 4'd0;\n        6'b1_1110_1 : o_data = 4'd6;\n        6'b1_1111_1 : o_data = 4'd13;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S1", "rtl/S2.sv": "module S2(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd15;\n        6'b0_0001_0 : o_data = 4'd1;\n        6'b0_0010_0 : o_data = 4'd8;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd11;\n        6'b0_0110_0 : o_data = 4'd3;\n        6'b0_0111_0 : o_data = 4'd4;\n        6'b0_1000_0 : o_data = 4'd9;\n        6'b0_1001_0 : o_data = 4'd7;\n        6'b0_1010_0 : o_data = 4'd2;\n        6'b0_1011_0 : o_data = 4'd13;\n        6'b0_1100_0 : o_data = 4'd12;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd5;\n        6'b0_1111_0 : o_data = 4'd10;\n        6'b0_0000_1 : o_data = 4'd3;\n        6'b0_0001_1 : o_data = 4'd13;\n        6'b0_0010_1 : o_data = 4'd4;\n        6'b0_0011_1 : o_data = 4'd7;\n        6'b0_0100_1 : o_data = 4'd15;\n        6'b0_0101_1 : o_data = 4'd2;\n        6'b0_0110_1 : o_data = 4'd8;\n        6'b0_0111_1 : o_data = 4'd14;\n        6'b0_1000_1 : o_data = 4'd12;\n        6'b0_1001_1 : o_data = 4'd0;\n        6'b0_1010_1 : o_data = 4'd1;\n        6'b0_1011_1 : o_data = 4'd10;\n        6'b0_1100_1 : o_data = 4'd6;\n        6'b0_1101_1 : o_data = 4'd9;\n        6'b0_1110_1 : o_data = 4'd11;\n        6'b0_1111_1 : o_data = 4'd5;\n        6'b1_0000_0 : o_data = 4'd0;\n        6'b1_0001_0 : o_data = 4'd14;\n        6'b1_0010_0 : o_data = 4'd7;\n        6'b1_0011_0 : o_data = 4'd11;\n        6'b1_0100_0 : o_data = 4'd10;\n        6'b1_0101_0 : o_data = 4'd4;\n        6'b1_0110_0 : o_data = 4'd13;\n        6'b1_0111_0 : o_data = 4'd1;\n        6'b1_1000_0 : o_data = 4'd5;\n        6'b1_1001_0 : o_data = 4'd8;\n        6'b1_1010_0 : o_data = 4'd12;\n        6'b1_1011_0 : o_data = 4'd6;\n        6'b1_1100_0 : o_data = 4'd9;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd2;\n        6'b1_1111_0 : o_data = 4'd15;\n        6'b1_0000_1 : o_data = 4'd13;\n        6'b1_0001_1 : o_data = 4'd8;\n        6'b1_0010_1 : o_data = 4'd10;\n        6'b1_0011_1 : o_data = 4'd1;\n        6'b1_0100_1 : o_data = 4'd3;\n        6'b1_0101_1 : o_data = 4'd15;\n        6'b1_0110_1 : o_data = 4'd4;\n        6'b1_0111_1 : o_data = 4'd2;\n        6'b1_1000_1 : o_data = 4'd11;\n        6'b1_1001_1 : o_data = 4'd6;\n        6'b1_1010_1 : o_data = 4'd7;\n        6'b1_1011_1 : o_data = 4'd12;\n        6'b1_1100_1 : o_data = 4'd0;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd14;\n        6'b1_1111_1 : o_data = 4'd9;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S2", "rtl/S3.sv": "module S3(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd10;\n        6'b0_0001_0 : o_data = 4'd0;\n        6'b0_0010_0 : o_data = 4'd9;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd3;\n        6'b0_0110_0 : o_data = 4'd15;\n        6'b0_0111_0 : o_data = 4'd5;\n        6'b0_1000_0 : o_data = 4'd1;\n        6'b0_1001_0 : o_data = 4'd13;\n        6'b0_1010_0 : o_data = 4'd12;\n        6'b0_1011_0 : o_data = 4'd7;\n        6'b0_1100_0 : o_data = 4'd11;\n        6'b0_1101_0 : o_data = 4'd4;\n        6'b0_1110_0 : o_data = 4'd2;\n        6'b0_1111_0 : o_data = 4'd8;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd7;\n        6'b0_0010_1 : o_data = 4'd0;\n        6'b0_0011_1 : o_data = 4'd9;\n        6'b0_0100_1 : o_data = 4'd3;\n        6'b0_0101_1 : o_data = 4'd4;\n        6'b0_0110_1 : o_data = 4'd6;\n        6'b0_0111_1 : o_data = 4'd10;\n        6'b0_1000_1 : o_data = 4'd2;\n        6'b0_1001_1 : o_data = 4'd8;\n        6'b0_1010_1 : o_data = 4'd5;\n        6'b0_1011_1 : o_data = 4'd14;\n        6'b0_1100_1 : o_data = 4'd12;\n        6'b0_1101_1 : o_data = 4'd11;\n        6'b0_1110_1 : o_data = 4'd15;\n        6'b0_1111_1 : o_data = 4'd1;\n        6'b1_0000_0 : o_data = 4'd13;\n        6'b1_0001_0 : o_data = 4'd6;\n        6'b1_0010_0 : o_data = 4'd4;\n        6'b1_0011_0 : o_data = 4'd9;\n        6'b1_0100_0 : o_data = 4'd8;\n        6'b1_0101_0 : o_data = 4'd15;\n        6'b1_0110_0 : o_data = 4'd3;\n        6'b1_0111_0 : o_data = 4'd0;\n        6'b1_1000_0 : o_data = 4'd11;\n        6'b1_1001_0 : o_data = 4'd1;\n        6'b1_1010_0 : o_data = 4'd2;\n        6'b1_1011_0 : o_data = 4'd12;\n        6'b1_1100_0 : o_data = 4'd5;\n        6'b1_1101_0 : o_data = 4'd10;\n        6'b1_1110_0 : o_data = 4'd14;\n        6'b1_1111_0 : o_data = 4'd7;\n        6'b1_0000_1 : o_data = 4'd1;\n        6'b1_0001_1 : o_data = 4'd10;\n        6'b1_0010_1 : o_data = 4'd13;\n        6'b1_0011_1 : o_data = 4'd0;\n        6'b1_0100_1 : o_data = 4'd6;\n        6'b1_0101_1 : o_data = 4'd9;\n        6'b1_0110_1 : o_data = 4'd8;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd4;\n        6'b1_1001_1 : o_data = 4'd15;\n        6'b1_1010_1 : o_data = 4'd14;\n        6'b1_1011_1 : o_data = 4'd3;\n        6'b1_1100_1 : o_data = 4'd11;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd2;\n        6'b1_1111_1 : o_data = 4'd12;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S3", "rtl/S4.sv": "module S4(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd7;\n        6'b0_0001_0 : o_data = 4'd13;\n        6'b0_0010_0 : o_data = 4'd14;\n        6'b0_0011_0 : o_data = 4'd3;\n        6'b0_0100_0 : o_data = 4'd0;\n        6'b0_0101_0 : o_data = 4'd6;\n        6'b0_0110_0 : o_data = 4'd9;\n        6'b0_0111_0 : o_data = 4'd10;\n        6'b0_1000_0 : o_data = 4'd1;\n        6'b0_1001_0 : o_data = 4'd2;\n        6'b0_1010_0 : o_data = 4'd8;\n        6'b0_1011_0 : o_data = 4'd5;\n        6'b0_1100_0 : o_data = 4'd11;\n        6'b0_1101_0 : o_data = 4'd12;\n        6'b0_1110_0 : o_data = 4'd4;\n        6'b0_1111_0 : o_data = 4'd15;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd8;\n        6'b0_0010_1 : o_data = 4'd11;\n        6'b0_0011_1 : o_data = 4'd5;\n        6'b0_0100_1 : o_data = 4'd6;\n        6'b0_0101_1 : o_data = 4'd15;\n        6'b0_0110_1 : o_data = 4'd0;\n        6'b0_0111_1 : o_data = 4'd3;\n        6'b0_1000_1 : o_data = 4'd4;\n        6'b0_1001_1 : o_data = 4'd7;\n        6'b0_1010_1 : o_data = 4'd2;\n        6'b0_1011_1 : o_data = 4'd12;\n        6'b0_1100_1 : o_data = 4'd1;\n        6'b0_1101_1 : o_data = 4'd10;\n        6'b0_1110_1 : o_data = 4'd14;\n        6'b0_1111_1 : o_data = 4'd9;\n        6'b1_0000_0 : o_data = 4'd10;\n        6'b1_0001_0 : o_data = 4'd6;\n        6'b1_0010_0 : o_data = 4'd9;\n        6'b1_0011_0 : o_data = 4'd0;\n        6'b1_0100_0 : o_data = 4'd12;\n        6'b1_0101_0 : o_data = 4'd11;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd13;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd1;\n        6'b1_1010_0 : o_data = 4'd3;\n        6'b1_1011_0 : o_data = 4'd14;\n        6'b1_1100_0 : o_data = 4'd5;\n        6'b1_1101_0 : o_data = 4'd2;\n        6'b1_1110_0 : o_data = 4'd8;\n        6'b1_1111_0 : o_data = 4'd4;\n        6'b1_0000_1 : o_data = 4'd3;\n        6'b1_0001_1 : o_data = 4'd15;\n        6'b1_0010_1 : o_data = 4'd0;\n        6'b1_0011_1 : o_data = 4'd6;\n        6'b1_0100_1 : o_data = 4'd10;\n        6'b1_0101_1 : o_data = 4'd1;\n        6'b1_0110_1 : o_data = 4'd13;\n        6'b1_0111_1 : o_data = 4'd8;\n        6'b1_1000_1 : o_data = 4'd9;\n        6'b1_1001_1 : o_data = 4'd4;\n        6'b1_1010_1 : o_data = 4'd5;\n        6'b1_1011_1 : o_data = 4'd11;\n        6'b1_1100_1 : o_data = 4'd12;\n        6'b1_1101_1 : o_data = 4'd7;\n        6'b1_1110_1 : o_data = 4'd2;\n        6'b1_1111_1 : o_data = 4'd14;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S4", "rtl/S5.sv": "module S5(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd2;\n        6'b0_0001_0 : o_data = 4'd12;\n        6'b0_0010_0 : o_data = 4'd4;\n        6'b0_0011_0 : o_data = 4'd1;\n        6'b0_0100_0 : o_data = 4'd7;\n        6'b0_0101_0 : o_data = 4'd10;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd6;\n        6'b0_1000_0 : o_data = 4'd8;\n        6'b0_1001_0 : o_data = 4'd5;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd15;\n        6'b0_1100_0 : o_data = 4'd13;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd14;\n        6'b0_1111_0 : o_data = 4'd9;\n        6'b0_0000_1 : o_data = 4'd14;\n        6'b0_0001_1 : o_data = 4'd11;\n        6'b0_0010_1 : o_data = 4'd2;\n        6'b0_0011_1 : o_data = 4'd12;\n        6'b0_0100_1 : o_data = 4'd4;\n        6'b0_0101_1 : o_data = 4'd7;\n        6'b0_0110_1 : o_data = 4'd13;\n        6'b0_0111_1 : o_data = 4'd1;\n        6'b0_1000_1 : o_data = 4'd5;\n        6'b0_1001_1 : o_data = 4'd0;\n        6'b0_1010_1 : o_data = 4'd15;\n        6'b0_1011_1 : o_data = 4'd10;\n        6'b0_1100_1 : o_data = 4'd3;\n        6'b0_1101_1 : o_data = 4'd9;\n        6'b0_1110_1 : o_data = 4'd8;\n        6'b0_1111_1 : o_data = 4'd6;\n        6'b1_0000_0 : o_data = 4'd4;\n        6'b1_0001_0 : o_data = 4'd2;\n        6'b1_0010_0 : o_data = 4'd1;\n        6'b1_0011_0 : o_data = 4'd11;\n        6'b1_0100_0 : o_data = 4'd10;\n        6'b1_0101_0 : o_data = 4'd13;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd8;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd9;\n        6'b1_1010_0 : o_data = 4'd12;\n        6'b1_1011_0 : o_data = 4'd5;\n        6'b1_1100_0 : o_data = 4'd6;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd0;\n        6'b1_1111_0 : o_data = 4'd14;\n        6'b1_0000_1 : o_data = 4'd11;\n        6'b1_0001_1 : o_data = 4'd8;\n        6'b1_0010_1 : o_data = 4'd12;\n        6'b1_0011_1 : o_data = 4'd7;\n        6'b1_0100_1 : o_data = 4'd1;\n        6'b1_0101_1 : o_data = 4'd14;\n        6'b1_0110_1 : o_data = 4'd2;\n        6'b1_0111_1 : o_data = 4'd13;\n        6'b1_1000_1 : o_data = 4'd6;\n        6'b1_1001_1 : o_data = 4'd15;\n        6'b1_1010_1 : o_data = 4'd0;\n        6'b1_1011_1 : o_data = 4'd9;\n        6'b1_1100_1 : o_data = 4'd10;\n        6'b1_1101_1 : o_data = 4'd4;\n        6'b1_1110_1 : o_data = 4'd5;\n        6'b1_1111_1 : o_data = 4'd3;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S5", "rtl/S6.sv": "module S6(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd12;\n        6'b0_0001_0 : o_data = 4'd1;\n        6'b0_0010_0 : o_data = 4'd10;\n        6'b0_0011_0 : o_data = 4'd15;\n        6'b0_0100_0 : o_data = 4'd9;\n        6'b0_0101_0 : o_data = 4'd2;\n        6'b0_0110_0 : o_data = 4'd6;\n        6'b0_0111_0 : o_data = 4'd8;\n        6'b0_1000_0 : o_data = 4'd0;\n        6'b0_1001_0 : o_data = 4'd13;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd4;\n        6'b0_1100_0 : o_data = 4'd14;\n        6'b0_1101_0 : o_data = 4'd7;\n        6'b0_1110_0 : o_data = 4'd5;\n        6'b0_1111_0 : o_data = 4'd11;\n        6'b0_0000_1 : o_data = 4'd10;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd4;\n        6'b0_0011_1 : o_data = 4'd2;\n        6'b0_0100_1 : o_data = 4'd7;\n        6'b0_0101_1 : o_data = 4'd12;\n        6'b0_0110_1 : o_data = 4'd9;\n        6'b0_0111_1 : o_data = 4'd5;\n        6'b0_1000_1 : o_data = 4'd6;\n        6'b0_1001_1 : o_data = 4'd1;\n        6'b0_1010_1 : o_data = 4'd13;\n        6'b0_1011_1 : o_data = 4'd14;\n        6'b0_1100_1 : o_data = 4'd0;\n        6'b0_1101_1 : o_data = 4'd11;\n        6'b0_1110_1 : o_data = 4'd3;\n        6'b0_1111_1 : o_data = 4'd8;\n        6'b1_0000_0 : o_data = 4'd9;\n        6'b1_0001_0 : o_data = 4'd14;\n        6'b1_0010_0 : o_data = 4'd15;\n        6'b1_0011_0 : o_data = 4'd5;\n        6'b1_0100_0 : o_data = 4'd2;\n        6'b1_0101_0 : o_data = 4'd8;\n        6'b1_0110_0 : o_data = 4'd12;\n        6'b1_0111_0 : o_data = 4'd3;\n        6'b1_1000_0 : o_data = 4'd7;\n        6'b1_1001_0 : o_data = 4'd0;\n        6'b1_1010_0 : o_data = 4'd4;\n        6'b1_1011_0 : o_data = 4'd10;\n        6'b1_1100_0 : o_data = 4'd1;\n        6'b1_1101_0 : o_data = 4'd13;\n        6'b1_1110_0 : o_data = 4'd11;\n        6'b1_1111_0 : o_data = 4'd6;\n        6'b1_0000_1 : o_data = 4'd4;\n        6'b1_0001_1 : o_data = 4'd3;\n        6'b1_0010_1 : o_data = 4'd2;\n        6'b1_0011_1 : o_data = 4'd12;\n        6'b1_0100_1 : o_data = 4'd9;\n        6'b1_0101_1 : o_data = 4'd5;\n        6'b1_0110_1 : o_data = 4'd15;\n        6'b1_0111_1 : o_data = 4'd10;\n        6'b1_1000_1 : o_data = 4'd11;\n        6'b1_1001_1 : o_data = 4'd14;\n        6'b1_1010_1 : o_data = 4'd1;\n        6'b1_1011_1 : o_data = 4'd7;\n        6'b1_1100_1 : o_data = 4'd6;\n        6'b1_1101_1 : o_data = 4'd0;\n        6'b1_1110_1 : o_data = 4'd8;\n        6'b1_1111_1 : o_data = 4'd13;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S6", "rtl/S7.sv": "module S7(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd4;\n        6'b0_0001_0 : o_data = 4'd11;\n        6'b0_0010_0 : o_data = 4'd2;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd15;\n        6'b0_0101_0 : o_data = 4'd0;\n        6'b0_0110_0 : o_data = 4'd8;\n        6'b0_0111_0 : o_data = 4'd13;\n        6'b0_1000_0 : o_data = 4'd3;\n        6'b0_1001_0 : o_data = 4'd12;\n        6'b0_1010_0 : o_data = 4'd9;\n        6'b0_1011_0 : o_data = 4'd7;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd10;\n        6'b0_1110_0 : o_data = 4'd6;\n        6'b0_1111_0 : o_data = 4'd1;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd0;\n        6'b0_0010_1 : o_data = 4'd11;\n        6'b0_0011_1 : o_data = 4'd7;\n        6'b0_0100_1 : o_data = 4'd4;\n        6'b0_0101_1 : o_data = 4'd9;\n        6'b0_0110_1 : o_data = 4'd1;\n        6'b0_0111_1 : o_data = 4'd10;\n        6'b0_1000_1 : o_data = 4'd14;\n        6'b0_1001_1 : o_data = 4'd3;\n        6'b0_1010_1 : o_data = 4'd5;\n        6'b0_1011_1 : o_data = 4'd12;\n        6'b0_1100_1 : o_data = 4'd2;\n        6'b0_1101_1 : o_data = 4'd15;\n        6'b0_1110_1 : o_data = 4'd8;\n        6'b0_1111_1 : o_data = 4'd6;\n        6'b1_0000_0 : o_data = 4'd1;\n        6'b1_0001_0 : o_data = 4'd4;\n        6'b1_0010_0 : o_data = 4'd11;\n        6'b1_0011_0 : o_data = 4'd13;\n        6'b1_0100_0 : o_data = 4'd12;\n        6'b1_0101_0 : o_data = 4'd3;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd14;\n        6'b1_1000_0 : o_data = 4'd10;\n        6'b1_1001_0 : o_data = 4'd15;\n        6'b1_1010_0 : o_data = 4'd6;\n        6'b1_1011_0 : o_data = 4'd8;\n        6'b1_1100_0 : o_data = 4'd0;\n        6'b1_1101_0 : o_data = 4'd5;\n        6'b1_1110_0 : o_data = 4'd9;\n        6'b1_1111_0 : o_data = 4'd2;\n        6'b1_0000_1 : o_data = 4'd6;\n        6'b1_0001_1 : o_data = 4'd11;\n        6'b1_0010_1 : o_data = 4'd13;\n        6'b1_0011_1 : o_data = 4'd8;\n        6'b1_0100_1 : o_data = 4'd1;\n        6'b1_0101_1 : o_data = 4'd4;\n        6'b1_0110_1 : o_data = 4'd10;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd9;\n        6'b1_1001_1 : o_data = 4'd5;\n        6'b1_1010_1 : o_data = 4'd0;\n        6'b1_1011_1 : o_data = 4'd15;\n        6'b1_1100_1 : o_data = 4'd14;\n        6'b1_1101_1 : o_data = 4'd2;\n        6'b1_1110_1 : o_data = 4'd3;\n        6'b1_1111_1 : o_data = 4'd12;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S7", "rtl/S8.sv": "module S8(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd13;\n        6'b0_0001_0 : o_data = 4'd2;\n        6'b0_0010_0 : o_data = 4'd8;\n        6'b0_0011_0 : o_data = 4'd4;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd15;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd1;\n        6'b0_1000_0 : o_data = 4'd10;\n        6'b0_1001_0 : o_data = 4'd9;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd14;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd12;\n        6'b0_1111_0 : o_data = 4'd7;\n        6'b0_0000_1 : o_data = 4'd1;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd13;\n        6'b0_0011_1 : o_data = 4'd8;\n        6'b0_0100_1 : o_data = 4'd10;\n        6'b0_0101_1 : o_data = 4'd3;\n        6'b0_0110_1 : o_data = 4'd7;\n        6'b0_0111_1 : o_data = 4'd4;\n        6'b0_1000_1 : o_data = 4'd12;\n        6'b0_1001_1 : o_data = 4'd5;\n        6'b0_1010_1 : o_data = 4'd6;\n        6'b0_1011_1 : o_data = 4'd11;\n        6'b0_1100_1 : o_data = 4'd0;\n        6'b0_1101_1 : o_data = 4'd14;\n        6'b0_1110_1 : o_data = 4'd9;\n        6'b0_1111_1 : o_data = 4'd2;\n        6'b1_0000_0 : o_data = 4'd7;\n        6'b1_0001_0 : o_data = 4'd11;\n        6'b1_0010_0 : o_data = 4'd4;\n        6'b1_0011_0 : o_data = 4'd1;\n        6'b1_0100_0 : o_data = 4'd9;\n        6'b1_0101_0 : o_data = 4'd12;\n        6'b1_0110_0 : o_data = 4'd14;\n        6'b1_0111_0 : o_data = 4'd2;\n        6'b1_1000_0 : o_data = 4'd0;\n        6'b1_1001_0 : o_data = 4'd6;\n        6'b1_1010_0 : o_data = 4'd10;\n        6'b1_1011_0 : o_data = 4'd13;\n        6'b1_1100_0 : o_data = 4'd15;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd5;\n        6'b1_1111_0 : o_data = 4'd8;\n        6'b1_0000_1 : o_data = 4'd2;\n        6'b1_0001_1 : o_data = 4'd1;\n        6'b1_0010_1 : o_data = 4'd14;\n        6'b1_0011_1 : o_data = 4'd7;\n        6'b1_0100_1 : o_data = 4'd4;\n        6'b1_0101_1 : o_data = 4'd10;\n        6'b1_0110_1 : o_data = 4'd8;\n        6'b1_0111_1 : o_data = 4'd13;\n        6'b1_1000_1 : o_data = 4'd15;\n        6'b1_1001_1 : o_data = 4'd12;\n        6'b1_1010_1 : o_data = 4'd9;\n        6'b1_1011_1 : o_data = 4'd0;\n        6'b1_1100_1 : o_data = 4'd3;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd6;\n        6'b1_1111_1 : o_data = 4'd11;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S8", "rtl/des_dec.sv": "module des_dec #(\n    parameter NBW_DATA = 'd64,\n    parameter NBW_KEY  = 'd64\n) (\n    input  logic              clk,\n    input  logic              rst_async_n,\n    input  logic              i_valid,\n    input  logic [1:NBW_DATA] i_data,\n    input  logic [1:NBW_KEY]  i_key,\n    output logic              o_valid,\n    output logic [1:NBW_DATA] o_data\n);\n\nlocalparam ROUNDS = 'd16;\nlocalparam EXPANDED_BLOCK = 'd48;\nlocalparam USED_KEY = 'd56;\n\nlogic [1:(NBW_DATA/2)] L16;\nlogic [1:(NBW_DATA/2)] R16;\nlogic [1:(NBW_DATA/2)] L_ff [0:ROUNDS-1];\nlogic [1:(NBW_DATA/2)] R_ff [0:ROUNDS-1];\nlogic [1:(USED_KEY/2)] C16;\nlogic [1:(USED_KEY/2)] D16;\nlogic [1:(USED_KEY/2)] C_ff [0:ROUNDS-1];\nlogic [1:(USED_KEY/2)] D_ff [0:ROUNDS-1];\nlogic [1:NBW_DATA]     last_perm;\nlogic [ROUNDS-1:0]     valid_ff;\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        valid_ff <= 0;\n    end else begin\n        valid_ff <= {valid_ff[ROUNDS-2:0], i_valid};\n    end\nend\n\nassign o_valid = valid_ff[ROUNDS-1];\n\nassign R16 = {i_data[58], i_data[50], i_data[42], i_data[34], i_data[26], i_data[18], i_data[10], i_data[2],\n              i_data[60], i_data[52], i_data[44], i_data[36], i_data[28], i_data[20], i_data[12], i_data[4],\n              i_data[62], i_data[54], i_data[46], i_data[38], i_data[30], i_data[22], i_data[14], i_data[6],\n              i_data[64], i_data[56], i_data[48], i_data[40], i_data[32], i_data[24], i_data[16], i_data[8]};\n\nassign L16 = {i_data[57], i_data[49], i_data[41], i_data[33], i_data[25], i_data[17], i_data[ 9], i_data[1],\n              i_data[59], i_data[51], i_data[43], i_data[35], i_data[27], i_data[19], i_data[11], i_data[3],\n              i_data[61], i_data[53], i_data[45], i_data[37], i_data[29], i_data[21], i_data[13], i_data[5],\n              i_data[63], i_data[55], i_data[47], i_data[39], i_data[31], i_data[23], i_data[15], i_data[7]};\n\nassign C16 = {i_key[57], i_key[49], i_key[41], i_key[33], i_key[25], i_key[17], i_key[ 9],\n              i_key[ 1], i_key[58], i_key[50], i_key[42], i_key[34], i_key[26], i_key[18],\n              i_key[10], i_key[ 2], i_key[59], i_key[51], i_key[43], i_key[35], i_key[27],\n              i_key[19], i_key[11], i_key[ 3], i_key[60], i_key[52], i_key[44], i_key[36]};\n\nassign D16 = {i_key[63], i_key[55], i_key[47], i_key[39], i_key[31], i_key[23], i_key[15],\n              i_key[ 7], i_key[62], i_key[54], i_key[46], i_key[38], i_key[30], i_key[22],\n              i_key[14], i_key[ 6], i_key[61], i_key[53], i_key[45], i_key[37], i_key[29],\n              i_key[21], i_key[13], i_key[ 5], i_key[28], i_key[20], i_key[12], i_key[ 4]};\n\ngenerate\n    for (genvar i = ROUNDS-1; i >= 0; i--) begin : rounds\n        logic [1:EXPANDED_BLOCK] round_key;\n        logic [1:(USED_KEY/2)]   C_nx;\n        logic [1:(USED_KEY/2)]   D_nx;\n        logic [1:USED_KEY]       perm_ch;\n        logic [1:(NBW_DATA/2)]   L_nx;\n        logic [1:EXPANDED_BLOCK] L_expanded;\n        logic [1:6]              Primitive_input  [1:8];\n        logic [1:4]              Primitive_output [1:8];\n        logic [1:(NBW_DATA/2)]   perm_in;\n\n        if(i == 15) begin\n            assign perm_ch = {C16, D16};\n        end else begin\n            assign perm_ch = {C_ff[i+1], D_ff[i+1]};\n        end\n        assign round_key = {perm_ch[14], perm_ch[17], perm_ch[11], perm_ch[24], perm_ch[ 1], perm_ch[ 5],\n                            perm_ch[ 3], perm_ch[28], perm_ch[15], perm_ch[ 6], perm_ch[21], perm_ch[10],\n                            perm_ch[23], perm_ch[19], perm_ch[12], perm_ch[ 4], perm_ch[26], perm_ch[ 8],\n                            perm_ch[16], perm_ch[ 7], perm_ch[27], perm_ch[20], perm_ch[13], perm_ch[ 2],\n                            perm_ch[41], perm_ch[52], perm_ch[31], perm_ch[37], perm_ch[47], perm_ch[55],\n                            perm_ch[30], perm_ch[40], perm_ch[51], perm_ch[45], perm_ch[33], perm_ch[48],\n                            perm_ch[44], perm_ch[49], perm_ch[39], perm_ch[56], perm_ch[34], perm_ch[53],\n                            perm_ch[46], perm_ch[42], perm_ch[50], perm_ch[36], perm_ch[29], perm_ch[32]};\n\n        if(i == 0 || i == 1 || i == 8 || i == 15) begin\n            if(i == 15) begin\n                assign C_nx = {C16[(USED_KEY/2)], C16[1:(USED_KEY/2)-1]};\n                assign D_nx = {D16[(USED_KEY/2)], D16[1:(USED_KEY/2)-1]};\n            end else begin\n                assign C_nx = {C_ff[i+1][(USED_KEY/2)], C_ff[i+1][1:(USED_KEY/2)-1]};\n                assign D_nx = {D_ff[i+1][(USED_KEY/2)], D_ff[i+1][1:(USED_KEY/2)-1]};\n            end\n        end else begin\n            assign C_nx = {C_ff[i+1][(USED_KEY/2)-1+:2], C_ff[i+1][1:(USED_KEY/2)-2]};\n            assign D_nx = {D_ff[i+1][(USED_KEY/2)-1+:2], D_ff[i+1][1:(USED_KEY/2)-2]};\n        end\n\n        assign Primitive_input[1] = L_expanded[ 1:6 ] ^ round_key[ 1:6 ];\n        assign Primitive_input[2] = L_expanded[ 7:12] ^ round_key[ 7:12];\n        assign Primitive_input[3] = L_expanded[13:18] ^ round_key[13:18];\n        assign Primitive_input[4] = L_expanded[19:24] ^ round_key[19:24];\n        assign Primitive_input[5] = L_expanded[25:30] ^ round_key[25:30];\n        assign Primitive_input[6] = L_expanded[31:36] ^ round_key[31:36];\n        assign Primitive_input[7] = L_expanded[37:42] ^ round_key[37:42];\n        assign Primitive_input[8] = L_expanded[43:48] ^ round_key[43:48];\n\n        S1 uu_S1 (\n            .i_data(Primitive_input [1]),\n            .o_data(Primitive_output[1])\n        );\n\n        S2 uu_S2 (\n            .i_data(Primitive_input [2]),\n            .o_data(Primitive_output[2])\n        );\n\n        S3 uu_S3 (\n            .i_data(Primitive_input [3]),\n            .o_data(Primitive_output[3])\n        );\n\n        S4 uu_S4 (\n            .i_data(Primitive_input [4]),\n            .o_data(Primitive_output[4])\n        );\n\n        S5 uu_S5 (\n            .i_data(Primitive_input [5]),\n            .o_data(Primitive_output[5])\n        );\n\n        S6 uu_S6 (\n            .i_data(Primitive_input [6]),\n            .o_data(Primitive_output[6])\n        );\n\n        S7 uu_S7 (\n            .i_data(Primitive_input [7]),\n            .o_data(Primitive_output[7])\n        );\n\n        S8 uu_S8 (\n            .i_data(Primitive_input [8]),\n            .o_data(Primitive_output[8])\n        );\n\n        assign perm_in = {Primitive_output[1], Primitive_output[2], Primitive_output[3], Primitive_output[4],\n                          Primitive_output[5], Primitive_output[6], Primitive_output[7], Primitive_output[8]};\n\n        assign L_nx = {perm_in[16], perm_in[ 7], perm_in[20], perm_in[21],\n                       perm_in[29], perm_in[12], perm_in[28], perm_in[17],\n                       perm_in[ 1], perm_in[15], perm_in[23], perm_in[26],\n                       perm_in[ 5], perm_in[18], perm_in[31], perm_in[10],\n                       perm_in[ 2], perm_in[ 8], perm_in[24], perm_in[14],\n                       perm_in[32], perm_in[27], perm_in[ 3], perm_in[ 9],\n                       perm_in[19], perm_in[13], perm_in[30], perm_in[ 6],\n                       perm_in[22], perm_in[11], perm_in[ 4], perm_in[25]};\n\n        if(i == 15) begin\n            assign L_expanded = {L16[32], L16[ 1], L16[ 2], L16[ 3], L16[ 4], L16[ 5],\n                                 L16[ 4], L16[ 5], L16[ 6], L16[ 7], L16[ 8], L16[ 9],\n                                 L16[ 8], L16[ 9], L16[10], L16[11], L16[12], L16[13],\n                                 L16[12], L16[13], L16[14], L16[15], L16[16], L16[17],\n                                 L16[16], L16[17], L16[18], L16[19], L16[20], L16[21],\n                                 L16[20], L16[21], L16[22], L16[23], L16[24], L16[25],\n                                 L16[24], L16[25], L16[26], L16[27], L16[28], L16[29],\n                                 L16[28], L16[29], L16[30], L16[31], L16[32], L16[ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    if(i_valid) begin\n                        L_ff[i] <= L_nx ^ R16;\n                        R_ff[i] <= L16;\n                        C_ff[i] <= C_nx;\n                        D_ff[i] <= D_nx;\n                    end\n                end\n            end\n        end else begin\n            assign L_expanded = {L_ff[i+1][32], L_ff[i+1][ 1], L_ff[i+1][ 2], L_ff[i+1][ 3], L_ff[i+1][ 4], L_ff[i+1][ 5],\n                                 L_ff[i+1][ 4], L_ff[i+1][ 5], L_ff[i+1][ 6], L_ff[i+1][ 7], L_ff[i+1][ 8], L_ff[i+1][ 9],\n                                 L_ff[i+1][ 8], L_ff[i+1][ 9], L_ff[i+1][10], L_ff[i+1][11], L_ff[i+1][12], L_ff[i+1][13],\n                                 L_ff[i+1][12], L_ff[i+1][13], L_ff[i+1][14], L_ff[i+1][15], L_ff[i+1][16], L_ff[i+1][17],\n                                 L_ff[i+1][16], L_ff[i+1][17], L_ff[i+1][18], L_ff[i+1][19], L_ff[i+1][20], L_ff[i+1][21],\n                                 L_ff[i+1][20], L_ff[i+1][21], L_ff[i+1][22], L_ff[i+1][23], L_ff[i+1][24], L_ff[i+1][25],\n                                 L_ff[i+1][24], L_ff[i+1][25], L_ff[i+1][26], L_ff[i+1][27], L_ff[i+1][28], L_ff[i+1][29],\n                                 L_ff[i+1][28], L_ff[i+1][29], L_ff[i+1][30], L_ff[i+1][31], L_ff[i+1][32], L_ff[i+1][ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    L_ff[i] <= L_nx ^ R_ff[i+1];\n                    R_ff[i] <= L_ff[i+1];\n                    C_ff[i] <= C_nx;\n                    D_ff[i] <= D_nx;\n                end\n            end\n        end\n    end\nendgenerate\n\nassign last_perm = {L_ff[0], R_ff[0]};\n\nassign o_data = {last_perm[40], last_perm[8], last_perm[48], last_perm[16], last_perm[56], last_perm[24], last_perm[64], last_perm[32],\n                 last_perm[39], last_perm[7], last_perm[47], last_perm[15], last_perm[55], last_perm[23], last_perm[63], last_perm[31],\n                 last_perm[38], last_perm[6], last_perm[46], last_perm[14], last_perm[54], last_perm[22], last_perm[62], last_perm[30],\n                 last_perm[37], last_perm[5], last_perm[45], last_perm[13], last_perm[53], last_perm[21], last_perm[61], last_perm[29],\n                 last_perm[36], last_perm[4], last_perm[44], last_perm[12], last_perm[52], last_perm[20], last_perm[60], last_perm[28],\n                 last_perm[35], last_perm[3], last_perm[43], last_perm[11], last_perm[51], last_perm[19], last_perm[59], last_perm[27],\n                 last_perm[34], last_perm[2], last_perm[42], last_perm[10], last_perm[50], last_perm[18], last_perm[58], last_perm[26],\n                 last_perm[33], last_perm[1], last_perm[41], last_perm[ 9], last_perm[49], last_perm[17], last_perm[57], last_perm[25]};\n\nendmodule : des_dec", "rtl/des_enc.sv": "module des_enc #(\n    parameter NBW_DATA = 'd64,\n    parameter NBW_KEY  = 'd64\n) (\n    input  logic              clk,\n    input  logic              rst_async_n,\n    input  logic              i_valid,\n    input  logic [1:NBW_DATA] i_data,\n    input  logic [1:NBW_KEY]  i_key,\n    output logic              o_valid,\n    output logic [1:NBW_DATA] o_data\n);\n\nlocalparam ROUNDS = 'd16;\nlocalparam EXPANDED_BLOCK = 'd48;\nlocalparam USED_KEY = 'd56;\n\nlogic [1:NBW_DATA]     IP;\nlogic [1:(NBW_DATA/2)] L0;\nlogic [1:(NBW_DATA/2)] R0;\nlogic [1:(NBW_DATA/2)] L_ff [1:ROUNDS];\nlogic [1:(NBW_DATA/2)] R_ff [1:ROUNDS];\nlogic [1:(USED_KEY/2)] C0;\nlogic [1:(USED_KEY/2)] D0;\nlogic [1:(USED_KEY/2)] C_ff [1:ROUNDS];\nlogic [1:(USED_KEY/2)] D_ff [1:ROUNDS];\nlogic [1:NBW_DATA]     last_perm;\nlogic [ROUNDS-1:0]     valid_ff;\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        valid_ff <= 0;\n    end else begin\n        valid_ff <= {valid_ff[ROUNDS-2:0], i_valid};\n    end\nend\n\nassign o_valid = valid_ff[ROUNDS-1];\n\nassign IP = {i_data[58], i_data[50], i_data[42], i_data[34], i_data[26], i_data[18], i_data[10], i_data[2],\n             i_data[60], i_data[52], i_data[44], i_data[36], i_data[28], i_data[20], i_data[12], i_data[4],\n             i_data[62], i_data[54], i_data[46], i_data[38], i_data[30], i_data[22], i_data[14], i_data[6],\n             i_data[64], i_data[56], i_data[48], i_data[40], i_data[32], i_data[24], i_data[16], i_data[8],\n             i_data[57], i_data[49], i_data[41], i_data[33], i_data[25], i_data[17], i_data[ 9], i_data[1],\n             i_data[59], i_data[51], i_data[43], i_data[35], i_data[27], i_data[19], i_data[11], i_data[3],\n             i_data[61], i_data[53], i_data[45], i_data[37], i_data[29], i_data[21], i_data[13], i_data[5],\n             i_data[63], i_data[55], i_data[47], i_data[39], i_data[31], i_data[23], i_data[15], i_data[7]};\n\nassign L0 = IP[1:NBW_DATA/2];\nassign R0 = IP[(NBW_DATA/2)+1:NBW_DATA];\n\nassign C0 = {i_key[57], i_key[49], i_key[41], i_key[33], i_key[25], i_key[17], i_key[ 9],\n             i_key[ 1], i_key[58], i_key[50], i_key[42], i_key[34], i_key[26], i_key[18],\n             i_key[10], i_key[ 2], i_key[59], i_key[51], i_key[43], i_key[35], i_key[27],\n             i_key[19], i_key[11], i_key[ 3], i_key[60], i_key[52], i_key[44], i_key[36]};\n\nassign D0 = {i_key[63], i_key[55], i_key[47], i_key[39], i_key[31], i_key[23], i_key[15],\n             i_key[ 7], i_key[62], i_key[54], i_key[46], i_key[38], i_key[30], i_key[22],\n             i_key[14], i_key[ 6], i_key[61], i_key[53], i_key[45], i_key[37], i_key[29],\n             i_key[21], i_key[13], i_key[ 5], i_key[28], i_key[20], i_key[12], i_key[ 4]};\n\ngenerate\n    for (genvar i = 1; i <= ROUNDS; i++) begin : rounds\n        logic [1:EXPANDED_BLOCK] round_key;\n        logic [1:(USED_KEY/2)]    C_nx;\n        logic [1:(USED_KEY/2)]    D_nx;\n        logic [1:USED_KEY]        perm_ch;\n        logic [1:(NBW_DATA/2)] R_nx;\n        logic [1:EXPANDED_BLOCK] R_expanded;\n        logic [1:6] Primitive_input  [1:8];\n        logic [1:4] Primitive_output [1:8];\n        logic [1:(NBW_DATA/2)] perm_in;\n\n        assign perm_ch = {C_nx, D_nx};\n        assign round_key = {perm_ch[14], perm_ch[17], perm_ch[11], perm_ch[24], perm_ch[ 1], perm_ch[ 5],\n                            perm_ch[ 3], perm_ch[28], perm_ch[15], perm_ch[ 6], perm_ch[21], perm_ch[10],\n                            perm_ch[23], perm_ch[19], perm_ch[12], perm_ch[ 4], perm_ch[26], perm_ch[ 8],\n                            perm_ch[16], perm_ch[ 7], perm_ch[27], perm_ch[20], perm_ch[13], perm_ch[ 2],\n                            perm_ch[41], perm_ch[52], perm_ch[31], perm_ch[37], perm_ch[47], perm_ch[55],\n                            perm_ch[30], perm_ch[40], perm_ch[51], perm_ch[45], perm_ch[33], perm_ch[48],\n                            perm_ch[44], perm_ch[49], perm_ch[39], perm_ch[56], perm_ch[34], perm_ch[53],\n                            perm_ch[46], perm_ch[42], perm_ch[50], perm_ch[36], perm_ch[29], perm_ch[32]};\n\n        if(i == 1 || i == 2 || i == 9 || i == 16) begin\n            if(i == 1) begin\n                assign C_nx = {C0[2:(USED_KEY/2)], C0[1]};\n                assign D_nx = {D0[2:(USED_KEY/2)], D0[1]};\n            end else begin\n                assign C_nx = {C_ff[i-1][2:(USED_KEY/2)], C_ff[i-1][1]};\n                assign D_nx = {D_ff[i-1][2:(USED_KEY/2)], D_ff[i-1][1]};\n            end\n        end else begin\n            assign C_nx = {C_ff[i-1][3:(USED_KEY/2)], C_ff[i-1][1:2]};\n            assign D_nx = {D_ff[i-1][3:(USED_KEY/2)], D_ff[i-1][1:2]};\n        end\n\n        assign Primitive_input[1] = R_expanded[ 1:6 ] ^ round_key[ 1:6 ];\n        assign Primitive_input[2] = R_expanded[ 7:12] ^ round_key[ 7:12];\n        assign Primitive_input[3] = R_expanded[13:18] ^ round_key[13:18];\n        assign Primitive_input[4] = R_expanded[19:24] ^ round_key[19:24];\n        assign Primitive_input[5] = R_expanded[25:30] ^ round_key[25:30];\n        assign Primitive_input[6] = R_expanded[31:36] ^ round_key[31:36];\n        assign Primitive_input[7] = R_expanded[37:42] ^ round_key[37:42];\n        assign Primitive_input[8] = R_expanded[43:48] ^ round_key[43:48];\n\n        S1 uu_S1 (\n            .i_data(Primitive_input [1]),\n            .o_data(Primitive_output[1])\n        );\n\n        S2 uu_S2 (\n            .i_data(Primitive_input [2]),\n            .o_data(Primitive_output[2])\n        );\n\n        S3 uu_S3 (\n            .i_data(Primitive_input [3]),\n            .o_data(Primitive_output[3])\n        );\n\n        S4 uu_S4 (\n            .i_data(Primitive_input [4]),\n            .o_data(Primitive_output[4])\n        );\n\n        S5 uu_S5 (\n            .i_data(Primitive_input [5]),\n            .o_data(Primitive_output[5])\n        );\n\n        S6 uu_S6 (\n            .i_data(Primitive_input [6]),\n            .o_data(Primitive_output[6])\n        );\n\n        S7 uu_S7 (\n            .i_data(Primitive_input [7]),\n            .o_data(Primitive_output[7])\n        );\n\n        S8 uu_S8 (\n            .i_data(Primitive_input [8]),\n            .o_data(Primitive_output[8])\n        );\n\n        assign perm_in = {Primitive_output[1], Primitive_output[2], Primitive_output[3], Primitive_output[4],\n                          Primitive_output[5], Primitive_output[6], Primitive_output[7], Primitive_output[8]};\n\n        assign R_nx = {perm_in[16], perm_in[ 7], perm_in[20], perm_in[21],\n                       perm_in[29], perm_in[12], perm_in[28], perm_in[17],\n                       perm_in[ 1], perm_in[15], perm_in[23], perm_in[26],\n                       perm_in[ 5], perm_in[18], perm_in[31], perm_in[10],\n                       perm_in[ 2], perm_in[ 8], perm_in[24], perm_in[14],\n                       perm_in[32], perm_in[27], perm_in[ 3], perm_in[ 9],\n                       perm_in[19], perm_in[13], perm_in[30], perm_in[ 6],\n                       perm_in[22], perm_in[11], perm_in[ 4], perm_in[25]};\n\n        if(i == 1) begin\n            assign R_expanded = {R0[32], R0[ 1], R0[ 2], R0[ 3], R0[ 4], R0[ 5],\n                                 R0[ 4], R0[ 5], R0[ 6], R0[ 7], R0[ 8], R0[ 9],\n                                 R0[ 8], R0[ 9], R0[10], R0[11], R0[12], R0[13],\n                                 R0[12], R0[13], R0[14], R0[15], R0[16], R0[17],\n                                 R0[16], R0[17], R0[18], R0[19], R0[20], R0[21],\n                                 R0[20], R0[21], R0[22], R0[23], R0[24], R0[25],\n                                 R0[24], R0[25], R0[26], R0[27], R0[28], R0[29],\n                                 R0[28], R0[29], R0[30], R0[31], R0[32], R0[ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    if(i_valid) begin\n                        L_ff[i] <= R0;\n                        R_ff[i] <= R_nx ^ L0;\n                        C_ff[i] <= C_nx;\n                        D_ff[i] <= D_nx;\n                    end\n                end\n            end\n        end else begin\n            assign R_expanded = {R_ff[i-1][32], R_ff[i-1][ 1], R_ff[i-1][ 2], R_ff[i-1][ 3], R_ff[i-1][ 4], R_ff[i-1][ 5],\n                                 R_ff[i-1][ 4], R_ff[i-1][ 5], R_ff[i-1][ 6], R_ff[i-1][ 7], R_ff[i-1][ 8], R_ff[i-1][ 9],\n                                 R_ff[i-1][ 8], R_ff[i-1][ 9], R_ff[i-1][10], R_ff[i-1][11], R_ff[i-1][12], R_ff[i-1][13],\n                                 R_ff[i-1][12], R_ff[i-1][13], R_ff[i-1][14], R_ff[i-1][15], R_ff[i-1][16], R_ff[i-1][17],\n                                 R_ff[i-1][16], R_ff[i-1][17], R_ff[i-1][18], R_ff[i-1][19], R_ff[i-1][20], R_ff[i-1][21],\n                                 R_ff[i-1][20], R_ff[i-1][21], R_ff[i-1][22], R_ff[i-1][23], R_ff[i-1][24], R_ff[i-1][25],\n                                 R_ff[i-1][24], R_ff[i-1][25], R_ff[i-1][26], R_ff[i-1][27], R_ff[i-1][28], R_ff[i-1][29],\n                                 R_ff[i-1][28], R_ff[i-1][29], R_ff[i-1][30], R_ff[i-1][31], R_ff[i-1][32], R_ff[i-1][ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    L_ff[i] <= R_ff[i-1];\n                    R_ff[i] <= R_nx ^ L_ff[i-1];\n                    C_ff[i] <= C_nx;\n                    D_ff[i] <= D_nx;\n                end\n            end\n        end\n    end\nendgenerate\n\nassign last_perm = {R_ff[ROUNDS], L_ff[ROUNDS]};\n\nassign o_data = {last_perm[40], last_perm[8], last_perm[48], last_perm[16], last_perm[56], last_perm[24], last_perm[64], last_perm[32],\n                 last_perm[39], last_perm[7], last_perm[47], last_perm[15], last_perm[55], last_perm[23], last_perm[63], last_perm[31],\n                 last_perm[38], last_perm[6], last_perm[46], last_perm[14], last_perm[54], last_perm[22], last_perm[62], last_perm[30],\n                 last_perm[37], last_perm[5], last_perm[45], last_perm[13], last_perm[53], last_perm[21], last_perm[61], last_perm[29],\n                 last_perm[36], last_perm[4], last_perm[44], last_perm[12], last_perm[52], last_perm[20], last_perm[60], last_perm[28],\n                 last_perm[35], last_perm[3], last_perm[43], last_perm[11], last_perm[51], last_perm[19], last_perm[59], last_perm[27],\n                 last_perm[34], last_perm[2], last_perm[42], last_perm[10], last_perm[50], last_perm[18], last_perm[58], last_perm[26],\n                 last_perm[33], last_perm[1], last_perm[41], last_perm[ 9], last_perm[49], last_perm[17], last_perm[57], last_perm[25]};\n\nendmodule : des_enc", "verif/tb_3des_enc.sv": "module tb;\n\nparameter NBW_DATA = 'd64;\nparameter NBW_KEY  = 'd192;\n\nlogic                clk;\nlogic                rst_async_n;\nlogic                i_valid;\nlogic [1:NBW_DATA] i_data;\nlogic [1:NBW_KEY ] i_key;\nlogic                o_valid;\nlogic [1:NBW_DATA] o_data;\n\ndes3_enc #(\n    .NBW_DATA(NBW_DATA),\n    .NBW_KEY (NBW_KEY )\n) uu_des3_enc (\n    .clk        (clk        ),\n    .rst_async_n(rst_async_n),\n    .i_valid    (i_valid    ),\n    .i_data     (i_data     ),\n    .i_key      (i_key      ),\n    .o_valid    (o_valid    ),\n    .o_data     (o_data     )\n);\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb);\nend\n\nalways #5 clk = ~clk;\n\ntask Single_test(logic [1:NBW_KEY] key, logic [1:NBW_DATA] data, logic [1:NBW_DATA] expected);\n    i_key   = key;\n    i_data  = data;\n    i_valid = 1;\n\n    @(negedge clk);\n    i_valid = 0;\n\n    @(posedge o_valid);\n    @(negedge clk);\n    if(o_data != expected) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", expected, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\nendtask\n\ntask Burst_test();\n    i_key   = 192'hB1FECAFEBEBAB1FEABCDABCDABCDABCD8765432187654321;\n    i_data  = 64'h4321432143214321;\n    i_valid = 1;\n\n    @(negedge clk);\n    i_data  = 64'h123456789ABCDEF0;\n\n    @(negedge clk);\n    i_data  = 64'h1234123412341234;\n    i_key   = 192'hABCDABCDABCDABCD8765432187654321B1FECAFEBEBAB1FE;\n\n    @(negedge clk);\n    i_valid = 0;\n\n    @(posedge o_valid);\n    @(negedge clk);\n    if(o_data != 64'h2749c9efcaed543a) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h2749c9efcaed543a, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n\n    @(negedge clk);\n    if(o_valid != 1) begin\n        $display(\"FAIL! o_valid should be asserted here.\");\n    end\n    if(o_data != 64'h984d23ecef8df5fd) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h984d23ecef8df5fd, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n\n    @(negedge clk);\n    if(o_valid != 1) begin\n        $display(\"FAIL! o_valid should be asserted here.\");\n    end\n    if(o_data != 64'h972161012599c927) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h972161012599c927, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n    \nendtask\n\ninitial begin\n    clk = 0;\n    i_valid = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    $display(\"\\nSingle Tests\");\n    Single_test(192'h0123456789abcdeffedcba9876543210abcdef9876543210, 64'h0123456789ABCDEF, 64'ha4688b153da3f95b);\n    Single_test(192'h0123456789abcdeffedcba9876543210abcdef9876543210, 64'hFEDCBA9876543210, 64'h7b9325d305515107);\n    Single_test(192'hBEBACAFE12345678B1FECAFE876543219898898974744747, 64'hFEDCBA9876543210, 64'h71f4eedd55b0f964);\n    Single_test(192'hBEBACAFE12345678B1FECAFE876543219898898974744747, 64'hB1FECAFEBEBAB1FE, 64'h2038ea8568d3f771);\n\n    $display(\"\\nBurst Test\");\n    Burst_test();\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/des3_enc.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n", "src/.env": "VERILOG_SOURCES = /code/rtl/des3_enc.sv /code/rtl/des_dec.sv /code/rtl/des_enc.sv /code/rtl/S1.sv /code/rtl/S2.sv /code/rtl/S3.sv /code/rtl/S4.sv /code/rtl/S5.sv /code/rtl/S6.sv /code/rtl/S7.sv /code/rtl/S8.sv\nTOPLEVEL        = des3_enc\nMODULE          = test_des3_enc\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 5-create-des3-enc\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass des:\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.data_out = 0\n        self.enc_out = 0\n        self.dec_out = 0\n        self.fifo = []\n\n    def permute(self, block, table, n):\n        result = 0\n        for i in range(len(table)):\n            bit = (block >> (n - table[i])) & 1\n            result |= (bit << (len(table) - 1 - i))\n        return result\n\n    def left_rotate(self, val, n):\n        return ((val << n) & 0x0FFFFFFF) | (val >> (28 - n))\n\n    def sbox(self, box, val):\n        row = ((val >> 5) & 1) * 2 + (val & 1)\n        col = (val >> 1) & 0xF\n        return box[row][col]\n\n    def f(self, R, subkey):\n        E = [32,1,2,3,4,5,4,5,6,7,8,9,\n             8,9,10,11,12,13,12,13,14,15,16,17,\n             16,17,18,19,20,21,20,21,22,23,24,25,\n             24,25,26,27,28,29,28,29,30,31,32,1]\n\n        P = [16,7,20,21,29,12,28,17,\n             1,15,23,26,5,18,31,10,\n             2,8,24,14,32,27,3,9,\n             19,13,30,6,22,11,4,25]\n\n        SBOXES = self.sboxes\n\n        expanded = self.permute(R << 32, E, 64)\n        xored = expanded ^ subkey\n\n        output = 0\n        for i in range(8):\n            chunk = (xored >> (42 - i*6)) & 0x3F\n            sbox_val = self.sbox(SBOXES[i], chunk)\n            output = (output << 4) | sbox_val\n\n        return self.permute(output << 32, P, 64)\n\n    def generate_subkeys(self, key):\n        PC1 = [57,49,41,33,25,17,9,\n               1,58,50,42,34,26,18,\n               10,2,59,51,43,35,27,\n               19,11,3,60,52,44,36,\n               63,55,47,39,31,23,15,\n               7,62,54,46,38,30,22,\n               14,6,61,53,45,37,29,\n               21,13,5,28,20,12,4]\n\n        PC2 = [14,17,11,24,1,5,\n               3,28,15,6,21,10,\n               23,19,12,4,26,8,\n               16,7,27,20,13,2,\n               41,52,31,37,47,55,\n               30,40,51,45,33,48,\n               44,49,39,56,34,53,\n               46,42,50,36,29,32]\n\n        rotations = [1, 1, 2, 2, 2, 2, 2, 2,\n                     1, 2, 2, 2, 2, 2, 2, 1]\n\n        key56 = self.permute(key, PC1, 64)\n        C = (key56 >> 28) & 0xFFFFFFF\n        D = key56 & 0xFFFFFFF\n\n        subkeys = []\n        for rot in rotations:\n            C = self.left_rotate(C, rot)\n            D = self.left_rotate(D, rot)\n            CD = (C << 28) | D\n            subkey = self.permute(CD, PC2, 56)\n            subkeys.append(subkey)\n        return subkeys\n    \n    def decrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)[::-1]  # Reverse subkeys for decryption\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.dec_out = self.permute(pre_output, FP, 64)\n\n    def encrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.enc_out = self.permute(pre_output, FP, 64)\n    \n    def des3_enc(self, data, key):\n        K1 = (key & 0xFFFFFFFFFFFFFFFF00000000000000000000000000000000) >> 128\n        K2 = (key & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64\n        K3 = key & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFF\n        self.encrypt(data, K1)\n        self.decrypt(self.enc_out, K2)\n        self.encrypt(self.dec_out, K3)\n\n        self.fifo.append(self.enc_out)\n    \n    def read_data(self):\n        if self.fifo:\n            return self.fifo.pop(0)\n        return 0\n\n    # Full DES S-box definitions\n    sboxes = [\n        [\n            [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n            [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n            [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n            [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13]\n        ],\n        [\n            [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10],\n            [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5],\n            [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15],\n            [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9]\n        ],\n        [\n            [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8],\n            [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1],\n            [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7],\n            [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12]\n        ],\n        [\n            [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15],\n            [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9],\n            [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4],\n            [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14]\n        ],\n        [\n            [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9],\n            [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6],\n            [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14],\n            [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3]\n        ],\n        [\n            [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11],\n            [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8],\n            [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6],\n            [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13]\n        ],\n        [\n            [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1],\n            [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6],\n            [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2],\n            [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12]\n        ],\n        [\n            [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7],\n            [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2],\n            [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8],\n            [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]\n        ]\n    ]", "src/test_des3_enc.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data   = dut.o_data.value.to_unsigned()\n    model_data = model.read_data()\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_des3_enc(dut):\n    \"\"\"Test the des3_enc module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n\n    model = hrs_lb.des()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**64 - 1\n\n    key_min  = 0\n    key_max  = 2**192 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_valid.value     = 0\n        dut.i_data.value      = 0\n        dut.i_key.value       = 0\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        # Latency check\n        key   = random.randint(key_min , key_max )\n        data  = random.randint(data_min, data_max)\n        valid = 1\n\n        await FallingEdge(dut.clk)\n        dut.i_data.value  = data\n        dut.i_key.value   = key\n        dut.i_valid.value = valid\n\n        model.des3_enc(data, key)\n        await FallingEdge(dut.clk)\n        latency_counter = 1\n        dut.i_valid.value = 0\n\n        while dut.o_valid.value == 0:\n            latency_counter = latency_counter + 1\n            await FallingEdge(dut.clk)\n        \n        assert latency_counter == 48, f\"[ERROR] DUT latency must be 48 clock cycles\"\n        \n        compare_values(dut, model)\n\n        for j in range(runs):\n            if (j+1)%500 == 0:\n                print(f'\\n------ Reset {i}, run {j+1} ------')\n\n            key   = random.randint(key_min , key_max )\n            data  = random.randint(data_min, data_max)\n            valid = random.randint(0,1)\n\n            await FallingEdge(dut.clk)\n\n            dut.i_data.value  = data\n            dut.i_key.value   = key\n            dut.i_valid.value = valid\n            if valid:\n                model.des3_enc(data, key)\n\n            if dut.o_valid.value == 1:\n                compare_values(dut, model)\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()"}}
{"id": "cvdp_agentic_azure_sapphire_tiger_4476", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "Integrate the `des_enc` and `des_dec` modules to perform the Triple Data Encryption Standard (TDES) decryption. This new module must not allow burst operations; instead, it must perform start/done controlled operations, where whenever a start occurs, the done signal must be de-asserted, and any data, key, or start signals are ignored until the done signal is asserted again. A testbench for this new module is available at `verif/tb_3des_dec.sv`.\n\nAlso, update the `des_enc` and `des_dec` so that the `o_valid` signal from their interface and all logic related to them are removed, and `i_valid` input signal is renamed to `i_start`.\n\n---\n\n## Specifications\n\n- **Module Name**: `des3_dec`\n\n- **File Name**: `des3_dec.sv` (to be added in `rtl` directory)\n\n- **Parameters**:\n    - `NBW_DATA`: Bit width of the input and output data blocks.\n        - Default: 64.\n        - Related interface signals: `i_data`, `o_data`.\n    - `NBW_KEY`: Bit width of the key.\n        - Default: 192.\n        - Related interface signal: `i_key`.  \n        - The 192-bit key is interpreted as three concatenated 64-bit DES keys (K1, K2, K3) used for Triple DES decryption, where `K1 = i_key[1:64]`, K2 = `i_key[65:128]`, and `K3 = i_key[129:192]`.\n\n- **Functionality**: Implements 3DES decryption in DED (Decrypt-Encrypt-Decrypt) mode using three 64-bit keys (K3, K2, K1). The input ciphertext is decrypted with K3, encrypted with K2, and decrypted again with K1.\n\n- **Latency**: The block's latency, from when `i_start` is read until `o_done` is asserted, is **48 cycles**, where each DES stage takes 16 cycles.\n\n---\n\n## Interface Signals\n\n  | Signal              | Direction | Width            | Description                                                                                                                           |\n  |---------------------|-----------|------------------|---------------------------------------------------------------------------------------------------------------------------------------|\n  | `clk`               | Input     | 1                | Drives the sequential logic on the rising edge.                                                                                       |\n  | `rst_async_n`       | Input     | 1                | Active-low asynchronous reset; clears all internal registers and state.                                                               |\n  | `i_start`           | Input     | 1                | Active high. Indicates that `i_data` and `i_key` are valid and ready to be processed.                                                 |\n  | `i_data`            | Input     | [1:NBW_DATA]     | 64-bit ciphertext input block (MSB-first).                                                                                            |\n  | `i_key`             | Input     | [1:NBW_KEY]      | 192-bit 3DES key, treated as three concatenated 64-bit keys: `{K1, K2, K3}`.                                                          |\n  | `o_done`            | Output    | 1                | Asserted high when `o_data` contains valid encrypted data. It remains asserted until a new `i_start` signal is received.              |\n  | `o_data`            | Output    | [1:NBW_DATA]     | 64-bit plaintext output block (MSB-first). After the decryption is calculated, it must remain stable until a next decryption is done. |\n", "context": {"rtl/S1.sv": "module S1(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd14;\n        6'b0_0001_0 : o_data = 4'd4;\n        6'b0_0010_0 : o_data = 4'd13;\n        6'b0_0011_0 : o_data = 4'd1;\n        6'b0_0100_0 : o_data = 4'd2;\n        6'b0_0101_0 : o_data = 4'd15;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd8;\n        6'b0_1000_0 : o_data = 4'd3;\n        6'b0_1001_0 : o_data = 4'd10;\n        6'b0_1010_0 : o_data = 4'd6;\n        6'b0_1011_0 : o_data = 4'd12;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd9;\n        6'b0_1110_0 : o_data = 4'd0;\n        6'b0_1111_0 : o_data = 4'd7;\n        6'b0_0000_1 : o_data = 4'd0;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd7;\n        6'b0_0011_1 : o_data = 4'd4;\n        6'b0_0100_1 : o_data = 4'd14;\n        6'b0_0101_1 : o_data = 4'd2;\n        6'b0_0110_1 : o_data = 4'd13;\n        6'b0_0111_1 : o_data = 4'd1;\n        6'b0_1000_1 : o_data = 4'd10;\n        6'b0_1001_1 : o_data = 4'd6;\n        6'b0_1010_1 : o_data = 4'd12;\n        6'b0_1011_1 : o_data = 4'd11;\n        6'b0_1100_1 : o_data = 4'd9;\n        6'b0_1101_1 : o_data = 4'd5;\n        6'b0_1110_1 : o_data = 4'd3;\n        6'b0_1111_1 : o_data = 4'd8;\n        6'b1_0000_0 : o_data = 4'd4;\n        6'b1_0001_0 : o_data = 4'd1;\n        6'b1_0010_0 : o_data = 4'd14;\n        6'b1_0011_0 : o_data = 4'd8;\n        6'b1_0100_0 : o_data = 4'd13;\n        6'b1_0101_0 : o_data = 4'd6;\n        6'b1_0110_0 : o_data = 4'd2;\n        6'b1_0111_0 : o_data = 4'd11;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd12;\n        6'b1_1010_0 : o_data = 4'd9;\n        6'b1_1011_0 : o_data = 4'd7;\n        6'b1_1100_0 : o_data = 4'd3;\n        6'b1_1101_0 : o_data = 4'd10;\n        6'b1_1110_0 : o_data = 4'd5;\n        6'b1_1111_0 : o_data = 4'd0;\n        6'b1_0000_1 : o_data = 4'd15;\n        6'b1_0001_1 : o_data = 4'd12;\n        6'b1_0010_1 : o_data = 4'd8;\n        6'b1_0011_1 : o_data = 4'd2;\n        6'b1_0100_1 : o_data = 4'd4;\n        6'b1_0101_1 : o_data = 4'd9;\n        6'b1_0110_1 : o_data = 4'd1;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd5;\n        6'b1_1001_1 : o_data = 4'd11;\n        6'b1_1010_1 : o_data = 4'd3;\n        6'b1_1011_1 : o_data = 4'd14;\n        6'b1_1100_1 : o_data = 4'd10;\n        6'b1_1101_1 : o_data = 4'd0;\n        6'b1_1110_1 : o_data = 4'd6;\n        6'b1_1111_1 : o_data = 4'd13;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S1", "rtl/S2.sv": "module S2(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd15;\n        6'b0_0001_0 : o_data = 4'd1;\n        6'b0_0010_0 : o_data = 4'd8;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd11;\n        6'b0_0110_0 : o_data = 4'd3;\n        6'b0_0111_0 : o_data = 4'd4;\n        6'b0_1000_0 : o_data = 4'd9;\n        6'b0_1001_0 : o_data = 4'd7;\n        6'b0_1010_0 : o_data = 4'd2;\n        6'b0_1011_0 : o_data = 4'd13;\n        6'b0_1100_0 : o_data = 4'd12;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd5;\n        6'b0_1111_0 : o_data = 4'd10;\n        6'b0_0000_1 : o_data = 4'd3;\n        6'b0_0001_1 : o_data = 4'd13;\n        6'b0_0010_1 : o_data = 4'd4;\n        6'b0_0011_1 : o_data = 4'd7;\n        6'b0_0100_1 : o_data = 4'd15;\n        6'b0_0101_1 : o_data = 4'd2;\n        6'b0_0110_1 : o_data = 4'd8;\n        6'b0_0111_1 : o_data = 4'd14;\n        6'b0_1000_1 : o_data = 4'd12;\n        6'b0_1001_1 : o_data = 4'd0;\n        6'b0_1010_1 : o_data = 4'd1;\n        6'b0_1011_1 : o_data = 4'd10;\n        6'b0_1100_1 : o_data = 4'd6;\n        6'b0_1101_1 : o_data = 4'd9;\n        6'b0_1110_1 : o_data = 4'd11;\n        6'b0_1111_1 : o_data = 4'd5;\n        6'b1_0000_0 : o_data = 4'd0;\n        6'b1_0001_0 : o_data = 4'd14;\n        6'b1_0010_0 : o_data = 4'd7;\n        6'b1_0011_0 : o_data = 4'd11;\n        6'b1_0100_0 : o_data = 4'd10;\n        6'b1_0101_0 : o_data = 4'd4;\n        6'b1_0110_0 : o_data = 4'd13;\n        6'b1_0111_0 : o_data = 4'd1;\n        6'b1_1000_0 : o_data = 4'd5;\n        6'b1_1001_0 : o_data = 4'd8;\n        6'b1_1010_0 : o_data = 4'd12;\n        6'b1_1011_0 : o_data = 4'd6;\n        6'b1_1100_0 : o_data = 4'd9;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd2;\n        6'b1_1111_0 : o_data = 4'd15;\n        6'b1_0000_1 : o_data = 4'd13;\n        6'b1_0001_1 : o_data = 4'd8;\n        6'b1_0010_1 : o_data = 4'd10;\n        6'b1_0011_1 : o_data = 4'd1;\n        6'b1_0100_1 : o_data = 4'd3;\n        6'b1_0101_1 : o_data = 4'd15;\n        6'b1_0110_1 : o_data = 4'd4;\n        6'b1_0111_1 : o_data = 4'd2;\n        6'b1_1000_1 : o_data = 4'd11;\n        6'b1_1001_1 : o_data = 4'd6;\n        6'b1_1010_1 : o_data = 4'd7;\n        6'b1_1011_1 : o_data = 4'd12;\n        6'b1_1100_1 : o_data = 4'd0;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd14;\n        6'b1_1111_1 : o_data = 4'd9;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S2", "rtl/S3.sv": "module S3(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd10;\n        6'b0_0001_0 : o_data = 4'd0;\n        6'b0_0010_0 : o_data = 4'd9;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd3;\n        6'b0_0110_0 : o_data = 4'd15;\n        6'b0_0111_0 : o_data = 4'd5;\n        6'b0_1000_0 : o_data = 4'd1;\n        6'b0_1001_0 : o_data = 4'd13;\n        6'b0_1010_0 : o_data = 4'd12;\n        6'b0_1011_0 : o_data = 4'd7;\n        6'b0_1100_0 : o_data = 4'd11;\n        6'b0_1101_0 : o_data = 4'd4;\n        6'b0_1110_0 : o_data = 4'd2;\n        6'b0_1111_0 : o_data = 4'd8;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd7;\n        6'b0_0010_1 : o_data = 4'd0;\n        6'b0_0011_1 : o_data = 4'd9;\n        6'b0_0100_1 : o_data = 4'd3;\n        6'b0_0101_1 : o_data = 4'd4;\n        6'b0_0110_1 : o_data = 4'd6;\n        6'b0_0111_1 : o_data = 4'd10;\n        6'b0_1000_1 : o_data = 4'd2;\n        6'b0_1001_1 : o_data = 4'd8;\n        6'b0_1010_1 : o_data = 4'd5;\n        6'b0_1011_1 : o_data = 4'd14;\n        6'b0_1100_1 : o_data = 4'd12;\n        6'b0_1101_1 : o_data = 4'd11;\n        6'b0_1110_1 : o_data = 4'd15;\n        6'b0_1111_1 : o_data = 4'd1;\n        6'b1_0000_0 : o_data = 4'd13;\n        6'b1_0001_0 : o_data = 4'd6;\n        6'b1_0010_0 : o_data = 4'd4;\n        6'b1_0011_0 : o_data = 4'd9;\n        6'b1_0100_0 : o_data = 4'd8;\n        6'b1_0101_0 : o_data = 4'd15;\n        6'b1_0110_0 : o_data = 4'd3;\n        6'b1_0111_0 : o_data = 4'd0;\n        6'b1_1000_0 : o_data = 4'd11;\n        6'b1_1001_0 : o_data = 4'd1;\n        6'b1_1010_0 : o_data = 4'd2;\n        6'b1_1011_0 : o_data = 4'd12;\n        6'b1_1100_0 : o_data = 4'd5;\n        6'b1_1101_0 : o_data = 4'd10;\n        6'b1_1110_0 : o_data = 4'd14;\n        6'b1_1111_0 : o_data = 4'd7;\n        6'b1_0000_1 : o_data = 4'd1;\n        6'b1_0001_1 : o_data = 4'd10;\n        6'b1_0010_1 : o_data = 4'd13;\n        6'b1_0011_1 : o_data = 4'd0;\n        6'b1_0100_1 : o_data = 4'd6;\n        6'b1_0101_1 : o_data = 4'd9;\n        6'b1_0110_1 : o_data = 4'd8;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd4;\n        6'b1_1001_1 : o_data = 4'd15;\n        6'b1_1010_1 : o_data = 4'd14;\n        6'b1_1011_1 : o_data = 4'd3;\n        6'b1_1100_1 : o_data = 4'd11;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd2;\n        6'b1_1111_1 : o_data = 4'd12;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S3", "rtl/S4.sv": "module S4(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd7;\n        6'b0_0001_0 : o_data = 4'd13;\n        6'b0_0010_0 : o_data = 4'd14;\n        6'b0_0011_0 : o_data = 4'd3;\n        6'b0_0100_0 : o_data = 4'd0;\n        6'b0_0101_0 : o_data = 4'd6;\n        6'b0_0110_0 : o_data = 4'd9;\n        6'b0_0111_0 : o_data = 4'd10;\n        6'b0_1000_0 : o_data = 4'd1;\n        6'b0_1001_0 : o_data = 4'd2;\n        6'b0_1010_0 : o_data = 4'd8;\n        6'b0_1011_0 : o_data = 4'd5;\n        6'b0_1100_0 : o_data = 4'd11;\n        6'b0_1101_0 : o_data = 4'd12;\n        6'b0_1110_0 : o_data = 4'd4;\n        6'b0_1111_0 : o_data = 4'd15;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd8;\n        6'b0_0010_1 : o_data = 4'd11;\n        6'b0_0011_1 : o_data = 4'd5;\n        6'b0_0100_1 : o_data = 4'd6;\n        6'b0_0101_1 : o_data = 4'd15;\n        6'b0_0110_1 : o_data = 4'd0;\n        6'b0_0111_1 : o_data = 4'd3;\n        6'b0_1000_1 : o_data = 4'd4;\n        6'b0_1001_1 : o_data = 4'd7;\n        6'b0_1010_1 : o_data = 4'd2;\n        6'b0_1011_1 : o_data = 4'd12;\n        6'b0_1100_1 : o_data = 4'd1;\n        6'b0_1101_1 : o_data = 4'd10;\n        6'b0_1110_1 : o_data = 4'd14;\n        6'b0_1111_1 : o_data = 4'd9;\n        6'b1_0000_0 : o_data = 4'd10;\n        6'b1_0001_0 : o_data = 4'd6;\n        6'b1_0010_0 : o_data = 4'd9;\n        6'b1_0011_0 : o_data = 4'd0;\n        6'b1_0100_0 : o_data = 4'd12;\n        6'b1_0101_0 : o_data = 4'd11;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd13;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd1;\n        6'b1_1010_0 : o_data = 4'd3;\n        6'b1_1011_0 : o_data = 4'd14;\n        6'b1_1100_0 : o_data = 4'd5;\n        6'b1_1101_0 : o_data = 4'd2;\n        6'b1_1110_0 : o_data = 4'd8;\n        6'b1_1111_0 : o_data = 4'd4;\n        6'b1_0000_1 : o_data = 4'd3;\n        6'b1_0001_1 : o_data = 4'd15;\n        6'b1_0010_1 : o_data = 4'd0;\n        6'b1_0011_1 : o_data = 4'd6;\n        6'b1_0100_1 : o_data = 4'd10;\n        6'b1_0101_1 : o_data = 4'd1;\n        6'b1_0110_1 : o_data = 4'd13;\n        6'b1_0111_1 : o_data = 4'd8;\n        6'b1_1000_1 : o_data = 4'd9;\n        6'b1_1001_1 : o_data = 4'd4;\n        6'b1_1010_1 : o_data = 4'd5;\n        6'b1_1011_1 : o_data = 4'd11;\n        6'b1_1100_1 : o_data = 4'd12;\n        6'b1_1101_1 : o_data = 4'd7;\n        6'b1_1110_1 : o_data = 4'd2;\n        6'b1_1111_1 : o_data = 4'd14;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S4", "rtl/S5.sv": "module S5(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd2;\n        6'b0_0001_0 : o_data = 4'd12;\n        6'b0_0010_0 : o_data = 4'd4;\n        6'b0_0011_0 : o_data = 4'd1;\n        6'b0_0100_0 : o_data = 4'd7;\n        6'b0_0101_0 : o_data = 4'd10;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd6;\n        6'b0_1000_0 : o_data = 4'd8;\n        6'b0_1001_0 : o_data = 4'd5;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd15;\n        6'b0_1100_0 : o_data = 4'd13;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd14;\n        6'b0_1111_0 : o_data = 4'd9;\n        6'b0_0000_1 : o_data = 4'd14;\n        6'b0_0001_1 : o_data = 4'd11;\n        6'b0_0010_1 : o_data = 4'd2;\n        6'b0_0011_1 : o_data = 4'd12;\n        6'b0_0100_1 : o_data = 4'd4;\n        6'b0_0101_1 : o_data = 4'd7;\n        6'b0_0110_1 : o_data = 4'd13;\n        6'b0_0111_1 : o_data = 4'd1;\n        6'b0_1000_1 : o_data = 4'd5;\n        6'b0_1001_1 : o_data = 4'd0;\n        6'b0_1010_1 : o_data = 4'd15;\n        6'b0_1011_1 : o_data = 4'd10;\n        6'b0_1100_1 : o_data = 4'd3;\n        6'b0_1101_1 : o_data = 4'd9;\n        6'b0_1110_1 : o_data = 4'd8;\n        6'b0_1111_1 : o_data = 4'd6;\n        6'b1_0000_0 : o_data = 4'd4;\n        6'b1_0001_0 : o_data = 4'd2;\n        6'b1_0010_0 : o_data = 4'd1;\n        6'b1_0011_0 : o_data = 4'd11;\n        6'b1_0100_0 : o_data = 4'd10;\n        6'b1_0101_0 : o_data = 4'd13;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd8;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd9;\n        6'b1_1010_0 : o_data = 4'd12;\n        6'b1_1011_0 : o_data = 4'd5;\n        6'b1_1100_0 : o_data = 4'd6;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd0;\n        6'b1_1111_0 : o_data = 4'd14;\n        6'b1_0000_1 : o_data = 4'd11;\n        6'b1_0001_1 : o_data = 4'd8;\n        6'b1_0010_1 : o_data = 4'd12;\n        6'b1_0011_1 : o_data = 4'd7;\n        6'b1_0100_1 : o_data = 4'd1;\n        6'b1_0101_1 : o_data = 4'd14;\n        6'b1_0110_1 : o_data = 4'd2;\n        6'b1_0111_1 : o_data = 4'd13;\n        6'b1_1000_1 : o_data = 4'd6;\n        6'b1_1001_1 : o_data = 4'd15;\n        6'b1_1010_1 : o_data = 4'd0;\n        6'b1_1011_1 : o_data = 4'd9;\n        6'b1_1100_1 : o_data = 4'd10;\n        6'b1_1101_1 : o_data = 4'd4;\n        6'b1_1110_1 : o_data = 4'd5;\n        6'b1_1111_1 : o_data = 4'd3;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S5", "rtl/S6.sv": "module S6(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd12;\n        6'b0_0001_0 : o_data = 4'd1;\n        6'b0_0010_0 : o_data = 4'd10;\n        6'b0_0011_0 : o_data = 4'd15;\n        6'b0_0100_0 : o_data = 4'd9;\n        6'b0_0101_0 : o_data = 4'd2;\n        6'b0_0110_0 : o_data = 4'd6;\n        6'b0_0111_0 : o_data = 4'd8;\n        6'b0_1000_0 : o_data = 4'd0;\n        6'b0_1001_0 : o_data = 4'd13;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd4;\n        6'b0_1100_0 : o_data = 4'd14;\n        6'b0_1101_0 : o_data = 4'd7;\n        6'b0_1110_0 : o_data = 4'd5;\n        6'b0_1111_0 : o_data = 4'd11;\n        6'b0_0000_1 : o_data = 4'd10;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd4;\n        6'b0_0011_1 : o_data = 4'd2;\n        6'b0_0100_1 : o_data = 4'd7;\n        6'b0_0101_1 : o_data = 4'd12;\n        6'b0_0110_1 : o_data = 4'd9;\n        6'b0_0111_1 : o_data = 4'd5;\n        6'b0_1000_1 : o_data = 4'd6;\n        6'b0_1001_1 : o_data = 4'd1;\n        6'b0_1010_1 : o_data = 4'd13;\n        6'b0_1011_1 : o_data = 4'd14;\n        6'b0_1100_1 : o_data = 4'd0;\n        6'b0_1101_1 : o_data = 4'd11;\n        6'b0_1110_1 : o_data = 4'd3;\n        6'b0_1111_1 : o_data = 4'd8;\n        6'b1_0000_0 : o_data = 4'd9;\n        6'b1_0001_0 : o_data = 4'd14;\n        6'b1_0010_0 : o_data = 4'd15;\n        6'b1_0011_0 : o_data = 4'd5;\n        6'b1_0100_0 : o_data = 4'd2;\n        6'b1_0101_0 : o_data = 4'd8;\n        6'b1_0110_0 : o_data = 4'd12;\n        6'b1_0111_0 : o_data = 4'd3;\n        6'b1_1000_0 : o_data = 4'd7;\n        6'b1_1001_0 : o_data = 4'd0;\n        6'b1_1010_0 : o_data = 4'd4;\n        6'b1_1011_0 : o_data = 4'd10;\n        6'b1_1100_0 : o_data = 4'd1;\n        6'b1_1101_0 : o_data = 4'd13;\n        6'b1_1110_0 : o_data = 4'd11;\n        6'b1_1111_0 : o_data = 4'd6;\n        6'b1_0000_1 : o_data = 4'd4;\n        6'b1_0001_1 : o_data = 4'd3;\n        6'b1_0010_1 : o_data = 4'd2;\n        6'b1_0011_1 : o_data = 4'd12;\n        6'b1_0100_1 : o_data = 4'd9;\n        6'b1_0101_1 : o_data = 4'd5;\n        6'b1_0110_1 : o_data = 4'd15;\n        6'b1_0111_1 : o_data = 4'd10;\n        6'b1_1000_1 : o_data = 4'd11;\n        6'b1_1001_1 : o_data = 4'd14;\n        6'b1_1010_1 : o_data = 4'd1;\n        6'b1_1011_1 : o_data = 4'd7;\n        6'b1_1100_1 : o_data = 4'd6;\n        6'b1_1101_1 : o_data = 4'd0;\n        6'b1_1110_1 : o_data = 4'd8;\n        6'b1_1111_1 : o_data = 4'd13;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S6", "rtl/S7.sv": "module S7(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd4;\n        6'b0_0001_0 : o_data = 4'd11;\n        6'b0_0010_0 : o_data = 4'd2;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd15;\n        6'b0_0101_0 : o_data = 4'd0;\n        6'b0_0110_0 : o_data = 4'd8;\n        6'b0_0111_0 : o_data = 4'd13;\n        6'b0_1000_0 : o_data = 4'd3;\n        6'b0_1001_0 : o_data = 4'd12;\n        6'b0_1010_0 : o_data = 4'd9;\n        6'b0_1011_0 : o_data = 4'd7;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd10;\n        6'b0_1110_0 : o_data = 4'd6;\n        6'b0_1111_0 : o_data = 4'd1;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd0;\n        6'b0_0010_1 : o_data = 4'd11;\n        6'b0_0011_1 : o_data = 4'd7;\n        6'b0_0100_1 : o_data = 4'd4;\n        6'b0_0101_1 : o_data = 4'd9;\n        6'b0_0110_1 : o_data = 4'd1;\n        6'b0_0111_1 : o_data = 4'd10;\n        6'b0_1000_1 : o_data = 4'd14;\n        6'b0_1001_1 : o_data = 4'd3;\n        6'b0_1010_1 : o_data = 4'd5;\n        6'b0_1011_1 : o_data = 4'd12;\n        6'b0_1100_1 : o_data = 4'd2;\n        6'b0_1101_1 : o_data = 4'd15;\n        6'b0_1110_1 : o_data = 4'd8;\n        6'b0_1111_1 : o_data = 4'd6;\n        6'b1_0000_0 : o_data = 4'd1;\n        6'b1_0001_0 : o_data = 4'd4;\n        6'b1_0010_0 : o_data = 4'd11;\n        6'b1_0011_0 : o_data = 4'd13;\n        6'b1_0100_0 : o_data = 4'd12;\n        6'b1_0101_0 : o_data = 4'd3;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd14;\n        6'b1_1000_0 : o_data = 4'd10;\n        6'b1_1001_0 : o_data = 4'd15;\n        6'b1_1010_0 : o_data = 4'd6;\n        6'b1_1011_0 : o_data = 4'd8;\n        6'b1_1100_0 : o_data = 4'd0;\n        6'b1_1101_0 : o_data = 4'd5;\n        6'b1_1110_0 : o_data = 4'd9;\n        6'b1_1111_0 : o_data = 4'd2;\n        6'b1_0000_1 : o_data = 4'd6;\n        6'b1_0001_1 : o_data = 4'd11;\n        6'b1_0010_1 : o_data = 4'd13;\n        6'b1_0011_1 : o_data = 4'd8;\n        6'b1_0100_1 : o_data = 4'd1;\n        6'b1_0101_1 : o_data = 4'd4;\n        6'b1_0110_1 : o_data = 4'd10;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd9;\n        6'b1_1001_1 : o_data = 4'd5;\n        6'b1_1010_1 : o_data = 4'd0;\n        6'b1_1011_1 : o_data = 4'd15;\n        6'b1_1100_1 : o_data = 4'd14;\n        6'b1_1101_1 : o_data = 4'd2;\n        6'b1_1110_1 : o_data = 4'd3;\n        6'b1_1111_1 : o_data = 4'd12;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S7", "rtl/S8.sv": "module S8(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd13;\n        6'b0_0001_0 : o_data = 4'd2;\n        6'b0_0010_0 : o_data = 4'd8;\n        6'b0_0011_0 : o_data = 4'd4;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd15;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd1;\n        6'b0_1000_0 : o_data = 4'd10;\n        6'b0_1001_0 : o_data = 4'd9;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd14;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd12;\n        6'b0_1111_0 : o_data = 4'd7;\n        6'b0_0000_1 : o_data = 4'd1;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd13;\n        6'b0_0011_1 : o_data = 4'd8;\n        6'b0_0100_1 : o_data = 4'd10;\n        6'b0_0101_1 : o_data = 4'd3;\n        6'b0_0110_1 : o_data = 4'd7;\n        6'b0_0111_1 : o_data = 4'd4;\n        6'b0_1000_1 : o_data = 4'd12;\n        6'b0_1001_1 : o_data = 4'd5;\n        6'b0_1010_1 : o_data = 4'd6;\n        6'b0_1011_1 : o_data = 4'd11;\n        6'b0_1100_1 : o_data = 4'd0;\n        6'b0_1101_1 : o_data = 4'd14;\n        6'b0_1110_1 : o_data = 4'd9;\n        6'b0_1111_1 : o_data = 4'd2;\n        6'b1_0000_0 : o_data = 4'd7;\n        6'b1_0001_0 : o_data = 4'd11;\n        6'b1_0010_0 : o_data = 4'd4;\n        6'b1_0011_0 : o_data = 4'd1;\n        6'b1_0100_0 : o_data = 4'd9;\n        6'b1_0101_0 : o_data = 4'd12;\n        6'b1_0110_0 : o_data = 4'd14;\n        6'b1_0111_0 : o_data = 4'd2;\n        6'b1_1000_0 : o_data = 4'd0;\n        6'b1_1001_0 : o_data = 4'd6;\n        6'b1_1010_0 : o_data = 4'd10;\n        6'b1_1011_0 : o_data = 4'd13;\n        6'b1_1100_0 : o_data = 4'd15;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd5;\n        6'b1_1111_0 : o_data = 4'd8;\n        6'b1_0000_1 : o_data = 4'd2;\n        6'b1_0001_1 : o_data = 4'd1;\n        6'b1_0010_1 : o_data = 4'd14;\n        6'b1_0011_1 : o_data = 4'd7;\n        6'b1_0100_1 : o_data = 4'd4;\n        6'b1_0101_1 : o_data = 4'd10;\n        6'b1_0110_1 : o_data = 4'd8;\n        6'b1_0111_1 : o_data = 4'd13;\n        6'b1_1000_1 : o_data = 4'd15;\n        6'b1_1001_1 : o_data = 4'd12;\n        6'b1_1010_1 : o_data = 4'd9;\n        6'b1_1011_1 : o_data = 4'd0;\n        6'b1_1100_1 : o_data = 4'd3;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd6;\n        6'b1_1111_1 : o_data = 4'd11;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S8", "rtl/des_dec.sv": "module des_dec #(\n    parameter NBW_DATA = 'd64,\n    parameter NBW_KEY  = 'd64\n) (\n    input  logic              clk,\n    input  logic              rst_async_n,\n    input  logic              i_valid,\n    input  logic [1:NBW_DATA] i_data,\n    input  logic [1:NBW_KEY]  i_key,\n    output logic              o_valid,\n    output logic [1:NBW_DATA] o_data\n);\n\nlocalparam ROUNDS = 'd16;\nlocalparam EXPANDED_BLOCK = 'd48;\nlocalparam USED_KEY = 'd56;\n\nlogic [1:(NBW_DATA/2)] L16;\nlogic [1:(NBW_DATA/2)] R16;\nlogic [1:(NBW_DATA/2)] L_ff [0:ROUNDS-1];\nlogic [1:(NBW_DATA/2)] R_ff [0:ROUNDS-1];\nlogic [1:(USED_KEY/2)] C16;\nlogic [1:(USED_KEY/2)] D16;\nlogic [1:(USED_KEY/2)] C_ff [0:ROUNDS-1];\nlogic [1:(USED_KEY/2)] D_ff [0:ROUNDS-1];\nlogic [1:NBW_DATA]     last_perm;\nlogic [ROUNDS-1:0]     valid_ff;\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        valid_ff <= 0;\n    end else begin\n        valid_ff <= {valid_ff[ROUNDS-2:0], i_valid};\n    end\nend\n\nassign o_valid = valid_ff[ROUNDS-1];\n\nassign R16 = {i_data[58], i_data[50], i_data[42], i_data[34], i_data[26], i_data[18], i_data[10], i_data[2],\n              i_data[60], i_data[52], i_data[44], i_data[36], i_data[28], i_data[20], i_data[12], i_data[4],\n              i_data[62], i_data[54], i_data[46], i_data[38], i_data[30], i_data[22], i_data[14], i_data[6],\n              i_data[64], i_data[56], i_data[48], i_data[40], i_data[32], i_data[24], i_data[16], i_data[8]};\n\nassign L16 = {i_data[57], i_data[49], i_data[41], i_data[33], i_data[25], i_data[17], i_data[ 9], i_data[1],\n              i_data[59], i_data[51], i_data[43], i_data[35], i_data[27], i_data[19], i_data[11], i_data[3],\n              i_data[61], i_data[53], i_data[45], i_data[37], i_data[29], i_data[21], i_data[13], i_data[5],\n              i_data[63], i_data[55], i_data[47], i_data[39], i_data[31], i_data[23], i_data[15], i_data[7]};\n\nassign C16 = {i_key[57], i_key[49], i_key[41], i_key[33], i_key[25], i_key[17], i_key[ 9],\n              i_key[ 1], i_key[58], i_key[50], i_key[42], i_key[34], i_key[26], i_key[18],\n              i_key[10], i_key[ 2], i_key[59], i_key[51], i_key[43], i_key[35], i_key[27],\n              i_key[19], i_key[11], i_key[ 3], i_key[60], i_key[52], i_key[44], i_key[36]};\n\nassign D16 = {i_key[63], i_key[55], i_key[47], i_key[39], i_key[31], i_key[23], i_key[15],\n              i_key[ 7], i_key[62], i_key[54], i_key[46], i_key[38], i_key[30], i_key[22],\n              i_key[14], i_key[ 6], i_key[61], i_key[53], i_key[45], i_key[37], i_key[29],\n              i_key[21], i_key[13], i_key[ 5], i_key[28], i_key[20], i_key[12], i_key[ 4]};\n\ngenerate\n    for (genvar i = ROUNDS-1; i >= 0; i--) begin : rounds\n        logic [1:EXPANDED_BLOCK] round_key;\n        logic [1:(USED_KEY/2)]   C_nx;\n        logic [1:(USED_KEY/2)]   D_nx;\n        logic [1:USED_KEY]       perm_ch;\n        logic [1:(NBW_DATA/2)]   L_nx;\n        logic [1:EXPANDED_BLOCK] L_expanded;\n        logic [1:6]              Primitive_input  [1:8];\n        logic [1:4]              Primitive_output [1:8];\n        logic [1:(NBW_DATA/2)]   perm_in;\n\n        if(i == 15) begin\n            assign perm_ch = {C16, D16};\n        end else begin\n            assign perm_ch = {C_ff[i+1], D_ff[i+1]};\n        end\n        assign round_key = {perm_ch[14], perm_ch[17], perm_ch[11], perm_ch[24], perm_ch[ 1], perm_ch[ 5],\n                            perm_ch[ 3], perm_ch[28], perm_ch[15], perm_ch[ 6], perm_ch[21], perm_ch[10],\n                            perm_ch[23], perm_ch[19], perm_ch[12], perm_ch[ 4], perm_ch[26], perm_ch[ 8],\n                            perm_ch[16], perm_ch[ 7], perm_ch[27], perm_ch[20], perm_ch[13], perm_ch[ 2],\n                            perm_ch[41], perm_ch[52], perm_ch[31], perm_ch[37], perm_ch[47], perm_ch[55],\n                            perm_ch[30], perm_ch[40], perm_ch[51], perm_ch[45], perm_ch[33], perm_ch[48],\n                            perm_ch[44], perm_ch[49], perm_ch[39], perm_ch[56], perm_ch[34], perm_ch[53],\n                            perm_ch[46], perm_ch[42], perm_ch[50], perm_ch[36], perm_ch[29], perm_ch[32]};\n\n        if(i == 0 || i == 1 || i == 8 || i == 15) begin\n            if(i == 15) begin\n                assign C_nx = {C16[(USED_KEY/2)], C16[1:(USED_KEY/2)-1]};\n                assign D_nx = {D16[(USED_KEY/2)], D16[1:(USED_KEY/2)-1]};\n            end else begin\n                assign C_nx = {C_ff[i+1][(USED_KEY/2)], C_ff[i+1][1:(USED_KEY/2)-1]};\n                assign D_nx = {D_ff[i+1][(USED_KEY/2)], D_ff[i+1][1:(USED_KEY/2)-1]};\n            end\n        end else begin\n            assign C_nx = {C_ff[i+1][(USED_KEY/2)-1+:2], C_ff[i+1][1:(USED_KEY/2)-2]};\n            assign D_nx = {D_ff[i+1][(USED_KEY/2)-1+:2], D_ff[i+1][1:(USED_KEY/2)-2]};\n        end\n\n        assign Primitive_input[1] = L_expanded[ 1:6 ] ^ round_key[ 1:6 ];\n        assign Primitive_input[2] = L_expanded[ 7:12] ^ round_key[ 7:12];\n        assign Primitive_input[3] = L_expanded[13:18] ^ round_key[13:18];\n        assign Primitive_input[4] = L_expanded[19:24] ^ round_key[19:24];\n        assign Primitive_input[5] = L_expanded[25:30] ^ round_key[25:30];\n        assign Primitive_input[6] = L_expanded[31:36] ^ round_key[31:36];\n        assign Primitive_input[7] = L_expanded[37:42] ^ round_key[37:42];\n        assign Primitive_input[8] = L_expanded[43:48] ^ round_key[43:48];\n\n        S1 uu_S1 (\n            .i_data(Primitive_input [1]),\n            .o_data(Primitive_output[1])\n        );\n\n        S2 uu_S2 (\n            .i_data(Primitive_input [2]),\n            .o_data(Primitive_output[2])\n        );\n\n        S3 uu_S3 (\n            .i_data(Primitive_input [3]),\n            .o_data(Primitive_output[3])\n        );\n\n        S4 uu_S4 (\n            .i_data(Primitive_input [4]),\n            .o_data(Primitive_output[4])\n        );\n\n        S5 uu_S5 (\n            .i_data(Primitive_input [5]),\n            .o_data(Primitive_output[5])\n        );\n\n        S6 uu_S6 (\n            .i_data(Primitive_input [6]),\n            .o_data(Primitive_output[6])\n        );\n\n        S7 uu_S7 (\n            .i_data(Primitive_input [7]),\n            .o_data(Primitive_output[7])\n        );\n\n        S8 uu_S8 (\n            .i_data(Primitive_input [8]),\n            .o_data(Primitive_output[8])\n        );\n\n        assign perm_in = {Primitive_output[1], Primitive_output[2], Primitive_output[3], Primitive_output[4],\n                          Primitive_output[5], Primitive_output[6], Primitive_output[7], Primitive_output[8]};\n\n        assign L_nx = {perm_in[16], perm_in[ 7], perm_in[20], perm_in[21],\n                       perm_in[29], perm_in[12], perm_in[28], perm_in[17],\n                       perm_in[ 1], perm_in[15], perm_in[23], perm_in[26],\n                       perm_in[ 5], perm_in[18], perm_in[31], perm_in[10],\n                       perm_in[ 2], perm_in[ 8], perm_in[24], perm_in[14],\n                       perm_in[32], perm_in[27], perm_in[ 3], perm_in[ 9],\n                       perm_in[19], perm_in[13], perm_in[30], perm_in[ 6],\n                       perm_in[22], perm_in[11], perm_in[ 4], perm_in[25]};\n\n        if(i == 15) begin\n            assign L_expanded = {L16[32], L16[ 1], L16[ 2], L16[ 3], L16[ 4], L16[ 5],\n                                 L16[ 4], L16[ 5], L16[ 6], L16[ 7], L16[ 8], L16[ 9],\n                                 L16[ 8], L16[ 9], L16[10], L16[11], L16[12], L16[13],\n                                 L16[12], L16[13], L16[14], L16[15], L16[16], L16[17],\n                                 L16[16], L16[17], L16[18], L16[19], L16[20], L16[21],\n                                 L16[20], L16[21], L16[22], L16[23], L16[24], L16[25],\n                                 L16[24], L16[25], L16[26], L16[27], L16[28], L16[29],\n                                 L16[28], L16[29], L16[30], L16[31], L16[32], L16[ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    if(i_valid) begin\n                        L_ff[i] <= L_nx ^ R16;\n                        R_ff[i] <= L16;\n                        C_ff[i] <= C_nx;\n                        D_ff[i] <= D_nx;\n                    end\n                end\n            end\n        end else begin\n            assign L_expanded = {L_ff[i+1][32], L_ff[i+1][ 1], L_ff[i+1][ 2], L_ff[i+1][ 3], L_ff[i+1][ 4], L_ff[i+1][ 5],\n                                 L_ff[i+1][ 4], L_ff[i+1][ 5], L_ff[i+1][ 6], L_ff[i+1][ 7], L_ff[i+1][ 8], L_ff[i+1][ 9],\n                                 L_ff[i+1][ 8], L_ff[i+1][ 9], L_ff[i+1][10], L_ff[i+1][11], L_ff[i+1][12], L_ff[i+1][13],\n                                 L_ff[i+1][12], L_ff[i+1][13], L_ff[i+1][14], L_ff[i+1][15], L_ff[i+1][16], L_ff[i+1][17],\n                                 L_ff[i+1][16], L_ff[i+1][17], L_ff[i+1][18], L_ff[i+1][19], L_ff[i+1][20], L_ff[i+1][21],\n                                 L_ff[i+1][20], L_ff[i+1][21], L_ff[i+1][22], L_ff[i+1][23], L_ff[i+1][24], L_ff[i+1][25],\n                                 L_ff[i+1][24], L_ff[i+1][25], L_ff[i+1][26], L_ff[i+1][27], L_ff[i+1][28], L_ff[i+1][29],\n                                 L_ff[i+1][28], L_ff[i+1][29], L_ff[i+1][30], L_ff[i+1][31], L_ff[i+1][32], L_ff[i+1][ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    L_ff[i] <= L_nx ^ R_ff[i+1];\n                    R_ff[i] <= L_ff[i+1];\n                    C_ff[i] <= C_nx;\n                    D_ff[i] <= D_nx;\n                end\n            end\n        end\n    end\nendgenerate\n\nassign last_perm = {L_ff[0], R_ff[0]};\n\nassign o_data = {last_perm[40], last_perm[8], last_perm[48], last_perm[16], last_perm[56], last_perm[24], last_perm[64], last_perm[32],\n                 last_perm[39], last_perm[7], last_perm[47], last_perm[15], last_perm[55], last_perm[23], last_perm[63], last_perm[31],\n                 last_perm[38], last_perm[6], last_perm[46], last_perm[14], last_perm[54], last_perm[22], last_perm[62], last_perm[30],\n                 last_perm[37], last_perm[5], last_perm[45], last_perm[13], last_perm[53], last_perm[21], last_perm[61], last_perm[29],\n                 last_perm[36], last_perm[4], last_perm[44], last_perm[12], last_perm[52], last_perm[20], last_perm[60], last_perm[28],\n                 last_perm[35], last_perm[3], last_perm[43], last_perm[11], last_perm[51], last_perm[19], last_perm[59], last_perm[27],\n                 last_perm[34], last_perm[2], last_perm[42], last_perm[10], last_perm[50], last_perm[18], last_perm[58], last_perm[26],\n                 last_perm[33], last_perm[1], last_perm[41], last_perm[ 9], last_perm[49], last_perm[17], last_perm[57], last_perm[25]};\n\nendmodule : des_dec", "rtl/des_enc.sv": "module des_enc #(\n    parameter NBW_DATA = 'd64,\n    parameter NBW_KEY  = 'd64\n) (\n    input  logic              clk,\n    input  logic              rst_async_n,\n    input  logic              i_valid,\n    input  logic [1:NBW_DATA] i_data,\n    input  logic [1:NBW_KEY]  i_key,\n    output logic              o_valid,\n    output logic [1:NBW_DATA] o_data\n);\n\nlocalparam ROUNDS = 'd16;\nlocalparam EXPANDED_BLOCK = 'd48;\nlocalparam USED_KEY = 'd56;\n\nlogic [1:NBW_DATA]     IP;\nlogic [1:(NBW_DATA/2)] L0;\nlogic [1:(NBW_DATA/2)] R0;\nlogic [1:(NBW_DATA/2)] L_ff [1:ROUNDS];\nlogic [1:(NBW_DATA/2)] R_ff [1:ROUNDS];\nlogic [1:(USED_KEY/2)] C0;\nlogic [1:(USED_KEY/2)] D0;\nlogic [1:(USED_KEY/2)] C_ff [1:ROUNDS];\nlogic [1:(USED_KEY/2)] D_ff [1:ROUNDS];\nlogic [1:NBW_DATA]     last_perm;\nlogic [ROUNDS-1:0]     valid_ff;\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        valid_ff <= 0;\n    end else begin\n        valid_ff <= {valid_ff[ROUNDS-2:0], i_valid};\n    end\nend\n\nassign o_valid = valid_ff[ROUNDS-1];\n\nassign IP = {i_data[58], i_data[50], i_data[42], i_data[34], i_data[26], i_data[18], i_data[10], i_data[2],\n             i_data[60], i_data[52], i_data[44], i_data[36], i_data[28], i_data[20], i_data[12], i_data[4],\n             i_data[62], i_data[54], i_data[46], i_data[38], i_data[30], i_data[22], i_data[14], i_data[6],\n             i_data[64], i_data[56], i_data[48], i_data[40], i_data[32], i_data[24], i_data[16], i_data[8],\n             i_data[57], i_data[49], i_data[41], i_data[33], i_data[25], i_data[17], i_data[ 9], i_data[1],\n             i_data[59], i_data[51], i_data[43], i_data[35], i_data[27], i_data[19], i_data[11], i_data[3],\n             i_data[61], i_data[53], i_data[45], i_data[37], i_data[29], i_data[21], i_data[13], i_data[5],\n             i_data[63], i_data[55], i_data[47], i_data[39], i_data[31], i_data[23], i_data[15], i_data[7]};\n\nassign L0 = IP[1:NBW_DATA/2];\nassign R0 = IP[(NBW_DATA/2)+1:NBW_DATA];\n\nassign C0 = {i_key[57], i_key[49], i_key[41], i_key[33], i_key[25], i_key[17], i_key[ 9],\n             i_key[ 1], i_key[58], i_key[50], i_key[42], i_key[34], i_key[26], i_key[18],\n             i_key[10], i_key[ 2], i_key[59], i_key[51], i_key[43], i_key[35], i_key[27],\n             i_key[19], i_key[11], i_key[ 3], i_key[60], i_key[52], i_key[44], i_key[36]};\n\nassign D0 = {i_key[63], i_key[55], i_key[47], i_key[39], i_key[31], i_key[23], i_key[15],\n             i_key[ 7], i_key[62], i_key[54], i_key[46], i_key[38], i_key[30], i_key[22],\n             i_key[14], i_key[ 6], i_key[61], i_key[53], i_key[45], i_key[37], i_key[29],\n             i_key[21], i_key[13], i_key[ 5], i_key[28], i_key[20], i_key[12], i_key[ 4]};\n\ngenerate\n    for (genvar i = 1; i <= ROUNDS; i++) begin : rounds\n        logic [1:EXPANDED_BLOCK] round_key;\n        logic [1:(USED_KEY/2)]    C_nx;\n        logic [1:(USED_KEY/2)]    D_nx;\n        logic [1:USED_KEY]        perm_ch;\n        logic [1:(NBW_DATA/2)] R_nx;\n        logic [1:EXPANDED_BLOCK] R_expanded;\n        logic [1:6] Primitive_input  [1:8];\n        logic [1:4] Primitive_output [1:8];\n        logic [1:(NBW_DATA/2)] perm_in;\n\n        assign perm_ch = {C_nx, D_nx};\n        assign round_key = {perm_ch[14], perm_ch[17], perm_ch[11], perm_ch[24], perm_ch[ 1], perm_ch[ 5],\n                            perm_ch[ 3], perm_ch[28], perm_ch[15], perm_ch[ 6], perm_ch[21], perm_ch[10],\n                            perm_ch[23], perm_ch[19], perm_ch[12], perm_ch[ 4], perm_ch[26], perm_ch[ 8],\n                            perm_ch[16], perm_ch[ 7], perm_ch[27], perm_ch[20], perm_ch[13], perm_ch[ 2],\n                            perm_ch[41], perm_ch[52], perm_ch[31], perm_ch[37], perm_ch[47], perm_ch[55],\n                            perm_ch[30], perm_ch[40], perm_ch[51], perm_ch[45], perm_ch[33], perm_ch[48],\n                            perm_ch[44], perm_ch[49], perm_ch[39], perm_ch[56], perm_ch[34], perm_ch[53],\n                            perm_ch[46], perm_ch[42], perm_ch[50], perm_ch[36], perm_ch[29], perm_ch[32]};\n\n        if(i == 1 || i == 2 || i == 9 || i == 16) begin\n            if(i == 1) begin\n                assign C_nx = {C0[2:(USED_KEY/2)], C0[1]};\n                assign D_nx = {D0[2:(USED_KEY/2)], D0[1]};\n            end else begin\n                assign C_nx = {C_ff[i-1][2:(USED_KEY/2)], C_ff[i-1][1]};\n                assign D_nx = {D_ff[i-1][2:(USED_KEY/2)], D_ff[i-1][1]};\n            end\n        end else begin\n            assign C_nx = {C_ff[i-1][3:(USED_KEY/2)], C_ff[i-1][1:2]};\n            assign D_nx = {D_ff[i-1][3:(USED_KEY/2)], D_ff[i-1][1:2]};\n        end\n\n        assign Primitive_input[1] = R_expanded[ 1:6 ] ^ round_key[ 1:6 ];\n        assign Primitive_input[2] = R_expanded[ 7:12] ^ round_key[ 7:12];\n        assign Primitive_input[3] = R_expanded[13:18] ^ round_key[13:18];\n        assign Primitive_input[4] = R_expanded[19:24] ^ round_key[19:24];\n        assign Primitive_input[5] = R_expanded[25:30] ^ round_key[25:30];\n        assign Primitive_input[6] = R_expanded[31:36] ^ round_key[31:36];\n        assign Primitive_input[7] = R_expanded[37:42] ^ round_key[37:42];\n        assign Primitive_input[8] = R_expanded[43:48] ^ round_key[43:48];\n\n        S1 uu_S1 (\n            .i_data(Primitive_input [1]),\n            .o_data(Primitive_output[1])\n        );\n\n        S2 uu_S2 (\n            .i_data(Primitive_input [2]),\n            .o_data(Primitive_output[2])\n        );\n\n        S3 uu_S3 (\n            .i_data(Primitive_input [3]),\n            .o_data(Primitive_output[3])\n        );\n\n        S4 uu_S4 (\n            .i_data(Primitive_input [4]),\n            .o_data(Primitive_output[4])\n        );\n\n        S5 uu_S5 (\n            .i_data(Primitive_input [5]),\n            .o_data(Primitive_output[5])\n        );\n\n        S6 uu_S6 (\n            .i_data(Primitive_input [6]),\n            .o_data(Primitive_output[6])\n        );\n\n        S7 uu_S7 (\n            .i_data(Primitive_input [7]),\n            .o_data(Primitive_output[7])\n        );\n\n        S8 uu_S8 (\n            .i_data(Primitive_input [8]),\n            .o_data(Primitive_output[8])\n        );\n\n        assign perm_in = {Primitive_output[1], Primitive_output[2], Primitive_output[3], Primitive_output[4],\n                          Primitive_output[5], Primitive_output[6], Primitive_output[7], Primitive_output[8]};\n\n        assign R_nx = {perm_in[16], perm_in[ 7], perm_in[20], perm_in[21],\n                       perm_in[29], perm_in[12], perm_in[28], perm_in[17],\n                       perm_in[ 1], perm_in[15], perm_in[23], perm_in[26],\n                       perm_in[ 5], perm_in[18], perm_in[31], perm_in[10],\n                       perm_in[ 2], perm_in[ 8], perm_in[24], perm_in[14],\n                       perm_in[32], perm_in[27], perm_in[ 3], perm_in[ 9],\n                       perm_in[19], perm_in[13], perm_in[30], perm_in[ 6],\n                       perm_in[22], perm_in[11], perm_in[ 4], perm_in[25]};\n\n        if(i == 1) begin\n            assign R_expanded = {R0[32], R0[ 1], R0[ 2], R0[ 3], R0[ 4], R0[ 5],\n                                 R0[ 4], R0[ 5], R0[ 6], R0[ 7], R0[ 8], R0[ 9],\n                                 R0[ 8], R0[ 9], R0[10], R0[11], R0[12], R0[13],\n                                 R0[12], R0[13], R0[14], R0[15], R0[16], R0[17],\n                                 R0[16], R0[17], R0[18], R0[19], R0[20], R0[21],\n                                 R0[20], R0[21], R0[22], R0[23], R0[24], R0[25],\n                                 R0[24], R0[25], R0[26], R0[27], R0[28], R0[29],\n                                 R0[28], R0[29], R0[30], R0[31], R0[32], R0[ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    if(i_valid) begin\n                        L_ff[i] <= R0;\n                        R_ff[i] <= R_nx ^ L0;\n                        C_ff[i] <= C_nx;\n                        D_ff[i] <= D_nx;\n                    end\n                end\n            end\n        end else begin\n            assign R_expanded = {R_ff[i-1][32], R_ff[i-1][ 1], R_ff[i-1][ 2], R_ff[i-1][ 3], R_ff[i-1][ 4], R_ff[i-1][ 5],\n                                 R_ff[i-1][ 4], R_ff[i-1][ 5], R_ff[i-1][ 6], R_ff[i-1][ 7], R_ff[i-1][ 8], R_ff[i-1][ 9],\n                                 R_ff[i-1][ 8], R_ff[i-1][ 9], R_ff[i-1][10], R_ff[i-1][11], R_ff[i-1][12], R_ff[i-1][13],\n                                 R_ff[i-1][12], R_ff[i-1][13], R_ff[i-1][14], R_ff[i-1][15], R_ff[i-1][16], R_ff[i-1][17],\n                                 R_ff[i-1][16], R_ff[i-1][17], R_ff[i-1][18], R_ff[i-1][19], R_ff[i-1][20], R_ff[i-1][21],\n                                 R_ff[i-1][20], R_ff[i-1][21], R_ff[i-1][22], R_ff[i-1][23], R_ff[i-1][24], R_ff[i-1][25],\n                                 R_ff[i-1][24], R_ff[i-1][25], R_ff[i-1][26], R_ff[i-1][27], R_ff[i-1][28], R_ff[i-1][29],\n                                 R_ff[i-1][28], R_ff[i-1][29], R_ff[i-1][30], R_ff[i-1][31], R_ff[i-1][32], R_ff[i-1][ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    L_ff[i] <= R_ff[i-1];\n                    R_ff[i] <= R_nx ^ L_ff[i-1];\n                    C_ff[i] <= C_nx;\n                    D_ff[i] <= D_nx;\n                end\n            end\n        end\n    end\nendgenerate\n\nassign last_perm = {R_ff[ROUNDS], L_ff[ROUNDS]};\n\nassign o_data = {last_perm[40], last_perm[8], last_perm[48], last_perm[16], last_perm[56], last_perm[24], last_perm[64], last_perm[32],\n                 last_perm[39], last_perm[7], last_perm[47], last_perm[15], last_perm[55], last_perm[23], last_perm[63], last_perm[31],\n                 last_perm[38], last_perm[6], last_perm[46], last_perm[14], last_perm[54], last_perm[22], last_perm[62], last_perm[30],\n                 last_perm[37], last_perm[5], last_perm[45], last_perm[13], last_perm[53], last_perm[21], last_perm[61], last_perm[29],\n                 last_perm[36], last_perm[4], last_perm[44], last_perm[12], last_perm[52], last_perm[20], last_perm[60], last_perm[28],\n                 last_perm[35], last_perm[3], last_perm[43], last_perm[11], last_perm[51], last_perm[19], last_perm[59], last_perm[27],\n                 last_perm[34], last_perm[2], last_perm[42], last_perm[10], last_perm[50], last_perm[18], last_perm[58], last_perm[26],\n                 last_perm[33], last_perm[1], last_perm[41], last_perm[ 9], last_perm[49], last_perm[17], last_perm[57], last_perm[25]};\n\nendmodule : des_enc", "verif/tb_3des_dec.sv": "module tb;\n\nparameter NBW_DATA = 'd64;\nparameter NBW_KEY  = 'd192;\n\nlogic              clk;\nlogic              rst_async_n;\nlogic              i_start;\nlogic [1:NBW_DATA] i_data;\nlogic [1:NBW_KEY ] i_key;\nlogic              o_done;\nlogic [1:NBW_DATA] o_data;\n\ndes3_dec #(\n    .NBW_DATA(NBW_DATA),\n    .NBW_KEY (NBW_KEY )\n) uu_des3_dec (\n    .clk        (clk        ),\n    .rst_async_n(rst_async_n),\n    .i_start    (i_start    ),\n    .i_data     (i_data     ),\n    .i_key      (i_key      ),\n    .o_done     (o_done     ),\n    .o_data     (o_data     )\n);\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb);\nend\n\nalways #5 clk = ~clk;\n\ntask Single_test(logic [1:NBW_KEY] key, logic [1:NBW_DATA] data, logic [1:NBW_DATA] expected);\n    i_key   = key;\n    i_data  = data;\n    i_start = 1;\n\n    @(negedge clk);\n    i_start = 0;\n\n    @(posedge o_done);\n    @(negedge clk);\n    if(o_data != expected) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", expected, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\nendtask\n\ntask Burst_test();\n    i_key   = 192'hB1FECAFEBEBAB1FEABCDABCDABCDABCD8765432187654321;\n    i_data  = 64'h4321432143214321;\n    i_start = 1;\n\n    @(negedge clk); // This next i_data must be ignored by the RTL\n    i_data  = 64'h123456789ABCDEF0;\n\n    @(negedge clk); // This next i_data and i_key must be ignored by the RTL\n    i_data  = 64'h1234123412341234;\n    i_key   = 192'hABCDABCDABCDABCD8765432187654321B1FECAFEBEBAB1FE;\n\n    @(negedge clk);\n    i_start = 0;\n\n    @(posedge o_done);\n    \n    // The ignored data/key can not change the output data, nor the o_done\n    for(int i = 0; i < 3; i++) begin // Using 3 to test the data output for the first value, and validating that the changes in i_data and i_key while the RTL is not done won't affect o_data\n        @(negedge clk);\n        if(o_done != 1) begin\n            $display(\"FAIL! o_done should be asserted here.\");\n        end\n        \n        if(o_data != 64'h32966b20b88edf53) begin\n            $display(\"FAIL!\");\n            $display(\"Expected %h, got %h\", 64'h32966b20b88edf53, o_data);\n        end else begin\n            $display(\"PASS!\");\n        end\n    end\n    \nendtask\n\ninitial begin\n    clk = 0;\n    i_start = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    $display(\"\\nSingle Tests\");\n    Single_test(192'h0123456789abcdeffedcba9876543210abcdef9876543210, 64'h0123456789ABCDEF, 64'h29d92f40554ab5dc);\n    Single_test(192'h0123456789abcdeffedcba9876543210abcdef9876543210, 64'hFEDCBA9876543210, 64'hf27a8ffec7e6be1e);\n    Single_test(192'hBEBACAFE12345678B1FECAFE876543219898898974744747, 64'hFEDCBA9876543210, 64'h64ff5c5ace7f03ba);\n    Single_test(192'hBEBACAFE12345678B1FECAFE876543219898898974744747, 64'hB1FECAFEBEBAB1FE, 64'hc78f7a5f19428db8);\n\n    $display(\"\\nBurst Test\");\n    Burst_test();\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/des3_dec.sv": "", "rtl/des_dec.sv": "", "rtl/des_enc.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n\n  des_enc:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env_des_enc\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n  \n  des_dec:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env_des_dec\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache", "src/.env": "VERILOG_SOURCES = /code/rtl/des3_dec.sv /code/rtl/des_dec.sv /code/rtl/des_enc.sv /code/rtl/S1.sv /code/rtl/S2.sv /code/rtl/S3.sv /code/rtl/S4.sv /code/rtl/S5.sv /code/rtl/S6.sv /code/rtl/S7.sv /code/rtl/S8.sv\nTOPLEVEL        = des3_dec\nMODULE          = test_des3_dec\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 7-create-des3-dec\nWAVE            = true", "src/.env_des_dec": "VERILOG_SOURCES = /code/rtl/des_dec.sv /code/rtl/S1.sv /code/rtl/S2.sv /code/rtl/S3.sv /code/rtl/S4.sv /code/rtl/S5.sv /code/rtl/S6.sv /code/rtl/S7.sv /code/rtl/S8.sv\nTOPLEVEL        = des_dec\nMODULE          = test_des_dec\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 7-create-des3-dec\nWAVE            = true", "src/.env_des_enc": "VERILOG_SOURCES = /code/rtl/des_enc.sv /code/rtl/S1.sv /code/rtl/S2.sv /code/rtl/S3.sv /code/rtl/S4.sv /code/rtl/S5.sv /code/rtl/S6.sv /code/rtl/S7.sv /code/rtl/S8.sv\nTOPLEVEL        = des_enc\nMODULE          = test_des_enc\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 7-create-des3-dec\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass des:\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.data_out = 0\n        self.enc_out = 0\n        self.dec_out = 0\n        self.fifo = []\n\n    def permute(self, block, table, n):\n        result = 0\n        for i in range(len(table)):\n            bit = (block >> (n - table[i])) & 1\n            result |= (bit << (len(table) - 1 - i))\n        return result\n\n    def left_rotate(self, val, n):\n        return ((val << n) & 0x0FFFFFFF) | (val >> (28 - n))\n\n    def sbox(self, box, val):\n        row = ((val >> 5) & 1) * 2 + (val & 1)\n        col = (val >> 1) & 0xF\n        return box[row][col]\n\n    def f(self, R, subkey):\n        E = [32,1,2,3,4,5,4,5,6,7,8,9,\n             8,9,10,11,12,13,12,13,14,15,16,17,\n             16,17,18,19,20,21,20,21,22,23,24,25,\n             24,25,26,27,28,29,28,29,30,31,32,1]\n\n        P = [16,7,20,21,29,12,28,17,\n             1,15,23,26,5,18,31,10,\n             2,8,24,14,32,27,3,9,\n             19,13,30,6,22,11,4,25]\n\n        SBOXES = self.sboxes\n\n        expanded = self.permute(R << 32, E, 64)\n        xored = expanded ^ subkey\n\n        output = 0\n        for i in range(8):\n            chunk = (xored >> (42 - i*6)) & 0x3F\n            sbox_val = self.sbox(SBOXES[i], chunk)\n            output = (output << 4) | sbox_val\n\n        return self.permute(output << 32, P, 64)\n\n    def generate_subkeys(self, key):\n        PC1 = [57,49,41,33,25,17,9,\n               1,58,50,42,34,26,18,\n               10,2,59,51,43,35,27,\n               19,11,3,60,52,44,36,\n               63,55,47,39,31,23,15,\n               7,62,54,46,38,30,22,\n               14,6,61,53,45,37,29,\n               21,13,5,28,20,12,4]\n\n        PC2 = [14,17,11,24,1,5,\n               3,28,15,6,21,10,\n               23,19,12,4,26,8,\n               16,7,27,20,13,2,\n               41,52,31,37,47,55,\n               30,40,51,45,33,48,\n               44,49,39,56,34,53,\n               46,42,50,36,29,32]\n\n        rotations = [1, 1, 2, 2, 2, 2, 2, 2,\n                     1, 2, 2, 2, 2, 2, 2, 1]\n\n        key56 = self.permute(key, PC1, 64)\n        C = (key56 >> 28) & 0xFFFFFFF\n        D = key56 & 0xFFFFFFF\n\n        subkeys = []\n        for rot in rotations:\n            C = self.left_rotate(C, rot)\n            D = self.left_rotate(D, rot)\n            CD = (C << 28) | D\n            subkey = self.permute(CD, PC2, 56)\n            subkeys.append(subkey)\n        return subkeys\n    \n    def decrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)[::-1]  # Reverse subkeys for decryption\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.dec_out = self.permute(pre_output, FP, 64)\n\n    def encrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.enc_out = self.permute(pre_output, FP, 64)\n    \n    def des3_enc(self, data, key):\n        K1 = (key & 0xFFFFFFFFFFFFFFFF00000000000000000000000000000000) >> 128\n        K2 = (key & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64\n        K3 = key & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFF\n        self.encrypt(data, K1)\n        self.decrypt(self.enc_out, K2)\n        self.encrypt(self.dec_out, K3)\n\n        self.fifo.append(self.enc_out)\n    \n    def des3_dec(self, data, key):\n        K1 = (key & 0xFFFFFFFFFFFFFFFF00000000000000000000000000000000) >> 128\n        K2 = (key & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64\n        K3 =  key & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFF\n        self.decrypt(data, K3)\n        self.encrypt(self.dec_out, K2)\n        self.decrypt(self.enc_out, K1)\n\n        self.fifo.append(self.dec_out)\n    \n    def read_data(self):\n        if self.fifo:\n            return self.fifo.pop(0)\n        return 0\n\n    # Full DES S-box definitions\n    sboxes = [\n        [\n            [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n            [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n            [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n            [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13]\n        ],\n        [\n            [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10],\n            [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5],\n            [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15],\n            [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9]\n        ],\n        [\n            [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8],\n            [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1],\n            [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7],\n            [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12]\n        ],\n        [\n            [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15],\n            [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9],\n            [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4],\n            [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14]\n        ],\n        [\n            [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9],\n            [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6],\n            [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14],\n            [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3]\n        ],\n        [\n            [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11],\n            [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8],\n            [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6],\n            [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13]\n        ],\n        [\n            [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1],\n            [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6],\n            [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2],\n            [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12]\n        ],\n        [\n            [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7],\n            [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2],\n            [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8],\n            [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]\n        ]\n    ]", "src/test_des3_dec.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data   = dut.o_data.value.to_unsigned()\n    model_data = model.read_data()\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_des3_dec(dut):\n    \"\"\"Test the des3_dec module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.des()\n\n    resets = 2\n    runs = 300\n\n    data_min = 0\n    data_max = 2**64 - 1\n\n    key_min  = 0\n    key_max  = 2**192 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_start.value     = 0\n        dut.i_data.value      = 0\n        dut.i_key.value       = 0\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        # Latency check\n        key   = random.randint(key_min , key_max )\n        data  = random.randint(data_min, data_max)\n        start = 1\n\n        await FallingEdge(dut.clk)\n        dut.i_data.value  = data\n        dut.i_key.value   = key\n        dut.i_start.value = start\n\n        model.des3_dec(data, key)\n        await FallingEdge(dut.clk)\n        latency_counter = 1\n        dut.i_start.value = 0\n\n        while dut.o_done.value == 0:\n            latency_counter = latency_counter + 1\n            await FallingEdge(dut.clk)\n        \n        assert latency_counter == 48, f\"[ERROR] DUT latency must be 48 clock cycles\"\n        \n        compare_values(dut, model)\n\n        done_tests = random.randint(1, 50)\n        for j in range(done_tests):\n            previous_data = dut.o_data.value\n            await FallingEdge(dut.clk)\n            assert dut.o_done.value == 1, \"[ERROR] DUT o_done should be 1 when not processing data\"\n            assert dut.o_data.value == previous_data, \"[ERROR] DUT o_data must not be changed when not processing data\"\n            \n\n        for j in range(runs):\n            if (j+1)%100 == 0:\n                print(f'\\n------ Reset {i}, run {j+1} ------')\n\n            key   = random.randint(key_min , key_max )\n            data  = random.randint(data_min, data_max)\n            start = 1\n\n            await FallingEdge(dut.clk)\n\n            dut.i_data.value  = data\n            dut.i_key.value   = key\n            dut.i_start.value = start\n            \n            model.des3_dec(data, key)\n\n            await FallingEdge(dut.clk)\n\n            dut.i_data.value  = 0\n            dut.i_key.value   = 0\n            dut.i_start.value = 0\n\n            while dut.o_done.value == 0:\n                await FallingEdge(dut.clk)\n            \n            compare_values(dut, model)\n", "src/test_des_dec.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data   = dut.o_data.value.to_unsigned()\n    model_data = model.dec_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_des_dec(dut):\n    \"\"\"Test the des_dec module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n\n    model = hrs_lb.des()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**64 - 1\n\n    key_min  = 0\n    key_max  = 2**64 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_start.value     = 0\n        dut.i_data.value      = 0\n        dut.i_key.value       = 0\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        # Latency check\n        key   = random.randint(key_min , key_max )\n        data  = random.randint(data_min, data_max)\n\n        await FallingEdge(dut.clk)\n        dut.i_data.value  = data\n        dut.i_key.value   = key\n        dut.i_start.value = 1\n\n        model.decrypt(data, key)\n        await FallingEdge(dut.clk)\n        latency_counter = 1\n        dut.i_start.value = 0\n\n        while model.dec_out != dut.o_data.value.to_unsigned():\n            latency_counter = latency_counter + 1\n            await FallingEdge(dut.clk)\n            if latency_counter > 16:\n                assert latency_counter == 16, f\"[ERROR] DUT latency must be 16 clock cycles\"\n        \n        assert latency_counter == 16, f\"[ERROR] DUT latency must be 16 clock cycles\"\n        \n        compare_values(dut, model)\n\n        for j in range(runs):\n            if (j+1)%500 == 0:\n                print(f'\\n------ Reset {i}, run {j+1} ------')\n\n            key   = random.randint(key_min , key_max )\n            data  = random.randint(data_min, data_max)\n\n            dut.i_data.value  = data\n            dut.i_key.value   = key\n            dut.i_start.value = 1\n            model.decrypt(data, key)\n            await FallingEdge(dut.clk)\n            dut.i_start.value = 0\n\n            latency_counter = 1\n\n            while latency_counter < 16:\n                await FallingEdge(dut.clk)\n                latency_counter = latency_counter + 1\n\n            compare_values(dut, model)\n", "src/test_des_enc.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data   = dut.o_data.value.to_unsigned()\n    model_data = model.enc_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_des_enc(dut):\n    \"\"\"Test the des_enc module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n\n    model = hrs_lb.des()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**64 - 1\n\n    key_min  = 0\n    key_max  = 2**64 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_start.value     = 0\n        dut.i_data.value      = 0\n        dut.i_key.value       = 0\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        # Latency check\n        key   = random.randint(key_min , key_max )\n        data  = random.randint(data_min, data_max)\n\n        await FallingEdge(dut.clk)\n        dut.i_data.value  = data\n        dut.i_key.value   = key\n        dut.i_start.value = 1\n\n        model.encrypt(data, key)\n        await FallingEdge(dut.clk)\n        latency_counter = 1\n        dut.i_start.value = 0\n\n        while model.enc_out != dut.o_data.value.to_unsigned():\n            latency_counter = latency_counter + 1\n            await FallingEdge(dut.clk)\n            if latency_counter > 16:\n                assert latency_counter == 16, f\"[ERROR] DUT latency must be 16 clock cycles\"\n        \n        assert latency_counter == 16, f\"[ERROR] DUT latency must be 16 clock cycles\"\n        \n        compare_values(dut, model)\n\n        for j in range(runs):\n            if (j+1)%500 == 0:\n                print(f'\\n------ Reset {i}, run {j+1} ------')\n\n            key   = random.randint(key_min , key_max )\n            data  = random.randint(data_min, data_max)\n\n            dut.i_data.value  = data\n            dut.i_key.value   = key\n            dut.i_start.value = 1\n            model.encrypt(data, key)\n            await FallingEdge(dut.clk)\n            dut.i_start.value = 0\n\n            latency_counter = 1\n\n            while latency_counter < 16:\n                await FallingEdge(dut.clk)\n                latency_counter = latency_counter + 1\n\n            compare_values(dut, model)\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()"}}
{"id": "cvdp_agentic_eagle_crystal_lunar_2638", "categories": ["cid003", "medium"], "system_message": " You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n \nYou will be given a prompt and your task is to understand it and solve the given issue by using the above mentioned commands as needed. At the final step you should create a linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itelf in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a linux based patch that needs to be applied to reach to the relevant solution)\n\n  The patch file should only be applied to a single file to reach to the required solution.", "prompt": "Design a `pcie_endpoint` module in System Verilog which is responsible for handling `PCIe transactions`, interfacing with a `DMA engine`, and managing `MSI-X interrupts`. It processes `PCIe Transaction Layer Packets` (TLPs), decodes them, and executes the corresponding read/write operations. This module follows a `Finite State Machine` (FSM) approach to ensure proper sequencing of PCIe endpoint write and read transactions. The design is parameterizable, allowing flexibility in configuring data width and address width. Please refer to the specification provided in `docs/specs.md` for detailed design description.\n\n## **Parameterization**\n- **Address Width (`ADDR_WIDTH`)**: Default **64 bits**, configurable for different PCIe address sizes.\n- **Data Width (`DATA_WIDTH`)**: Default **128 bits**, supporting high-speed PCIe transfers.\n\n## **1. Features**\n### **PCIe Transaction Handling**\n- Receives PCIe TLPs and processes valid transactions.\n- Decodes received TLPs and forwards them for execution.\n- Transmits processed transactions.\n\n### **DMA Engine Interface**\n- Supports DMA requests and generates corresponding complete requests.\n- Provides `dma_address` and `dma_data` signals to interact with external memory controllers.\n\n### **MSI-X Interrupt Management**\n- Generates MSI-X interrupts upon DMA completion.\n- Ensures proper sequencing of interrupt generation to prevent missed events.\n\n## **2. Functional Description**\nThe `pcie_endpoint` module consists of multiple FSMs, each handling a distinct function:\n\n### **PCIe Transaction FSM**\n- Manages the reception and processing of incoming PCIe TLPs.\n- Decodes received transactions and prepares them for further execution.\n\n### **PCIe Data Link FSM**\n- Handles transmission of PCIe transactions.\n- Ensures data integrity and proper sequencing of outgoing TLPs.\n\n### **DMA FSM**\n- Manages the interaction with the DMA engine.\n- Tracks DMA requests and ensures completion of memory operations.\n\n### **MSI-X FSM**\n- Generates MSI-X interrupts upon successful completion of DMA operations.\n- Ensures correct signaling of interrupts to the host system.\n\n## **3. Transaction Flow**\n### **PCIe Write Transaction**\n1. Receives a PCIe TLP.\n2. Decodes and processes the transaction.\n3. Stores the data in the appropriate memory location.\n\n### **PCIe Read Transaction**\n1. Receives a read request from PCIe.\n2. Fetches the required data from memory.\n3. Sends the data as a PCIe response.\n\n### **DMA Transaction**\n1. Receives a DMA request.\n2. Reads or writes data from/to memory.\n3. Signals DMA completion.\n\n### **MSI-X Interrupt Generation**\n1. Detects completion of DMA operations.\n2. Generates an MSI-X interrupt signal.\n3. Waits for acknowledgment before resetting the interrupt state.\n\n## **4. SystemVerilog Best Practices**\n- **Modular Design:** FSMs are independently implemented for different functions, ensuring better maintainability.\n- **Parameterization:** Address and data width are configurable to accommodate various PCIe configurations.\n- **Clock Domain Handling:** All FSMs operate under a single `clk` domain to maintain synchronization.\n- **Reset Handling:** The `rst_n` signal ensures proper initialization of all FSMs and state registers.\n\nThe code follows best practices in SystemVerilog, ensuring readability, reusability, and maintainability. Proper comments and documentation are included to explain the functionality of each major block.\n", "context": {"docs/specs.md": "# PCIe Endpoint Module (`pcie_endpoint.sv`)\n\n## Overview\nThe `pcie_endpoint` module implements a PCIe endpoint logic block that:\n- Receives and processes PCIe Transaction Layer Packets (TLPs),\n- Initiates and monitors DMA transfers,\n- Triggers MSI-X interrupts on DMA completion.\n\nIt is architected using multiple finite state machines (FSMs) to separate concerns and ensure robust design: one FSM each for PCIe transaction management, data link layer coordination, DMA handling, and interrupt generation.\n\n---\n\n## Parameterization\n\n| Parameter     | Description                                  | Default |\n|---------------|----------------------------------------------|---------|\n| `ADDR_WIDTH`  | Bit-width of the DMA address signals         | 64      |\n| `DATA_WIDTH`  | Bit-width of the PCIe and DMA data bus       | 128     |\n\nThese parameters enable adaptation to various PCIe configurations and host systems.\n\n---\n\n## Interfaces\n\n### Clock and Reset\n| Signal   | Direction | Width | Description                            |\n|----------|-----------|-------|----------------------------------------|\n| `clk`    | Input     | 1     | Clock signal for synchronous logic     |\n| `rst_n`  | Input     | 1     | Active-low reset                       |\n\n### PCIe Interface\n| Signal           | Direction | Width         | Description                                     |\n|------------------|-----------|---------------|-------------------------------------------------|\n| `pcie_rx_tlp`    | Input     | `DATA_WIDTH`  | Incoming PCIe TLP data                          |\n| `pcie_rx_valid`  | Input     | 1             | Indicates `pcie_rx_tlp` contains valid data     |\n| `pcie_rx_ready`  | Output    | 1             | Indicates endpoint is ready to receive TLP      |\n| `pcie_tx_tlp`    | Output    | `DATA_WIDTH`  | Outgoing PCIe TLP data                          |\n| `pcie_tx_valid`  | Output    | 1             | Indicates valid TLP data on `pcie_tx_tlp`       |\n| `pcie_tx_ready`  | Input     | 1             | Indicates host is ready to accept outgoing TLP  |\n\n### DMA Interface\n| Signal         | Direction | Width | Description                                 |\n|----------------|-----------|-------|---------------------------------------------|\n| `dma_request`  | Input     | 1     | Request to initiate a DMA transfer          |\n| `dma_complete` | Output    | 1     | Indicates that DMA operation is complete    |\n\n### MSI-X Interrupt Interface\n| Signal           | Direction | Width | Description                                     |\n|------------------|-----------|-------|-------------------------------------------------|\n| `msix_interrupt` | Output    | 1     | MSI-X interrupt generated after DMA completion  |\n\n---\n\n## Internal Signals\n\n| Signal             | Width        | Description                                         |\n|--------------------|--------------|-----------------------------------------------------|\n| `tlp_decoded_data` | `DATA_WIDTH` | Latched copy of received PCIe TLP                   |\n| `tlp_valid`        | 1            | Indicates valid TLP is available for processing     |\n| `dma_address`      | `ADDR_WIDTH` | Address for DMA operation                           |\n| `dma_data`         | `DATA_WIDTH` | Data for DMA write operation                        |\n| `dma_start`        | 1            | Trigger signal to begin DMA                         |\n\n---\n\n## Functional Description\n\n### PCIe Transaction FSM (`pcie_transaction_fsm`)\nHandles incoming PCIe TLPs:\n- **States**: `IDLE`, `RECEIVE`, `PROCESS`, `SEND_RESPONSE`\n- When a TLP is received (`pcie_rx_valid`), the FSM transitions to `RECEIVE`, captures the data, and marks it valid.\n- In `PROCESS`, it may trigger DMA or other logic.\n- In `SEND_RESPONSE`, it transitions to data link FSM for sending a response.\n\n### PCIe Data Link FSM (`pcie_data_link_fsm`)\nManages transmission of TLPs over PCIe:\n- **States**: `DLL_IDLE`, `TRANSMIT`, `WAIT_ACK`, `RETRY`\n- When valid TLP data is ready, FSM asserts `pcie_tx_valid` and waits for `pcie_tx_ready`.\n- Retries transmission if not acknowledged.\n\n### DMA FSM (`dma_fsm`)\nPerforms memory operations via DMA engine:\n- **States**: `DMA_IDLE`, `READ_DESC`, `FETCH_DATA`, `WRITE_DMA`\n- On `dma_request`, begins reading descriptors and fetching data.\n- Once data is written to the target, it asserts `dma_complete`.\n\n### MSI-X FSM (`msix_fsm`)\nGenerates interrupts after DMA:\n- **States**: `MSIX_IDLE`, `GENERATE_INT`\n- Monitors `dma_complete`, and upon detection, asserts `msix_interrupt` for one clock cycle.\n\n---\n\n## Timing and Handshake Behavior\n\n- **`pcie_rx_ready`** is high only when the module is in `IDLE` state and ready to receive.\n- **`pcie_tx_valid`** is asserted when in `TRANSMIT` state and remains high until `pcie_tx_ready` is received.\n- **`dma_complete`** and **`msix_interrupt`** are single-cycle pulses triggered by respective FSM transitions.\n\n---\n\n## Summary\n\nThe `pcie_endpoint` is a modular and FSM-driven PCIe endpoint logic capable of:\n\n- Accepting and decoding PCIe TLPs.\n- Coordinating DMA data transfers using descriptors.\n- Sending completion or response TLPs.\n- Triggering MSI-X interrupts for host notification.\n\n### Key Features:\n- Parameterized for address and data width.\n- Separated FSMs for clean logic partitioning.\n- PCIe TLP RX/TX handshake compliant.\n- Single-cycle MSI-X interrupt signaling.\n- Scalable for integration with full PCIe/DMA systems."}, "patch": {"rtl/pcie_endpoint.sv": ""}, "harness": {"docker-compose.yml": "services:\n  \n direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command: pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/pcie_endpoint.sv\nTOPLEVEL        = pcie_endpoint\nMODULE          = test_pcie_ep\nPYTHONPATH      = /src\nHASH            = 1-design-pcie-endpoint-with-dma-engine-protocol-support", "src/test_pcie_ep.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\nADDR_WIDTH = 64\nDATA_WIDTH = 128\nMEM_DEPTH = 256  # Simulated memory depth\n\nclass PCIeTestbench:\n    def __init__(self, dut):\n        self.dut = dut\n        self.memory = [0] * MEM_DEPTH  # Simulated memory\n\n    async def reset(self):\n        \"\"\" Reset DUT \"\"\"\n        self.dut.rst_n.value = 0\n        await Timer(20, units=\"ns\")\n        self.dut.rst_n.value = 1\n        self.dut.pcie_rx_valid.value = 0\n        self.dut.pcie_tx_ready.value = 1  # Always ready\n        self.dut.dma_request.value = 0\n        cocotb.log.info(\"Reset complete.\")\n\n    async def single_write(self, addr, data):\n        \"\"\" Perform a single write operation \"\"\"\n        index = addr % MEM_DEPTH\n        self.memory[index] = data  # Store in simulated memory\n        \n        self.dut.pcie_rx_tlp.value = data\n        self.dut.pcie_rx_valid.value = 1\n        await Timer(10, units=\"ns\")  # Simulate write delay\n        self.dut.pcie_rx_valid.value = 0\n        \n        cocotb.log.info(f\"[WRITE] Addr: {hex(addr)}, Data: {hex(data)}\")\n\n    async def single_read(self, addr):\n        \"\"\" Perform a single read operation \"\"\"\n        index = addr % MEM_DEPTH\n        expected_data = self.memory[index]\n\n        await Timer(20, units=\"ns\")  # Simulate read delay\n\n        read_data = expected_data  # In real HW, read from DUT\n        cocotb.log.info(f\"[READ] Addr: {hex(addr)}, Data: {hex(read_data)}\")\n\n        if read_data != expected_data:\n            cocotb.log.error(f\"[ERROR] Data Mismatch! Expected: {hex(expected_data)}, Got: {hex(read_data)}\")\n        else:\n            cocotb.log.info(f\"[PASS] Data Matched!\")\n\n    async def burst_write(self, start_addr, num_writes):\n        \"\"\" Perform a burst write operation \"\"\"\n        cocotb.log.info(f\"[BURST WRITE] Addr: {hex(start_addr)}, Count: {num_writes}\")\n        \n        write_data_queue = [random.randint(0, 2**DATA_WIDTH - 1) for _ in range(num_writes)]\n        \n        for i, data in enumerate(write_data_queue):\n            index = (start_addr + i) % MEM_DEPTH\n            self.memory[index] = data  # Store in simulated memory\n\n            self.dut.pcie_rx_tlp.value = data\n            self.dut.pcie_rx_valid.value = 1\n            await Timer(10, units=\"ns\")\n            self.dut.pcie_rx_valid.value = 0\n\n            cocotb.log.info(f\"[WRITE {i}] Addr: {hex(start_addr + (i * 4))}, Data: {hex(data)}\")\n\n        await Timer(20, units=\"ns\")  # Wait for writes to settle\n\n    async def burst_read(self, start_addr, num_reads):\n        \"\"\" Perform a burst read operation \"\"\"\n        cocotb.log.info(f\"[BURST READ] Addr: {hex(start_addr)}, Count: {num_reads}\")\n\n        for i in range(num_reads):\n            await Timer(20, units=\"ns\")  # Simulate read delay\n            index = (start_addr + i) % MEM_DEPTH\n            read_data = self.memory[index]  # Read from simulated memory\n\n            cocotb.log.info(f\"[READ {i}] Addr: {hex(start_addr + (i * 4))}, Data: {hex(read_data)}\")\n\n            # Data verification\n            expected_data = self.memory[index]\n            if read_data != expected_data:\n                cocotb.log.error(f\"[ERROR] Data Mismatch at index {i}! Expected: {hex(expected_data)}, Got: {hex(read_data)}\")\n            else:\n                cocotb.log.info(f\"[PASS] Data Matched at index {i}!\")\n\n@cocotb.test()\nasync def run_test(dut):\n    \"\"\" Main test function \"\"\"\n    tb = PCIeTestbench(dut)\n\n    # Start clock (100MHz -> 10ns period)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply Reset\n    await tb.reset()\n\n    # Single Write and Read Test\n    await tb.single_write(0x1000, 0xA5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5)\n    await tb.single_read(0x1000)\n\n    # Burst Write and Read Test\n    await tb.burst_write(0x2000, 16)\n    await tb.burst_read(0x2000, 16)\n\n    cocotb.log.info(\"[TEST COMPLETED]\")", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}
{"id": "cvdp_agentic_sunrise_ivory_glacier_9089", "categories": ["cid004", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n    \n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a module `search_binary_search_tree` in the `rtl` directory that performs a search for a given `search_key` in a binary search tree (BST) which is given as an array of unsigned integers with a parameterizable size, `ARRAY_SIZE` (greater than 0). The module locates the position of the `search_key` in the array sorted with the constructed BST. The position where the `search_key` is located is based on its **position in the sorted array** (sorted such that the smallest element is at index 0 and the largest element is at index `ARRAY_SIZE`-1). Modify the existing SystemVerilog code to a module named `delete_node_binary_search_tree` to correctly implement the deletion of a node in the given BST input after its searching is completed. The renamed module should be in the same file `rtl/search_binary_search_tree.sv`. The specification of the new module is available in `docs` directory.\nThe module should handle the following scenarios:\n\n1. When the node to search and delete has both left and right children.\n2. When the node to search and delete has only a left child.\n3. When the node to search and delete has only the right child.\n4. When the node to search and delete has no children.\n\nThe module should also ensure that the BST structure is maintained after deletion, and invalid keys and pointers are correctly updated. The interfaces for the modified code must remain similar to that of the existing code with some additional interfaces relevant to the deletion logic. The `search_key`, `complete_found`and `search_invalid` input in the `search_binary_search_tree` module must be replaced with `delete_key`, `complete_deletion` and `delete_invalid` to adapt better to the deletion operation. Additional outputs relevant to the deletion logic must include modified BST consisting of key, left_child, and right_child with the `delete_key` deleted, and invalid keys and pointers correctly updated.\n\nThe latency for the total deletion for the modified code depends on the depth of the tree to search the node. In the worst case, the FSM will traverse the depth of the tree. The latency of the search algorithm must be maintained similar to the existing algorithm. \n\n---\n\n### Task\n\n1. **Review the Existing Code:**\n   - Ensure the FSM correctly transitions between states.\n   - Verify that the search logic correctly identifies the node to delete.\n   - The search logic determines the index of the node to be deleted and information about its left and right child.\n\n2. **Implement the Deletion Logic:**\n   - Handle all deletion scenarios in the `S_DELETE` state.\n   - Ensure that the BST structure is maintained after deletion.\n   - Update the `modified_keys`, `modified_left_child`, and `modified_right_child` arrays correctly.\n\n3. **Handle Invalid Keys and Pointers:**\n   - Replace deleted keys and pointers with the appropriate invalid values.\n   - Ensure that any references to the deleted node are updated to point to invalid values.\n\n4. **Handle Reset of Outputs and Control Flags:**\n   - After the deletion is complete for a given input BST and `delete_key`, ensure the output and control flags are reset to their reset value.\n\n---\n\n### Example Test Cases for DATA_WIDTH = 6\n1. **Delete Node with Both Children:**\n   - Input: `keys = [10, 5, 15, 3, 7, 12, 20]`, `left_child = [1, 3, 5, 15, 15, 15, 15]`, `right_child = [2, 4, 6, 15, 15, 15, 15]`, `delete_key = 10`\n   - Expected Output: `modified_keys = [12, 5, 15, 3, 7, 63, 20]`, `modified_left_child = [1, 3, 15, 15, 15, 15, 15]`, `modified_right_child = [2, 4, 6, 15, 15, 15, 15]`\n\n2. **Delete Node with Only Left Child:**\n   - Input: `keys = [10, 5, 15, 3, 63, 12, 20]`, `left_child = [1, 3, 5, 15, 15, 15, 15]`, `right_child = [2, 4, 6, 15, 15, 15, 15]`, `delete_key = 5`\n   - Expected Output: `modified_keys = [10, 3, 15, 63, 63, 12, 20]`, `modified_left_child = [1, 15, 5, 15, 15, 15, 15]`, `modified_right_child = [2, 4, 6, 15, 15, 15, 15]`\n\n3. **Delete Node with No Children:**\n   - Input: `keys = [10, 5, 15, 3, 7, 12, 20]`, `left_child = [1, 3, 5, 15, 15, 15, 15]`, `right_child = [2, 4, 6, 15, 15, 15, 15]`, `delete_key = 3`\n   - Expected Output: `modified_keys = [10, 5, 15, 63, 7, 12, 20]`, `modified_left_child = [1, 15, 5, 15, 15, 15, 15]`, `modified_right_child = [2, 4, 6, 15, 15, 15, 15]`\n\n---\n\n### Deliverables\nEnsure that the modified SystemVerilog code correctly implements the deletion logic for all scenarios and maintains the BST structure. \n", "context": {"rtl/search_binary_search_tree.sv": "module search_binary_search_tree #(\n    parameter DATA_WIDTH = 16,         // Width of the data\n    parameter ARRAY_SIZE = 5           // Maximum number of elements in the BST\n) (\n\n    input clk,                         // Clock signal\n    input reset,                       // Reset signal\n    input reg start,                   // Start signal to initiate the search\n    input reg [DATA_WIDTH-1:0] search_key, // Key to search in the BST\n    input reg [$clog2(ARRAY_SIZE):0] root, // Root node of the BST\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys, // Node keys in the BST\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child, // Left child pointers\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child, // Right child pointers\n    output reg [$clog2(ARRAY_SIZE):0] key_position, // Position of the found key\n    output reg complete_found,         // Signal indicating search completion\n    output reg search_invalid\n);\n                                                                                                                                        \n    // Parameters for FSM states\n    parameter S_IDLE = 3'b000,                 // Idle state\n              S_INIT = 3'b001,                 // Initialization state\n              S_SEARCH_LEFT = 3'b010,          // Search in left subtree\n              S_SEARCH_LEFT_RIGHT = 3'b011,    // Search in both left and right subtrees\n              S_COMPLETE_SEARCH = 3'b100;      // Search completion state\n   \n    // Registers to store the current FSM state\n    reg [2:0] search_state;\n\n    // Variables to manage traversal\n    reg [$clog2(ARRAY_SIZE):0] position;       // Position of the current node\n    reg found;                                 // Indicates if the key is found\n\n    reg left_done, right_done;                 // Flags to indicate completion of left and right subtree traversals\n\n    // Stacks for managing traversal of left and right subtrees\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack;  // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_left;         // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_right;        // Stack pointer for right subtree\n\n    // Pointers for the current nodes in left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node;  // Current node in the left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in the right subtree\n\n    // Output indices for traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] left_output_index;  // Output index for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] right_output_index; // Output index for right subtree\n\n    // Integer for loop iterations\n    integer i;\n\n    // Always block triggered on the rising edge of the clock or reset signal\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            search_state <= S_IDLE;  // Set state to IDLE\n            found <= 0;              // Reset found flag\n            position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid position\n            complete_found <= 0;     // Reset complete_found signal\n            key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid key position\n            left_output_index <= 0;  // Reset left output index\n            right_output_index <= 0; // Reset right output index\n            sp_left <= 0;            // Reset left stack pointer\n            sp_right <= 0;           // Reset right stack pointer\n            left_done <= 0;          // Reset left_done flag\n            right_done <= 0;         // Reset right_done flag\n            search_state <= S_IDLE;  // Set state to IDLE\n            search_invalid <= 0;        // Set invalid_key to 0\n            \n            // Clear the stacks\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n            end\n\n        end else begin\n            // Main FSM logic\n            case (search_state)\n                S_IDLE: begin\n                    // Reset intermediate variables\n                    for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                    end\n                    complete_found <= 0;\n                    search_invalid <= 0;\n                    position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                    key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n\n                    if (start) begin\n                        // Start the search\n                        left_output_index <= 0;\n                        right_output_index <= 0;\n                        sp_left <= 0;\n                        sp_right <= 0;\n                        left_done <= 0;\n                        right_done <= 0;\n                        found <= 0;\n                        search_state <= S_INIT; // Move to INIT state\n                    end\n                end\n\n                S_INIT: begin\n                    if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        // Compare the search key with the root key\n                        if (search_key == keys[root*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            if (left_child[0*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                position <= 0;\n                                search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                            end else begin\n                                search_state <= S_SEARCH_LEFT; // Search in the left subtree\n                                current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end\n                        end else if (keys[0*DATA_WIDTH +: DATA_WIDTH] > search_key) begin\n                            search_state <= S_SEARCH_LEFT;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else begin\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            search_state <= S_SEARCH_LEFT_RIGHT; // Search in both left and right subtrees\n                        end\n                    end else begin\n                        search_state <= S_COMPLETE_SEARCH; // Root is null\n                    end\n                end\n\n                S_SEARCH_LEFT: begin\n                    // Traverse the left subtree\n                    if (current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        if (search_key == keys[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            position <= left_output_index;   \n                            search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                        end\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else begin //if (!left_done) begin\n                        if (found == 1) begin\n                            position <= left_output_index;\n                        end \n                        left_done <= 1;\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_SEARCH_LEFT_RIGHT: begin\n                    // Traverse both left and right subtrees\n                    if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done && sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done) begin\n                        left_done <= 1;\n                    end\n\n                    if (!found) begin\n                        if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                            right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                            sp_right <= sp_right + 1;\n                            current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done && sp_right > 0) begin\n                            sp_right <= sp_right - 1;\n                            current_right_node <= right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            if (search_key == keys[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                                found <= 1;\n                            end\n                            right_output_index <= right_output_index + 1;\n                            current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done) begin\n                            right_done <= 1;\n                        end\n\n                    end else if (left_done) begin\n                        position <= left_output_index + right_output_index;\n                        search_state <= S_COMPLETE_SEARCH; \n\n                    end\n\n                    if (right_done && left_done && !found) begin\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_COMPLETE_SEARCH: begin\n                    // Complete the search\n                    if (!found) begin\n                        complete_found <= 0;\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_invalid <= 1;\n                    end else begin\n                        complete_found  <= 1;\n                        key_position <= position;\n                        search_invalid <= 0;\n                    end\n                    search_state <= S_IDLE; // Return to IDLE state\n                end\n\n                default: begin\n                    search_state <= S_IDLE; // Default to IDLE state\n                end\n            endcase\n        end\n    end \n\nendmodule", "docs/specification.md": "## Specification\n\nThe BST is a structure formed where each node contains a key, with its `left_child` containing `keys` less than or equal to the node, and its `right_child` containing `keys` greater than the node. The key to be searched and deleted  (`delete_key`) is located based on its **position in the sorted array** (sorted such that the smallest element is at index 0 and the largest element is at index `ARRAY_SIZE`-1). The array is not sorted in this module. However, the BST is constructed in a way that traversing to the nodes results in a sorted array. The module doesn't wait for the complete BST to be traversed. As soon as the `delete_key` is found and its position is located, the module stops its search and transitions to the stage where the key is deleted based on the number of possible children (no, one, or two children). Furthermore, it is expected that the keys are not duplicated. \n\n---\n\n### Invalid Key and Pointer Values\n- **Invalid key value:** `(2^DATA_WIDTH) - 1`\n- **Invalid pointer value for left_child and right_child:** `(2^(clog2(ARRAY_SIZE) + 1) - 1`\n\n---\n\n### Inputs:\n- `[ARRAY_SIZE*DATA_WIDTH-1:0] keys`: A packed array containing the node values of the BST. \n- `[ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child`: A packed array containing the left child pointers for each node in the BST.\n- `[ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child`: A packed array containing the right child pointers for each node in the BST.\n- `[$clog2(ARRAY_SIZE):0] root`: The index of the root node (always 0 except for an empty BST, assuming the BST is constructed such that the first element in the arrays corresponds to the root node). For an empty BST, `root` is assigned an invalid index where all bits are set to 1; Eg, 15 (for ARRAY_SIZE = 7).\n- `[DATA_WIDTH-1:0] delete_key`: The key to search and delete in the BST.\n- `start`: 1-bit active high signal to initiate the search and deletion (1 clock cycle in duration).\n- `clk`: Clock Signal. The design is synchronized to the positive edge of this clock.\n- `reset`: Asynchronous active high reset to reset all control signal outputs to zero and `key_position`, `modified_keys`. `modified_left_child` and `modified_right_child` to null(invalid) values.\n\n### Outputs\n- `[$clog2(ARRAY_SIZE):0] key_position`: The position of the `delete_key` in the BST with respect to its sorted position. If the `delete_key` is not found in the constructed BST or if the tree is empty (indicated by all entries in `left_child`, `right_child` being null pointers, and all `keys` being zero) the module sets all the bits of `key_position` to 1 (null position). Value is also reset to null pointer 1 cycle after a deletion operation is completed.\n- `complete_deletion`: 1-bit active high signal that is asserted once the deletion is complete, indicating that the key was found and deleted (1 clock cycle in duration). If the `delete_key` is not found in the constructed BST or if the tree is empty, `complete_deletion` remains at 0.\n- `delete_invalid`: 1-bit Active high signal that is asserted when the BST is empty or when the `delete_key` doesn't exist in the given BST (1 clock cycle in duration). \n- `modified_keys`: Updated array of node keys after deletion. Each value in `modified_keys` gets reset to an invalid key value, 1 cycle after the deletion has been completed for a given BST and `delete_key`.\n- `modified_left_child`: Updated array of left child pointers after deletion. Each value in `modified_left_child` gets reset to an invalid pointer value, 1 cycle after the deletion has been completed for a given BST and `delete_key`.\n- `modified_right_child`: Updated array of right child pointers after deletion. Each value in `modified_right_child` gets reset to an invalid pointer value, 1 cycle after the deletion has been completed for a given BST and `delete_key`.\n\n---\n\n### Deletion Scenarios\n1. **Node with Both Left and Right Children:**\n   - Find the inorder successor (the leftmost node in the right subtree).\n   - Replace the node's key with the in-order successor's key.\n   - Delete the inorder successor node.\n\n2. **Node with Only Left Child:**\n   - Replace the node's key and pointers with those of its left child.\n   - Mark the left child's original position as invalid.\n\n3. **Node with Only Right Child:**\n   - Replace the node's key and pointers with those of its right child.\n   - Mark the right child's original position as invalid.\n\n4. **Node with No Children:**\n   - Mark the node's key and pointers as invalid.\n\n---\n\n### Implementation details \n\n**FSM (Finite State Machine) Design**:\nThe search and delete processes must be controlled by an FSM. \n\n- **S_IDLE**: The system resets intermediate variables and the outputs and waits for the `start` signal.\n- **S_INIT**: The search begins by comparing the `delete_key` with the root node and decides the direction of traversal (left or right).\n- **S_SEARCH_LEFT**: The FSM traverses the left subtree if the `delete_key` is less than the `root` node.\n- **S_SEARCH_LEFT_RIGHT**: The FSM traverses both left and right subtrees if the `delete_key` is greater than the `root` node.\n- **S_DELETE**:  The FSM deletes the key based on the number of children and different combinations. It traverses to `S_DELETE_COMPLETE` for completion. But when the `delete_key` has both the children, it traverses to `S_FIND_INORDER_SUCCESSOR` first.\n-  **S_DELETE_COMPLETE**: The FSM outputs the signals `complete_deletion`, `key_position`, and  `delete_invalid` and the keys and pointer of the modified tree.\n-  **S_FIND_INORDER_SUCCESSOR**: The FSM finds the in-order successor of the `delete_key`. It traverses to the right child and stays in the same state until it encounters a left child that has no key, and then traverses to `S_DELETE_COMPLETE`.\n\n---\n\n**Latency Analysis**:\n\n- **Example 1**: The worst case scenario is for deleting the largest node in the right-skewed tree (every node only consists of a right_child and no left_child.). The design traverses to the left child of every node (which does not exist for a right-skewed tree) and then searches for its right child. The process is repeated for every node except the root node until the key of the node matches the `delete_key` to update the `key_position`. Since the largest node in the right-skewed tree is the last node without any child, this leads to a latency of (`ARRAY_SIZE` - 1) * 2. The updation of the `key_position` takes 1 additional clock cycle. Based on the information of the node determined, the deletion of the node in the `S_DELETE` state is performed which takes 1 clock cycle. Additionally, it takes 2 clock cycles in the **S_INIT** and **S_DELETE_COMPLETE** states and 1 clock cycle to transition from `S_IDLE` to `S_INIT` when `start` is asserted.\n     - Total Latency = Start (`1`) + Initialization (`1`)  + Traversal (`(`ARRAY_SIZE` - 1) * 2`)  + Update `key_position` (`1`) +  Deletion (`1`)  + Completion (`1`)\n     \n- **Example 2**: If the `delete_key` matches the smallest node in the left skewed tree (every node only consists of a left_child and no right_child). The latency for all nodes except the root node to be traversed once until the depth of the left sub-tree (until the smallest key), is equal to `ARRAY_SIZE-1`. The process is then stopped and the `key_position` is updated for the smallest key which takes 1 additional clock cycle. Similar to other cases, it takes 3 clock cycles in the **S_INIT**, **S_DELETE** and **S_DELETE_COMPLETE** states and 1 clock cycle to transition from `S_IDLE` to `S_INIT`when start is asserted.\n     - Total Latency = Start (`1`) + Initialization (`1`)  + Traversal (`ARRAY_SIZE - 1`) + Update `key_position` (`1`) +  Deletion (`1`)  + Completion (`1`)\n\n- **Example 3**: To delete a node (15) in the given Binary Search Tree (BST) below that has both left and right children, consider the following example: \n\n  - **BST Structure**:  \n      - `keys = [10, 5, 15, 3, 12, 20]`  \n      - `left_child = [1, 3, 4, 15, 15, 15]`  \n      - `right_child = [2, 15, 5, 15, 15, 15]`  \n\n  - **Delete Operation**:  \n      - The node to delete has the key `delete_key = 15`, which has a right child at index 6 (key = 20) and a left child at index 5 (key = 12).  \n\n  - **Traversal Process**:  \n      - Searching for the node with `key = 15` takes **4 clock cycles** to traverse to its left child and backtrack in this BST example. Additional 1 clock cycle to update the position of `delete_key = 15` and to set the `left_done` signal for the left subtree. To determine the position of the `delete_key` in the right subtree, the left subtree must be completely traversed, hence the search algorithm waits for the `left_done` to be set. After the `left_done` is set, it takes 1 clock cycle to transition to the `S_DELETE` state. In total, searching the node requires **6 clock cycles**. \n\n  - **Deletion Process**:  \n      - Deleting the node involves finding its in-order successor (the leftmost node in the right subtree). This process takes **3 clock cycles**:  \n          1. **1 clock cycle** to assign the right child of `delete_key` in the `S_DELETE` state.  \n          2. **2 clock cycles** to traverse to the leftmost child of the right child of `delete_key` in the `S_FIND_INORDER_SUCCESSOR` state and replace the node with its in-order successor.  \n\n  - **State Transitions**:  \n       - Similar to other cases, the `S_INIT` and `S_DELETE_COMPLETE` states each take **2 clock cycles**.  \n       - Additional 1 clock cycle to transition from `S_IDLE` to `S_INIT`when start is asserted\n  \n  - So total latency = Start (`1`) + Initialization (`1`) + Traversal (`6`) +  Deletion (`3`) + Completion (`1`)\n \n---"}, "patch": {"rtl/search_binary_search_tree.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -vs", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/search_binary_search_tree.sv \nTOPLEVEL        = delete_node_binary_search_tree\nMODULE          = test_delete_node_binary_search_tree\nPYTHONPATH      = /src\nHASH            = 1-deletion-of-a-node-in-bst-code-modify\n", "src/test_delete_node_binary_search_tree.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport math \nimport random\nimport math\n\ndef compute_invalid_key(data_width):\n    \"\"\"\n    The invalid key is all ones in data_width bits, i.e., (2^data_width) - 1.\n    Example: if data_width=6, invalid_key=63.\n    \"\"\"\n    return (1 << data_width) - 1\n\ndef compute_invalid_pointer(array_size):\n    \"\"\"\n    The invalid pointer for the left_child/right_child arrays.\n    = 2^(ceil(log2(array_size)) + 1) - 1\n\n    For example, if array_size=5 => ceil(log2(5))=3 => pointer=2^(3+1)-1=15.\n    \"\"\"\n    if array_size <= 1:\n        # degenerate case\n        return 0\n    exp = math.ceil(math.log2(array_size))\n    return (1 << (exp + 1)) - 1\n\ndef find_node_and_parent(keys, left_child, right_child, root_index,\n                         pointer_invalid, target_key):\n    \"\"\"\n    Find the node that has key == target_key in the BST, along with its parent.\n    Returns (node_index, parent_index) or (None, None) if not found.\n\n    'root_index' is the index of the BST root (often 0 if valid).\n    'pointer_invalid' indicates an invalid pointer (no child).\n    \"\"\"\n    parent_idx = None\n    current_idx = root_index\n    \n    while current_idx != pointer_invalid:\n        current_key = keys[current_idx]\n        if current_key == target_key:\n            return (current_idx, parent_idx)\n        elif target_key < current_key:\n            parent_idx = current_idx\n            current_idx = left_child[current_idx]\n        else:\n            parent_idx = current_idx\n            current_idx = right_child[current_idx]\n    \n    return (None, None)  # not found\n\ndef find_leftmost_index(keys, left_child, right_child, start_index, pointer_invalid):\n    \"\"\"\n    Find the index of the leftmost node in the subtree rooted at 'start_index'.\n    i.e. 'inorder successor' if 'start_index' is the root of a right subtree.\n    \"\"\"\n    current = start_index\n    while left_child[current] != pointer_invalid:\n        current = left_child[current]\n    return current\n\ndef replace_parent_pointer(parent_idx, child_idx, new_idx,\n                           left_child, right_child):\n    \"\"\"\n    Helper to redirect parent_idx\u2019s pointer (left or right) that was referencing child_idx\n    to now reference new_idx instead.\n    This is used to \u201cbypass\u201d or remove the child_idx from the tree structure.\n    \"\"\"\n    if parent_idx is None:\n        # No parent => the deleted node was the root.\n        # We'll return special info so the caller knows how to fix the root\n        return None, new_idx\n    \n    # If the parent's left pointer was the child_idx, update that\n    if left_child[parent_idx] == child_idx:\n        left_child[parent_idx] = new_idx\n    # Else if the parent's right pointer was the child_idx, update that\n    elif right_child[parent_idx] == child_idx:\n        right_child[parent_idx] = new_idx\n    \n    return parent_idx, None  # No change to root; no new root\n\ndef delete_node_with_zero_or_one_child(node_idx, parent_idx,\n                                       keys, left_child, right_child,\n                                       pointer_invalid, key_invalid):\n    \"\"\"\n    Handle the case where node_idx has 0 or 1 child.\n    Returns (new_root_idx) if node_idx was the root and we replaced it,\n    or None if the root is unchanged.\n    \"\"\"\n    left_idx = left_child[node_idx]\n    right_idx = right_child[node_idx]\n    \n    # Determine the single child (or none)\n    if left_idx == pointer_invalid and right_idx == pointer_invalid:\n        # No children (leaf)\n        new_idx = pointer_invalid\n    elif left_idx != pointer_invalid and right_idx == pointer_invalid:\n        # Only left child\n        new_idx = left_idx\n    elif left_idx == pointer_invalid and right_idx != pointer_invalid:\n        # Only right child\n        new_idx = right_idx\n    else:\n        # This function should not be called if there are 2 children\n        return None  # logic error if we get here\n    \n    # Replace parent's pointer from node_idx -> new_idx\n    p, new_root = replace_parent_pointer(parent_idx, node_idx, new_idx,\n                                         left_child, right_child)\n    # Invalidate this node\n    keys[node_idx] = key_invalid\n    left_child[node_idx] = pointer_invalid\n    right_child[node_idx] = pointer_invalid\n    \n    # If new_root is not None, that means the old node_idx was the root\n    return new_root\n\ndef _delete_bst_key_inplace(keys, left_child, right_child, delete_key, data_width=6):\n    \"\"\"\n    Internal helper that modifies the lists IN-PLACE. \n    Standard BST deletion algorithm:\n\n      1. Find the node containing 'delete_key'.\n      2. If not found => done.\n      3. If found, apply BST deletion logic:\n         - If node has 0 or 1 child => bypass it.\n         - If node has 2 children => find the inorder successor from the right subtree,\n           copy that key into the node, and then remove the successor using the\n           0-or-1 child rule.\n\n    This is the same logic as before, but it is *internal*, so we can do it in place\n    after copying in the user-facing function.\n    \"\"\"\n    n = len(keys)\n    if n == 0:\n        return  # Nothing to delete\n\n    key_invalid = compute_invalid_key(data_width)       # e.g. 63\n    pointer_invalid = compute_invalid_pointer(n)        # e.g. 15 for array_size=5\n\n    # Assume the BST root is index=0 if valid\n    root_index = 0\n    if keys[root_index] == key_invalid:\n        # Tree is effectively empty\n        return\n\n    # 1) Find the node to delete (node_idx) and its parent (parent_idx)\n    node_idx, parent_idx = find_node_and_parent(keys, left_child, right_child,\n                                                root_index, pointer_invalid, delete_key)\n    if node_idx is None:\n        return  # Key not found, do nothing\n\n    left_idx = left_child[node_idx]\n    right_idx = right_child[node_idx]\n    has_left = (left_idx != pointer_invalid)\n    has_right = (right_idx != pointer_invalid)\n\n    # 2) If node has 0 or 1 child => remove or bypass it\n    # -------------------- CASE 2: ONLY LEFT CHILD -----------------------\n    if has_left and not has_right:\n        # Copy the left child's data into node_idx\n        keys[node_idx]       = keys[left_idx]\n        left_child[node_idx] = left_child[left_idx]\n        right_child[node_idx]= right_child[left_idx]\n        \n        # Now invalidate the old child's index\n        keys[left_idx]          = key_invalid\n        left_child[left_idx]    = pointer_invalid\n        right_child[left_idx]   = pointer_invalid\n\n    elif not has_left and has_right:\n        # Copy the right child's data into node_idx\n        keys[node_idx]       = keys[right_idx]\n        left_child[node_idx] = left_child[right_idx]\n        right_child[node_idx]= right_child[right_idx]\n        \n        # Now invalidate the old child's index\n        keys[right_idx]          = key_invalid\n        left_child[right_idx]    = pointer_invalid\n        right_child[right_idx]   = pointer_invalid\n       \n    elif not has_left and not has_right:\n        new_root = delete_node_with_zero_or_one_child(node_idx, parent_idx,\n                                                      keys, left_child, right_child,\n                                                      pointer_invalid, key_invalid)\n        if new_root is not None:\n            # If we actually replaced the root with a child or invalid,\n            # just note that in case you want to track the new root. \n            pass\n    else:\n        # 3) Node has 2 children => find inorder successor in right subtree\n        successor_idx = find_leftmost_index(keys, left_child, right_child,\n                                            right_idx, pointer_invalid)\n        successor_key = keys[successor_idx]\n\n        # Overwrite the current node's key with the successor's key\n        keys[node_idx] = successor_key\n\n        # Now remove the successor node. The successor is guaranteed to have <=1 child.\n        # We still need to find the successor's parent for that operation:\n\n        if successor_idx == right_idx and left_child[successor_idx] == pointer_invalid:\n            # The successor is the immediate right child, with no left child\n            # => its parent is node_idx\n            succ_parent = node_idx\n        else:\n            # Otherwise, find the successor's parent by searching in the right subtree\n            # from node_idx:\n            current = right_idx\n            prev = node_idx\n            while current != successor_idx:\n                prev = current\n                if keys[successor_idx] < keys[current]:\n                    current = left_child[current]\n                else:\n                    current = right_child[current]\n            succ_parent = prev\n\n        delete_node_with_zero_or_one_child(successor_idx, succ_parent,\n                                           keys, left_child, right_child,\n                                           pointer_invalid, key_invalid)\n\ndef delete_bst_key(\n    keys, left_child, right_child, delete_key, data_width=6\n):\n    \"\"\"\n    *USER-FACING FUNCTION* that behaves like call-by-value in other languages:\n      - Makes copies of the input arrays.\n      - Performs the BST deletion on those copies.\n      - Returns the new copies (modified).\n    \n    The original arrays remain untouched.\n    \"\"\"\n    # Copy the arrays locally (shallow copy is enough for lists of ints)\n    new_keys = list(keys)\n    new_left_child = list(left_child)\n    new_right_child = list(right_child)\n\n    # Perform the in-place BST deletion on these copies\n    _delete_bst_key_inplace(new_keys, new_left_child, new_right_child,\n                            delete_key, data_width)\n\n    # Return the modified copies\n    return new_keys, new_left_child, new_right_child\n\n\ndef generate_random_with_constraints(data_width, input_array):\n    \"\"\"\n    Generate a random number within the range [0, 2^data_width - 1] \n    that is not present in input_array.\n    \"\"\"\n    range_limit = (1 << data_width) - 1  # 2^data_width - 1\n    input_set = set(input_array)  # Convert array to a set for fast lookups\n    \n    while True:\n        random_number = random.randint(0, range_limit)\n        if random_number not in input_set:\n            return random_number\n\n@cocotb.test()\nasync def test_search_bst(dut):\n    \"\"\"Cocotb testbench for the search_binary_search_tree module.\"\"\"\n    left_child = []\n    right_child = []\n    packed_left_child = 0\n    packed_right_child = 0\n    packed_keys = 0\n    run = 0\n\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n    ARRAY_SIZE = int(dut.ARRAY_SIZE.value)\n\n    INVALID_KEY = (2**DATA_WIDTH) - 1\n    INVALID_POINTER = 2**(math.ceil(math.log2(ARRAY_SIZE)) + 1) - 1\n\n    invalid_key_list = []\n    invalid_pointer_list = []\n\n    # Initialize the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Reset the DUT\n    dut.reset.value = 1\n    await Timer(20, units=\"ns\")\n    dut.reset.value = 0\n\n    for i in range(4):\n        await RisingEdge(dut.clk)\n\n    for i in range(ARRAY_SIZE):\n        invalid_key_list.append(INVALID_KEY)\n        invalid_pointer_list.append(INVALID_POINTER)\n\n    # Test Case 1: Empty tree\n    dut.delete_key.value = 10  # Key to search\n    dut.keys.value = 0; \n\n    for i in range(ARRAY_SIZE):\n        left_child.append(2**(math.ceil(math.log2(ARRAY_SIZE)) + 1)-1)\n        right_child.append(2**(math.ceil(math.log2(ARRAY_SIZE)) + 1)-1)\n\n    for idx, val in enumerate(left_child):\n        packed_left_child |= (val << (idx * (math.ceil(math.log2(ARRAY_SIZE)) + 1)))\n    dut.left_child.value = packed_left_child\n \n\n    for idx, val in enumerate(right_child):\n        packed_right_child |= (val << (idx * (math.ceil(math.log2(ARRAY_SIZE)) + 1)))\n    dut.right_child.value = packed_right_child\n\n    dut.root.value = 2**(math.ceil(math.log2(ARRAY_SIZE)) + 1)-1\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    #await RisingEdge(dut.search_invalid.value)\n\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.complete_deletion.value == 1 or dut.delete_invalid.value == 1:\n            break\n\n    print('delete_invalid', dut.delete_invalid.value)\n\n    assert (dut.delete_invalid.value == 1) , \"Failed: Tree is empty; delete_key should not be found, delete_invalid not set\"\n\n    for i in range(2):\n        await RisingEdge(dut.clk)\n\n    # Test Case 2: Non-empty BST\n    if (ARRAY_SIZE == 10 and DATA_WIDTH == 16):\n        keys = [58514, 50092, 48887, 48080, 5485, 5967, 19599, 23938, 34328, 42874]\n        right_child = [31, 31, 31, 31, 5, 6, 7, 8, 9, 31]\n        left_child = [1, 2, 3, 4, 31, 31, 31, 31, 31, 31]\n        run = 1\n        expected_latency_smallest = 9 \n        expected_latency_largest = (ARRAY_SIZE - 1) * 2 + 2  + 3\n    elif (ARRAY_SIZE == 15 and DATA_WIDTH == 6):\n        keys = [9, 14, 15, 17, 19, 21, 30, 32, 35, 40, 46, 47, 48, 49, 50]\n        left_child = [31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31]\n        right_child = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 31]\n        run = 1\n        expected_latency_smallest = 4\n        expected_latency_largest = (ARRAY_SIZE - 1) * 2 + 2 + 3\n    elif (ARRAY_SIZE == 15 and DATA_WIDTH == 32):\n        keys = [200706183, 259064287, 811616460, 956305578, 987713153, 1057458493, 1425113391, 1512400858, 2157180141, 2322902151, 2683058769, 2918411874, 2982472603, 3530595430, 3599316877]\n        keys = sorted(keys, reverse=True)\n        right_child = [31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31]\n        left_child = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 31]\n        run = 1\n        expected_latency_smallest = (ARRAY_SIZE - 1) + 2 + 3\n        expected_latency_largest = (ARRAY_SIZE - 1) * 2 + 2 + 3\n    elif (ARRAY_SIZE == 5 and DATA_WIDTH == 6):\n        keys = [1, 20, 0, 61, 5]\n        left_child = [2,4,15,15,15]\n        right_child = [1,3,15,15,15]\n        run = 1\n        expected_latency_smallest = 6 \n        expected_latency_largest = (ARRAY_SIZE - 1)*2 + 3 \n\n    \n    if run == 1:\n        print('keys', keys)\n        print('left_child', left_child)\n        print('right_child', right_child)\n\n        print('----------------------------Test case 2: Random key-----------------------------------')\n        dut.start.value = 1\n        index = random.randint(1, ARRAY_SIZE-2)\n        dut.delete_key.value = sorted(keys)[index]  # Random index\n        packed_left_child = 0\n        packed_right_child = 0\n        \n        for idx, val in enumerate(keys):\n            packed_keys |= (val << (idx * DATA_WIDTH))\n        \n        dut.keys.value = packed_keys\n\n        for idx, val in enumerate(left_child):\n            packed_left_child |= (val << (idx * (math.ceil(math.log2(ARRAY_SIZE)) + 1)))\n    \n        dut.left_child.value = packed_left_child\n\n        for idx, val in enumerate(right_child):\n            packed_right_child |= (val << (idx * (math.ceil(math.log2(ARRAY_SIZE)) + 1)))\n        dut.right_child.value = packed_right_child\n\n    \n        dut.root.value = 0\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        delete = dut.complete_deletion.value\n        \n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.complete_deletion.value == 1:\n                break\n        \n        print('key_value ', dut.delete_key.value.to_unsigned())\n        print('delete_invalid ', dut.delete_invalid.value)\n\n        modified_keys = int(dut.modified_keys.value)\n        modified_left = int(dut.modified_left_child.value)\n        modified_right = int(dut.modified_right_child.value)\n\n        actual_modified_keys = [ (modified_keys >> (i * DATA_WIDTH)) & ((1 << DATA_WIDTH) - 1) for i in range(ARRAY_SIZE)]\n        actual_modified_left = [ (modified_left >> (i * (math.ceil(math.log2(ARRAY_SIZE))+1))) & ((1 <<  (math.ceil(math.log2(ARRAY_SIZE))+1)) - 1) for i in range(ARRAY_SIZE)]\n        actual_modified_right = [ (modified_right >> (i * (math.ceil(math.log2(ARRAY_SIZE))+1))) & ((1 << (math.ceil(math.log2(ARRAY_SIZE))+1)) - 1) for i in range(ARRAY_SIZE)]\n       \n        key_bst, left_child_bst, right_child_bst = delete_bst_key(keys, left_child, right_child, dut.delete_key.value.to_unsigned(), DATA_WIDTH)\n  \n        print('expected keys', key_bst)\n        print('expected left', left_child_bst)\n        print('expected right', right_child_bst)\n\n        print('actual keys', actual_modified_keys)\n        print('actual left', actual_modified_left)\n        print('actual right', actual_modified_right)\n\n        assert ((key_bst == actual_modified_keys)), \\\n                f\"Failed: Key {actual_modified_keys} should be modified as {key_bst}.\"\n        assert ((left_child_bst == actual_modified_left)), \\\n                f\"Failed: Key {actual_modified_left} should be modified as  {left_child_bst}.\"\n        assert ((right_child_bst == actual_modified_right)), \\\n                f\"Failed: Key {actual_modified_right} should be modified as {right_child_bst}.\"\n\n        assert (dut.delete_invalid.value == 0) , \"Failed: delete_invalid  set, but delete_key present\"\n\n        expected_position = reference_model(dut.delete_key.value, keys)\n        assert dut.complete_deletion.value and dut.key_position.value.to_unsigned() == expected_position, \\\n            f\"Failed: Largest key {dut.delete_key.value} should be at position {expected_position}.\"\n\n\n        for i in range(2):\n            await RisingEdge(dut.clk)\n\n        #-------------------------------- Test Case 3: Key not in BST -----------------------------------------\n        dut.start.value = 1\n\n        print('---------------------------Test case 3: not in key-----------------------------------------')\n\n        dut.delete_key.value = generate_random_with_constraints(DATA_WIDTH, keys)  # Key not in BST\n       \n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.complete_deletion.value == 1 or dut.delete_invalid.value == 1:\n                break\n        \n        print('key_value ', dut.delete_key.value.to_unsigned())\n        print('delete_invalid ', dut.delete_invalid.value)\n\n        modified_keys = int(dut.modified_keys.value)\n        modified_left = int(dut.modified_left_child.value)\n        modified_right = int(dut.modified_right_child.value)\n\n        actual_modified_keys = [ (modified_keys >> (i * DATA_WIDTH)) & ((1 << DATA_WIDTH) - 1) for i in range(ARRAY_SIZE)]\n        actual_modified_left = [ (modified_left >> (i * (math.ceil(math.log2(ARRAY_SIZE))+1))) & ((1 <<  (math.ceil(math.log2(ARRAY_SIZE))+1)) - 1) for i in range(ARRAY_SIZE)]\n        actual_modified_right = [ (modified_right >> (i * (math.ceil(math.log2(ARRAY_SIZE))+1))) & ((1 << (math.ceil(math.log2(ARRAY_SIZE))+1)) - 1) for i in range(ARRAY_SIZE)]\n    \n        print('expected keys', key_bst)\n        print('expected left', left_child_bst)\n        print('expected right', right_child_bst)\n\n        print('actual keys', actual_modified_keys)\n        print('actual left', actual_modified_left)\n        print('actual right', actual_modified_right)\n    \n        assert ((invalid_key_list == actual_modified_keys)), \\\n                f\"Failed: Key {actual_modified_keys} should be modified as {invalid_key_list}.\"\n        assert ((invalid_pointer_list == actual_modified_left)), \\\n                f\"Failed: Key {actual_modified_left} should be modified as  {invalid_pointer_list}.\"\n        assert ((invalid_pointer_list == actual_modified_right)), \\\n                f\"Failed: Key {actual_modified_right} should be modified as {invalid_pointer_list}.\"\n     \n        assert (dut.delete_invalid.value == 1) , \"Failed: delete_key should not be found, delete_invalid not set\"\n\n        for i in range(2):\n            await RisingEdge(dut.clk)\n\n        # Test Case 4: Smallest key in BST\n        print('-------------------------------Test case 4: Smallest key-----------------------------')\n        \n        dut.start.value = 1\n        dut.delete_key.value = sorted(keys)[0]  # Smallest key\n       \n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.complete_deletion.value == 1:\n                break\n\n        \n        print('key_value ', dut.delete_key.value.to_unsigned())\n        print('delete_invalid ', dut.delete_invalid.value)\n\n        modified_keys = int(dut.modified_keys.value)\n        modified_left = int(dut.modified_left_child.value)\n        modified_right = int(dut.modified_right_child.value)\n\n        actual_modified_keys = [ (modified_keys >> (i * DATA_WIDTH)) & ((1 << DATA_WIDTH) - 1) for i in range(ARRAY_SIZE)]\n        actual_modified_left = [ (modified_left >> (i * (math.ceil(math.log2(ARRAY_SIZE))+1))) & ((1 <<  (math.ceil(math.log2(ARRAY_SIZE))+1)) - 1) for i in range(ARRAY_SIZE)]\n        actual_modified_right = [ (modified_right >> (i * (math.ceil(math.log2(ARRAY_SIZE))+1))) & ((1 << (math.ceil(math.log2(ARRAY_SIZE))+1)) - 1) for i in range(ARRAY_SIZE)]\n    \n        key_bst, left_child_bst, right_child_bst = delete_bst_key(keys, left_child, right_child, sorted(keys)[0] , DATA_WIDTH)\n\n        print('expected keys', key_bst)\n        print('expected left', left_child_bst)\n        print('expected right', right_child_bst)\n\n        print('actual keys', actual_modified_keys)\n        print('actual left', actual_modified_left)\n        print('actual right', actual_modified_right)\n\n        assert ((key_bst == actual_modified_keys)), \\\n                f\"Failed: Key {actual_modified_keys} should be modified as {key_bst}.\"\n        assert ((left_child_bst == actual_modified_left)), \\\n                f\"Failed: Key {actual_modified_left} should be modified as  {left_child_bst}.\"\n        assert ((right_child_bst == actual_modified_right)), \\\n                f\"Failed: Key {actual_modified_right} should be modified as {right_child_bst}.\"\n        \n        assert (dut.delete_invalid.value == 0) , \"Failed: delete_invalid  set, but delete_key present\"\n\n        cocotb.log.debug(f\"Total Latency : {cycle_count}, expected : {expected_latency_smallest}\")\n        assert expected_latency_smallest == cycle_count, f\"Latency incorrect. Got: {cycle_count}, Expected: {expected_latency_smallest}\"\n\n        expected_position = reference_model(dut.delete_key.value.to_unsigned(), keys)\n        assert dut.complete_deletion.value == 1 and dut.key_position.value.to_unsigned() == expected_position, \\\n            f\"Failed: Smallest key {dut.delete_key.value} should be at position {expected_position}.\"\n\n        for i in range(2):\n            await RisingEdge(dut.clk)\n\n        # Test Case 5: Largest key in BST\n        print('---------------------------Test case 5: Largest key-----------------------------------------')\n        \n        dut.start.value = 1\n        dut.delete_key.value = sorted(keys)[ARRAY_SIZE-1]  # Largest key\n        \n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.complete_deletion.value == 1:\n                break\n\n        print('key_value ', dut.delete_key.value.to_unsigned())\n        print('delete_invalid ', dut.delete_invalid.value)\n\n        modified_keys = int(dut.modified_keys.value)\n        modified_left = int(dut.modified_left_child.value)\n        modified_right = int(dut.modified_right_child.value)\n\n        actual_modified_keys = [ (modified_keys >> (i * DATA_WIDTH)) & ((1 << DATA_WIDTH) - 1) for i in range(ARRAY_SIZE)]\n        actual_modified_left = [ (modified_left >> (i * (math.ceil(math.log2(ARRAY_SIZE))+1))) & ((1 <<  (math.ceil(math.log2(ARRAY_SIZE))+1)) - 1) for i in range(ARRAY_SIZE)]\n        actual_modified_right = [ (modified_right >> (i * (math.ceil(math.log2(ARRAY_SIZE))+1))) & ((1 << (math.ceil(math.log2(ARRAY_SIZE))+1)) - 1) for i in range(ARRAY_SIZE)]\n    \n        key_bst, left_child_bst, right_child_bst = delete_bst_key(keys, left_child, right_child, sorted(keys)[ARRAY_SIZE-1], DATA_WIDTH)\n\n        print('expected keys', key_bst)\n        print('expected left', left_child_bst)\n        print('expected right', right_child_bst)\n\n        print('actual keys', actual_modified_keys)\n        print('actual left', actual_modified_left)\n        print('actual right', actual_modified_right)\n\n        assert ((key_bst == actual_modified_keys)), \\\n                f\"Failed: Key {actual_modified_keys} should be modified as {key_bst}.\"\n        assert ((left_child_bst == actual_modified_left)), \\\n                f\"Failed: Key {actual_modified_left} should be modified as  {left_child_bst}.\"\n        assert ((right_child_bst == actual_modified_right)), \\\n                f\"Failed: Key {actual_modified_right} should be modified as {right_child_bst}.\"\n        \n        assert (dut.delete_invalid.value == 0) , \"Failed: delete_invalid  set, but delete_key present\"\n        \n        cocotb.log.debug(f\"Total Latency : {cycle_count}, expected : {expected_latency_largest}\")\n        assert expected_latency_largest == cycle_count, f\"Latency incorrect. Got: {cycle_count}, Expected: {expected_latency_largest}\"\n\n        expected_position = reference_model(dut.delete_key.value, keys)\n        assert dut.complete_deletion.value and dut.key_position.value.to_unsigned() == expected_position, \\\n            f\"Failed: Largest key {dut.delete_key.value} should be at position {expected_position}.\"\n\n        cocotb.log.info(\"---------------------------------All test cases passed!-------------------------------------\")\n\n# Reference model\ndef reference_model(delete_key, keys):\n    \"\"\"Sort the keys and find the position of the search key.\"\"\"\n    sorted_keys = sorted(keys)\n    if delete_key in sorted_keys:\n        return sorted_keys.index(delete_key)\n    else:\n        return -1\n", "src/test_runner.py": "import os\nimport random\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Gather environment variables for simulation settings\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n# Define a runner function that takes the WIDTH parameter\ndef runner(DATA_WIDTH, ARRAY_SIZE):\n    # Get the simulator runner for the specified simulator (e.g., icarus)\n    runner = get_runner(sim)\n    \n    # Build the simulation environment with the randomized WIDTH parameter\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters={'DATA_WIDTH': DATA_WIDTH, 'ARRAY_SIZE' : ARRAY_SIZE},\n        always=True,               # Build even if files have not changed\n        clean=True,                # Clean previous builds\n        waves=True,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),  # Set timescale\n        log_file=\"sim.log\"         # Log the output of the simulation\n    )\n    \n    # Run the test module\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n# Parametrize test for different WIDTH and SIGNED_EN\n@pytest.mark.parametrize(\"DATA_WIDTH\", [6,16,32]) \n@pytest.mark.parametrize(\"ARRAY_SIZE\", [5, 10, 15])\ndef test_bst(DATA_WIDTH, ARRAY_SIZE):\n    # Log the randomized WIDTH\n    print(f'Running with: DATA_WIDTH = {DATA_WIDTH}, ARRAY_SIZE = {ARRAY_SIZE}')\n\n    # Call the runner function with the randomized WIDTH\n    runner(DATA_WIDTH,ARRAY_SIZE)"}}
{"id": "cvdp_agentic_breeze_velvet_violet_7060", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt, and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "You are provided with three SystemVerilog modules in the rtl/ directory. You need to integrate these three modules into a top-level module called `bst_operations`,  which should support the operations described further in the specification in the docs/bst_operations.md. \n\n1. `search_binary_search_tree` \u2014 performs key search in a binary search tree (BST)  \n2. `delete_node_binary_search_tree` \u2014 deletes a node with the given key from the BST  \n3. `binary_search_tree_sort_construct` \u2014 performs both BST construction and  sorting  via in-order traversal \n\n---\n\n### Required Modifications\n\n1. The module `binary_search_tree_sort_construct` currently combines **BST construction** and **sorting** into one module.  \n   Create **two separate functional modules** using `binary_search_tree_sort_construct` as the reference to be able to provide a BST input to the `search_binary_search_tree` and `delete_node_binary_search_tree` modules and optionally sort after the operations. While creating modules for separating the operations, add necessary input/output ports to the new submodules to propagate data between modules. (Only top module consistency needs to be retained as per the spec).\n   - `bst_tree_construct`: builds the BST\n   - `binary_search_tree_sort`: performs in-order traversal to output sorted keys\n\n2. You must **connect these new modules** inside `bst_operations` along with  `search_binary_search_tree` and  `delete_node_binary_search_tree`\n\n3. No additional latency other than that for handling completion flags must be added in between operations. \n\n---\n\n### Key Handling Consistency\n\nThere is an inconsistency in how **invalid keys** are handled across the modules. The original `binary_search_tree_sort_construct`  module uses `0` to indicate **invalid keys**. In contrast, both `search_binary_search_tree` and `delete_node_binary_search_tree` use **all 1s** (`{DATA_WIDTH{1'b1}}`) to represent invalid key values\n\n- Ensure that all modules within `bst_operations` use **consistent invalid key and pointer representations**  \n- Recommended:\n  - `INVALID Key = {DATA_WIDTH{1'b1}}`\n  - `INVALID Pointer = {($clog2(ARRAY_SIZE)+1){1'b1}}`\n\n---\n\n###  Top-Level Interface\n\nThe `bst_operations` module must:\n- Accept input data as a flattened array (`data_in`)\n- Accept a key (`operation_key`) and operation selector (`operation`)\n- Output the updated BST structure and, optionally, sorted keys\n- Output flags to indicate operation completion and validity\n---\n", "context": {"rtl/delete_node_binary_search_tree.sv": "module delete_node_binary_search_tree #(\n    parameter DATA_WIDTH = 16,         // Width of the data (of a single element)\n    parameter ARRAY_SIZE = 5          // Maximum number of elements in the BST\n) (\n\n    input clk,                                  // Clock signal\n    input reset,                                // Reset signal\n    input reg start,                            // Start signal to initiate the search\n    input reg [DATA_WIDTH-1:0] delete_key,      // Key to delete in the BST\n    input reg [$clog2(ARRAY_SIZE):0] root,      // Root node of the BST\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys, // Node keys in the BST\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child,           // Left child pointers\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child,           // Right child pointers\n    output reg [ARRAY_SIZE*DATA_WIDTH-1:0] modified_keys,                    // Node keys in the BST\n    output reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] modified_left_child,  // Left child pointers\n    output reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] modified_right_child, // Right child pointers\n    output reg complete_deletion,         // Signal indicating search completion\n    output reg delete_invalid            // Signal indicating invalid search\n);\n                                                                                                                                       \n    // Parameters for FSM states\n    parameter S_IDLE = 3'b000,                   // Idle state\n              S_INIT = 3'b001,                   // Initialization state\n              S_SEARCH_LEFT = 3'b010,            // Search in left subtree\n              S_SEARCH_RIGHT = 3'b011,           // Search in both left and right subtrees\n              S_DELETE = 3'b100,                 // Delete a node\n              S_DELETE_COMPLETE = 3'b101,        // Complete deletion\n              S_FIND_INORDER_SUCCESSOR = 3'b110; // State to find inorder successor\n\n   \n    // Registers to store the current FSM state\n    reg [2:0] delete_state;\n\n    // Variables to manage traversal\n    reg found;                                 // Indicates if the key is found\n\n    // Stacks for managing traversal of left and right subtrees\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack;  // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_left;         // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_right;        // Stack pointer for right subtree\n\n    // Pointers for the current nodes in left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node;  // Current node in the left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in the right subtree\n    reg [$clog2(ARRAY_SIZE):0] current_node;       // Current node\n\n    // Integer for loop iterations\n    integer i, j;\n    reg [$clog2(ARRAY_SIZE):0] null_node;\n\n    // Registers for inorder successor search\n    reg [$clog2(ARRAY_SIZE):0] min_node;       // Inorder successor node\n\n    // The INVALID pointer value used in comparisons.\n    localparam [($clog2(ARRAY_SIZE)+1)-1:0] INVALID = {($clog2(ARRAY_SIZE)+1){1'b1}};\n    localparam [DATA_WIDTH-1:0] INVALID_KEY = {DATA_WIDTH{1'b1}};\n\n     // FSM for inorder successor search\n    reg inorder_search_active;                 // Flag to activate inorder successor search\n\n    // Always block triggered on the rising edge of the clock or reset signal\n    always @(posedge clk or posedge reset) begin\n         reg [$clog2(ARRAY_SIZE):0] lchild, rchild;\n        if (reset) begin\n            // Reset all states and variables\n            delete_state <= S_IDLE;  // Set state to IDLE\n            found <= 0;              // Reset found flag\n            complete_deletion <= 0;     // Reset complete_deletion signal\n            sp_left <= 0;            // Reset left stack pointer\n            sp_right <= 0;           // Reset right stack pointer\n            delete_invalid <= 0;     // Set invalid_key to 0\n            inorder_search_active <= 0;           \n            // Clear the stacks\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                modified_left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                modified_right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                modified_keys[i*DATA_WIDTH +: DATA_WIDTH] <= INVALID_KEY;\n            end\n\n        end else begin\n            // Main FSM logic\n            case (delete_state)\n                S_IDLE: begin\n                    // Reset intermediate variables\n                     for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        modified_left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        modified_right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        modified_keys[i*DATA_WIDTH +: DATA_WIDTH] <= INVALID_KEY;\n                    end\n                    complete_deletion <= 0;\n                    delete_invalid <= 0;\n                    inorder_search_active <= 0;\n                    if (start) begin\n                        // Start the search\n                        sp_left <= 0;\n                        sp_right <= 0;\n                        found <= 0;\n                        delete_state <= S_INIT; // Move to INIT state\n                    end\n                end\n\n                S_INIT: begin\n                    if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        // Compare the delete key with the root key\n                        if (delete_key == keys[root*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            current_node <= 0;\n                            delete_state <= S_DELETE; // Move to complete search state\n                        end else if (keys[0*DATA_WIDTH +: DATA_WIDTH] > delete_key) begin // Else if the first key in the keys array is greater than the delete key\n                            delete_state <= S_SEARCH_LEFT;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];    // Set current left node pointer from the root's left child\n                        end else begin\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];    // Set current left node pointer from the root's left child\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];  // Set current right node pointer from the root's right child\n                            delete_state <= S_SEARCH_RIGHT; // Search in both left and right subtrees\n                        end\n                    end else begin\n                        delete_invalid <= 1;\n                        complete_deletion <= 0;\n                        delete_state <= S_IDLE;\n                    end\n                end\n\n                S_SEARCH_LEFT: begin\n                    // Traverse the left subtree\n                    if (current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin                // If left traversal is not finished and the current left node is valid\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;  // Push the current left node index onto the left stack\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];  // Move to the left child of the current node\n                        if (delete_key == keys[current_left_node*DATA_WIDTH +: DATA_WIDTH]) begin    // If the key at the retrieved node matches the search key\n                            found <= 1;\n                            current_node <= current_left_node;  \n                            delete_state <= S_DELETE; // Move to complete search state\n                        end\n                    end else if (sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];   // Move to the right child of the popped node for further traversal\n                    end else begin\n                        if (found == 1) begin\n                            delete_state <= S_DELETE; // Move to complete search state\n                        end else begin\n                            delete_invalid <= 1;\n                            complete_deletion <= 0;\n                            delete_state <= S_IDLE;\n                        end\n                    end\n                end\n\n                S_SEARCH_RIGHT: begin\n                    if (current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                        sp_right <= sp_right + 1;\n                        current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; // Move to left child of the current right node\n                        if (delete_key == keys[current_right_node*DATA_WIDTH +: DATA_WIDTH]) begin\n                            current_node <= current_right_node;\n                            found <= 1;\n                            delete_state <= S_DELETE;  \n                        end\n                    end else if (sp_right > 0) begin\n                        sp_right <= sp_right - 1;\n                        current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; // Move to right child of the popped node\n                    end else begin\n                        if (found == 1) begin\n                            delete_state <= S_DELETE; // Move to complete search state\n                        end else begin\n                            delete_invalid <= 1;\n                            complete_deletion <= 0;\n                            delete_state <= S_IDLE;\n                        end\n                    end\n                end\n\n                S_DELETE: begin\n                    // First, load the left and right child indices of the node.\n                    modified_keys <= keys;     //if not copied here then will give buggy output with only valid values with the moddified tree without the original tree values\n                    modified_left_child <= left_child;\n                    modified_right_child <= right_child;\n\n                    rchild = right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    lchild = left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n\n                    if (left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == INVALID\n                                    && right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] != INVALID) begin\n                        // Node has only right child\n                        // Replace the current node's key and pointers with those of its right child.\n                        modified_keys[current_node*DATA_WIDTH +: DATA_WIDTH] <= keys[rchild*DATA_WIDTH +: DATA_WIDTH];\n                        modified_left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= left_child[rchild*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        modified_right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= right_child[rchild*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        null_node <= rchild;\n                        delete_state <= S_DELETE_COMPLETE;\n                    end\n                    else if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == INVALID\n                                && left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] != INVALID) begin\n                        // Node has only left child.\n                        modified_keys[current_node*DATA_WIDTH +: DATA_WIDTH] <= keys[lchild*DATA_WIDTH +: DATA_WIDTH];\n                        modified_left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= left_child[lchild*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        modified_right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= right_child[lchild*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        null_node <= lchild;\n                        delete_state <= S_DELETE_COMPLETE;\n                    end\n                    else if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == INVALID    //Will give bug 'x' is both condition set to != INVAALID\n                                && left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == INVALID) begin\n                        // Node has no right or left child\n                        null_node <= current_node;\n                        delete_state <= S_DELETE_COMPLETE;\n                    end\n                    else begin\n                        // Node has two children.\n                        // Start finding the inorder successor.\n                        min_node <= rchild;\n                        inorder_search_active <= 1;\n                        delete_state <= S_FIND_INORDER_SUCCESSOR;\n                        \n                    end\n                end\n\n                S_FIND_INORDER_SUCCESSOR: begin\n                    if (inorder_search_active) begin\n                        if (left_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] != INVALID) begin\n                            min_node <= left_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; // Move to the left child\n                        end else begin\n                            // Copy the inorder successor's key into the current node.\n                            modified_keys[current_node*DATA_WIDTH +: DATA_WIDTH] <= keys[min_node*DATA_WIDTH +: DATA_WIDTH];\n\n                            // Delete the inorder successor by replacing it with its right child.\n                            if (right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]!= INVALID) begin\n                                modified_keys[min_node*DATA_WIDTH +: DATA_WIDTH] <= keys[right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                modified_right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= right_child[right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                modified_left_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= left_child[right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                null_node <= right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else begin\n                                null_node <= min_node;\n                            end\n\n                            delete_state <= S_DELETE_COMPLETE;\n                            inorder_search_active <= 0;\n                        end\n                    end\n\n                end\n\n                S_DELETE_COMPLETE:begin\n                    modified_keys[null_node*DATA_WIDTH +: DATA_WIDTH] <= INVALID_KEY;\n                    modified_left_child[null_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= INVALID;\n                    modified_right_child[null_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= INVALID;\n \n                    for (j=0; j < ARRAY_SIZE; j++) begin\n                        if (modified_left_child[j*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == null_node) begin  //Buggy output if instead of modified child the original child is checked\n                            modified_left_child[j*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= INVALID;\n                        end\n                        if (modified_right_child[j*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == null_node) begin\n                            modified_right_child[j*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= INVALID;\n                        end\n                    end\n                    delete_state <= S_IDLE;\n                    complete_deletion <= 1;\n                end\n\n                default: begin\n                    delete_state <= S_IDLE; // Default to IDLE state\n                end\n            endcase\n        end\n    end\n\nendmodule", "docs/bst_operations.md": "## Specification\n\nA **Binary Search Tree (BST)** is a hierarchical data structure where:\n\n- Each node contains a key.\n- The left child contains keys less than the parent.\n- The right child contains keys greater than the parent.\n\n### Overview\n\nThe `bst_operations` module implements **core Binary Search Tree (BST) operations** in hardware. It supports:\n\n- **Search**\n- **Delete**\n- **Optional sorting** of the BST post-operation\n\nThe module constructs a BST from an input array, performs the requested operation (`search` or `delete`), and outputs the resulting BST (and optionally its sorted version).\n\n---\n\n### Module Interface\n\n#### Inputs\n\n| Name                  | Width                                    | Description                                                             |\n|-----------------------|------------------------------------------|-------------------------------------------------------------------------|\n| `clk`                 | 1 bit                                    | Clock signal. The design is synchronized to the positive edge of this   |\n| `reset`               | 1 bit                                    | Asynchronous active high reset                                          |\n| `start`               | 1 bit                                    | Active high start signal to begin operation                             |\n| `operation_key`       | `DATA_WIDTH`                             | Key to search or delete                                                 |\n| `data_in`             | `ARRAY_SIZE \u00d7 DATA_WIDTH`                | Flattened input array of node values                                    |\n| `operation`           | 1 bit                                    | `0`: Search, `1`: Delete                                                |\n| `sort_after_operation`| 1 bit                                    | `1`: Sort BST after operation, `0`: Skip sorting                        |\n\n---\n\n#### Outputs\n\n| Name                  | Width                                                | Description                                                                                                                  |\n|-----------------------|------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------|\n| `key_position`        | `clog2(ARRAY_SIZE)+1`                                | Index of `operation_key` if found during search. For other operations, it is asserted as INVALID.                            |\n| `complete_operation`  | 1 bit                                                | High when operation is successfully completed                                                                                |\n| `operation_invalid`   | 1 bit                                                | High if the operation was invalid (e.g., key not found)                                                                      |\n| `out_sorted_data`     | `(ARRAY_SIZE \u00d7 DATA_WIDTH)`                          | Sorted BST output (if `sort_after_operation = 1`)                                                                            |\n| `out_keys`            | `(ARRAY_SIZE \u00d7 DATA_WIDTH)`                          | Updated node keys after operation                                                                                            |\n| `out_left_child`      | `(ARRAY_SIZE \u00d7 (clog2(ARRAY_SIZE)+1))`               | Updated left child indices                                                                                                   |\n| `out_right_child`     | `(ARRAY_SIZE \u00d7 (clog2(ARRAY_SIZE)+1))`               | Updated right child indices                                                                                                  |\n\n---\n\n#### Parameters:\n- DATA_WIDTH (default 16): Width of a single element, greater than 0.\n- ARRAY_SIZE (default 5): Number of elements in the array, will be greater than 0 \n\n### Internal Components\n\n#### Tree Construction\n\n- `bst_tree_construct` constructs the BST from the input `data_in`. No duplicate keys are allowed. \n- Outputs keys, left and right child arrays, and root node.\n- Signals the top module `bst_operations` on completion of tree construction.\n- If the structure is invalid (any of the data in the input array is invalid), a control signal to flag that the operation is invalid is raised. This terminates all the ations and asserts the `operation_invalid` to 1. \n\n---\n\n#### Search Operation\n\n- Triggered when `operation == 0` and `start` is asserted.\n- Uses `search_binary_search_tree` module.\n- If `sort_after_operation == 1`, then sorting logic is also invoked.\n- If the key is not found, `operation_invalid` is raised.\n\n---\n\n#### Delete Operation\n\n- Triggered when `operation == 1`.\n- Uses `delete_node_binary_search_tree`.\n- Updates BST and optionally triggers sort if `sort_after_operation` is high.\n- Handles cases where a node has:\n  - No child\n  - One child\n  - Two children (uses in-order successor)\n\n---\n\n#### BST Sorting\n\n- `binary_search_tree_sort` traverses the BST in order.\n- Generates `out_sorted_data`.\n- If sorting is disabled, `out_sorted_data` is filled with `INVALID_KEY`.\n\n---\n\n### Handling Invalid Keys & Pointers\n\n| Signal              | Value                        | Purpose                                                                                                          |\n|---------------------|------------------------------|------------------------------------------------------------------------------------------------------------------|\n| `INVALID Key`       | All 1s in `DATA_WIDTH`       | Represents unused or removed keys                                                                                |\n| `INVALID Pointer`   | All 1s in child pointer width| Represents NULL pointer in left/right child arrays                                                               |\n| `operation_invalid` | 1                            | Raised when operation (search and delete) is not complete, BST structure is invalid, or when sorting is invalid  |\n| `out_sorted_data`   | All 1s if invalid            | Filled with `INVALID_KEY` if sorting was skipped                                                                 |\n\n### Successful Completion of Operation\n\nThe `bst_operations` module asserts the `complete_operation` signal only after all required processes are finished\u2014specifically, the selected operation (search or delete)  if enabled, the sorting operation (`sort_after_operation` = 1). Since each submodule (search, delete, and sort) asserts its respective done signal for only one clock e, these signals must be latched internally to ensure accurate detection and confirmation of successful completion across multiple cycles.\n\n### Latency Analysis\n\nThe total latency from asserting `start` to the `complete_operation` signal being set to `1` depends on the selected operation (**search** or **delete**) and whether sorting nabled using `sort_after_operation`.\n\nIt includes the cumulative clock cycles for:\n- Constructing the BST,\n- Performing the specified operation,\n- Optional sorting of the resulting BST.\n\nEach internal module asserts its respective done signal for 1 clock cycle, which is latched and used by the top-level module to trigger subsequent stages.\n\nWhen sorting is **enabled**, the design requires:\n- 1 additional clock cycle each for: construction complete, operation complete, and sort complete  \n- **Total overhead = 3 clock cycles**\n\nWhen sorting is **not enabled**, the design still incurs:\n- 1 clock cycle each for construction complete and operation complete  \n- +1 additional cycle to latch the `done` or `invalid` signal from the operation module  \n- **Total overhead = 3 clock cycles**\n\nThis ensures control signal synchronization and consistent behavior regardless of sorting.", "rtl/binary_search_tree_sort_construct.sv": "module binary_search_tree_sort_construct #(\n    parameter DATA_WIDTH = 16,\n    parameter ARRAY_SIZE = 5\n) (\n    input clk,\n    input reset,\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in, // Input data to be sorted\n    input start,\n    output reg [ARRAY_SIZE*DATA_WIDTH-1:0] sorted_out, // Sorted output\n    output reg done\n);\n\n    // Parameters for top-level FSM states\n    parameter IDLE = 2'b00, BUILD_TREE = 2'b01, SORT_TREE = 2'b10;\n\n    // Parameters for nested FSM states (Build Tree)\n    parameter INIT = 2'b00, INSERT = 2'b01, TRAVERSE = 2'b10, COMPLETE = 2'b11;\n\n    // Parameters for nested FSM states (Sort Tree)\n    parameter S_INIT = 2'b00, S_TRAVERSE_LEFT = 2'b01, S_PROCESS_NODE = 2'b10, S_TRAVERSE_RIGHT = 2'b11;\n\n    // Registers for FSM states\n    reg [1:0] top_state, build_state, sort_state;\n\n    // BST representation\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in_copy;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] temp_out;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys; // Array to store node keys\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child; // Left child pointers\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child; // Right child pointers\n    reg [$clog2(ARRAY_SIZE):0] root; // Root node pointer\n    reg [$clog2(ARRAY_SIZE):0] next_free_node; // Pointer to the next free node\n\n    // Stack for in-order traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] stack; // Stack for traversal\n    reg [$clog2(ARRAY_SIZE):0] sp; // Stack pointer\n\n    // Working registers\n    reg [$clog2(ARRAY_SIZE):0] current_node; // Current node being processed\n    reg [$clog2(ARRAY_SIZE):0] input_index; // Index for input data\n    reg [$clog2(ARRAY_SIZE):0] output_index; // Index for output data\n    reg [DATA_WIDTH-1:0] temp_data; // Temporary data register\n\n    // Initialize all variables\n    integer i;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            top_state <= IDLE;\n            build_state <= INIT;\n            sort_state <= S_INIT;\n            root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Null pointer\n            next_free_node <= 0;\n            sp <= 0;\n            input_index <= 0;\n            output_index <= 0;\n            done <= 0;\n\n            // Clear tree arrays\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                temp_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n            end\n\n        end else begin\n            case (top_state)\n                IDLE: begin\n                    done <= 0;\n                    input_index <= 0;\n                    output_index <= 0; \n                    root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n                    next_free_node <= 0;\n                    sp <= 0;\n                    for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                        keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                        right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        temp_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                    end\n                    if (start) begin\n                        // Load input data into input array\n                        top_state <= BUILD_TREE;\n                        build_state <= INIT;\n                        data_in_copy <= data_in;\n                    end\n                end\n                BUILD_TREE: begin\n                    case (build_state)\n                        INIT: begin\n                            if (input_index < ARRAY_SIZE) begin\n                                temp_data <= data_in_copy[input_index*DATA_WIDTH +: DATA_WIDTH]; \n                                input_index <= input_index + 1;\n                                build_state <= INSERT;\n                            end else begin\n                                build_state <= COMPLETE;\n                            end\n                        end\n\n                        INSERT: begin\n                            if (root == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                // Tree is empty, insert at root\n                                root <= next_free_node;\n                                keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                next_free_node <= next_free_node + 1; \n                                build_state <= INIT;\n                            end else begin\n                                // Traverse the tree to find the correct position\n                                current_node <= root; \n                                build_state <= TRAVERSE;\n                            end\n                        end\n                        \n                        TRAVERSE: begin      \n                            if ((temp_data < keys[current_node*DATA_WIDTH +: DATA_WIDTH])) begin\n                                if (left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end else begin\n                                if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data; \n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end\n                        end\n                        COMPLETE: begin\n                            // Tree construction complete\n                            top_state <= SORT_TREE;\n                            sort_state <= S_INIT;\n                        end\n                    endcase\n                end\n\n                SORT_TREE: begin\n                    case (sort_state)\n                        S_INIT: begin\n                            \n                            if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                current_node <= root; // Start from the root node\n                                sp <= 0;\n                                sort_state <= S_TRAVERSE_LEFT;\n                            end\n                        end\n\n                        S_TRAVERSE_LEFT: begin\n                            if (current_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                stack[sp*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_node;\n                                sp <= sp + 1;\n                                current_node <= left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else begin\n                                sort_state <= S_PROCESS_NODE;\n                            end\n                        end\n\n                        S_PROCESS_NODE: begin\n                            if (sp > 0) begin\n                                sp <= sp - 1;\n                                current_node <= stack[(sp-1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                output_index <= output_index + 1; \n                                temp_out[output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[stack[($unsigned(sp)-1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]; // Output the key\n                                sort_state <= S_TRAVERSE_RIGHT;\n                            end else begin\n                                done <= 1; // All nodes processed\n                                sort_state <= S_INIT;\n                                top_state <= IDLE;\n                                sorted_out <= temp_out;\n                            end\n                        end\n\n                        S_TRAVERSE_RIGHT: begin\n                            current_node <= right_child[current_node*($clog2(ARRAY_SIZE)+1) +:($clog2(ARRAY_SIZE)+1)];\n                            sort_state <= S_TRAVERSE_LEFT;\n                        end\n                    endcase    \n                end\n\n                default: begin\n                    top_state <= IDLE; // Default behavior for top-level FSM\n                end\n            endcase\n        end\n    end\nendmodule", "rtl/search_binary_search_tree.sv": "module search_binary_search_tree #(\n    parameter DATA_WIDTH = 16,         // Width of the data (of a single element)\n    parameter ARRAY_SIZE = 5          // Maximum number of elements in the BST\n) (\n\n    input clk,                         // Clock signal\n    input reset,                       // Reset signal\n    input reg start,                   // Start signal to initiate the search\n    input reg [DATA_WIDTH-1:0] search_key, // Key to search in the BST\n    input reg [$clog2(ARRAY_SIZE):0] root, // Root node of the BST\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys, // Node keys in the BST\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child, // Left child pointers\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child, // Right child pointers\n    output reg [$clog2(ARRAY_SIZE):0] key_position, // Position of the found key\n    output reg complete_found,         // Signal indicating search completion\n    output reg search_invalid          // Signal indicating invalid search\n);\n                                                                                                                                        \n    // Parameters for FSM states\n    parameter S_IDLE = 3'b000,                 // Idle state\n              S_INIT = 3'b001,                 // Initialization state\n              S_SEARCH_LEFT = 3'b010,          // Search in left subtree\n              S_SEARCH_LEFT_RIGHT = 3'b011,    // Search in both left and right subtrees\n              S_COMPLETE_SEARCH = 3'b100;      // Search completion state\n   \n    // Registers to store the current FSM state\n    reg [2:0] search_state;\n\n    // Variables to manage traversal\n    reg [$clog2(ARRAY_SIZE):0] position;       // Position of the current node\n    reg found;                                 // Indicates if the key is found\n\n    reg left_done, right_done;                 // Flags to indicate completion of left and right subtree traversals\n\n    // Stacks for managing traversal of left and right subtrees\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack;  // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE):0] sp_left;         // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE):0] sp_right;        // Stack pointer for right subtree\n\n    // Pointers for the current nodes in left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node;  // Current node in the left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in the right subtree\n\n    // Output indices for traversal\n    reg [$clog2(ARRAY_SIZE):0] left_output_index;  // Output index for left subtree\n    reg [$clog2(ARRAY_SIZE):0] right_output_index; // Output index for right subtree\n\n    // Integer for loop iterations\n    integer i;\n\n    // Always block triggered on the rising edge of the clock or reset signal\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            search_state <= S_IDLE;  // Set state to IDLE\n            found <= 0;              // Reset found flag\n            position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid position\n            complete_found <= 0;     // Reset complete_found signal\n            key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid key position\n            left_output_index <= 0;  // Reset left output index\n            right_output_index <= 0; // Reset right output index\n            sp_left <= 0;            // Reset left stack pointer\n            sp_right <= 0;           // Reset right stack pointer\n            left_done <= 0;          // Reset left_done flag\n            right_done <= 0;         // Reset right_done flag\n            search_state <= S_IDLE;  // Set state to IDLE\n            search_invalid <= 0;        // Set invalid_key to 0\n            \n            // Clear the stacks\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n            end\n\n        end else begin\n            // Main FSM logic\n            case (search_state)\n                S_IDLE: begin\n                    // Reset intermediate variables\n                    for (i = 0; i < ARRAY_SIZE+1; i = i + 1) begin\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                    end\n                    complete_found <= 0;\n                    search_invalid <= 0;\n\n                    if (start) begin\n                        // Start the search\n                        left_output_index <= 0;\n                        right_output_index <= 0;\n                        sp_left <= 0;\n                        sp_right <= 0;\n                        left_done <= 0;\n                        right_done <= 0;\n                        found <= 0;\n                        position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_state <= S_INIT; // Move to INIT state\n                    end\n                end\n\n                S_INIT: begin\n                    if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        // Compare the search key with the root key\n                        if (search_key == keys[root*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            if (left_child[0*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                position <= 0;\n                                search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                            end else begin\n                                search_state <= S_SEARCH_LEFT; // Search in the left subtree\n                                current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end\n                        end else if (keys[0*DATA_WIDTH +: DATA_WIDTH] > search_key) begin\n                            search_state <= S_SEARCH_LEFT;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else begin\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            search_state <= S_SEARCH_LEFT_RIGHT; // Search in both left and right subtrees\n                        end\n                    end else begin\n                        search_state <= S_COMPLETE_SEARCH; // Root is null\n                    end\n                end\n\n                S_SEARCH_LEFT: begin\n                    // Traverse the left subtree\n                    if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done && sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        if (search_key == keys[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            position <= left_output_index;   \n                            search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                        end\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done) begin\n                        if (found == 1) begin\n                            position <= left_output_index;\n                        end \n                        left_done <= 1;\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_SEARCH_LEFT_RIGHT: begin\n                    // Traverse both left and right subtrees\n                    if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done && sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done) begin\n                        left_done <= 1;\n                    end\n\n                    if (!found) begin\n                        if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                            right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                            sp_right <= sp_right + 1;\n                            current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done && sp_right > 0) begin\n                            sp_right <= sp_right - 1;\n                            current_right_node <= right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            if (found != 1) begin\n                                if (search_key == keys[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                                    found <= 1;\n                                end\n                            end\n                            right_output_index <= right_output_index + 1;\n                            current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done) begin\n                            right_done <= 1;\n                        end\n\n                    end else if (left_done) begin\n                        position <= left_output_index + right_output_index;\n                        search_state <= S_COMPLETE_SEARCH;  \n                    end\n\n                    if (right_done && left_done && !found) begin\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_COMPLETE_SEARCH: begin\n                    // Complete the search\n                    if (!found) begin\n                        complete_found <= 0;\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_invalid <= 1;\n                    end else begin\n                        complete_found  <= 1;\n                        key_position <= position;\n                        search_invalid <= 0;\n                    end\n                    search_state <= S_IDLE; // Return to IDLE state\n                end\n\n                default: begin\n                    search_state <= S_IDLE; // Default to IDLE state\n                end\n            endcase\n        end\n    end\n\nendmodule"}, "patch": {"rtl/binary_search_tree_sort.sv": "", "rtl/bst_operations.sv": "", "rtl/bst_tree_construct.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -vs", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/bst_operations.sv /code/rtl/binary_search_tree_sort.sv   /code/rtl/bst_tree_construct.sv  /code/rtl/search_binary_search_tree.sv /code/rtl/delete_node_binary_search_tree.sv\nTOPLEVEL        = bst_operations\nMODULE          = test_bst_operations\nPYTHONPATH      = /src\nHASH            = 14-bst-operations-initial-wo-insert\n", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport math\n\n# Reference model\ndef search_reference_model(search_key, keys):\n    \"\"\"Sort the keys and find the position of the search key.\"\"\"\n    sorted_keys = sorted(keys)\n    if search_key in sorted_keys:\n        return sorted_keys.index(search_key)\n    else:\n        return -1\n\ndef compute_invalid_key(data_width):\n    \"\"\"\n    The invalid key is all ones in data_width bits, i.e., (2^data_width) - 1.\n    Example: if data_width=6, invalid_key=63.\n    \"\"\"\n    return (1 << data_width) - 1\n\ndef compute_invalid_pointer(array_size):\n    \"\"\"\n    The invalid pointer for the left_child/right_child arrays.\n    = 2^(ceil(log2(array_size)) + 1) - 1\n\n    For example, if array_size=5 => ceil(log2(5))=3 => pointer=2^(3+1)-1=15.\n    \"\"\"\n    if array_size <= 1:\n        # degenerate case\n        return 0\n    exp = math.ceil(math.log2(array_size))\n    return (1 << (exp + 1)) - 1\n\ndef find_node_and_parent(keys, left_child, right_child, root_index,\n                         pointer_invalid, target_key):\n    \"\"\"\n    Find the node that has key == target_key in the BST, along with its parent.\n    Returns (node_index, parent_index) or (None, None) if not found.\n\n    'root_index' is the index of the BST root (often 0 if valid).\n    'pointer_invalid' indicates an invalid pointer (no child).\n    \"\"\"\n    parent_idx = None\n    current_idx = root_index\n    \n    while current_idx != pointer_invalid:\n        current_key = keys[current_idx]\n        if current_key == target_key:\n            return (current_idx, parent_idx)\n        elif target_key < current_key:\n            parent_idx = current_idx\n            current_idx = left_child[current_idx]\n        else:\n            parent_idx = current_idx\n            current_idx = right_child[current_idx]\n    \n    return (None, None)  # not found\n\ndef find_leftmost_index(keys, left_child, right_child, start_index, pointer_invalid):\n    \"\"\"\n    Find the index of the leftmost node in the subtree rooted at 'start_index'.\n    i.e. 'inorder successor' if 'start_index' is the root of a right subtree.\n    \"\"\"\n    current = start_index\n    while left_child[current] != pointer_invalid:\n        current = left_child[current]\n    return current\n\ndef replace_parent_pointer(parent_idx, child_idx, new_idx,\n                           left_child, right_child):\n    \"\"\"\n    Helper to redirect parent_idx\u2019s pointer (left or right) that was referencing child_idx\n    to now reference new_idx instead.\n    This is used to \u201cbypass\u201d or remove the child_idx from the tree structure.\n    \"\"\"\n    if parent_idx is None:\n        # No parent => the deleted node was the root.\n        # We'll return special info so the caller knows how to fix the root\n        return None, new_idx\n    \n    # If the parent's left pointer was the child_idx, update that\n    if left_child[parent_idx] == child_idx:\n        left_child[parent_idx] = new_idx\n    # Else if the parent's right pointer was the child_idx, update that\n    elif right_child[parent_idx] == child_idx:\n        right_child[parent_idx] = new_idx\n    \n    return parent_idx, None  # No change to root; no new root\n\ndef delete_node_with_zero_or_one_child(node_idx, parent_idx,\n                                       keys, left_child, right_child,\n                                       pointer_invalid, key_invalid):\n    \"\"\"\n    Handle the case where node_idx has 0 or 1 child.\n    Returns (new_root_idx) if node_idx was the root and we replaced it,\n    or None if the root is unchanged.\n    \"\"\"\n    left_idx = left_child[node_idx]\n    right_idx = right_child[node_idx]\n    \n    # Determine the single child (or none)\n    if left_idx == pointer_invalid and right_idx == pointer_invalid:\n        # No children (leaf)\n        new_idx = pointer_invalid\n    elif left_idx != pointer_invalid and right_idx == pointer_invalid:\n        # Only left child\n        new_idx = left_idx\n    elif left_idx == pointer_invalid and right_idx != pointer_invalid:\n        # Only right child\n        new_idx = right_idx\n    else:\n        # This function should not be called if there are 2 children\n        return None  # logic error if we get here\n    \n    # Replace parent's pointer from node_idx -> new_idx\n    p, new_root = replace_parent_pointer(parent_idx, node_idx, new_idx,\n                                         left_child, right_child)\n    # Invalidate this node\n    keys[node_idx] = key_invalid\n    left_child[node_idx] = pointer_invalid\n    right_child[node_idx] = pointer_invalid\n    \n    # If new_root is not None, that means the old node_idx was the root\n    return new_root\n\ndef _delete_bst_key_inplace(keys, left_child, right_child, delete_key, data_width=6):\n    \"\"\"\n    Internal helper that modifies the lists IN-PLACE. \n    Standard BST deletion algorithm:\n\n      1. Find the node containing 'delete_key'.\n      2. If not found => done.\n      3. If found, apply BST deletion logic:\n         - If node has 0 or 1 child => bypass it.\n         - If node has 2 children => find the inorder successor from the right subtree,\n           copy that key into the node, and then remove the successor using the\n           0-or-1 child rule.\n\n    This is the same logic as before, but it is *internal*, so we can do it in place\n    after copying in the user-facing function.\n    \"\"\"\n    n = len(keys)\n    if n == 0:\n        return  # Nothing to delete\n\n    key_invalid = compute_invalid_key(data_width)       # e.g. 63\n    pointer_invalid = compute_invalid_pointer(n)        # e.g. 15 for array_size=5\n\n    # Assume the BST root is index=0 if valid\n    root_index = 0\n    if keys[root_index] == key_invalid:\n        # Tree is effectively empty\n        return\n\n    # 1) Find the node to delete (node_idx) and its parent (parent_idx)\n    node_idx, parent_idx = find_node_and_parent(keys, left_child, right_child,\n                                                root_index, pointer_invalid, delete_key)\n    if node_idx is None:\n        return  # Key not found, do nothing\n\n    left_idx = left_child[node_idx]\n    right_idx = right_child[node_idx]\n    has_left = (left_idx != pointer_invalid)\n    has_right = (right_idx != pointer_invalid)\n\n    # 2) If node has 0 or 1 child => remove or bypass it\n    # -------------------- CASE 2: ONLY LEFT CHILD -----------------------\n    if has_left and not has_right:\n        # Copy the left child's data into node_idx\n        keys[node_idx]       = keys[left_idx]\n        left_child[node_idx] = left_child[left_idx]\n        right_child[node_idx]= right_child[left_idx]\n        \n        # Now invalidate the old child's index\n        keys[left_idx]          = key_invalid\n        left_child[left_idx]    = pointer_invalid\n        right_child[left_idx]   = pointer_invalid\n\n    elif not has_left and has_right:\n        # Copy the right child's data into node_idx\n        keys[node_idx]       = keys[right_idx]\n        left_child[node_idx] = left_child[right_idx]\n        right_child[node_idx]= right_child[right_idx]\n        \n        # Now invalidate the old child's index\n        keys[right_idx]          = key_invalid\n        left_child[right_idx]    = pointer_invalid\n        right_child[right_idx]   = pointer_invalid\n       \n    elif not has_left and not has_right:\n        new_root = delete_node_with_zero_or_one_child(node_idx, parent_idx,\n                                                      keys, left_child, right_child,\n                                                      pointer_invalid, key_invalid)\n        if new_root is not None:\n            # If we actually replaced the root with a child or invalid,\n            # just note that in case you want to track the new root. \n            pass\n    else:\n        # 3) Node has 2 children => find inorder successor in right subtree\n        successor_idx = find_leftmost_index(keys, left_child, right_child,\n                                            right_idx, pointer_invalid)\n        successor_key = keys[successor_idx]\n\n        # Overwrite the current node's key with the successor's key\n        keys[node_idx] = successor_key\n\n        # Now remove the successor node. The successor is guaranteed to have <=1 child.\n        # We still need to find the successor's parent for that operation:\n\n        if successor_idx == right_idx and left_child[successor_idx] == pointer_invalid:\n            # The successor is the immediate right child, with no left child\n            # => its parent is node_idx\n            succ_parent = node_idx\n        else:\n            # Otherwise, find the successor's parent by searching in the right subtree\n            # from node_idx:\n            current = right_idx\n            prev = node_idx\n            while current != successor_idx:\n                prev = current\n                if keys[successor_idx] < keys[current]:\n                    current = left_child[current]\n                else:\n                    current = right_child[current]\n            succ_parent = prev\n\n        delete_node_with_zero_or_one_child(successor_idx, succ_parent,\n                                           keys, left_child, right_child,\n                                           pointer_invalid, key_invalid)\n\ndef delete_bst_key(\n    keys, left_child, right_child, delete_key, data_width=6\n):\n    \"\"\"\n    *USER-FACING FUNCTION* that behaves like call-by-value in other languages:\n      - Makes copies of the input arrays.\n      - Performs the BST deletion on those copies.\n      - Returns the new copies (modified).\n    \n    The original arrays remain untouched.\n    \"\"\"\n    # Copy the arrays locally (shallow copy is enough for lists of ints)\n    new_keys = list(keys)\n    new_left_child = list(left_child)\n    new_right_child = list(right_child)\n\n    # Perform the in-place BST deletion on these copies\n    _delete_bst_key_inplace(new_keys, new_left_child, new_right_child,\n                            delete_key, data_width)\n\n    # Return the modified copies\n    return new_keys, new_left_child, new_right_child\n\n\n", "src/test_bst_operations.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport harness_library as hrs_lb\nimport math\n\n\n@cocotb.test()\nasync def test_bst_operations(dut):\n    ARRAY_SIZE = int(dut.ARRAY_SIZE.value)\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n\n    clk_period = 10  # ns\n    random.seed(0)  # For reproducibility\n\n    cocotb.start_soon(clock(dut, clk_period))\n\n    await reset_dut(dut, 5)\n    dut.start.value = 0\n\n    build_tree_latency = (((ARRAY_SIZE - 1) * ARRAY_SIZE)/2 + 2 * ARRAY_SIZE + 2)\n    sort_latency = (4 * ARRAY_SIZE + 3)\n    invalid = 0\n\n    # Test Case 2: Non-empty BST\n    if (ARRAY_SIZE == 10 and DATA_WIDTH == 16):\n        keys = arr = [58514, 50092, 48887, 48080, 5485, 5967, 19599, 23938, 34328, 42874]\n        right_child = [31, 31, 31, 31, 5, 6, 7, 8, 9, 31]\n        left_child = [1, 2, 3, 4, 31, 31, 31, 31, 31, 31]\n        run = 0\n        expected_latency_smallest_delete = 8 \n        expected_latency_largest_delete = 4 \n        expected_latency_smallest_search =  8 \n        expected_latency_largest_search = (ARRAY_SIZE - 1) * 2 + 2  + 2\n    elif (ARRAY_SIZE == 15 and DATA_WIDTH == 6):\n        run = 1\n        keys =  arr = [9, 14, 15, 17, 19, 21, 30, 32, 35, 40, 46, 47, 48, 49, 50]\n        left_child = [31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31]\n        right_child = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 31]\n        expected_latency_smallest_delete = 4\n        expected_latency_largest_delete =  ((ARRAY_SIZE - 1) * 2 + 3)      \n        expected_latency_smallest_search = 3\n        expected_latency_largest_search = (ARRAY_SIZE - 1) * 2 + 2 + 2\n    elif (ARRAY_SIZE == 15 and DATA_WIDTH == 32):\n        run = 1\n        keys =  arr =  [200706183, 259064287, 811616460, 956305578, 987713153, 1057458493, 1425113391, 1512400858, 2157180141, 2322902151, 2683058769, 2918411874, 2982472603, 3530595430, 3599316877]\n        keys =  arr = sorted(keys, reverse=True)\n        right_child = [31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31]\n        left_child = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 31]\n        expected_latency_smallest_delete = (ARRAY_SIZE - 1) + 4\n        expected_latency_largest_delete = 4\n        expected_latency_smallest_search = (ARRAY_SIZE - 1) + 2 + 2\n        expected_latency_largest_search = (ARRAY_SIZE - 1) * 2 + 2 + 2\n    elif (ARRAY_SIZE == 5 and DATA_WIDTH == 6):\n        keys =  arr = [1, 20, 0, 61, 5]\n        left_child = [2,4,15,15,15]\n        right_child = [1,3,15,15,15]\n        run = 0\n        expected_latency_smallest_delete = 5 \n        expected_latency_largest_delete = (ARRAY_SIZE - 1) + 3 + 2\n        expected_latency_smallest_search = 5 \n        expected_latency_largest_search = (ARRAY_SIZE - 1)*2 + 2 \n    elif (ARRAY_SIZE == 6 and DATA_WIDTH == 6):\n        keys = arr = [2, 20, 63, 61, 5, 1]\n        left_child = [5,4,15,15,15, 15]\n        right_child = [1,3,15,15,15, 15]\n        run = 0\n        invalid = 1\n        expected_latency_smallest_delete = 5 \n        expected_latency_largest_delete = (ARRAY_SIZE - 1) + 3 + 2\n        expected_latency_smallest_search = 5 \n        expected_latency_largest_search = (ARRAY_SIZE - 1)*2 + 2 \n\n    if (invalid != 1):\n\n        packed_keys = 0\n        for i, val in enumerate(arr):\n            packed_keys |= (val << (i * DATA_WIDTH))\n\n        dut.data_in.value = packed_keys\n        sort_after_operation = random.randint(0, 1)\n        key_random = random.randint(0, 2)\n        if key_random == 0:\n            operation_key = sorted(arr)[0]  # Smallest key\n            expected_latency = 4 + expected_latency_smallest_search + build_tree_latency + sort_after_operation * sort_latency\n            check_latency = 1\n            label = \"SEARCH (smallest key)\"\n        elif key_random == 1:\n            operation_key = sorted(arr)[ARRAY_SIZE-1]  # largest key\n            expected_latency =  4 + expected_latency_largest_search + build_tree_latency + sort_after_operation * sort_latency\n            check_latency = 1\n            label = \"SEARCH (largest key)\"\n        else:\n            index = random.randint(1, ARRAY_SIZE-2)\n            operation_key = sorted(arr)[index]  # random key\n            check_latency = 0\n            label = \"SEARCH (random key)\"\n\n        expected_position = hrs_lb.search_reference_model(operation_key, keys)\n\n        # === Test: Search ===\n        await run_operation(\n            dut,\n            operation_key=operation_key,\n            operation=0b0,  # Search\n            sort_after_operation=sort_after_operation,\n            label=label, \n            keys=keys, left_child=left_child, right_child=right_child, \n            check_latency=check_latency*run, expected_latency=expected_latency, \n            ARRAY_SIZE=ARRAY_SIZE, DATA_WIDTH=DATA_WIDTH,\n            key_position = expected_position, operation_invalid = 0  \n        )\n\n        sort_after_operation = random.randint(0, 1)\n        key_random = random.randint(0, 2)\n        if key_random == 0:\n            operation_key = sorted(arr)[0]  # Smallest key\n            expected_latency = expected_latency_smallest_delete + build_tree_latency + sort_after_operation * sort_latency + 4 * (sort_after_operation != 1)\n            check_latency = 1\n            label = \"DELETE (smallest key)\"\n        elif key_random == 1:\n            operation_key = sorted(arr)[ARRAY_SIZE-1]  # largest key\n            expected_latency = expected_latency_largest_delete + build_tree_latency + sort_after_operation * sort_latency + 4 * (sort_after_operation != 1)\n            check_latency = 1\n            label = \"DELETE (largest key)\"\n        else:\n            index = random.randint(1, ARRAY_SIZE-2)\n            operation_key = sorted(arr)[index]  # random key\n            check_latency = 0\n            label = \"DELETE (Random key)\"\n\n        key_bst, left_child_bst, right_child_bst = hrs_lb.delete_bst_key(keys, left_child, right_child, operation_key, DATA_WIDTH)\n\n        print('key', key_bst)\n        print('left_child', left_child_bst)\n        print('right_child', right_child_bst)\n\n        # === Test: Delete ===\n        await run_operation(\n            dut,\n            operation_key=operation_key,\n            operation=0b1,  # Delete\n            sort_after_operation=sort_after_operation,\n            label=label, \n            keys=key_bst, left_child=left_child_bst, right_child=right_child_bst, \n            check_latency=check_latency*run, expected_latency=expected_latency, ARRAY_SIZE=ARRAY_SIZE, DATA_WIDTH=DATA_WIDTH,\n            key_position = expected_position, operation_invalid = 0     \n        )\n    else:\n        left_child = []\n        right_child = []\n        keys = []\n        for i in range(ARRAY_SIZE):\n            left_child.append(2**(math.ceil(math.log2(ARRAY_SIZE)) + 1)-1)\n            right_child.append(2**(math.ceil(math.log2(ARRAY_SIZE)) + 1)-1)\n            keys.append(2**(DATA_WIDTH)-1)\n\n        expected_position = 2**(math.ceil(math.log2(ARRAY_SIZE)) + 1)-1\n        dut.start.value = 1\n        sort_after_operation = random.randint(0, 1)\n        operation_key = sorted(arr)[0]  # Smallest key\n        expected_latency = expected_latency_smallest_delete + build_tree_latency + sort_after_operation * sort_latency\n        check_latency = 1\n        label = \"DELETE (smallest key)\"\n        await run_operation(\n            dut,\n            operation_key=operation_key,\n            operation=0b1,  # Delete\n            sort_after_operation=sort_after_operation,\n            label=label, \n            keys=keys, left_child=left_child, right_child=right_child, \n            check_latency=1, expected_latency=2, ARRAY_SIZE=ARRAY_SIZE, DATA_WIDTH=DATA_WIDTH,\n            key_position = expected_position, operation_invalid = 1     \n        )\n    \n\nasync def reset_dut(dut, duration):\n    dut.reset.value = 1\n    for _ in range(duration):\n        await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\nasync def clock(dut, clk_period):\n        while True:\n            dut.clk.value = 0\n            await Timer(clk_period/2, units='ns')\n            dut.clk.value = 1\n            await Timer(clk_period/2, units='ns')\n\n\nasync def run_operation(dut, operation_key, operation, sort_after_operation, label, \n                        keys, left_child, right_child,  check_latency, expected_latency, ARRAY_SIZE, DATA_WIDTH,\n                        key_position, operation_invalid = 0 ):\n\n\n    dut.operation_key.value = operation_key\n    dut.operation.value = operation\n    dut.sort_after_operation.value = sort_after_operation\n\n    await RisingEdge(dut.clk)\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    cycle = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle += 1\n        if (dut.complete_operation.value == 1 or dut.operation_invalid.value == 1):\n            break\n\n    if (dut.operation_invalid.value == 1):\n        cocotb.log.warning(f\"[{label}] Operation invalid\")\n    else:\n        cocotb.log.info(f\"[{label}] Operation complete in {cycle} cycles\")\n        cocotb.log.info(f\"[{label}] out_keys: {dut.out_keys.value}\")\n        cocotb.log.info(f\"[{label}] out_sorted_data: {dut.out_sorted_data.value}\")\n\n\n    if (operation_invalid != 1):\n        if (sort_after_operation == 1):\n            out_data_val = int(dut.out_sorted_data.value)\n            print('output data', out_data_val)\n            output_array = [ (out_data_val >> (i * DATA_WIDTH)) & ((1 << DATA_WIDTH) - 1) for i in range(ARRAY_SIZE)]\n            expected_sorted_out = sorted(keys)\n            assert output_array == expected_sorted_out, f\"[Output incorrect. Got: {output_array}, Expected: {expected_sorted_out}]\"\n    \n    output_keys = [ (int(dut.out_keys.value) >> (i * DATA_WIDTH)) & ((1 << DATA_WIDTH) - 1) for i in range(ARRAY_SIZE)]\n    output_left_child = [ (int(dut.out_left_child.value) >> (i *  (math.ceil(math.log2(ARRAY_SIZE)) + 1) )) & ((1 <<  (math.ceil(math.log2(ARRAY_SIZE)) + 1)) - 1) for i in range(ARRAY_SIZE)]\n    output_right_child = [ (int(dut.out_right_child.value) >> (i *  (math.ceil(math.log2(ARRAY_SIZE)) + 1))) & ((1 <<  (math.ceil(math.log2(ARRAY_SIZE)) + 1)) - 1) for i in range(ARRAY_SIZE)]\n\n    assert ((keys == output_keys)), \\\n                f\"Failed: Key {output_keys} should be modified as {keys}.\"\n    assert ((left_child == output_left_child)), \\\n            f\"Failed: Key {output_left_child} should be modified as  {left_child}.\"\n    assert ((right_child == output_right_child)), \\\n            f\"Failed: Key {output_right_child} should be modified as {right_child}.\"\n    \n    assert (dut.operation_invalid.value == operation_invalid) , \"Failed: delete_invalid  set, but delete_key present\"\n    \n    if (operation == 0):\n         assert dut.key_position.value.to_unsigned() == key_position, \\\n            f\"Failed: Smallest key {dut.search_key.value} should be at position {key_position}.\"\n\n    if (check_latency):\n        cocotb.log.debug(f\"Total Latency : {cycle}, expected : {expected_latency}\")\n        assert expected_latency == cycle, f\"Latency incorrect. Got: {cycle}, Expected: {expected_latency}\"\n", "src/test_runner.py": "import os\nimport random\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Gather environment variables for simulation settings\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n# Define a runner function that takes the WIDTH parameter\ndef runner(DATA_WIDTH, ARRAY_SIZE):\n    # Get the simulator runner for the specified simulator (e.g., icarus)\n    runner = get_runner(sim)\n    \n    # Build the simulation environment with the randomized WIDTH parameter\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters={'DATA_WIDTH': DATA_WIDTH, 'ARRAY_SIZE' : ARRAY_SIZE},\n        always=True,               # Build even if files have not changed\n        clean=True,                # Clean previous builds\n        waves=True,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),  # Set timescale\n        log_file=\"sim.log\"         # Log the output of the simulation\n    )\n    \n    # Run the test module\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n# Parametrize test for different WIDTH and SIGNED_EN\n@pytest.mark.parametrize(\"DATA_WIDTH, ARRAY_SIZE\", [(6, 5), (6,6), (16,10), (6,15), (32,15)]) \n#@pytest.mark.parametrize(\"DATA_WIDTH, ARRAY_SIZE\", [(6, 5)]) \ndef test_bst(DATA_WIDTH, ARRAY_SIZE):\n    # Log the randomized WIDTH\n    print(f'Running with: DATA_WIDTH = {DATA_WIDTH}, ARRAY_SIZE = {ARRAY_SIZE}')\n\n    # Call the runner function with the randomized WIDTH\n    runner(DATA_WIDTH,ARRAY_SIZE)"}}
{"id": "cvdp_agentic_forest_fountain_river_0702", "categories": ["cid004", "easy"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "The `clock_estimator` module is currently present in the file `/code/rtl/clock_estimator.sv`. It implements a clock frequency estimator by counting rising edges of the `clk_test` relative to a reference clock (`clk_sys`) using fixed 32-bit counters and a basic clock domain crossing mechanism. Could you modify the existing RTL to create a parameterized version that adds a clock divider to handle high-frequency test clocks and scales the output count accordingly?\n\n#### **Modifications Required**\n\n1. **Parameterization:**\n   - Introduce two parameters:  \n     - `COUNT_WIDTH` to define the bit width of the reference counter, `count_ref`, and output `o_clock_est`.  \n     - `CLK_DIV_WIDTH` to specify the width of the clock divider.\n   - Update the widths of signals such as `count_ref`, `o_clock_est`, and `ref_counter` to use `COUNT_WIDTH`.\n   - Adjust the width of `edge_counter` to be `(COUNT_WIDTH - CLK_DIV_WIDTH)` bits.\n\n2. **Clock Divider Implementation:**\n   - Create a clock divider for `clk_test` by adding a counter register (`clk_test_div`) that increments on every rising edge of `clk_test`.\n   - Use this divider's most significant bit (`clk_test_div[CLK_DIV_WIDTH-1]`) as the effective test clock for further processing.\n\n3. **Signal Synchronization:**\n   - Synchronize the divided test clock into the `clk_sys` domain using a three-stage synchronizer (`clk_test_cdc`).\n   - Implement a rising edge detector on the synchronized signal to generate a pulse (`tst_posedge`) for each rising edge.\n\n4. **Output Scaling:**\n   - When the reference counter reaches `count_ref - 1`, latch the `edge_counter` and assign it to `o_clock_est` with scaling by concatenating `CLK_DIV_WIDTH` zero bits to the lower bits. This scales the measured edge count to account for the clock divider.\n\n5. **Bug Fixes & Cleanup:**\n   - Use explicit reset assignments with matching bit widths (e.g., use `{COUNT_WIDTH{1'b0}}` or appropriate width literals) to avoid mismatches.\n   - Remove any unused signals (such as `clk_in_prev`) present in the original module.\n\n---\n\n### **Module Specification: `nv_clock_estimator`**\n\n#### **Ports Description**\n\n- **`clk_sys`** (Input, 1-bit): Reference clock signal.\n- **`clk_test`** (Input, 1-bit): Test clock signal to be estimated.\n- **`rst_n`** (Input, 1-bit): Active low reset signal.\n- **`enable`** (Input, 1-bit): Pulse to initiate the counting operation.\n- **`count_ref`** (Input, `COUNT_WIDTH`-bit): Static reference count value determining the counting period.\n- **`o_clock_est`** (Output, `COUNT_WIDTH`-bit): Output edge count, scaled to account for the clock divider.\n- **`o_irq`** (Output, 1-bit): Interrupt signal asserted when the counting operation is complete.\n\n---\n\n#### **Functional Requirements**\n\n- **Counting Operation:**\n  - When `enable` is asserted, start the counting process using `clk_sys`.\n  - The reference counter (`ref_counter`) counts system clock cycles until it reaches `count_ref - 1`.\n  - Concurrently, a clock divider divides the `clk_test` signal. The most significant bit of the divider is synchronized into the `clk_sys` domain.\n  - A rising edge detector counts each rising edge of the synchronized, divided test clock and increments the `edge_counter`.\n\n- **Output Generation:**\n  - When the reference counter reaches the specified count, the counting operation stops.\n  - The output `o_clock_est` is generated by concatenating the `edge_counter` with `CLK_DIV_WIDTH` zero bits to scale the result appropriately.\n  - The interrupt `o_irq` is asserted when counting is complete.\n\n- **Parameterization and Reset Handling:**\n  - All internal signal widths and reset values must be defined using the parameters (`COUNT_WIDTH` and `CLK_DIV_WIDTH`) to ensure scalability and proper synthesis.\n  - Ensure that all resets are synchronous and that no unused signals are included.\n\n---\n\n#### **Assumptions & Constraints**\n\n- All reset signals are assumed to be synchronous.\n- The design is targeted for typical FPGA/ASIC implementations with well-defined clock frequencies.\n- The parameter `COUNT_WIDTH` must be greater than `CLK_DIV_WIDTH` to ensure that `(COUNT_WIDTH - CLK_DIV_WIDTH)` yields a positive bit width for the `edge_counter`.\n- The enable signal behavior remains unchanged; a new counting operation only starts when `enable` is asserted and the previous operation has been completed.\n- The clock divider and synchronization logic must reliably handle high-frequency inputs without introducing metastability issues.\n- The output scaling using zero concatenation is expected to correctly compensate for the divider, assuming the divider only reduces the effective count resolution.\n\n---\n\nPlease modify the RTL in `/code/rtl/clock_estimator.sv` according to the specifications provided above.\n", "context": {"rtl/clock_estimator.sv": "module clock_estimator (\n    input  logic         clk_sys,        // Reference clock\n    input  logic         clk_test,       // Clock to be estimated\n    input  logic         rst_n,          // Active low reset signal\n    input  logic         enable,         // Enable pulse\n    input  logic [31:0]  count_ref,      // Static count reference value\n    output logic [31:0]  o_clock_est,    // Number of edges counted\n    output logic         o_irq           // Interrupt signal\n);\n\n    // Counters and control signals\n    logic [31:0] ref_counter;   // Counter for reference clock cycles\n    logic [31:0] edge_counter;  // Counter for detected test clock edges\n    logic        counting;      // Indicates counting operation is in progress\n    // Removed unused signal \"clk_in_prev\"\n    logic [2:0]  clk_test_cdc;   // Clock domain crossing synchronizer register\n    logic        tst_posedge;    // Detected rising edge after synchronization\n\n    // Synchronize test clock into the reference clock domain\n    always_ff @(posedge clk_sys or negedge rst_n) begin\n      if (!rst_n)\n        clk_test_cdc <= 3'b0;  // Use a 3-bit zero value\n      else\n        clk_test_cdc <= { clk_test_cdc[1:0], clk_test };\n    end\n\n    // Start counting when enable is asserted and stop when ref_counter reaches count_ref - 1\n    always_ff @(posedge clk_sys or negedge rst_n) begin\n      if (!rst_n)\n        counting <= 1'b0;\n      else if (enable && !counting)\n        counting <= 1'b1;\n      else if (ref_counter >= (count_ref - 1))\n        counting <= 1'b0;\n    end\n\n    // Generate a pulse when a rising edge is detected in the synchronized test clock\n    always_ff @(posedge clk_sys or negedge rst_n) begin\n      if (!rst_n)\n        tst_posedge <= 1'b0;\n      else\n        tst_posedge <= (clk_test_cdc[2:1] == 2'b01);\n    end\n\n    // Reference counter: count clock cycles while counting is active\n    always_ff @(posedge clk_sys or negedge rst_n) begin\n      if (!rst_n)\n        ref_counter <= 32'b0;\n      else if (counting)\n        ref_counter <= ref_counter + 1;\n      else\n        ref_counter <= 32'b0;    \n    end\n\n    // Edge counter: count rising edges detected on the test clock\n    always_ff @(posedge clk_sys or negedge rst_n) begin\n      if (!rst_n)\n        edge_counter <= 32'b0;\n      else if (counting && tst_posedge)\n        edge_counter <= edge_counter + 1;\n      else if (!counting)\n        edge_counter <= 32'b0;\n    end\n\n    // Output logic: when counting completes, latch the edge count and raise the interrupt.\n    always_ff @(posedge clk_sys or negedge rst_n) begin\n      if (!rst_n) begin      \n        o_clock_est <= 32'b0;\n        o_irq       <= 1'b0;\n      end\n      else if (enable && !counting) begin\n        // When not counting, ensure outputs are reset.\n        o_clock_est <= 32'b0;\n        o_irq       <= 1'b0;\n      end\n      else if (counting && (ref_counter >= count_ref - 1)) begin\n        // Counting complete: latch the edge counter value and assert interrupt.\n        o_clock_est <= edge_counter;\n        o_irq       <= 1'b1;\n      end\n      else begin\n        // Default case: deassert interrupt.\n        o_irq       <= 1'b0;\n      end\n    end\n\nendmodule"}, "patch": {"rtl/clock_estimator.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/clock_estimator.sv \nTOPLEVEL        = clock_estimator\nMODULE          = test_clock_estimator\nPYTHONPATH      = /src\nHASH            = b9ca76a6d10b5ac8e15b3e54f4ef84d43eb850bc\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_clock_estimator.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer, First\nimport random\n\n# Global frequency: 1 GHz reference clock\nfreq = 1000000000\n\n# ----------------------------------------\n# - Test Initializations & Helper Functions\n# ----------------------------------------\ndef randomize_variables(lR, uR, v1_less_v2):\n    var1 = random.randint(lR, uR)\n    var2 = random.randint(var1 + 1, var1 + uR)\n    return var1, var2\n\nasync def reset_dut(dut):\n    dut.rst_n.value = 0\n    dut.clk_sys.value = 0\n    dut.clk_test.value = 0\n    dut.enable.value = 0\n    dut.count_ref.value = 0\n\n    await Timer(random.randint(100, 1000), units='ns')\n    dut.rst_n.value = 1\n    await Timer(random.randint(100, 1000), units='ns')\n\ndef clock_gen(signal, period_ns):\n    \"\"\"Generate a clock on the given signal with the specified period in nanoseconds.\"\"\"\n    while True:\n        signal.value = 0\n        yield Timer(period_ns / 2, units='ns')\n        signal.value = 1\n        yield Timer(period_ns / 2, units='ns')\n\nasync def start_one_enable(dut, count_ref):\n    dut.enable.value = 1\n    dut.count_ref.value = count_ref\n    await RisingEdge(dut.clk_sys)\n    await RisingEdge(dut.clk_sys)\n    dut.enable.value = 0\n\nasync def get_dut_count(dut, count_ref, clk_test_freq, clk_sys_freq):\n    await RisingEdge(dut.o_irq)\n    clock_est = int(dut.o_clock_est.value)\n    expected_count = (count_ref * clk_test_freq) / clk_sys_freq\n    print(f\"Expected count: {expected_count}\")\n    print(f\"Actual count: {clock_est}\")\n    assert (clock_est > expected_count - 16 and clock_est < expected_count + 16), \\\n        f\"Count mismatch: expected around {expected_count}, got {clock_est}\"\n\n# ----------------------------------------\n# - Original Tests\n# ----------------------------------------\n\n# Basic test\n@cocotb.test()\nasync def basic_test(dut):\n    clk_sys_period = 10  # ns\n    clk_test_period = 4  # ns\n    clk_sys_freq = freq / clk_sys_period\n    clk_test_freq = freq / clk_test_period\n    count_ref = 100\n\n    # Start clocks\n    cocotb.start_soon(Clock(dut.clk_sys, clk_sys_period, units='ns').start())\n    cocotb.start_soon(Clock(dut.clk_test, clk_test_period, units='ns').start())\n    cocotb.start_soon(get_dut_count(dut, count_ref, clk_test_freq, clk_sys_freq))\n\n    await reset_dut(dut)\n    await start_one_enable(dut, count_ref)\n\n    signal_high = RisingEdge(dut.o_irq)\n    timeout = Timer(10, units='us')\n    event = await First(signal_high, timeout)\n\n    if event is signal_high:\n        print(\"basic_test: Test gracefully ended\")\n        assert True\n    else:\n        print(\"basic_test: Test Timeout\")\n        assert False\n\n# Multi enable check\n@cocotb.test()\nasync def multi_en_check(dut):\n    clk_test_period, clk_sys_period = randomize_variables(5, 10, 1)\n    clk_sys_freq = freq / clk_sys_period\n    clk_test_freq = freq / clk_test_period\n    print(f\"multi_en_check: clk_sys = {clk_sys_period} ns, clk_test = {clk_test_period} ns\")\n    print(f\"multi_en_check: clk_sys_freq = {clk_sys_freq}, clk_test_freq = {clk_test_freq}\")\n\n    count_ref = random.randint(100, 1000)\n    print(f\"multi_en_check: count_ref = {count_ref}\")\n\n    # Start clocks\n    cocotb.start_soon(Clock(dut.clk_sys, clk_sys_period, units='ns').start())\n    cocotb.start_soon(Clock(dut.clk_test, clk_test_period, units='ns').start())\n    cocotb.start_soon(get_dut_count(dut, count_ref, clk_test_freq, clk_sys_freq))\n\n    await reset_dut(dut)\n    await start_one_enable(dut, count_ref)\n    await Timer(random.randint(100, 200), units='ns')\n    await start_one_enable(dut, count_ref)\n    await Timer(random.randint(100, 200), units='ns')\n    await start_one_enable(dut, count_ref)\n\n    signal_high = RisingEdge(dut.o_irq)\n    timeout = Timer(20, units='us')\n    event = await First(signal_high, timeout)\n\n    if event is signal_high:\n        print(\"multi_en_check: Test gracefully ended\")\n        assert True\n    else:\n        print(\"multi_en_check: Test Timeout\")\n        assert False\n\n# ----------------------------------------\n# - Additional Tests\n# ----------------------------------------\n\n# Additional Test 1: Reset Behavior Verification\n@cocotb.test()\nasync def reset_behavior_test(dut):\n    clk_sys_period = 10\n    clk_test_period = 4\n    cocotb.start_soon(Clock(dut.clk_sys, clk_sys_period, units='ns').start())\n    cocotb.start_soon(Clock(dut.clk_test, clk_test_period, units='ns').start())\n\n    await reset_dut(dut)\n    # Verify that outputs are reset\n    assert int(dut.o_clock_est.value) == 0, \"o_clock_est not reset to 0 after reset\"\n    assert int(dut.o_irq.value) == 0, \"o_irq not reset to 0 after reset\"\n    print(\"reset_behavior_test: Reset behavior verified successfully.\")\n\n# Additional Test 2: Boundary Condition Testing for count_ref\n@cocotb.test()\nasync def boundary_condition_test(dut):\n    clk_sys_period = 10\n    clk_test_period = 4\n    clk_sys_freq = freq / clk_sys_period\n    clk_test_freq = freq / clk_test_period\n\n    # Test with a minimal count_ref (e.g., 2)\n    min_count_ref = 2\n    print(f\"boundary_condition_test: Testing minimum count_ref = {min_count_ref}\")\n    cocotb.start_soon(Clock(dut.clk_sys, clk_sys_period, units='ns').start())\n    cocotb.start_soon(Clock(dut.clk_test, clk_test_period, units='ns').start())\n    await reset_dut(dut)\n    await start_one_enable(dut, min_count_ref)\n    await get_dut_count(dut, min_count_ref, clk_test_freq, clk_sys_freq)\n\n    # Test with a maximum count_ref (e.g., 1000)\n    max_count_ref = 1000\n    print(f\"boundary_condition_test: Testing maximum count_ref = {max_count_ref}\")\n    await reset_dut(dut)\n    await start_one_enable(dut, max_count_ref)\n    await get_dut_count(dut, max_count_ref, clk_test_freq, clk_sys_freq)\n\n# Additional Test 3: Stress/Random Testing with multiple iterations\n@cocotb.test()\nasync def stress_test(dut):\n    iterations = 10\n    for i in range(iterations):\n        clk_sys_period, clk_test_period = randomize_variables(5, 15, 1)\n        clk_sys_freq = freq / clk_sys_period\n        clk_test_freq = freq / clk_test_period\n        count_ref = random.randint(50, 500)\n        print(f\"stress_test (Iteration {i+1}): clk_sys = {clk_sys_period} ns, clk_test = {clk_test_period} ns, count_ref = {count_ref}\")\n\n        # Start clocks (restart for each iteration)\n        cocotb.start_soon(Clock(dut.clk_sys, clk_sys_period, units='ns').start())\n        cocotb.start_soon(Clock(dut.clk_test, clk_test_period, units='ns').start())\n        cocotb.start_soon(get_dut_count(dut, count_ref, clk_test_freq, clk_sys_freq))\n        await reset_dut(dut)\n        await start_one_enable(dut, count_ref)\n        # Wait a bit before the next iteration\n        await Timer(random.randint(50, 100), units='ns')\n\n# Additional Test 4: Interrupt Signal Behavior Check\n@cocotb.test()\nasync def interrupt_behavior_test(dut):\n    clk_sys_period = 10\n    clk_test_period = 4\n    cocotb.start_soon(Clock(dut.clk_sys, clk_sys_period, units='ns').start())\n    cocotb.start_soon(Clock(dut.clk_test, clk_test_period, units='ns').start())\n\n    count_ref = random.randint(100, 500)\n    print(f\"interrupt_behavior_test: count_ref = {count_ref}\")\n    await reset_dut(dut)\n    await start_one_enable(dut, count_ref)\n    # Wait for the interrupt signal\n    await RisingEdge(dut.o_irq)\n    irq_initial = int(dut.o_irq.value)\n    # Wait a short period to see if it deasserts\n    await Timer(50, units='ns')\n    irq_after = int(dut.o_irq.value)\n    print(f\"interrupt_behavior_test: o_irq initially {irq_initial}, after 50 ns {irq_after}\")\n    assert irq_initial == 1, \"o_irq was not asserted when expected\"\n    assert irq_after == 0, \"o_irq did not deassert after completion\"\n    print(\"interrupt_behavior_test: Interrupt signal behavior verified successfully.\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\n#if __name__ == \"__main__\":\n#    test_runner()"}}
{"id": "cvdp_agentic_crimson_river_butterfly_1181", "categories": ["cid016", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Edit files** by using:\n    - `sed -i 's/old_text/new_text/g' <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "The given `fifo_buffer` module implements a parameterizable FIFO for managing request data and error signals, where the FIFO depth is set to NUM_OF_REQS+1. It buffers incoming data (addresses, read data, and error flags) and selects between freshly arrived input and stored FIFO data to produce aligned or unaligned outputs based on the instruction alignment bits. The module also computes the next instruction address by conditionally incrementing the stored address by two or four bytes depending on whether the instruction is compressed (as indicated by specific bit patterns) and updates its registers either synchronously or asynchronously based on the ResetAll parameter. Data is efficiently shifted through the FIFO using combinational logic that determines the lowest free entry, manages push/pop operations, and generates busy signals for backpressure control.\n\n\nThe various test cases with  signal responses for Buggy and Bug Free RTL codes are as tabulated as follows:\n\n**Test 1 \u2013 Clear FIFO (Aligned PC)**\n| Time  | clear | in_valid | in_addr  | in_rdata | in_err | Signal        | Buggy Value | Bug Free Value |\n|-------|-------|----------|----------|----------|--------|---------------|-------------|----------------|\n| 30000 | 1     | 0        | 00000000 | 00000000 | 0      | out_err_plus2 | 1           | 0              |\n| 35000 | 1     | 0        | 00000000 | 00000000 | 0      | out_err_plus2 | 1           | 0              |\n| 40000 | 0     | 0        | 00000000 | 00000000 | 0      | out_err_plus2 | 1           | 0              |\n\n**Test 2 \u2013 Single Instruction Fetch (Aligned)**\n| Time  | clear | in_valid | in_addr  | in_rdata | in_err | Signal        | Buggy Value | Bug Free Value |\n|-------|-------|----------|----------|----------|--------|---------------|-------------|----------------|\n| 50000 | 0     | 1        | 00000000 | 8c218363 | 0      | out_err_plus2 | 1           | 0              |\n| 60000 | 0     | 0        | 00000000 | 8c218363 | 0      | out_valid     | 0           | 1              |\n| 60000 | 0     | 0        | 00000000 | 8c218363 | 0      | out_err_plus2 | 1           | 0              |\n\n**Test 3 \u2013 FIFO Depth Test**\n| Time   | clear | in_valid | in_addr  | in_rdata | in_err | Signal        | Buggy Value | Bug Free Value |\n|--------|-------|----------|----------|----------|--------|---------------|-------------|----------------|\n| 90000  | 0     | 1        | 00000000 | 6c2183e3 | 0      | out_addr      | 00000000    | 00000004       |\n| 90000  | 0     | 1        | 00000000 | 6c2183e3 | 0      | out_err_plus2 | 1           | 0              |\n| 100000 | 0     | 1        | 00000000 | 926cf16f | 0      | out_addr      | 00000000    | 00000004       |\n| 100000 | 0     | 1        | 00000000 | 926cf16f | 0      | out_err_plus2 | 1           | 0              |\n| 105000 | 0     | 1        | 00000000 | 926cf16f | 0      | out_addr      | 00000000    | 00000004       |\n| 105000 | 0     | 1        | 00000000 | 926cf16f | 0      | out_err_plus2 | 3           | 1              |\n| 110000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_addr      | 00000000    | 00000004       |\n| 110000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_err_plus2 | 3           | 1              |\n| 125000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_addr      | 00000004    | 00000008       |\n| 125000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_err_plus2 | 1           | 0              |\n| 135000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_addr      | 00000008    | 0000000c       |\n| 135000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_err_plus2 | 1           | 0              |\n\n**Test 4 \u2013 Unaligned Instruction Fetch**\n| Time   | clear | in_valid | in_addr  | in_rdata | in_err | Signal        | Buggy Value | Bug Free Value |\n|--------|-------|----------|----------|----------|--------|---------------|-------------|----------------|\n| 160000 | 1     | 0        | 00000002 | 926cf16f | 0      | out_addr      | 00000008    | 0000000c       |\n| 215000 | 0     | 0        | 00000002 | 763101e7 | 0      | out_valid     | 0           | 1              |\n| 215000 | 0     | 0        | 00000002 | 763101e7 | 0      | out_err_plus2 | 1           | 0              |\n                                                                                \n**Test 5 \u2013 Error Handling**\n| Time   | clear | in_valid | in_addr  | in_rdata | in_err | Signal        | Buggy Value | Bug Free Value |\n|--------|-------|----------|----------|----------|--------|---------------|-------------|----------------|\n| 250000 | 1     | 0        | 00000000 | 763101e7 | 0      | out_addr      | 00000004    | 00000008       |\n| 250000 | 1     | 0        | 00000000 | 763101e7 | 0      | out_err_plus2 | 1           | 0              |\n| 255000 | 1     | 0        | 00000000 | 763101e7 | 0      | out_err_plus2 | 1           | 0              |\n| 260000 | 0     | 0        | 00000000 | 763101e7 | 0      | out_err_plus2 | 1           | 0              |\n| 270000 | 0     | 1        | 00000000 | 4840006f | 1      | out_err_plus2 | 1           | 0              |\n| 280000 | 0     | 0        | 00000000 | 4840006f | 1      | out_valid     | 0           | 1              |\n| 280000 | 0     | 0        | 00000000 | 4840006f | 1      | out_err_plus2 | 1           | 0              |\n\n## Identified Bugs :\n### 1. Out_err_plus2 Constant in Aligned Mode:\n\n**Reference from Test 1 and Test 2**:\nIn `Test 1` (Clear FIFO), the table shows that for times 30000, 35000, and 40000 the buggy design always drives `out_err_plus2` as 1 while the bug-free design expects 0. Similarly, in `Test 2` (Single Instruction Fetch \u2013 Aligned), at time 50000 and 60000 the buggy RTL again drives `out_err_plus2` as 1 when it should be 0.\n\n**Bug Cause**:\nThe combinational block for the aligned case (when `out_addr_o[1]` is false) in the buggy RTL forces `out_err_plus2_o` to a constant 1'b1 instead of using the computed error signal.\n\n### 2.Mis-indexed Data and Valid Signal Selection:\n\n**Reference from Test 3 and Test 4**:\nIn Test 3 (FIFO Depth Test), the output address (`out_addr`) is observed as 00000000 at times 90000, 100000, and 105000 in the buggy design, while the bug-free design shows it should increment (e.g., 00000004 at these times). In Test 4 (Unaligned Instruction Fetch), at time 160000 the buggy design reports an out_addr of 00000008 versus the expected 0000000c.\n\n**Bug Cause**:\nThe buggy code selects the rdata and err signals based on `valid_q[1]` rather than `valid_q[0]`. This off-by-one error in indexing causes the output data and addresses to be misaligned.\n\n### 3.Incorrect Err_plus2 Signal Computation:\n\n**Reference from Test 1, Test 2, Test 3, and Test 5**:\nAcross multiple tests, the out_err_plus2 value in the buggy RTL is incorrect. For instance, in Test 3 at time 105000 the buggy RTL computes `out_err_plus2` as 3 instead of 1 (as in the bug-free design). Similar discrepancies occur in Test 1, Test 2, and Test 5, where the error signal remains high when it should be low.\n\n**Bug Cause**:\nThe logic for generating err_plus2 in the buggy code uses incorrect FIFO indices and logical operations, leading to miscomputation of this error flag.\n\n### 4.FIFO Addressing and Extra/Missing Cycle Behavior:\n\n**Reference from Test 2 and Test 3**:\nIn Test 2, the bug-free design produces an extra cycle at time 75000 that is missing in the buggy response. In Test 3, an extra row appears at time 95000 in the buggy design that should not exist.\n\n**Bug Cause**:\nThese issues indicate that the update logic for FIFO addressing and valid signal propagation is inconsistent\u2014likely due to the off-by-one error from mis-indexing\u2014which leads to extra or missing FIFO cycles and misaligned output addresses.\n\n### 5.FIFO Pop and Compressed Instruction Detection Issues:\n\n**Reference from Test 4 (Unaligned Instruction Fetch)**:\nAt time 215000, the table shows that the buggy RTL incorrectly drives `out_valid` as 0 and `out_err_plus2` as 1 instead of the expected 1 and 0, respectively.\n\n**Bug Cause**:\nThe FIFO pop logic in the buggy RTL is missing a crucial gating condition for handling unaligned (compressed) instructions. In the bug-free design, the FIFO pop signal is conditioned not only on the `out_ready_i` and `out_valid_o` handshake but also on whether the instruction is compressed. Specifically, the bug-free RTL uses an extra condition\u2014such as checking (`~aligned_is_compressed | out_addr_o[1]`)\u2014to ensure that for compressed instructions the FIFO is only popped when the second half of the instruction is ready. Without this condition, the buggy design pops the FIFO prematurely, clearing the valid signal too early and resulting in misaligned outputs and incorrect error flags.\n\n### 6. Error Handling and Output Misalignment:\n\n**Reference from Test 5 (Error Handling)**:\nThe table for Test 5 shows that, under error conditions, the output address is misaligned (e.g., 00000004 instead of 00000008 at 250000) and out_err_plus2 remains high over several cycles (times 250000, 255000, 260000, 270000, 280000) when the bug-free design expects it to be 0.\n\n**Bug Cause**:\nThese issues reinforce that mis-indexing in FIFO handling and the flawed computation of the err_plus2 signal lead to incorrect behavior during error conditions, resulting in both address misalignment and persistent error flags.\n\n## Deliverable :\nDuring testing, the module failed to produce the expected output, leading to incorrect results. The module and its testbench are available in the current working directory for debugging, and the expected output is available in the testbench. Could you help debug and fix the RTL to ensure correct functionality?\n", "context": {"rtl/fifo_buffer.sv": "module fifo_buffer #(\n  parameter int unsigned NUM_OF_REQS = 2,\n  parameter bit          ResetAll      = 1'b0\n) (\n  input  logic                clk_i,\n  input  logic                rst_i,\n\n  input  logic                clear_i,   \n  output logic [NUM_OF_REQS-1:0] busy_o,\n\n  input  logic                in_valid_i,\n  input  logic [31:0]         in_addr_i,\n  input  logic [31:0]         in_rdata_i,\n  input  logic                in_err_i,\n\n  output logic                out_valid_o,\n  input  logic                out_ready_i,\n  output logic [31:0]         out_addr_o,\n  output logic [31:0]         out_rdata_o,\n  output logic                out_err_o,\n  output logic                out_err_plus2_o\n);\n\n  localparam int unsigned FIFO_DEPTH = NUM_OF_REQS + 1;\n\n  logic [31:0] rdata_d [0:FIFO_DEPTH-1];\n  logic [31:0] rdata_q [0:FIFO_DEPTH-1];\n  logic [FIFO_DEPTH-1:0]         err_d,     err_q;\n  logic [FIFO_DEPTH-1:0]         valid_d,   valid_q;\n  logic [FIFO_DEPTH-1:0]         lowest_free_entry;\n  logic [FIFO_DEPTH-1:0]         valid_pushed, valid_popped;\n  logic [FIFO_DEPTH-1:0]         entry_en;\n\n  logic                     pop_fifo;\n  logic         [31:0]      rdata, rdata_unaligned;\n  logic                     err,   err_unaligned, err_plus2;\n  logic                     valid, valid_unaligned;\n\n  logic                     aligned_is_compressed, unaligned_is_compressed;\n\n  logic                     addr_incr_two;\n  logic [31:1]              instr_addr_next;\n  logic [31:1]              instr_addr_d, instr_addr_q;\n  logic                     instr_addr_en;\n  logic                     unused_addr_in;\n\n  assign rdata = valid_q[1] ? rdata_q[1] : in_rdata_i;\n  assign err   = valid_q[1] ? err_q[1]   : in_err_i;\n  assign valid = valid_q[1] | in_valid_i;\n\n  assign rdata_unaligned = valid_q[1] ? {rdata_q[1][15:0], rdata[31:16]} :\n                                        {in_rdata_i[15:0], rdata[31:16]};\n\n  assign err_unaligned   = valid_q[1] ? ((err_q[1] & ~unaligned_is_compressed) | err_q[0]) :\n                                        ((valid_q[0] & err_q[0]) |\n                                         (in_err_i & (~valid_q[0] | ~unaligned_is_compressed)));\n\n  assign err_plus2       = valid_q[0] ? (err_q[0] & ~err_q[0]) :\n                                        (in_err_i & valid_q[1] & ~err_q[1]);\n\n  assign valid_unaligned = valid_q[1] ? 1'b1 :\n                                        (valid_q[0] & in_valid_i);\n\n  assign unaligned_is_compressed = (rdata[17:16] != 2'b11);\n  assign aligned_is_compressed   = (rdata[1:0]   != 2'b11);\n\n  always @(*) begin\n    if (out_addr_o[1]) begin\n      out_rdata_o     = rdata_unaligned;\n      out_err_o       = err_unaligned;\n      out_err_plus2_o = err_plus2;\n      if (unaligned_is_compressed) begin\n        out_valid_o = valid;\n      end else begin\n        out_valid_o = valid_unaligned;\n      end\n    end else begin\n      out_rdata_o     = rdata;\n      out_err_o       = err;\n      out_err_plus2_o = 1'b1;\n      out_valid_o     = valid;\n    end\n  end\n\n  assign instr_addr_en   = clear_i | (out_ready_i & out_valid_o);\n  assign addr_incr_two   = instr_addr_q[1] ? unaligned_is_compressed :\n                                               aligned_is_compressed;\n\n  assign instr_addr_next = (instr_addr_q[31:1] +\n                            {29'd0, ~addr_incr_two, addr_incr_two});\n\n  assign instr_addr_d    = clear_i ? in_addr_i[31:1] : instr_addr_next;\n\n  if (ResetAll) begin : g_instr_addr_ra\n    always_ff @(posedge clk_i or negedge rst_i) begin\n      if (!rst_i) begin\n        instr_addr_q <= '0;\n      end else if (instr_addr_en) begin\n        instr_addr_q <= instr_addr_q;\n      end\n    end\n  end else begin : g_instr_addr_nr\n    always_ff @(posedge clk_i) begin\n      if (instr_addr_en) begin\n        instr_addr_q <= instr_addr_d;\n      end\n    end\n  end\n\n  assign out_addr_o = {instr_addr_q, 1'b0};\n  assign unused_addr_in = in_addr_i[0];\n\n  assign busy_o = valid_q[FIFO_DEPTH-1:FIFO_DEPTH-NUM_OF_REQS];\n  assign pop_fifo = out_ready_i & out_valid_o;\n\n  for (genvar i = 0; i < (FIFO_DEPTH - 1); i++) begin : g_fifo_next\n    if (i == 0) begin : g_ent0\n      assign lowest_free_entry[i] = ~valid_q[i];\n    end else begin : g_ent_others\n      assign lowest_free_entry[i] = ~valid_q[i] & valid_q[i-1];\n    end\n\n    assign valid_pushed[i] = (in_valid_i & lowest_free_entry[i]) | valid_q[i];\n    assign valid_popped[i] = pop_fifo ? valid_pushed[i+1] : valid_pushed[i];\n    assign valid_d[i]      = valid_popped[i] & ~clear_i;\n    assign entry_en[i]     = (valid_pushed[i+1] & pop_fifo) |\n                             (in_valid_i & lowest_free_entry[i] & ~pop_fifo);\n    assign rdata_d[i]      = valid_q[i+1] ? rdata_q[i+1] : in_rdata_i;\n    assign err_d[i]        = valid_q[i+1] ? err_q[i+1]   : in_err_i;\n  end\n\n  assign lowest_free_entry[FIFO_DEPTH-1] = ~valid_q[FIFO_DEPTH-1] & valid_q[FIFO_DEPTH-2];\n  assign valid_pushed[FIFO_DEPTH-1]      = valid_q[FIFO_DEPTH-1] | (in_valid_i & lowest_free_entry[FIFO_DEPTH-1]);\n  assign valid_popped[FIFO_DEPTH-1]      = pop_fifo ? 1'b0 : valid_pushed[FIFO_DEPTH-1];\n  assign valid_d[FIFO_DEPTH-1]           = valid_popped[FIFO_DEPTH-1] & ~clear_i;\n  assign entry_en[FIFO_DEPTH-1]          = in_valid_i & lowest_free_entry[FIFO_DEPTH-1];\n  assign rdata_d[FIFO_DEPTH-1]           = in_rdata_i;\n  assign err_d[FIFO_DEPTH-1]             = in_err_i;\n\n  always_ff @(posedge clk_i or negedge rst_i) begin\n    if (!rst_i) begin\n      valid_q <= '0;\n    end else begin\n      valid_q <= valid_d;\n    end\n  end\n\n  for (genvar i = 0; i < FIFO_DEPTH; i++) begin : g_fifo_regs\n    if (ResetAll) begin : g_rdata_ra\n      always_ff @(posedge clk_i or negedge rst_i) begin\n        if (!rst_i) begin\n          rdata_q[i] <= '0;\n          err_q[i]   <= '0;\n        end else if (entry_en[i]) begin\n          rdata_q[i] <= rdata_d[i];\n          err_q[i]   <= err_d[i];\n        end\n      end\n    end else begin : g_rdata_nr\n      always_ff @(posedge clk_i) begin\n        if (entry_en[i]) begin\n          rdata_q[i] <= rdata_d[i];\n          err_q[i]   <= err_d[i];\n        end\n      end\n    end\n  end\nendmodule", "verif/tb_fifo_buffer.sv": "`timescale 1ns/1ps\n\nmodule tb_fifo_buffer;\n\n  \n  parameter int unsigned NUM_OF_REQS = 2;\n  parameter bit          ResetAll    = 1'b0; \n\n  \n  logic                clk_i;\n  logic                rst_i;\n  logic                clear_i;\n  logic [NUM_OF_REQS-1:0] busy_o;\n\n  logic                in_valid_i;\n  logic [31:0]         in_addr_i;\n  logic [31:0]         in_rdata_i;\n  logic                in_err_i;\n\n  logic                out_valid_o;\n  logic                out_ready_i;\n  logic [31:0]         out_addr_o;\n  logic [31:0]         out_rdata_o;\n  logic                out_err_o;\n  logic                out_err_plus2_o;\n\n  \n  fifo_buffer #(\n    .NUM_OF_REQS(NUM_OF_REQS),\n    .ResetAll(ResetAll)\n  ) dut (\n    .clk_i(clk_i),\n    .rst_i(rst_i),\n    .clear_i(clear_i),\n    .busy_o(busy_o),\n    .in_valid_i(in_valid_i),\n    .in_addr_i(in_addr_i),\n    .in_rdata_i(in_rdata_i),\n    .in_err_i(in_err_i),\n    .out_valid_o(out_valid_o),\n    .out_ready_i(out_ready_i),\n    .out_addr_o(out_addr_o),\n    .out_rdata_o(out_rdata_o),\n    .out_err_o(out_err_o),\n    .out_err_plus2_o(out_err_plus2_o)\n  );\n\n  initial begin\n    clk_i = 0;\n    forever #5 clk_i = ~clk_i;\n  end\n\n  initial begin\n    rst_i = 0;\n    #20;\n    rst_i = 1;\n  end\n\n  initial begin\n    clear_i     = 0;\n    in_valid_i  = 0;\n    in_addr_i   = 32'h0000_0000;\n    in_rdata_i  = 32'h0;\n    in_err_i    = 0;\n    out_ready_i = 0;\n    \n    @(posedge rst_i);\n    #10;\n    \n    $display(\"\\n*** Test 1: Clear FIFO (Aligned PC) ***\");\n    clear_i   = 1;\n    in_addr_i = 32'h0000_0000;\n    #10;\n    clear_i = 0;\n    #10;\n    \n    $display(\"\\n*** Test 2: Single Instruction Fetch (Aligned) ***\");\n    in_valid_i = 1;\n    in_rdata_i = 32'h8C218363;\n    in_err_i   = 0;\n    #10;\n    in_valid_i = 0;\n    #10;\n    \n    out_ready_i = 1;\n    #10;\n    out_ready_i = 0;\n    #10;\n    \n    $display(\"\\n*** Test 3: FIFO Depth Test ***\");\n    in_valid_i = 1;\n    in_rdata_i = 32'h6C2183E3;\n    in_err_i   = 0;\n    #10;\n    in_rdata_i = 32'h926CF16F;\n    #10;\n    in_valid_i = 0;\n    #10;\n    \n    out_ready_i = 1;\n    repeat (3) begin\n      #10;\n    end\n    out_ready_i = 0;\n    #10;\n    \n    $display(\"\\n*** Test 4: Unaligned Instruction Fetch ***\");\n    clear_i   = 1;\n    in_addr_i = 32'h0000_0002;\n    #10;\n    clear_i = 0;\n    #10;\n    \n    in_valid_i = 1;\n    in_rdata_i = 32'hF63101E7;\n    in_err_i   = 0;\n    #10;\n    \n    in_rdata_i = 32'h763101E7;\n    #10;\n    in_valid_i = 0;\n    #10;\n    \n    out_ready_i = 1;\n    repeat (3) begin\n      #10;\n    end\n    out_ready_i = 0;\n    #10;\n    \n    $display(\"\\n*** Test 5: Error Handling ***\");\n    clear_i   = 1;\n    in_addr_i = 32'h0000_0000;\n    #10;\n    clear_i = 0;\n    #10;\n    \n    in_valid_i = 1;\n    in_rdata_i = 32'h4840006F;\n    in_err_i   = 1;\n    #10;\n    in_valid_i = 0;\n    #10;\n    \n    out_ready_i = 1;\n    #10;\n    out_ready_i = 0;\n    #10;\n    \n    $display(\"\\n*** End of Simulation ***\");\n    $finish;\n  end\n\n  initial begin\n    $display(\"Time\\tclear in_valid in_addr    in_rdata      in_err | out_valid out_addr    out_rdata     out_err out_err_plus2 | busy\");\n    $monitor(\"%0t\\t%b      %b      %h   %h    %b    | %b      %h  %h   %b    %b    | %h\",\n             $time, clear_i, in_valid_i, in_addr_i, in_rdata_i, in_err_i,\n             out_valid_o, out_addr_o, out_rdata_o, out_err_o, out_err_plus2_o,\n             busy_o);\n  end\n\nendmodule"}, "patch": {"rtl/fifo_buffer.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fifo_buffer.sv\nTOPLEVEL        = fifo_buffer\nMODULE          = test_fifo_buffer\nPYTHONPATH      = /src\nHASH            = 4-debug-and-fix-fifo-buffer-issue\n", "src/test_fifo_buffer.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import Timer, RisingEdge\n\ndef safe_int(sig):\n    \"\"\"Converts a signal value to int if fully resolved; otherwise returns 'X'.\"\"\"\n    val_str = sig.value.binstr.lower()\n    if \"x\" in val_str or \"z\" in val_str:\n        return \"X\"\n    try:\n        return int(sig.value)\n    except Exception:\n        return \"X\"\n\nasync def monitor_signals(dut):\n    \"\"\"Continuously print out signal values similar to the SV $monitor.\"\"\"\n    sim_time = 0  # local simulation time counter in ns\n    dut._log.info(\"Time\\tclear in_valid in_addr    in_rdata      in_err | out_valid out_addr    out_rdata     out_err out_err_plus2 | busy\")\n    while True:\n        await Timer(10, units=\"ns\")\n        sim_time += 10\n        clear_val      = safe_int(dut.clear_i)\n        in_valid_val   = safe_int(dut.in_valid_i)\n        in_addr_val    = safe_int(dut.in_addr_i)\n        in_rdata_val   = safe_int(dut.in_rdata_i)\n        in_err_val     = safe_int(dut.in_err_i)\n        out_valid_val  = safe_int(dut.out_valid_o)\n        out_addr_val   = safe_int(dut.out_addr_o)\n        out_rdata_val  = safe_int(dut.out_rdata_o)\n        out_err_val    = safe_int(dut.out_err_o)\n        out_err2_val   = safe_int(dut.out_err_plus2_o)\n        busy_val       = safe_int(dut.busy_o)\n        msg = (\n            f\"{sim_time}\\t\"\n            f\"{clear_val}      {in_valid_val}      \"\n            f\"{in_addr_val if in_addr_val=='X' else format(in_addr_val, '08X')}   \"\n            f\"{in_rdata_val if in_rdata_val=='X' else format(in_rdata_val, '08X')}    {in_err_val}    | \"\n            f\"{out_valid_val}      {out_addr_val if out_addr_val=='X' else format(out_addr_val, '08X')}  \"\n            f\"{out_rdata_val if out_rdata_val=='X' else format(out_rdata_val, '08X')}   \"\n            f\"{out_err_val}    {out_err2_val}    | {busy_val}\"\n        )\n        dut._log.info(msg)\n\n@cocotb.test()\nasync def tb_fifo_buffer_test(dut):\n    \"\"\"\n    Cocotb testbench for fifo_buffer that exactly mimics the provided SV testbench,\n    with assertions at the end of each test case.\n    \"\"\"\n    # -----------------------\n    # Clock Generation\n    # -----------------------\n    clock = Clock(dut.clk_i, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # -----------------------\n    # Reset Generation\n    # -----------------------\n    dut.rst_i.value = 0\n    await Timer(20, units=\"ns\")\n    dut.rst_i.value = 1\n    dut._log.info(\"Reset deasserted\")\n\n    # -----------------------\n    # Initialize Inputs\n    # -----------------------\n    dut.clear_i.value     = 0\n    dut.in_valid_i.value  = 0\n    dut.in_addr_i.value   = 0x00000000  # Initial instruction address\n    dut.in_rdata_i.value  = 0\n    dut.in_err_i.value    = 0\n    dut.out_ready_i.value = 0\n\n    # Start a monitor to mimic the SV $monitor\n    monitor_task = cocotb.start_soon(monitor_signals(dut))\n\n    # Wait until after reset is applied (simulate @(posedge rst_i); #10)\n    await Timer(10, units=\"ns\")\n\n    # -----------------------\n    # Test 1: Clear FIFO and set aligned PC\n    # -----------------------\n    dut._log.info(\"*** Test 1: Clear FIFO (Aligned PC) ***\")\n    dut.clear_i.value   = 1\n    dut.in_addr_i.value = 0x00000000  # Using an aligned address\n    await Timer(10, units=\"ns\")\n    dut.clear_i.value = 0\n    await Timer(10, units=\"ns\")\n    # (Optionally, assert conditions here if required for Test 1)\n\n    # -----------------------\n    # Test 2: Single Instruction Fetch (Aligned case)\n    # -----------------------\n    dut._log.info(\"*** Test 2: Single Instruction Fetch (Aligned) ***\")\n    dut.in_valid_i.value = 1\n    dut.in_rdata_i.value = 0x8C218363  # BEQ instruction with negative offset\n    dut.in_err_i.value   = 0\n    await Timer(10, units=\"ns\")\n    dut.in_valid_i.value = 0\n    await Timer(10, units=\"ns\")\n    # Allow the instruction to be popped by asserting out_ready\n    dut.out_ready_i.value = 1\n    await Timer(10, units=\"ns\")\n    dut.out_ready_i.value = 0\n    await Timer(20, units=\"ns\")\n\n    # --- Test 2 Assertions ---\n    # Expected (from logs): at end of Test 2, out_valid should be 0,\n    # out_addr should be 0x00000004, and out_rdata should be 0x8C218363.\n    assert safe_int(dut.out_valid_o) != \"X\" and int(dut.out_valid_o.value) == 0, \\\n        \"Test 2: out_valid_o should be 0 after instruction pop\"\n    assert safe_int(dut.out_addr_o) != \"X\" and int(dut.out_addr_o.value) == 0x00000004, \\\n        \"Test 2: out_addr_o should be 0x00000004\"\n    assert safe_int(dut.out_rdata_o) != \"X\" and int(dut.out_rdata_o.value) == 0x8C218363, \\\n        \"Test 2: out_rdata_o should match input (8C218363)\"\n\n    # -----------------------\n    # Test 3: FIFO Depth Test - Push Multiple Instructions\n    # -----------------------\n    dut._log.info(\"*** Test 3: FIFO Depth Test ***\")\n    dut.in_valid_i.value = 1\n    dut.in_rdata_i.value = 0x6C2183E3  # BEQ instruction with positive offset\n    dut.in_err_i.value   = 0\n    await Timer(10, units=\"ns\")\n    dut.in_rdata_i.value = 0x926CF16F  # JAL instruction with negative offset\n    await Timer(10, units=\"ns\")\n    dut.in_valid_i.value = 0\n    await Timer(10, units=\"ns\")\n    # Pop the FIFO entries (simulate repeat (3) begin #10)\n    dut.out_ready_i.value = 1\n    for _ in range(3):\n        await Timer(10, units=\"ns\")\n    dut.out_ready_i.value = 0\n    await Timer(10, units=\"ns\")\n\n    # --- Test 3 Assertions ---\n    # Expected: out_valid should be 0, out_addr should be 0x0000000C,\n    # and out_rdata should be 0x926CF16F.\n    assert safe_int(dut.out_valid_o) != \"X\" and int(dut.out_valid_o.value) == 0, \\\n        \"Test 3: out_valid_o should be 0 after FIFO pop\"\n    assert safe_int(dut.out_addr_o) != \"X\" and int(dut.out_addr_o.value) == 0x0000000C, \\\n        \"Test 3: out_addr_o should be 0x0000000C\"\n    assert safe_int(dut.out_rdata_o) != \"X\" and int(dut.out_rdata_o.value) == 0x926CF16F, \\\n        \"Test 3: out_rdata_o should be 0x926CF16F\"\n\n    # -----------------------\n    # Test 4: Unaligned Instruction Fetch\n    # -----------------------\n    dut._log.info(\"*** Test 4: Unaligned Instruction Fetch ***\")\n    # Clear FIFO with a new PC that produces an unaligned fetch.\n    dut.clear_i.value   = 1\n    dut.in_addr_i.value = 0x00000002  # 0x00000002 gives an unaligned PC (instr_addr_q[0] = 1)\n    await Timer(10, units=\"ns\")\n    dut.clear_i.value = 0\n    await Timer(10, units=\"ns\")\n    # Provide two consecutive instruction data words to form an unaligned instruction.\n    dut.in_valid_i.value = 1\n    dut.in_rdata_i.value = 0xF63101E7  # JAL instruction with negative offset\n    dut.in_err_i.value   = 0\n    await Timer(10, units=\"ns\")\n    dut.in_rdata_i.value = 0x763101E7  # JALR instruction with positive offset\n    await Timer(10, units=\"ns\")\n    dut.in_valid_i.value = 0\n    await Timer(10, units=\"ns\")\n    # Pop the unaligned instruction\n    dut.out_ready_i.value = 1\n    for _ in range(3):\n        await Timer(10, units=\"ns\")\n    dut.out_ready_i.value = 0\n    await Timer(10, units=\"ns\")\n\n    # --- Test 4 Assertions ---\n    # Expected: out_valid should be 0, out_addr should be 0x00000008,\n    # and out_rdata should be 0x763101E7.\n    assert safe_int(dut.out_valid_o) != \"X\" and int(dut.out_valid_o.value) == 0, \\\n        \"Test 4: out_valid_o should be 0 after unaligned fetch\"\n    assert safe_int(dut.out_addr_o) != \"X\" and int(dut.out_addr_o.value) == 0x00000008, \\\n        \"Test 4: out_addr_o should be 0x00000008\"\n    assert safe_int(dut.out_rdata_o) != \"X\" and int(dut.out_rdata_o.value) == 0x763101E7, \\\n        \"Test 4: out_rdata_o should be 0x763101E7\"\n\n    # -----------------------\n    # Test 5: Error Handling\n    # -----------------------\n    dut._log.info(\"*** Test 5: Error Handling ***\")\n    # Clear FIFO and reset PC to an aligned address.\n    dut.clear_i.value   = 1\n    dut.in_addr_i.value = 0x00000000\n    await Timer(15, units=\"ns\")\n    dut.clear_i.value = 0\n    await Timer(15, units=\"ns\")\n    # Drive an instruction fetch with an error on the first half.\n    dut.in_valid_i.value = 1\n    dut.in_rdata_i.value = 0x4840006F  # C.J instruction with positive offset\n    dut.in_err_i.value   = 1          # Signal an error\n    await Timer(15, units=\"ns\")\n    dut.in_valid_i.value = 0\n    await Timer(15, units=\"ns\")\n    # Allow the error-containing instruction to be popped.\n    dut.out_ready_i.value = 1\n    await Timer(15, units=\"ns\")\n    dut.out_ready_i.value = 0\n    await Timer(15, units=\"ns\")\n\n    # --- Test 5 Assertions ---\n    # Expected: out_valid should be 0, out_addr should be 0x00000004,\n    # out_rdata should be 0x4840006F, and in_err should be 1.\n    assert safe_int(dut.out_valid_o) != \"X\" and int(dut.out_valid_o.value) == 0, \\\n        \"Test 5: out_valid_o should be 0 after error handling\"\n    assert safe_int(dut.out_addr_o) != \"X\" and int(dut.out_addr_o.value) == 0x00000004, \\\n        \"Test 5: out_addr_o should be 0x00000004\"\n    assert safe_int(dut.out_rdata_o) != \"X\" and int(dut.out_rdata_o.value) == 0x4840006F, \\\n        \"Test 5: out_rdata_o should match error instruction data (4840006F)\"\n    assert safe_int(dut.in_err_i) != \"X\" and int(dut.in_err_i.value) == 1, \\\n        \"Test 5: in_err_i should be 1 for error instruction\"\n\n    dut._log.info(\"*** End of Simulation ***\")\n    monitor_task.kill()\n\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Fetch environment variables for simulation setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang = os.getenv(\"TOPLEVEL_LANG\", \"verilog\")\nsim = os.getenv(\"SIM\", \"icarus\")\ntoplevel = os.getenv(\"TOPLEVEL\", \"fifo_buffer\")\nmodule = os.getenv(\"MODULE\", \"test_fifo_buffer\")\nwave = os.getenv(\"WAVE\", \"0\")\n\n# Function to configure and run the simulation\ndef runner():\n    \"\"\"Runs the simulation for the fifo buffer.\"\"\"\n    # Get the simulation runner\n    simulation_runner = get_runner(sim)\n\n    # Build the simulation environment\n    simulation_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,         # Always rebuild\n        clean=True,          # Clean previous build files\n        waves=True ,   # Enable waveform generation if WAVE=1\n        verbose=True,        # Verbose build and simulation output\n        timescale=(\"1ns\", \"1ns\"),  # Set the timescale for simulation\n        log_file=\"build.log\"      # Log file for the build process\n    )\n\n    # Run the testbench\n    simulation_runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True    # Enable waveform dump if WAVE=1\n    )\n\n# Pytest function to run the simulation\n@pytest.mark.simulation\ndef test_fifo_buffer():\n    \"\"\"Pytest function to execute the fifo buffer testbench.\"\"\"\n    print(\"Running fifo buffer testbench...\")\n    runner()\n\n"}}
{"id": "cvdp_agentic_nebula_nova_castle_8184", "categories": ["cid004", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYour task is to modify the existing RTL design based on the provided specifications to improve Quality of Results (QoR) such as timing, area, or power efficiency. Ensure the modifications are verified against the provided testbench and meet the updated specifications.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Modify the direct_map_cache module to implement a 2-way set associative cache with victim-way replacement and retain all current functionality (including tag comparison, write/read access, valid/dirty/error status, and LSB alignment error checking). The module should select between two cache ways during tag matches and use a victim policy for cache line replacement when both ways are valid but there is a miss. The modified module introduces a new internal victimway register to alternate replacement decisions in the absence of a direct match.\n\n## Added/Modified Parameterization\n\n- **N**: Number of ways per set. Default is 2 to implement a 2-way set-associative cache. its a local parameter \n\n## Design Modifications\n\n### Associative Cache Structure\n\n- Introduced 2-way set associativity by instantiating tag, data, valid, and dirty storage for two ways.\n- A new internal `victimway` register implements a round-robin replacement policy on cache misses.\n- Read and Write logic updated to probe both ways, handle hits/misses correctly, and update the correct way.\n- Error signal continues to detect misaligned offset accesses, specifically when the LSB of the offset is high.\n- Cache reset and enable handling behavior remains consistent but expanded for two-way state management.\n\n### Hit and Miss Logic\n\n- Hits can occur in either of the two ways, indicated by separate internal signals (`hit0`, `hit1`).\n- A multiplexer selects outputs (`data_out`, `tag_out`, `valid`, `dirty`) from the correct way based on which way had a hit.\n\n### Victim-Way Replacement Policy\n\n- A `victim-way` register tracks which way to replace upon a miss if both ways are valid.\n- On a cache miss and when both ways are valid, the victim way is used to store new data and the victim-way indicator toggles to ensure even usage of both ways.\n\n### Misalignment Error Handling\n\n- Continues to set the error signal high if the least significant bit of the offset is 1 (misaligned access).\n\n## Behavioral Changes\n\n### Operation Modes\n\n1. **Compare Read** (`comp=1, write=0`):  \n   - Checks for tag matches in both ways, updates output signals accordingly.\n\n2. **Compare Write** (`comp=1, write=1`):  \n   - Performs write if a match is found in either way or initiates victim-way replacement if a miss occurs.\n\n3. **Access Read** (`comp=0, write=0`):  \n   - Performs reads based on valid bits, without affecting victim-way tracking.\n\n4. **Access Write** (`comp=0, write=1`):  \n   - Writes data and tag inputs to both ways without victim logic engagement.\n\n### Example Usage\n\n#### Compare Write (Miss, Replacement)\n\n- **comp = 1, write = 1**, `tag_in = <tag>`, `index = <idx>`, `valid_in = 1`, `data_in = <data>`, both ways valid, tag mismatch in both ways.\n- Data is written into the current victim way, and the victim-way toggles for the next replacement.\n\n#### Compare Read (Hit)\n\n- **comp = 1, write = 0**, `tag_in = <tag>`, matching tag found in either way.\n- `hit` is set high, and the correct `data_out` is returned from the matching way.\n", "context": {"rtl/direct_map_cache.sv": "module direct_map_cache #(\n    parameter CACHE_SIZE = 256,                 // Number of cache lines\n    parameter DATA_WIDTH = 16,                  // Width of data\n    parameter TAG_WIDTH = 5,                    // Width of the tag\n    parameter OFFSET_WIDTH = 3,                 // Width of the offset\n    localparam INDEX_WIDTH = $clog2(CACHE_SIZE) // Width of the index\n) (\n    input wire enable,                          // Enable signal\n    input wire [INDEX_WIDTH-1:0] index,         // Cache index\n    input wire [OFFSET_WIDTH-1:0] offset,       // Byte offset within the cache line\n    input wire comp,                            // Compare operation signal\n    input wire write,                           // Write operation signal\n    input wire [TAG_WIDTH-1:0] tag_in,          // Input tag for comparison and writing\n    input wire [DATA_WIDTH-1:0] data_in,        // Input data to be written\n    input wire valid_in,                        // Valid state for cache line\n    input wire clk,                             // Clock signal\n    input wire rst,                             // Reset signal (active high)\n    output reg hit,                             // Hit indication\n    output reg dirty,                           // Dirty state indication\n    output reg [TAG_WIDTH-1:0] tag_out,         // Output tag of the cache line\n    output reg [DATA_WIDTH-1:0] data_out,       // Output data from the cache line\n    output reg valid,                           // Valid state output\n    output reg error                            // Error indication for invalid accesses\n);\n\n    // Cache line definitions\n    reg [TAG_WIDTH-1:0] tags [CACHE_SIZE-1:0];                       // Tag storage\n    reg [DATA_WIDTH-1:0] data_mem [CACHE_SIZE-1:0][OFFSET_WIDTH:0];  // Data storage\n    reg valid_bits [CACHE_SIZE-1:0];                                 // Valid bits for each line\n    reg dirty_bits [CACHE_SIZE-1:0];                                 // Dirty bits for each line\n    integer i;\n\n    // Sequential logic for cache operations\n    always @(posedge clk) begin\n        if (rst) begin\n            // Initialize cache lines on reset\n            for (i = 0; i < CACHE_SIZE; i = i + 1) begin\n                valid_bits[i] <= 1'b0;                       \n                dirty_bits[i] <= 1'b0;                                      \n            end\n            hit      <= 1'b0;                                    \n            dirty    <= 1'b0;                                                     \n            valid    <= 1'b0;\n            data_out <= {DATA_WIDTH{1'b0}};                                   \n        end \n        else if (enable) begin\n            // Check for LSB alignment error\n            if (offset[0] == 1'b1) begin\n                error <= 1'b1;                               // Set error if LSB of offset is 1\n                hit   <= 1'b0;                                 \n                dirty <= 1'b0;                               \n                valid <= 1'b0;                               \n                data_out <= {DATA_WIDTH{1'b0}};              \n            end \n            else begin\n                error <= 1'b0;                               // Clear error if LSB of offset is 0\n\n                // Compare operation\n                if (comp) begin\n                    // Compare Write (comp = 1, write = 1) \n                    if (write) begin\n                        if ((tags[index] == tag_in) && valid_bits[index]) begin\n                            hit <= 1'b1;\n                            data_mem[index][offset[OFFSET_WIDTH-1:1]] <= data_in; \n                            dirty_bits[index] <= 1'b1;  \n                            valid_bits[index] <= valid_in; \n                            valid    <= 1'b0;                 \n                            dirty    <= 1'b0; \n\n                        end\n                        else begin\n                            hit <= 1'b0;\n                            dirty_bits[index] <= 1'b0;\n                            valid_bits[index] <= valid_in;\n                            tags[index]       <= tag_in;\n                            valid    <= 1'b0;                 \n                            dirty    <= 1'b0;  \n                            data_mem[index][offset[OFFSET_WIDTH-1:1]] <= data_in;              \n                        end\n                    end \n                    else begin // Write\n                        // Compare Read (comp = 1, write = 0)\n                        if ((tags[index] == tag_in) && valid_bits[index]) begin\n                            hit <= 1'b1;\n                            data_out <= data_mem[index][offset[OFFSET_WIDTH-1:1]]; \n                            valid    <= valid_bits[index];                 \n                            dirty    <= dirty_bits[index]; \n                            tag_out  <= tags[index];                \n                        end\n                        else begin\n                            hit <= 1'b0;\n                            tag_out  <= tags[index];\n                            valid <= valid_bits[index];                   \n                            dirty <= dirty_bits[index]; \n                            data_out <= data_mem[index][offset[OFFSET_WIDTH-1:1]];                 \n                        end\n                    end\n                end \n                else begin //compare\n                    if (write) begin\n                        // Access Write (comp = 0, write = 1)\n                        tags[index]       <= tag_in;                       \n                        data_mem[index][offset[OFFSET_WIDTH-1:1]] <= data_in; \n                        valid_bits[index] <= valid_in;               \n                        dirty_bits[index] <= 1'b0;\n                        hit      <= 1'b0;\n                        valid    <= 1'b0;                 \n                        dirty    <= 1'b0;\n\n                    end \n                    else begin\n                        // Access Read (comp = 0, write = 0)\n                        tag_out  <= tags[index];                      \n                        data_out <= data_mem[index][offset[OFFSET_WIDTH-1:1]]; \n                        valid    <= valid_bits[index];                  \n                        dirty    <= dirty_bits[index];\n                        hit      <= 1'b0;\n\n                    end\n                end\n            end \n        end \n        else begin // enable\n            // enable is low\n            for (i = 0; i < CACHE_SIZE; i = i + 1) begin\n                valid_bits[i] <= 1'b0;                           \n                dirty_bits[i] <= 1'b0;                                                  \n            end\n\n            hit      <= 1'b0;                                       \n            dirty    <= 1'b0;                                                         \n            data_out <= {DATA_WIDTH{1'b0}};                    \n            valid    <= 1'b0;                                     \n        end\n    end\n\nendmodule", "verif/tb_direct_map_cache.sv": "`timescale 1ns/1ps\n\nmodule tb_direct_map_cache;\n\n    // Parameters\n    parameter CACHE_SIZE = 256;               // Number of cache lines\n    parameter DATA_WIDTH = 16;                // Width of data\n    parameter TAG_WIDTH = 5;                  // Width of the tag\n    parameter OFFSET_WIDTH = 3;               // Width of the offset\n\n    // Inputs\n    reg enable;                               // Enable signal for cache\n    reg [7:0] index;                          // 8 bits for indexing into the cache\n    reg [OFFSET_WIDTH-1:0] offset;            // 3 bits for offset\n    reg comp;                                 // Compare signal\n    reg write;                                // Write signal\n    reg [TAG_WIDTH-1:0] tag_in;               // Tag input\n    reg [DATA_WIDTH-1:0] data_in;             // Data input\n    reg valid_in;                             // Valid input for cache line\n    reg clk;                                  // Clock signal\n    reg rst;                                  // Reset signal\n    reg [DATA_WIDTH-1:0] data;                // Data variable for tasks\n\n    // Outputs\n    wire hit;                                 // Hit indication\n    wire dirty;                               // Dirty state indication\n    wire [TAG_WIDTH-1:0] tag_out;             // Output tag of the cache line\n    wire [DATA_WIDTH-1:0] data_out;           // Output data from the cache line\n    wire valid;                               // Valid state output\n    wire error;                               // Error indication\n\n    integer i;                                \n\n    // Instantiate the cache\n    direct_map_cache #(\n                                    .CACHE_SIZE(CACHE_SIZE),\n                                    .DATA_WIDTH(DATA_WIDTH),\n                                    .TAG_WIDTH(TAG_WIDTH),\n                                    .OFFSET_WIDTH(OFFSET_WIDTH)\n                                   )\n\t\t\t                   uut (\n                                    .enable(enable),\n                                    .index(index),\n                                    .offset(offset),\n                                    .comp(comp),\n                                    .write(write),\n                                    .tag_in(tag_in),\n                                    .data_in(data_in),\n                                    .valid_in(valid_in),\n                                    .clk(clk),\n                                    .rst(rst),\n                                    .hit(hit),\n                                    .dirty(dirty),\n                                    .tag_out(tag_out),\n                                    .data_out(data_out),\n                                    .valid(valid),\n                                    .error(error)\n                                   );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;  // 10 ns period\n    end\n\n    // Test procedure\n    initial begin\n        // Initialize inputs\n        enable = 0;\n        rst = 1;\n        @(posedge clk);\n        rst = 0;\n        @(posedge clk); \n\n        // Enable cache\n        enable = 1;\n        // Pseudo-Random Replacement Condition Checking\n        // Fill the cache to trigger replacement\n        write_task(8'h02, 3'b000, 5'b00000, 1'b1,1'b1);\n        read_task(8'h02, 3'b000, 5'b00000, 1'b1);\n        write_task(8'h02, 3'b000, 5'b00001, 1'b1,1'b1);\n        read_task(8'h02, 3'b000, 5'b00001, 1'b1);\n        write_task(8'h02, 3'b000, 5'b00010, 1'b1,1'b1);\n        read_task(8'h02, 3'b000, 5'b00010, 1'b1);\n        write_task(8'h02, 3'b000, 5'b00011, 1'b1,1'b1);\n        read_task(8'h02, 3'b000, 5'b00011, 1'b1);\n\n        @(posedge clk); \n\n        // Write to cache without compare\n        write_task(8'h00, 3'b000, 5'b00001, 1'b0,1'b1);\n\n\t    // Read from cache without compare\n        read_task(8'h00, 3'b000, 5'b00001, 1'b0);\n\n        // Write to cache with compare\n        write_task(8'h00, 3'b000, 5'b00001, 1'b1,1'b1);\n\n        // Read from cache  with compare\n        read_task(8'h00, 3'b000, 5'b00001, 1'b1);\n\n        // Write to cache with out compare \n        write_task(8'h01, 3'b110, 5'b00010, 1'b0,1'b1);\n\n        // Read from cache  with compare\n        read_task(8'h01, 3'b110, 5'b00010, 1'b1);\n\n        // Error condition\n        write_task(8'h01, 3'b001, 5'b00010, 1'b0,1'b1);      \n        @(posedge clk); \n        check_error(3'b001, error);\n        // Finalize simulation\n        $finish;\n    end\n\n    // Task to handle writing to the cache\n    task write_task(input [7:0] indx, input [2:0] off, input [4:0] tag, input compr, valid);\n        begin\n            index = indx;  \n            offset = off; \n            tag_in = tag; \n            data_in = $random; \n            valid_in = valid;    \n            write = 1'b1;       \n            comp = compr; \n            @(posedge clk); \n\n             // Display after the clock\n            $display(\"\\n[WRITE_TASK] @time %0t\", $time);\n            $display(\"  -> index=%0d (0x%0h), offset=%0d (0x%0h), tag_in=%b, data_in=%0h\",\n                      index, index, offset, offset, tag_in, data_in);\n            $display(\"  -> comp=%b, write=%b, valid_in=%b\", comp, write, valid_in);\n            $display(\"  -> hit=%b, dirty=%b, tag_out=%b, data_out=%0h, valid=%b, error=%b\",\n                      hit, dirty, tag_out, data_out, valid, error);\n        end\n    endtask \n\n    // Task to handle reading from the cache\n    task read_task(input [7:0] indx, input [2:0] off, input [4:0] tag, input compr);\n        begin\n            index = indx;  \n            offset = off; \n            tag_in = tag; \n            comp = compr;\n            @(posedge clk);        \n            write = 1'b0;\n            @(posedge clk);\n        \n            $display(\"\\n[READ_TASK] @time %0t\", $time);\n            $display(\"  -> index=%0d (0x%0h), offset=%0d (0x%0h), tag_in=%b\",\n                      index, index, offset, offset, tag_in);\n            $display(\"  -> comp=%b, write=%b\", comp, write);\n            $display(\"  -> hit=%b, dirty=%b, tag_out=%b, data_out=%0h, valid=%b, error=%b\",\n                      hit, dirty, tag_out, data_out, valid, error);\n\n\n            if (data_in !== data_out)\n                $display(\"  -> [Error] Data mismatch! data_in=%0h, data_out=%0h\",\n                          data_in, data_out);\n            else\n                $display(\"  -> [Pass] Data matched.\");\n            @(posedge clk); \n        end\n    endtask\n\n    task check_error(input [2:0] offset_val, input error_signal);\n        begin\n            if (offset_val[0]) begin\n                if (error_signal)\n                    $display(\"  -> [PASS] ERROR correctly asserted for misaligned offset (offset[0]=1)\");\n                else\n                    $display(\"  -> [FAIL] ERROR was expected for misaligned offset, but not asserted!\");\n                end else begin\n                if (error_signal)\n                    $display(\"  -> [FAIL] ERROR was unexpectedly asserted on aligned offset (offset[0]=0)\");\n                else\n                    $display(\"  -> [PASS] No error as expected (aligned offset)\");\n            end\n        end\n    endtask\n\n    // Waveform dumping for simulation analysis\n    initial begin\n        $dumpfile(\"direct_map_cachet.vcd\");    // Specify the VCD file for waveform dumping\n        $dumpvars(0, tb_direct_map_cache);     // Dump all variables in the testbench\n    end\nendmodule"}, "patch": {"rtl/direct_map_cache.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n\n  03-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v \n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/direct_map_cache.sv \nTOPLEVEL        = direct_map_cache\nMODULE          = test_direct_map_cache\nPYTHONPATH      = /src\nHASH            = 994b8e75f4f3e16dd719e14f57c1297ea9d7441b\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_direct_map_cache.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge\nimport random\n\n# Global state for read/write comparisons\nstored_index = 0\nstored_offset = 0\nstored_tag = 0\nstored_data = 0\n\n@cocotb.test()\nasync def test_direct_map_cache(dut):\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    await reset_dut(dut)\n\n    await write_access(dut, comp=0)\n    await read_access(dut, comp=1)\n    await compare_write(dut)\n    await read_access(dut, comp=1)\n    await miss_test(dut)\n    await read_access(dut, comp=0)\n    await force_offset_error(dut)\n    await corner_case_zero_tag_index(dut)\n    await corner_case_max_tag_index(dut)\n    await corner_case_toggle_enable(dut)\n    await victimway_assertion(dut)\n\ndef get_param(dut, name):\n    return int(getattr(dut, name).value)\n\nasync def reset_dut(dut):\n    dut.rst.value = 1\n    dut.enable.value = 0\n    dut.comp.value = 0\n    dut.write.value = 0\n    dut.index.value = 0\n    dut.offset.value = 0\n    dut.tag_in.value = 0\n    dut.data_in.value = 0\n    dut.valid_in.value = 0\n    for _ in range(3):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    dut._log.info(\"[RESET] Complete\")\n\nasync def write_access(dut, comp):\n    global stored_index, stored_offset, stored_tag, stored_data\n    cache_size   = int(dut.CACHE_SIZE.value)\n    data_width   = int(dut.DATA_WIDTH.value)\n    tag_width    = int(dut.TAG_WIDTH.value)\n    offset_width = int(dut.OFFSET_WIDTH.value)\n    index_width  = int(dut.INDEX_WIDTH.value)\n\n    stored_index = random.randint(0, cache_size - 1)\n    stored_offset = random.randint(0, (1 << offset_width) - 1) & ~1\n    stored_tag = random.randint(0, (1 << tag_width) - 1)\n    stored_data = random.randint(0, (1 << data_width) - 1)\n\n    dut.enable.value = 1\n    dut.comp.value = comp\n    dut.write.value = 1\n    dut.valid_in.value = 1\n    dut.index.value = stored_index\n    dut.offset.value = stored_offset\n    dut.tag_in.value = stored_tag\n    dut.data_in.value = stored_data\n\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"[WRITE_COMP{comp}] idx={stored_index}, off={stored_offset}, tag={stored_tag}, data={stored_data:04X}\")\n\nasync def read_access(dut, comp):\n    global stored_index, stored_offset, stored_tag, stored_data\n\n    dut.enable.value = 1\n    dut.comp.value = comp\n    dut.write.value = 0\n    dut.index.value = stored_index\n    dut.offset.value = stored_offset\n    dut.tag_in.value = stored_tag\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    dout = int(dut.data_out.value)\n    hit = dut.hit.value\n    valid = dut.valid.value\n\n    dut._log.info(f\"[READ_COMP{comp}] idx={stored_index}, off={stored_offset}, tag={stored_tag}, dout={dout:04X}, hit={hit}, valid={valid}\")\n\n    if not dut.error.value:\n        if hit and valid and dout == stored_data:\n            dut._log.info(\"  [PASS] Data matched on read.\")\n        else:\n            dut._log.error(\"  [FAIL] Data mismatch or miss.\")\n\nasync def compare_write(dut):\n    global stored_data\n    data_width = get_param(dut, \"DATA_WIDTH\")\n    new_data = random.randint(0, (1 << data_width) - 1)\n    stored_data = new_data\n\n    dut.enable.value = 1\n    dut.comp.value = 1\n    dut.write.value = 1\n    dut.valid_in.value = 1\n    dut.data_in.value = new_data\n\n    await RisingEdge(dut.clk)\n\n    hit = dut.hit.value\n    dirty = dut.dirty.value\n    dut._log.info(f\"[WRITE_COMP1] dirty={dirty}, hit={hit}, data={new_data:04X}\")\n\nasync def miss_test(dut):\n    cache_size = get_param(dut, \"CACHE_SIZE\")\n    offset_width = get_param(dut, \"OFFSET_WIDTH\")\n    tag_width = get_param(dut, \"TAG_WIDTH\")\n    new_index = (stored_index + 1) % cache_size\n    new_offset = random.randint(0, (1 << offset_width) - 1) & ~1\n    new_tag = random.randint(0, (1 << tag_width) - 1)\n\n    dut.enable.value = 1\n    dut.comp.value = 1\n    dut.write.value = 0\n    dut.index.value = new_index\n    dut.offset.value = new_offset\n    dut.tag_in.value = new_tag\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    hit = dut.hit.value\n    dut._log.info(f\"[MISS_TEST] idx={new_index}, off={new_offset}, tag={new_tag}, hit={hit}\")\n    if hit == 0:\n        dut._log.info(\"  [PASS] Expected miss\")\n    else:\n        dut._log.error(\"  [FAIL] Unexpected hit on miss test\")\n\nasync def force_offset_error(dut):\n    dut.enable.value = 1\n    dut.comp.value = 0\n    dut.write.value = 0\n    dut.index.value = 0\n    dut.offset.value = 0b001  # Misaligned\n    dut.tag_in.value = 0\n    dut.data_in.value = 0\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    check_error(dut, dut.offset.value, dut.error.value, \"OFFSET_ERROR\")\n\nasync def corner_case_zero_tag_index(dut):\n    data_width = get_param(dut, \"DATA_WIDTH\")\n    dut.enable.value = 1\n    dut.comp.value = 1\n    dut.write.value = 1\n    dut.index.value = 0\n    dut.offset.value = 0\n    dut.tag_in.value = 0\n    dut.data_in.value = 0xABCD & ((1 << data_width) - 1)\n    dut.valid_in.value = 1\n    await RisingEdge(dut.clk)\n    dut._log.info(\"[CORNER] Write with zero index and zero tag\")\n\nasync def corner_case_max_tag_index(dut):\n    cache_size = get_param(dut, \"CACHE_SIZE\")\n    tag_width = get_param(dut, \"TAG_WIDTH\")\n    data_width = get_param(dut, \"DATA_WIDTH\")\n    dut.enable.value = 1\n    dut.comp.value = 1\n    dut.write.value = 1\n    dut.index.value = cache_size - 1\n    dut.offset.value = 0\n    dut.tag_in.value = (1 << tag_width) - 1\n    dut.data_in.value = 0x1234 & ((1 << data_width) - 1)\n    dut.valid_in.value = 1\n    await RisingEdge(dut.clk)\n    dut._log.info(\"[CORNER] Write with max index and max tag\")\n\nasync def corner_case_toggle_enable(dut):\n    global stored_index, stored_offset, stored_tag\n    dut.enable.value = 0\n    dut.comp.value = 1\n    dut.write.value = 0\n    dut.index.value = stored_index\n    dut.offset.value = stored_offset\n    dut.tag_in.value = stored_tag\n    await RisingEdge(dut.clk)\n    dut._log.info(\"[CORNER] Access with enable low\")\n    if dut.valid.value == 1 or dut.hit.value == 1:\n        dut._log.error(\"  [FAIL] Outputs should be zero when enable is low\")\n    else:\n        dut._log.info(\"  [PASS] Outputs correctly reset when enable is low\")\n\ndef check_error(dut, offset_val, err_signal, context=\"\"):\n    if int(offset_val) & 0x1:\n        if (err_signal):\n            dut._log.info(f\"  [PASS] ERROR asserted as expected in {context} (offset LSB=1)\")\n        else:\n            dut._log.error(f\"  [FAIL] ERROR not asserted in {context} (expected offset LSB=1)\")\n    else:\n        if (err_signal):\n            dut._log.error(f\"  [FAIL] ERROR incorrectly asserted in {context} (offset LSB=0)\")\n        else:\n            dut._log.info(f\"  [PASS] No error in {context} (offset aligned)\")\n\nasync def victimway_assertion(dut):\n    # Select a test index (e.g. 7)\n    test_index = 7\n    cache_size = get_param(dut, \"CACHE_SIZE\")\n    tag_width = get_param(dut, \"TAG_WIDTH\")\n    data_width = get_param(dut, \"DATA_WIDTH\")\n    # First, perform an access write (comp=0, write=1) to fill the cache for this index.\n    # In an \"access\" mode write, both ways are written.\n    dut.enable.value = 1\n    dut.comp.value = 0  # access write mode\n    dut.write.value = 1\n    dut.index.value = test_index\n    dut.offset.value = 0  # aligned offset (LSB=0)\n    dut.tag_in.value = 0xA  & ((1 << tag_width) - 1)\n    dut.data_in.value = 0x1234 & ((1 << data_width) - 1)\n    dut.valid_in.value = 1\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"[VICTIM] Filled index {test_index} with tag 0xA (access write updates both ways)\")\n\n    # Now, perform a compare write (comp=1, write=1) with a mismatching tag so that a miss occurs.\n    prev_victim = int(dut.victimway.value)\n    new_tag = 0xB  & ((1 << tag_width) - 1)\n    dut.enable.value = 1\n    dut.comp.value = 1\n    dut.write.value = 1\n    dut.index.value = test_index\n    dut.offset.value = 0  # aligned offset\n    dut.tag_in.value = new_tag\n    dut.data_in.value = 0x5678 & ((1 << data_width) - 1)\n    dut.valid_in.value = 1\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    new_victim = int(dut.victimway.value)\n    dut._log.info(f\"[VICTIM] Compare write at index {test_index} with tag 0xB: previous victim={prev_victim}, new victim={new_victim}\")\n\n    # Assert that victimway toggled during the replace.\n    assert new_victim == (1 - prev_victim), \\\n      f\"Victimway did not toggle properly: was {prev_victim}, now {new_victim}\"\n    dut._log.info(\"  [PASS] Victimway toggled correctly on compare write miss\")\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(CACHE_SIZE: int = 256,DATA_WIDTH: int = 16,TAG_WIDTH: int = 5,OFFSET_WIDTH: int = 3):\n    parameter = {\"CACHE_SIZE\": CACHE_SIZE,\"DATA_WIDTH\":DATA_WIDTH,\"TAG_WIDTH\": TAG_WIDTH,\"OFFSET_WIDTH\":OFFSET_WIDTH}\n    print(f\"[DEBUG] Parameters: {parameter}\")     \n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n\n@pytest.mark.parametrize(\"test\", range(1))\n@pytest.mark.parametrize(\"CACHE_SIZE\", [64,256])\n@pytest.mark.parametrize(\"DATA_WIDTH\", [8,16])\n@pytest.mark.parametrize(\"TAG_WIDTH\", [3,5])\n@pytest.mark.parametrize(\"OFFSET_WIDTH\", [3,6])\ndef test_direct_cache(CACHE_SIZE,DATA_WIDTH,TAG_WIDTH,OFFSET_WIDTH, test):\n    runner(CACHE_SIZE=CACHE_SIZE,DATA_WIDTH=DATA_WIDTH,TAG_WIDTH=TAG_WIDTH,OFFSET_WIDTH=OFFSET_WIDTH)\n    \n"}}
{"id": "cvdp_agentic_ember_meadow_sunrise_1765", "categories": ["cid004", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Modify the elevator control system to support overload detection and direction indicators (LEDs), while retaining its core functionality of managing multiple floors, handling call requests, and responding to emergency stops. The updated module now includes an `overload` input to simulate elevator weight overload, and additional outputs `up_led`, `down_led`, and `overload_led` to reflect current operational status.\n\n---\n\n### **Design Specification**\n\nThe `elevator_control_system` module is an FSM-based design that manages elevator movement across `N` floors, processes floor requests, handles emergency stops, and opens/closes doors automatically. The enhanced version now includes **overload protection** and **direction indication via LEDs**.\n\n**New Functional Features**\n1. **Overload Detection**\n   - Input signal: `overload`\n   - When `overload = 1`, the elevator halts in its current state and transitions to the `DOOR_OPEN` state if not already there.\n   - Doors remain open during overload.\n   - Elevator movement is disabled until the overload is cleared (`overload = 0`).\n   - Output signal: `overload_led = 1` when overload is active.\n\n2. **Direction LEDs**\n   - `up_led = 1` when the elevator is moving up (`MOVING_UP` state).\n   - `down_led = 1` when the elevator is moving down (`MOVING_DOWN` state).\n   - Both LEDs are deactivated in `IDLE`, `DOOR_OPEN`, or `EMERGENCY_HALT` states.\n\n---\n\n### **Operational Behavior**\n\n**State Transitions**\n- **IDLE**: Waits for a request. If `overload` is active, it transitions directly to `DOOR_OPEN`.\n- **MOVING_UP / MOVING_DOWN**: Moves floor-by-floor based on pending requests. Transitions to `DOOR_OPEN` when a requested floor is reached.\n- **DOOR_OPEN**: Keeps doors open for a predefined duration. If `overload = 1`, the doors remain open indefinitely until the overload clears.\n- **EMERGENCY_HALT**: Activated by `emergency_stop`. Resumes to IDLE once the signal is deactivated.\n\n**Priority Logic**\n- Requests are served based on current direction:\n  - Upward requests take priority when going up.\n  - Downward requests take priority when descending.\n- If no request remains in the current direction, the system returns to IDLE.\n\n---\n\n### **Example Scenarios**\n\n**Example 1: Overload During Movement**\n- **Input**:\n  - Current floor: 5, Requested floor: 2\n  - `overload` = 1 triggered while elevator is moving down\n- **Expected Behavior**:\n  - Elevator halts immediately\n  - Door opens and stays open\n  - `overload_led` = 1\n  - After clearing overload, elevator resumes to floor 2\n\n**Example 2: Direction LED Behavior**\n- **Input**:\n  - Request floor 3 from ground floor\n- **Expected Behavior**:\n  - `up_led` = 1 while elevator ascends\n  - `down_led` = 0\n  - Once door opens, both LEDs turn off\n\n**Example 3: Overload While Idle**\n- **Input**:\n  - No active requests, `overload = 1`\n- **Expected Behavior**:\n  - Elevator stays in `DOOR_OPEN` state\n  - `overload_led` = 1\n  - No movement until overload clears\n", "context": {"rtl/elevator_control_system.sv": "/*\n * Elevator Control System\n * \n * This module implements an FSM-based elevator control system capable of managing multiple floors,\n * handling call requests, and responding to emergency stops. The elevator transitions between \n * five main states: Idle, Moving Up, Moving Down, Emergency Halt, Door Open. It prioritizes floor requests \n * based on direction, moving to the highest or lowest requested floor depending on the current direction.\n*/\nmodule elevator_control_system #(\n    parameter N = 8, //Number of floors\n    parameter DOOR_OPEN_TIME_MS = 500 // Door open time in milliseconds\n) ( \n    input wire clk,                   // 100MHz clock input\n    input wire reset,                 // Active-high reset signal\n    input wire [N-1:0] call_requests, // External Floor call requests\n    input wire emergency_stop,        // Emergency stop signal\n    output wire [$clog2(N)-1:0] current_floor, // Current floor of the elevator\n    output reg direction,             // Elevator direction: 1 = up, 0 = down\n    output reg door_open,             // Door open signal\n    output reg [2:0] system_status    // Elevator system state indicator\n);\n\n    typedef enum logic [2:0] {\n        IDLE           = 3'b000,\n        MOVING_UP      = 3'b001,\n        MOVING_DOWN    = 3'b010,\n        EMERGENCY_HALT = 3'b011,\n        DOOR_OPEN   = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n\n// Internal registers\nreg [N-1:0] call_requests_internal;   // Internal copy of call requests\nreg [$clog2(N)-1:0] max_request;     // Highest requested floor\nreg [$clog2(N)-1:0] min_request;    // Lowest requested floor\n\n\n// Door open time configuration\n`ifdef SIMULATION\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam SIM_DOOR_OPEN_TIME_MS = 0.05; // Shorter door open time for simulation\n    localparam DOOR_OPEN_CYCLES = (SIM_DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000); // Door open cycles for simulation   \n`else\n    // Calculating door open cycles based on time and clock frequency\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam DOOR_OPEN_CYCLES = (DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000);   // Door open cycles for real implementation\n`endif\n\n\nreg [$clog2(DOOR_OPEN_CYCLES)-1:0] door_open_counter;   // Counter for door open duration\n\n\nreg [$clog2(N)-1:0] current_floor_reg, current_floor_next=0;\n\nassign current_floor = current_floor_reg;\n\n// FSM state transition\nalways_ff @(posedge clk or posedge reset) begin\n    if(reset)begin\n        state <= IDLE;\n        system_status <= IDLE;\n        current_floor_reg <= 0;\n        max_request <= 0;\n        min_request <= N-1;        \n    end else begin\n        state <= next_state;\n        system_status <= next_state;\n        current_floor_reg <= current_floor_next;\n        \n        // Calculate max_request and min_request based on active requests\n        max_request = 0;\n        min_request = N-1;\n        for (integer i = 0; i < N; i = i + 1) begin\n            if (call_requests_internal[i]) begin\n                if (i > max_request) max_request = i;\n                if (i < min_request) min_request = i;\n            end\n        end\n    end\nend\n\n    always_comb begin\n    next_state = state;\n    current_floor_next = current_floor_reg;\n    \n    case(state)\n        IDLE:begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal != 0)begin\n                if(max_request > current_floor_reg)begin\n                    next_state = MOVING_UP;\n                end else if(min_request < current_floor_reg) begin\n                    next_state = MOVING_DOWN;\n                end\n            end\n        end\n\n        MOVING_UP: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg+1]) begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg >= max_request) begin\n                // If we reach the highest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = MOVING_UP;\n            end\n        end\n\n        MOVING_DOWN: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg-1]) begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg <= min_request) begin\n                // If we reach the lowest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = MOVING_DOWN;\n            end\n        end\n\n        EMERGENCY_HALT: begin\n            if (!emergency_stop) begin\n                next_state = IDLE;\n                current_floor_next = 0; // Optionally reset to ground floor\n            end\n        end\n        DOOR_OPEN: begin\n            if (door_open_counter == 0) begin\n                next_state = IDLE;\n            end else begin\n                next_state = DOOR_OPEN;\n            end\n        end\n    endcase\nend\n\n\n// Door open control logic\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n        door_open_counter <= 0;\n        door_open <= 0;\n    end else begin\n        if (state == DOOR_OPEN) begin\n            if (door_open_counter > 0) begin\n                door_open <= 1;\n                door_open_counter <= door_open_counter - 1;\n            end else begin\n                door_open <= 0;\n                next_state = IDLE;\n            end\n        end else begin\n            door_open <= 0;\n            door_open_counter <= DOOR_OPEN_CYCLES; // Reset door open counter\n        end\n    end\nend\n\n// Call request management\n    always_comb begin\n    if(reset) begin\n        call_requests_internal = 0;\n    end else begin\n        if(call_requests_internal[current_floor_reg])begin\n            call_requests_internal[current_floor_reg] = 0;      // Clear served request\n        end\n        call_requests_internal = call_requests_internal | call_requests;    // Update requests\n    end\nend\n\n// Direction control logic\n    always_comb begin\n        if (reset) direction = 1;\n        else if (state == MOVING_UP) direction = 1;\n        else if (state == MOVING_DOWN) direction = 0;\n        else direction = 1;\n    end\n\nendmodule"}, "patch": {"rtl/elevator_control_system.sv": ""}, "harness": {"docker-compose.yml": "services:\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir: /code/rundir\n    env_file: ./src/.env\n    command: pytest --log-cli-level=INFO -o cache_dir=/code/rundir/.cache -sv /src/test_runner.py\n    # command     : python3 /src/test_runner.py\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nWAVE            = 1\nVERILOG_SOURCES = /code/rtl/elevator_control_system.sv\nTOPLEVEL        = elevator_control_system\nMODULE          = elevator_control\nPYTHONPATH      = /src\nHASH            = ba961059c438b2c098f3472380705c9b8d5e153d\n", "src/elevator_control.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\n\n\nFLOOR = cocotb.plusargs.get(\"N\")\n\n# Helper function to reset DUT\nasync def reset_dut(dut, duration_ns):\n    dut.reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\n# Helper function to trigger a floor request\nasync def request_floor(dut, floor):\n    #current_requests = int(dut.call_requests.value)  # Convert LogicArray to integer\n    dut.call_requests.value =  (1 << floor)  # Perform bitwise OR\n    await RisingEdge(dut.clk)\n    dut.call_requests.value =  0\n\n# Helper function to clear call requests\nasync def clear_requests(dut):\n    dut.call_requests.value = 0\n    await RisingEdge(dut.clk)\n\n\n#Helper function to wait for door close\nasync def wait_door_close(dut):\n    # Wait until the door closes\n    dut._log.info(\"Waiting for the door to close\")\n    while dut.door_open.value == 1:\n        await RisingEdge(dut.clk)\n\n# Helper: Check direction LEDs during motion\nasync def check_direction_leds(dut, expected_direction):\n    if expected_direction == \"up\":\n        assert dut.up_led.value == 1, \"up_led not active while moving up\"\n        assert dut.down_led.value == 0, \"down_led should not be active while moving up\"\n    elif expected_direction == \"down\":\n        assert dut.up_led.value == 0, \"up_led should not be active while moving down\"\n        assert dut.down_led.value == 1, \"down_led not active while moving down\"\n\n# Test case 1: Single floor request\nasync def test_case_1(dut):\n    \"\"\"Test case 1: Single floor request\"\"\"\n\n    # Request floor 3 and check if the elevator reaches it\n    dut._log.info(\"Requesting floor 3\")\n    await request_floor(dut, 3)\n\n    #print(\"A Current Floor\", dut.current_floor.value)\n\n    # Wait and check if the elevator reaches floor 3\n    while dut.current_floor.value != 3:\n        await RisingEdge(dut.clk)\n        #print(\"Current Floor\", dut.current_floor.value)\n    await RisingEdge(dut.clk)\n    await Timer(30, units=\"ns\")\n    \n    assert dut.door_open.value == 1, \"Door did not open at requested floor\"\n\n\n    dut._log.info(\"Elevator reached floor 3 successfully\")\n\n    await wait_door_close(dut)\n\n    dut._log.info(\"Door closed successfully after reaching floor\")\n\n# Test case 2: Multiple floor requests\nasync def test_case_2(dut):\n    \"\"\"Test case 2: Multiple floor requests\"\"\"\n\n    FLOOR_SIZE = int(FLOOR)\n\n    if(FLOOR_SIZE == 5):\n        dut._log.info(\"Requesting floor 2,4\")\n        floor_list = [2,4]\n        # Request floors 2, 4, and 6\n        await request_floor(dut, 2)\n        await request_floor(dut, 4)\n    else:\n        dut._log.info(\"Requesting floor 2,4,6\")\n        floor_list = [2,4,6]\n        # Request floors 2, 4, and 6\n        await request_floor(dut, 2)\n        await request_floor(dut, 4)\n        await request_floor(dut, 6)\n\n    # Check if the elevator serves requests in sequence\n    for expected_floor in floor_list:\n        while dut.current_floor.value != expected_floor:\n            await RisingEdge(dut.clk)\n        #print(\"FLOOR\",dut.current_floor.value)\n        await Timer(30, units=\"ns\")\n        assert dut.door_open.value == 1, f\"Door did not open at floor {expected_floor}\"\n        await Timer(10, units=\"ns\")  # Simulate door open delay\n        dut._log.info(f\"Elevator reached floor {expected_floor}\")\n        await wait_door_close(dut)\n        dut._log.info(\"Door closed successfully after reaching floor\")\n\n    dut._log.info(\"Elevator served multiple requests successfully\")\n\n# Test case 3: Emergency stop\nasync def test_case_3(dut):\n    \"\"\"Test case 3: Emergency stop\"\"\"\n\n    # Request floor 5 and activate emergency stop midway\n    dut._log.info(\"Requesting floor 4\")\n    await request_floor(dut, 4)\n    await Timer(30, units=\"ns\")  # Wait for some time during movement\n\n    dut._log.info(\"Activating emergency stop\")\n    dut.emergency_stop.value = 1\n    await RisingEdge(dut.clk)\n    await Timer(30, units=\"ns\")  # Wait for some time during movement\n    assert dut.system_status.value == 3, \"Elevator did not enter emergency halt state\"\n    dut._log.info(\"Elevator entered emergency halt state\")\n\n    # Deactivate emergency stop and check if elevator resumes operation\n    dut.emergency_stop.value = 0\n    await RisingEdge(dut.clk)\n    await Timer(10, units=\"ns\")  # Wait for some time during movement    \n    assert dut.system_status.value == 0, \"Elevator did not return to idle after emergency stop\"\n    dut._log.info(\"Emergency stop cleared, elevator resumed operation\")\n\n# Test case 4: Reset during operation\nasync def test_case_4(dut):\n    \"\"\"Test case 4: Reset during operation\"\"\"\n\n    # Request floor 4\n    await request_floor(dut, 4)\n    await Timer(20, units=\"ns\")\n\n    # Apply reset and check if elevator goes to idle\n    dut._log.info(\"Applying reset during operation\")\n    await reset_dut(dut, 20)\n    assert dut.current_floor.value == 0, \"Elevator did not reset to ground floor\"\n    assert dut.system_status.value == 0, \"Elevator did not return to idle after reset\"\n    dut._log.info(\"Reset applied successfully, elevator returned to idle\")\n\n# Test case 5: Overload handling\nasync def test_case_5(dut):\n    \"\"\"Test case 5: Elevator overload\"\"\"\n\n    # Request a floor\n    await request_floor(dut, 4)\n    await Timer(20, units=\"ns\")\n\n    # Activate overload\n    dut._log.info(\"Activating overload\")\n    dut.overload.value = 1\n\n    await Timer(100, units=\"ns\")\n\n    # Ensure door is open, system is not moving, and overload LED is active\n    assert dut.door_open.value == 1, \"Door should be open during overload\"\n    assert dut.overload_led.value == 1, \"Overload LED should be active during overload\"\n    assert dut.system_status.value != 1 and dut.system_status.value != 2, \"Elevator should not be moving under overload\"\n\n    dut._log.info(\"Overload active: door open and elevator stationary\")\n\n    # Clear overload and wait for elevator to resume\n    dut.overload.value = 0\n    await Timer(50, units=\"ns\")\n    dut._log.info(\"Overload cleared\")\n\n    while dut.current_floor.value != 4:\n        await RisingEdge(dut.clk)\n        await check_direction_leds(dut, \"up\")\n\n    await Timer(30, units=\"ns\")\n    assert dut.door_open.value == 1, \"Door did not open after overload cleared\"\n    dut._log.info(\"Elevator reached requested floor after overload\")\n    await wait_door_close(dut)\n\n    dut._log.info(\"Requesting floor 2 (downward motion)\")\n    await request_floor(dut, 2)\n    await Timer(10, units=\"ns\")\n\n    await Timer(50, units=\"ns\")\n\n    while dut.current_floor.value != 2:\n        await RisingEdge(dut.clk)\n        await check_direction_leds(dut, \"down\")\n\n    await Timer(30, units=\"ns\")\n    assert dut.door_open.value == 1, \"Door did not open at floor 2\"\n    dut._log.info(\"Elevator resumed and reached floor 2 after overload\")\n    await wait_door_close(dut)\n\n\n@cocotb.test()\nasync def test_elevator_control_system(dut):\n    \"\"\"Main test function for elevator control system\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clk, 10, units=\"ns\")  # 100 MHz clock\n    cocotb.start_soon(clock.start())\n\n    # Initialize all signals to known values\n    dut.reset.value = 0\n    dut.call_requests.value = 0\n    dut.emergency_stop.value = 0\n    dut.overload.value = 0\n\n    FLOOR_SIZE = int(FLOOR) - 1\n    print(\"System FLOOR Size: 0 to\", FLOOR_SIZE)\n\n    ## Apply reset\n    await reset_dut(dut, 30)\n\n    ## Run test cases\n    await test_case_1(dut)\n    await Timer(20, units=\"ns\")  # Wait before next test\n\n    await test_case_2(dut)\n    await Timer(20, units=\"ns\")\n\n    ## Apply reset\n    await reset_dut(dut, 30)\n\n    await test_case_3(dut)\n    await Timer(20, units=\"ns\")\n\n    await test_case_4(dut)\n    await Timer(20, units=\"ns\")\n\n    ## Apply reset\n    await reset_dut(dut, 30)\n    await test_case_5(dut)\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport re\nimport logging\n\n# List from Files\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\ndef test_runner(FLOOR: int=8):\n\n    ## Note: To reduce the sim time, design is passed with SIMULATION define to have door open time of 0.05 ms\n    ##Note: Harness if not intended to test for various DOOR OPEN TIME.\n    ##      It only test for multiple floors.\n\n    # Parameterize the test\n    parameter_defines = {\n        \"N\": FLOOR,\n    }\n    print(f\"script: N={FLOOR}\")\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        parameters=parameter_defines,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n        defines={\"SIMULATION\": None}\n\n    )\n\n    plusargs = [f\"+N={FLOOR}\"]\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True, plusargs=plusargs)\n\n\n\n@pytest.mark.parametrize(\"FLOOR\", [8,5,10])\ndef test_elevator_control_system(FLOOR):\n    \"\"\"Parameterized test for elevator control system\"\"\"\n\n    print(f\"Runner script: N={FLOOR}\")\n    test_runner(FLOOR=FLOOR)\n"}}
{"id": "cvdp_agentic_garden_sapphire_amber_0307", "categories": ["cid004", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n    \n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a module named `event_scheduler` in the rtl directory that implements a programmable event scheduler for real-time systems. The original module supports dynamic event addition and cancellation by maintaining arrays of timestamps, priorities, and validity flags for up to 16 events. It increments an internal system time by a fixed step of 10\u202fns each clock cycle and triggers events when their scheduled time is reached. When multiple events are eligible, it selects the one with the highest priority. The module also signals an error if an event is added to an already active slot or if an attempt is made to cancel a non-existent event.\n\nYour task is to modify the existing SystemVerilog code to enhance the functionality of the event scheduler while retaining the original interface ports. The modified module should still be named event_scheduler and remain in the same file (`rtl/event_scheduler.sv`). The specification detailing the architecture of the modified RTL is available in `docs` directory\n\n\n**The modifications must include the following new features**:\n\n## Event Modification/Rescheduling:\n\nAdd a new control input called `modify_event` and two additional inputs: `new_timestamp` and `new_priority.\n\nWhen `modify_event` is asserted, the module should update the timestamp and priority for an existing event (identified by `event_id`), provided that the event is already active.\n\nThe module must assert the error signal if the event is inactive.\n\n## Recurring Events:\n\nIntroduce two new inputs: `recurring_event` (a flag) and `recurring_interval` (a 16-bit value).\n\nIf an event is marked as recurring (i.e. recurring_event is high), then when that event is triggered, its timestamp should be automatically updated by adding the recurring_interval rather than deactivating the event.\n\nThis feature allows the scheduler to support periodic events.\n\n## Event Logging:\n\nAdd two new outputs: `log_event_time` and `log_event_id`.\n\nThese outputs should capture the system time at which an event is triggered and the corresponding event ID.\n\nThe logging must occur in the same cycle as the event trigger.\n\n## Additional requirements:\n\nThe modified module must retain the original interface for `clk`, `reset`, `add_event`, `cancel_event`, `event_id`, `timestamp`, and `priority_in`.\n\nAll additional functionality must be added by introducing extra inputs and outputs without altering the existing ones.\n\nThe design must continue to increment the internal `current_time` by 10\u202fns per cycle and use temporary arrays for atomic updates.\n\nThe error handling should remain intact: the module must assert an error if a duplicate event addition is attempted or if a modification/cancellation is attempted on a non-existent event.\n\nThe selection logic should continue to choose the highest priority event among those that are due, based on the updated time.\n\nThe module should update all temporary state and then commit the changes at the end of the clock cycle to ensure proper synchronization.\n\n## Deliverable :\nYour deliverable is the modified SystemVerilog code in the file `rtl/event_scheduler.sv` that implements these enhancements while maintaining similar timing characteristics and behavior as the original design. \n", "context": {"docs/modified_specs.md": "# Modified Event Scheduler Module Specification\n\nThis module implements a programmable event scheduler for real-time systems with enhanced capabilities. In addition to the original functionality (dynamic event addition and cancellation, time tracking, and priority-based triggering), the modified design supports:\n\n## Event Modification/Rescheduling\n- **Functionality:** Allows an existing event to be updated with a new timestamp and priority.\n- **Operation:** When the `modify_event` control signal is asserted, the scheduler updates the event\u2019s scheduled time and its priority using `new_timestamp` and `new_priority` respectively.\n\n## Recurring Events\n- **Functionality:** Supports periodic events by automatically rescheduling an event when triggered if it is marked as recurring.\n- **Operation:** When an event with the recurring flag is triggered, its timestamp is updated by adding the `recurring_interval`, allowing it to trigger again.\n\n## Event Logging\n- **Functionality:** Provides logging outputs that capture the time and event ID whenever an event is triggered.\n- **Operation:** Each time an event is triggered, the scheduler logs the system time (`log_event_time`) and the event identifier (`log_event_id`) for diagnostic and debugging purposes.\n\n## Parameterization\n- **MAX_EVENTS:** 16  \n  The scheduler supports 16 distinct events, indexed 0 to 15.\n- **TIMESTAMP_WIDTH:** 16 bits  \n  Each event timestamp is 16 bits wide, representing time in nanoseconds.\n- **PRIORITY_WIDTH:** 4 bits  \n  Event priorities are represented with 4 bits, used to resolve conflicts among due events.\n- **TIME_INCREMENT:** 10 ns  \n  The internal system time is incremented by 10 ns every clock cycle.\n\n## Additional Parameters\n- **Recurring Event Flag:**  \n  A binary signal indicating if an event is periodic.\n- **Recurring Interval:**  \n  A 16-bit value that specifies the interval (in ns) after which a recurring event should be rescheduled.\n\n## Interfaces\n\n### Clock and Reset\n- **clk:**  \n  Posedge Clock signal driving synchronous operations.\n- **reset:**  \n  Asynchronous Active-high reset that initializes the system and clears all event-related data.\n\n### Control Signals\n- **add_event:**  \n  When asserted ACTIVE HIGH the addition of a new event.\n- **cancel_event:**  \n  When asserted ACTIVE HIGH , makes the DUT perform cancellation of an existing event.\n- **modify_event:**  \n  When asserted ACTIVE HIGH, instructs the scheduler to modify (reschedule and/or change the priority of) an existing event.\n\n### Event Input Data\n- **event_id (4 bits, [3:0]):**  \n  Identifier for the event (0 to 15). Used for addition, cancellation, and modification.\n- **timestamp (16 bits, [15:0]):**  \n  The scheduled time at which the event should be triggered when added.\n- **priority_in (4 bits, [3:0]):**  \n  The priority for the event when added; higher values indicate higher priority.\n- **new_timestamp (16 bits, [15:0]):**  \n  The updated timestamp for an event when `modify_event` is asserted.\n- **new_priority (4 bits, [3:0]):**  \n  The updated priority for an event when `modify_event` is asserted.\n- **recurring_event (1-bit):**  \n  A flag that, when set ACTIVE HIGH, indicates that the event should automatically reschedule after being triggered.\n- **recurring_interval (16 bits, [15:0]):**  \n  Specifies the interval (in ns) by which to reschedule a recurring event after each trigger.\n\n### Event Output Data\n- **event_triggered (1-bit):**  \n  A one-clock-cycle pulse indicating that an event has been triggered.\n- **triggered_event_id (4 bits, [3:0]):**  \n  The identifier of the event that was triggered.\n- **error (1-bit):**  \n  Signals an error when an invalid operation is attempted (e.g., adding an event to an already active slot, or modifying/canceling a non-existent event).\n- **current_time (16 bits, [15:0]):**  \n  The internal system time, which is incremented by 10 ns every clock cycle.\n- **log_event_time (16 bits, [15:0]):**  \n  Captures the system time at which an event was triggered. Useful for logging and debugging.\n- **log_event_id (4 bits, [3:0]):**  \n  Records the event ID that was triggered at the time logged.\n\n## Detailed Functionality\n\n### 1. Event Storage and Temporary Updates\n- **Primary Storage Arrays:**  \n  - `event_timestamps`: Holds the scheduled time for each event.  \n  - `event_priorities`: Holds the priority value for each event.  \n  - `event_valid`: Flags indicating if an event slot is active.\n- **Recurring Event Storage:**  \n  - `recurring_flags`: Indicates which events are recurring.  \n  - `recurring_intervals`: Holds the rescheduling interval for recurring events.\n- **Temporary Arrays and Atomic Update:**  \n  Temporary copies (e.g., `tmp_event_timestamps`, `tmp_event_priorities`, `tmp_event_valid`, `tmp_recurring_flags`, and `tmp_recurring_intervals`) are used to perform all updates atomically within a clock cycle. The current time is updated to `tmp_current_time = current_time + 10` before evaluating event conditions.\n\n### 2. Time Management\n- **Time Increment:**  \n  On every positive clock edge (outside reset), the module increments `current_time` by 10 ns. The new value is temporarily stored in `tmp_current_time` and then committed at the end of the cycle.\n\n### 3. Event Addition, Modification, and Cancellation\n- **Event Addition:**  \n  When `add_event` is asserted, the scheduler checks if the event slot (`event_id`) is already active:\n  - **Not Active:**  \n    The event\u2019s timestamp and priority are stored, and the slot is marked valid. If the event is recurring, the recurring flag and interval are saved.\n  - **Already Active:**  \n    The `error` output is asserted to indicate a duplicate event addition.\n- **Event Modification:**  \n  When `modify_event` is asserted, the scheduler verifies that the event is active:\n  - **Active:**  \n    It updates the event\u2019s timestamp and priority using `new_timestamp` and `new_priority`. Recurring parameters are also updated.\n  - **Not Active:**  \n    An error is signaled.\n- **Event Cancellation:**  \n  When `cancel_event` is asserted, the scheduler clears the valid flag for the specified event if it exists; otherwise, an error is raised.\n\n### 4. Event Selection, Triggering, and Logging\n- **Event Eligibility:**  \n  The scheduler scans through all event slots (via the temporary arrays) to determine which events are due (i.e., `tmp_event_timestamps[j] <= tmp_current_time`).\n- **Priority-Based Selection:**  \n  Among the eligible events, the one with the highest priority (largest value in `tmp_event_priorities`) is selected as the `chosen_event`.\n- **Triggering:**  \n  If an eligible event is found, the module:\n  - Asserts the one-cycle `event_triggered` pulse.\n  - Sets `triggered_event_id` to the selected event's ID.\n  - Logs the trigger time (`log_event_time`) and event ID (`log_event_id`).\n- **Recurring Events:**  \n  If the event is marked as recurring (via `tmp_recurring_flags`), its timestamp is updated by adding the recurring interval, allowing the event to trigger again later. Otherwise, the event is deactivated (its valid flag is cleared).\n- **No Eligible Event:**  \n  If no event is eligible, `event_triggered` remains low.\n\n### 5. State Commit\n- **Commit Operation:**  \n  At the end of each clock cycle, the temporary state\u2014including current time and all event-related arrays\u2014is written back to the corresponding permanent registers. This ensures that all operations are synchronized.\n\n---\n\n## Testbench Requirements\n\n**File:** `tb_sobel_edge_detection.sv`\n\nThe provided testbench applies 10 test scenarios to fully exercise the design:\n\n1. **Reset Behavior:**  \n   - Applies a reset, then verifies that all internal signals initialize correctly.\n\n2. **Single Pixel Pulse:**  \n   - Drives a single pixel value (`din = 100`) to check basic pipeline activation.\n\n3. **One Line Data Feed (640 Pixels):**  \n   - Simulates a continuous line of pixel data to exercise window formation over an entire row.\n\n4. **Pixel Count Trigger (1920 Pixels):**  \n   - Ensures that the total pixel count reaches the threshold required to trigger the FIFO output and read mode.\n\n5. **Intermittent Pixel Data Feed:**  \n   - Randomly toggles `in_valid` to mimic noncontinuous image data.\n\n6. **Constant Maximum Pixel Data Feed:**  \n   - Provides a stream of 255 to test how the filter responds to maximum input, typically producing a consistent edge output.\n\n7. **FIFO Backpressure Simulation:**  \n   - Forces backpressure by disabling `in_ready`, then re-enables it to observe FIFO behavior.\n\n8. **Extended Random Pixel Data Feed:**  \n   - Feeds a long sequence of randomized pixels to verify robustness over prolonged operation.\n\n9. **FIFO Preload and Monitor:**  \n   - Preloads the FIFO by disabling reads while feeding pixels, then re-enables reads to ensure data is correctly buffered and output.\n\n10. **Sudden Burst of Pixel Data:**  \n    - Subjects the design to a burst of pixel data to test system response under stress conditions.\n\nFor each test scenario, the testbench monitors key signals (`data_ready`, `last_signal`, `out_valid`, `dout`, `interrupt_out`) to validate correct functional behavior across various operating conditions.\n\n---\n\n## Summary\nThe modified event scheduler maintains core functionalities such as dynamic event scheduling and priority-based triggering, while now incorporating enhanced features including event modification/rescheduling, recurring events, and comprehensive event logging. This design ensures a robust, flexible, and fully parameterized solution suitable for real-time systems where precise timing and error handling are critical. Robust error handling mechanisms signal improper operations such as duplicate additions or invalid modifications/cancellations. Overall, the advanced architecture and the detailed testbench requirements together provide a comprehensive framework for verifying correct operation under a wide range of conditions.", "docs/specs.md": "# Event Scheduler Module Description\n\nThis module implements a programmable event scheduler for a real-time system. The scheduler supports up to 16 events, with each event defined by a timestamp and a priority. It continuously tracks an internal system time and triggers events when their scheduled time is reached. When multiple events are eligible, it selects the one with the highest priority. The design supports dynamic addition and cancellation of events, along with error signaling for invalid operations.\n\n---\n\n## Parameterization\n\n- **MAX_EVENTS:** Fixed number of events supported \u2013 16  \n- **TIMESTAMP_WIDTH:** Bit-width of the event timestamp \u2013 16 bits  \n- **PRIORITY_WIDTH:** Bit-width of the event priority \u2013 4 bits  \n- **TIME_INCREMENT:** Increment applied to `current_time` every clock cycle \u2013 10 ns\n\nThese parameters define the fixed storage capacity and timing resolution of the scheduler.\n\n---\n\n## Interfaces\n\n### Clock and Reset\n\n- **clk:** Clock signal for synchronous operations.\n- **reset:** Active-high reset signal that initializes the system and clears all event data.\n\n### Control Signals\n\n- **add_event:** When asserted, instructs the scheduler to add a new event.\n- **cancel_event:** When asserted, instructs the scheduler to cancel an existing event.\n\n### Event Input Data\n\n- **event_id** (4 bits): Identifier for the event (ranging from 0 to 15).\n- **timestamp** (16 bits): The scheduled trigger time (in ns) for the event.\n- **priority_in** (4 bits): Priority of the event; used for resolving conflicts when multiple events are eligible.\n\n### Event Output Data\n\n- **event_triggered:** A one-cycle pulse that indicates an event has been triggered.\n- **triggered_event_id** (4 bits): Identifier of the event that was triggered.\n- **error:** Signals an error when attempting invalid operations (e.g., adding an already active event or cancelling a non-existent event).\n- **current_time** (16 bits): The current system time, which is incremented by 10 ns every clock cycle.\n\n---\n\n## Detailed Functionality\n\n### 1. Event Storage and Temporary State Management\n\n- **Event Arrays:**  \n  The scheduler maintains three main arrays:\n  - `event_timestamps`: Stores the scheduled timestamps for each event.\n  - `event_priorities`: Stores the priority for each event.\n  - `event_valid`: A flag array indicating if a particular event slot is active.\n  \n- **Temporary Arrays:**  \n  To ensure atomic updates within a clock cycle, temporary copies of the event arrays (`tmp_event_timestamps`, `tmp_event_priorities`, and `tmp_event_valid`) are created. A temporary variable, `tmp_current_time`, holds the updated time.\n\n### 2. Time Management\n\n- **Incrementing Time:**  \n  On each clock cycle (outside of reset), `current_time` is incremented by a fixed value (10 ns) and stored in `tmp_current_time`. This updated time is later committed back to `current_time`.\n\n### 3. Event Addition and Cancellation\n\n- **Event Addition:**  \n  When `add_event` is asserted:\n  - The scheduler checks if an event with the given `event_id` is already active.\n  - If the slot is free, the event\u2019s `timestamp` and `priority_in` are stored in the temporary arrays and marked valid.\n  - If the slot is already occupied, the module sets the `error` signal.\n\n- **Event Cancellation:**  \n  When `cancel_event` is asserted:\n  - The scheduler verifies if the event corresponding to `event_id` is active.\n  - If active, the valid flag is cleared in the temporary state.\n  - If not, an error is signaled.\n\n### 4. Event Selection and Triggering\n\n- **Selection Mechanism:**  \n  The module scans through the temporary event arrays to find eligible events\u2014those with a timestamp less than or equal to the updated `tmp_current_time`.  \n  - If multiple eligible events exist, the one with the highest priority is chosen.\n\n- **Triggering:**  \n  If an eligible event is found:\n  - The `event_triggered` signal is asserted for one clock cycle.\n  - The `triggered_event_id` output is set to the chosen event.\n  - The valid flag for that event is cleared in the temporary arrays to prevent it from being triggered again.\n\n### 5. State Commit\n\n- **Commit Process:**  \n  After processing additions, cancellations, and event selection:\n  - The temporary time and event arrays are written back to the main registers (`current_time`, `event_timestamps`, `event_priorities`, and `event_valid`), ensuring that all updates are synchronized at the end of the clock cycle.\n\n---\n\n## Summary\n\n- **Architecture:**  \n  The event scheduler is designed to manage a fixed number of events (16) using dedicated storage arrays for timestamps, priorities, and validity flags. Temporary arrays ensure that operations are performed atomically within each clock cycle.\n\n- **Time and Priority Management:**  \n  The system increments an internal clock (`current_time`) by 10 ns every cycle. It triggers events when the scheduled timestamp is reached, and when multiple events are eligible, it resolves conflicts by selecting the one with the highest priority.\n\n- **Dynamic Handling:**  \n  The scheduler supports dynamic event addition and cancellation. It also provides error signaling for invalid operations, making it robust for real-time scheduling applications.\n\nThis analysis provides a comprehensive overview of the architecture and functionality of the event scheduler module, highlighting its suitability for applications requiring precise and dynamic event management in real-time systems.\n", "rtl/event_scheduler.sv": "module event_scheduler(\n    input clk,\n    input reset,\n    input add_event,\n    input cancel_event,\n    input [3:0] event_id,\n    input [15:0] timestamp,\n    input [3:0] priority_in,\n    output reg event_triggered,\n    output reg [3:0] triggered_event_id,\n    output reg error,\n    output reg [15:0] current_time\n);\n\n    \n    reg [15:0] event_timestamps [15:0];\n    reg [3:0]  event_priorities [15:0];\n    reg        event_valid      [15:0];\n    reg [15:0] tmp_current_time;\n    reg [15:0] tmp_event_timestamps [15:0];\n    reg [3:0]  tmp_event_priorities [15:0];\n    reg        tmp_event_valid [15:0];\n    integer i, j;\n    integer chosen_event;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_time <= 0;\n            event_triggered <= 0;\n            triggered_event_id <= 0;\n            error <= 0;\n            for (i = 0; i < 16; i = i + 1) begin\n                event_timestamps[i] <= 0;\n                event_priorities[i] <= 0;\n                event_valid[i] <= 0;\n            end\n        end else begin\n            tmp_current_time = current_time + 10;\n            for (j = 0; j < 16; j = j + 1) begin\n                tmp_event_timestamps[j] = event_timestamps[j];\n                tmp_event_priorities[j] = event_priorities[j];\n                tmp_event_valid[j] = event_valid[j];\n            end\n\n            if (add_event) begin\n                if (tmp_event_valid[event_id]) begin\n                    error <= 1; \n                end else begin\n                    tmp_event_timestamps[event_id] = timestamp;\n                    tmp_event_priorities[event_id] = priority_in;\n                    tmp_event_valid[event_id] = 1;\n                    error <= 0;\n                end\n            end\n\n            if (cancel_event) begin\n                if (tmp_event_valid[event_id]) begin\n                    tmp_event_valid[event_id] = 0;\n                    error <= 0;\n                end else begin\n                    error <= 1; \n                end\n            end\n\n            chosen_event = -1;\n            for (j = 0; j < 16; j = j + 1) begin\n                if (tmp_event_valid[j] && (tmp_event_timestamps[j] <= tmp_current_time)) begin\n                    if ((chosen_event == -1) || (tmp_event_priorities[j] > tmp_event_priorities[chosen_event])) begin\n                        chosen_event = j;\n                    end\n                end\n            end\n\n            if (chosen_event != -1) begin\n                event_triggered <= 1;\n                triggered_event_id <= chosen_event;\n                tmp_event_valid[chosen_event] = 0;\n            end else begin\n                event_triggered <= 0;\n            end\n\n            current_time <= tmp_current_time;\n            for (j = 0; j < 16; j = j + 1) begin\n                event_timestamps[j] <= tmp_event_timestamps[j];\n                event_priorities[j] <= tmp_event_priorities[j];\n                event_valid[j] <= tmp_event_valid[j];\n            end\n        end\n    end\n\nendmodule", "verif/tb_event_scheduler.sv": "`timescale 1ns/1ps\n\nmodule tb_event_scheduler;\n\n  \n  reg clk;\n  reg reset;\n  reg add_event;\n  reg cancel_event;\n  reg [3:0] event_id;\n  reg [15:0] timestamp;\n  reg [3:0] priority_in;\n  reg modify_event;\n  reg [15:0] new_timestamp;\n  reg [3:0] new_priority;\n  reg recurring_event;\n  reg [15:0] recurring_interval;\n  wire event_triggered;\n  wire [3:0] triggered_event_id;\n  wire error;\n  wire [15:0] current_time;\n  wire [15:0] log_event_time;\n  wire [3:0] log_event_id;\n\n  \n  event_scheduler dut (\n    .clk(clk),\n    .reset(reset),\n    .add_event(add_event),\n    .cancel_event(cancel_event),\n    .event_id(event_id),\n    .timestamp(timestamp),\n    .priority_in(priority_in),\n    .modify_event(modify_event),\n    .new_timestamp(new_timestamp),\n    .new_priority(new_priority),\n    .recurring_event(recurring_event),\n    .recurring_interval(recurring_interval),\n    .event_triggered(event_triggered),\n    .triggered_event_id(triggered_event_id),\n    .error(error),\n    .current_time(current_time),\n    .log_event_time(log_event_time),\n    .log_event_id(log_event_id)\n  );\n\n  \n  initial begin\n    clk = 0;\n    forever #5 clk = ~clk;\n  end\n\n  \n  task clear_signals;\n    begin\n      add_event         = 0;\n      cancel_event      = 0;\n      modify_event      = 0;\n      event_id          = 4'b0;\n      timestamp         = 16'b0;\n      priority_in       = 4'b0;\n      new_timestamp     = 16'b0;\n      new_priority      = 4'b0;\n      recurring_event   = 0;\n      recurring_interval= 16'b0;\n    end\n  endtask\n\n  \n  task do_reset;\n    begin\n      clear_signals;\n      reset = 1;\n      #12;  \n      reset = 0;\n      #10;  \n    end\n  endtask\n\n  \n  task wait_for_trigger;\n    begin\n      wait (event_triggered == 1);\n      #1; \n    end\n  endtask\n\n  \n  initial begin\n    $display(\"Starting Modified Testbench with Correct Sampling...\");\n\n    \n    do_reset();\n    $display(\"\\nTC1: Adding event ID=1 with timestamp=30, priority=2\");\n    clear_signals;\n    event_id    = 4'd1;\n    timestamp   = 16'd30;\n    priority_in = 4'd2;\n    add_event   = 1;\n    #10;\n    clear_signals;\n    wait_for_trigger();\n    $display(\"TC1 Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n             event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n\n    \n    do_reset();\n    $display(\"\\nTC2: Adding event ID=2 then canceling it\");\n    clear_signals;\n    event_id    = 4'd2;\n    timestamp   = 16'd50;\n    priority_in = 4'd3;\n    add_event   = 1;\n    #10;\n    clear_signals;\n    event_id    = 4'd2;\n    cancel_event= 1;\n    #10;\n    clear_signals;\n    repeat (5) #10;\n    $display(\"TC2 Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n             event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n\n    \n    do_reset();\n    $display(\"\\nTC3: Adding event ID=3 then modifying its timestamp and priority\");\n    clear_signals;\n    event_id    = 4'd3;\n    timestamp   = 16'd70;\n    priority_in = 4'd1;\n    add_event   = 1;\n    #10;\n    clear_signals;\n    event_id       = 4'd3;\n    new_timestamp  = 16'd90;\n    new_priority   = 4'd4;\n    modify_event   = 1;\n    #10;\n    clear_signals;\n    wait_for_trigger();\n    $display(\"TC3 Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n             event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n\n    \n    do_reset();\n    $display(\"\\nTC4: Adding event ID=4 twice to generate error\");\n    clear_signals;\n    event_id    = 4'd4;\n    timestamp   = 16'd40;\n    priority_in = 4'd2;\n    add_event   = 1;\n    #10;\n    clear_signals;\n    event_id    = 4'd4;\n    timestamp   = 16'd60;\n    priority_in = 4'd3;\n    add_event   = 1;\n    #10;\n    clear_signals;\n    repeat (3) #10;\n    $display(\"TC4 Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n             event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n\n    \n    do_reset();\n    $display(\"\\nTC5: Attempting to modify non-existent event ID=5 to generate error\");\n    clear_signals;\n    event_id      = 4'd5;\n    new_timestamp = 16'd100;\n    new_priority  = 4'd5;\n    modify_event  = 1;\n    #10;\n    clear_signals;\n    repeat (2) #10;\n    $display(\"TC5 Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n             event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n\n    \n    do_reset();\n    $display(\"\\nTC6: Attempting to cancel non-existent event ID=6 to generate error\");\n    clear_signals;\n    event_id    = 4'd6;\n    cancel_event= 1;\n    #10;\n    clear_signals;\n    repeat (2) #10;\n    $display(\"TC6 Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n             event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n\n    \n    do_reset();\n    $display(\"\\nTC7: Adding recurring event ID=7 with interval=20\");\n    clear_signals;\n    event_id          = 4'd7;\n    timestamp         = 16'd20; \n    priority_in       = 4'd3;\n    recurring_event   = 1;\n    recurring_interval= 16'd20;\n    add_event         = 1;\n    #10;\n    clear_signals;\n    wait_for_trigger(); \n    $display(\"TC7 (First Trigger) Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n             event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n    repeat (2) #10;\n    if (event_triggered == 1) begin\n      $display(\"TC7 (Additional Trigger) Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n               event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n    end\n\n    \n    do_reset();\n    $display(\"\\nTC8: Adding event ID=8 and checking log outputs\");\n    clear_signals;\n    event_id    = 4'd8;\n    timestamp   = current_time + 10;\n    priority_in = 4'd2;\n    add_event   = 1;\n    #10;\n    clear_signals;\n    wait_for_trigger();\n    $display(\"TC8 Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n             event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n\n    \n    do_reset();\n    $display(\"\\nTC9: Adding event ID=9, then modifying and finally canceling it\");\n    clear_signals;\n    event_id    = 4'd9;\n    timestamp   = 16'd150;\n    priority_in = 4'd2;\n    add_event   = 1;\n    #10;\n    clear_signals;\n    event_id       = 4'd9;\n    new_timestamp  = 16'd170;\n    new_priority   = 4'd4;\n    modify_event   = 1;\n    #10;\n    clear_signals;\n    event_id    = 4'd9;\n    cancel_event= 1;\n    #10;\n    clear_signals;\n    repeat (3) #10;\n    $display(\"TC9 Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n             event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n\n    \n    do_reset();\n    $display(\"\\nTC10: Adding events ID=10 and ID=11 concurrently with same timestamp but different priorities\");\n    clear_signals;\n    event_id    = 4'd10;\n    timestamp   = current_time + 20;\n    priority_in = 4'd2;\n    add_event   = 1;\n    #1;  \n    event_id    = 4'd11;\n    timestamp   = current_time + 20;\n    priority_in = 4'd5;\n    add_event   = 1;\n    #10;  \n    clear_signals;\n    wait_for_trigger();\n    $display(\"TC10 Outputs: event_triggered=%0d, triggered_event_id=%0d, error=%0d, current_time=%0d, log_event_time=%0d, log_event_id=%0d\",\n             event_triggered, triggered_event_id, error, current_time, log_event_time, log_event_id);\n\n\n    $display(\"\\nModified Testbench finished.\");\n    $finish;\n  end\n\nendmodule"}, "patch": {"rtl/event_scheduler.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/event_scheduler.sv\nTOPLEVEL        = event_scheduler\nMODULE          = test_event_scheduler\nPYTHONPATH      = /src\nHASH            = 4-event_scheduler_rtl_modification_issue-1\n", "src/test_event_scheduler.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import Timer, RisingEdge\n\n# Start a clock with a 10 ns period.\nasync def start_clock(dut):\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n# Reset the DUT for 2 clock cycles.\nasync def reset_dut(dut):\n    dut.reset.value = 1\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\n# Clear all control signals (only control signals, not internal storage).\nasync def clear_signals(dut):\n    dut.add_event.value = 0\n    dut.cancel_event.value = 0\n    dut.modify_event.value = 0\n    dut.event_id.value = 0\n    dut.timestamp.value = 0\n    dut.priority_in.value = 0\n    dut.new_timestamp.value = 0\n    dut.new_priority.value = 0\n    dut.recurring_event.value = 0\n    dut.recurring_interval.value = 0\n    await RisingEdge(dut.clk)\n\n# Wait until event_triggered becomes high and immediately capture outputs.\nasync def wait_for_trigger(dut, timeout_ns=500):\n    remaining = timeout_ns\n    while remaining > 0:\n        await RisingEdge(dut.clk)\n        if int(dut.event_triggered.value) == 1:\n            return {\n                \"event_triggered\": int(dut.event_triggered.value),\n                \"triggered_event_id\": int(dut.triggered_event_id.value),\n                \"log_event_time\": int(dut.log_event_time.value),\n                \"log_event_id\": int(dut.log_event_id.value),\n                \"current_time\": int(dut.current_time.value)\n            }\n        remaining -= 10\n    raise Exception(\"Timed out waiting for event_triggered signal.\")\n\n###############################################################################\n# Test Case 1: Add a new event and wait for it to trigger.\n@cocotb.test()\nasync def tc1_add_event_and_trigger(dut):\n    \"\"\"TC1: Add event ID=1 with timestamp = current_time+30, priority=2 and wait for trigger.\"\"\"\n    cocotb.log.info(\"TC1: Starting test: add event and trigger\")\n    await start_clock(dut)\n    await reset_dut(dut)\n    await clear_signals(dut)\n    base_time = int(dut.current_time.value)\n\n    dut.event_id.value = 1\n    dut.timestamp.value = base_time + 30\n    dut.priority_in.value = 2\n    dut.add_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.add_event.value = 0\n    await clear_signals(dut)\n    result = await wait_for_trigger(dut)\n    assert result[\"event_triggered\"] == 1, \"Event did not trigger\"\n    assert result[\"triggered_event_id\"] == 1, \"Triggered event id is not 1\"\n    assert int(dut.error.value) == 0, \"Error flag unexpectedly asserted\"\n    cocotb.log.info(f\"TC1: current_time={result['current_time']}, log_event_time={result['log_event_time']}, log_event_id={result['log_event_id']}\")\n\n###############################################################################\n# Test Case 2: Add an event then cancel it so it never triggers.\n@cocotb.test()\nasync def tc2_cancel_event(dut):\n    \"\"\"TC2: Add event ID=2 with timestamp=current_time+50 then cancel it before trigger.\"\"\"\n    cocotb.log.info(\"TC2: Starting test: add event then cancel it\")\n    await start_clock(dut)\n    await reset_dut(dut)\n    await clear_signals(dut)\n    base_time = int(dut.current_time.value)\n\n    dut.event_id.value = 2\n    dut.timestamp.value = base_time + 50\n    dut.priority_in.value = 3\n    dut.add_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.add_event.value = 0\n    await clear_signals(dut)\n\n    # Cancel the event.\n    dut.event_id.value = 2\n    dut.cancel_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.cancel_event.value = 0\n    await clear_signals(dut)\n    for _ in range(5):\n        await RisingEdge(dut.clk)\n    assert int(dut.event_triggered.value) == 0, \"Event unexpectedly triggered after cancel\"\n    cocotb.log.info(f\"TC2: current_time={int(dut.current_time.value)}\")\n\n###############################################################################\n# Test Case 3: Add an event then modify it so that the modified event triggers.\n@cocotb.test()\nasync def tc3_modify_event(dut):\n    \"\"\"TC3: Add event ID=3, then modify it (timestamp=current_time+90, priority=4) and wait for trigger.\"\"\"\n    cocotb.log.info(\"TC3: Starting test: add event then modify it\")\n    await start_clock(dut)\n    await reset_dut(dut)\n    await clear_signals(dut)\n    base_time = int(dut.current_time.value)\n\n    # Add event ID 3.\n    dut.event_id.value = 3\n    dut.timestamp.value = base_time + 70\n    dut.priority_in.value = 1\n    dut.add_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.add_event.value = 0\n    await clear_signals(dut)\n\n    # Modify event ID 3.\n    dut.event_id.value = 3\n    dut.new_timestamp.value = base_time + 90\n    dut.new_priority.value = 4\n    dut.modify_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.modify_event.value = 0\n    await clear_signals(dut)\n    result = await wait_for_trigger(dut)\n    assert result[\"triggered_event_id\"] == 3, \"Modified event did not trigger with event ID 3\"\n    cocotb.log.info(f\"TC3: current_time={result['current_time']}, log_event_time={result['log_event_time']}\")\n\n###############################################################################\n# Test Case 4: Try adding an event twice to generate an error.\n@cocotb.test()\nasync def tc4_duplicate_add(dut):\n    \"\"\"TC4: Add event ID=4 twice; expect error on duplicate addition.\"\"\"\n    cocotb.log.info(\"TC4: Starting test: duplicate add event\")\n    await start_clock(dut)\n    await reset_dut(dut)\n    await clear_signals(dut)\n    base_time = int(dut.current_time.value)\n\n    # First addition.\n    dut.event_id.value = 4\n    dut.timestamp.value = base_time + 40\n    dut.priority_in.value = 2\n    dut.add_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.add_event.value = 0\n    await clear_signals(dut)\n\n    # Duplicate addition.\n    dut.event_id.value = 4\n    dut.timestamp.value = base_time + 60\n    dut.priority_in.value = 3\n    dut.add_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.add_event.value = 0\n    # Wait one extra cycle for error flag to settle.\n    await RisingEdge(dut.clk)\n    await clear_signals(dut)\n    assert int(dut.error.value) == 1, \"Error flag not set on duplicate add\"\n    cocotb.log.info(f\"TC4: current_time={int(dut.current_time.value)}, log_event_time={int(dut.log_event_time.value)}\")\n\n###############################################################################\n# Test Case 5: Attempt to modify a non-existent event.\n@cocotb.test()\nasync def tc5_modify_nonexistent(dut):\n    \"\"\"TC5: Attempt to modify event ID=5 (which hasn't been added); expect error.\"\"\"\n    cocotb.log.info(\"TC5: Starting test: modify non-existent event\")\n    await start_clock(dut)\n    await reset_dut(dut)\n    await clear_signals(dut)\n    dut.event_id.value = 5\n    dut.new_timestamp.value = 100\n    dut.new_priority.value = 5\n    dut.modify_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.modify_event.value = 0\n    await clear_signals(dut)\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    assert int(dut.error.value) == 1, \"Error flag not set when modifying non-existent event\"\n    cocotb.log.info(f\"TC5: current_time={int(dut.current_time.value)}\")\n\n###############################################################################\n# Test Case 6: Attempt to cancel a non-existent event.\n@cocotb.test()\nasync def tc6_cancel_nonexistent(dut):\n    \"\"\"TC6: Attempt to cancel event ID=6 (which hasn't been added); expect error.\"\"\"\n    cocotb.log.info(\"TC6: Starting test: cancel non-existent event\")\n    await start_clock(dut)\n    await reset_dut(dut)\n    await clear_signals(dut)\n    dut.event_id.value = 6\n    dut.cancel_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.cancel_event.value = 0\n    await clear_signals(dut)\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    assert int(dut.error.value) == 1, \"Error flag not set when cancelling non-existent event\"\n    cocotb.log.info(f\"TC6: current_time={int(dut.current_time.value)}\")\n\n###############################################################################\n# Test Case 7: Add a recurring event and observe multiple triggers.\n@cocotb.test()\nasync def tc7_recurring_event(dut):\n    \"\"\"TC7: Add recurring event ID=7 with recurring_interval=20 and verify repeated triggers.\"\"\"\n    cocotb.log.info(\"TC7: Starting test: recurring event\")\n    await start_clock(dut)\n    await reset_dut(dut)\n    await clear_signals(dut)\n    base_time = int(dut.current_time.value)\n\n    dut.event_id.value = 7\n    dut.timestamp.value = base_time + 20\n    dut.priority_in.value = 3\n    dut.recurring_event.value = 1\n    dut.recurring_interval.value = 20\n    dut.add_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.add_event.value = 0\n    await clear_signals(dut)\n\n    result1 = await wait_for_trigger(dut)\n    assert result1[\"triggered_event_id\"] == 7, \"Recurring event did not trigger with event ID 7\"\n    cocotb.log.info(f\"TC7: First trigger at time {result1['log_event_time']}\")\n    result2 = await wait_for_trigger(dut)\n    cocotb.log.info(f\"TC7: Second trigger at time {result2['log_event_time']}\")\n    assert result2[\"log_event_time\"] > result1[\"log_event_time\"], \"Second recurring trigger did not occur\"\n\n###############################################################################\n# Test Case 8: Add an event and verify logging outputs.\n@cocotb.test()\nasync def tc8_logging(dut):\n    \"\"\"TC8: Add event ID=8 and verify log_event_time and log_event_id outputs.\"\"\"\n    cocotb.log.info(\"TC8: Starting test: event logging\")\n    await start_clock(dut)\n    await reset_dut(dut)\n    await clear_signals(dut)\n    base_time = int(dut.current_time.value)\n\n    # Schedule event ID 8 at base_time+30.\n    dut.event_id.value = 8\n    dut.timestamp.value = base_time + 30\n    dut.priority_in.value = 2\n    dut.add_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.add_event.value = 0\n    # Do not clear signals immediately\u2014allow the event to remain in memory.\n    result = await wait_for_trigger(dut)\n    captured_id = result[\"log_event_id\"]\n    assert captured_id == 8, f\"Expected log_event_id 8, got {captured_id}\"\n    cocotb.log.info(f\"TC8: Triggered at time {result['log_event_time']} with event id {captured_id}\")\n\n###############################################################################\n# Test Case 9: Add an event, then modify and cancel it so that no trigger occurs.\n@cocotb.test()\nasync def tc9_modify_then_cancel(dut):\n    \"\"\"TC9: Add event ID=9, then modify and cancel it; expect no trigger.\"\"\"\n    cocotb.log.info(\"TC9: Starting test: modify then cancel event\")\n    await start_clock(dut)\n    await reset_dut(dut)\n    await clear_signals(dut)\n    base_time = int(dut.current_time.value)\n\n    # Add event ID 9.\n    dut.event_id.value = 9\n    dut.timestamp.value = base_time + 150\n    dut.priority_in.value = 2\n    dut.add_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.add_event.value = 0\n    await clear_signals(dut)\n\n    # Modify event ID 9.\n    dut.event_id.value = 9\n    dut.new_timestamp.value = base_time + 170\n    dut.new_priority.value = 4\n    dut.modify_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.modify_event.value = 0\n    await clear_signals(dut)\n\n    # Cancel event ID 9.\n    dut.event_id.value = 9\n    dut.cancel_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.cancel_event.value = 0\n    await clear_signals(dut)\n\n    for _ in range(3):\n        await RisingEdge(dut.clk)\n    assert int(dut.event_triggered.value) == 0, \"Event triggered despite cancellation\"\n    cocotb.log.info(f\"TC9: current_time={int(dut.current_time.value)}\")\n\n###############################################################################\n# Test Case 10: Add two events sequentially (in consecutive cycles) with same timestamp but different priorities.\n@cocotb.test()\nasync def tc10_priority_selection(dut):\n    \"\"\"TC10: Add event ID=10 and then event ID=11 (with same target timestamp) in consecutive cycles; expect event with higher priority (ID 11) to trigger.\"\"\"\n    cocotb.log.info(\"TC10: Starting test: concurrent events with priority selection\")\n    await start_clock(dut)\n    await reset_dut(dut)\n    await clear_signals(dut)\n    base_time = int(dut.current_time.value)\n\n    # Add event ID 10.\n    dut.event_id.value = 10\n    dut.timestamp.value = base_time + 170\n    dut.priority_in.value = 2\n    dut.add_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.add_event.value = 0\n    await clear_signals(dut)\n\n    # Add event ID 11 in the next cycle with the same target timestamp.\n    dut.event_id.value = 11\n    dut.timestamp.value = base_time + 170\n    dut.priority_in.value = 5\n    dut.add_event.value = 1\n    await RisingEdge(dut.clk)\n    dut.add_event.value = 0\n    await clear_signals(dut)\n\n    result = await wait_for_trigger(dut)\n    captured_triggered = result[\"triggered_event_id\"]\n    assert captured_triggered == 11, f\"Expected triggered_event_id 11, got {captured_triggered}\"\n    cocotb.log.info(f\"TC10: Triggered event id {captured_triggered} at time {result['log_event_time']}\")\n\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Fetch environment variables for simulation setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang = os.getenv(\"TOPLEVEL_LANG\", \"verilog\")\nsim = os.getenv(\"SIM\", \"icarus\")\ntoplevel = os.getenv(\"TOPLEVEL\", \"event_scheduler\")\nmodule = os.getenv(\"MODULE\", \"test_event_scheduler\")\nwave = os.getenv(\"WAVE\", \"0\")\n\n# Function to configure and run the simulation\ndef runner():\n    \"\"\"Runs the simulation for the Event Scheduler.\"\"\"\n    # Get the simulation runner\n    simulation_runner = get_runner(sim)\n\n    # Build the simulation environment\n    simulation_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,         # Always rebuild\n        clean=True,          # Clean previous build files\n        waves=True ,   # Enable waveform generation if WAVE=1\n        verbose=True,        # Verbose build and simulation output\n        timescale=(\"1ns\", \"1ns\"),  # Set the timescale for simulation\n        log_file=\"build.log\"      # Log file for the build process\n    )\n\n    # Run the testbench\n    simulation_runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True    # Enable waveform dump if WAVE=1\n    )\n\n# Pytest function to run the simulation\n@pytest.mark.simulation\ndef test_event_scheduler():\n    \"\"\"Pytest function to execute the event scheduler testbench.\"\"\"\n    print(\"Running event scheduler testbench...\")\n    runner()\n\n"}}
{"id": "cvdp_agentic_summit_horizon_diamond_3314", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "The `event_storage` module in rtl directory synchronously stores events from the input `i_event` in a register bank. Each `i_event` input has an equivalent register. If the interface signal `i_en_overflow` is asserted, the register bank may wrap around when it reaches its maximum value, and an event occurs. If not asserted, the data stored in the register bank must be saturated.\n\nThe signals `i_bypass`, `i_data`, `i_raddr` are used to set the `o_data` signal such as:\n- If `i_bypass == 1`, then `o_data = i_data`.\n- If `i_bypass == 0`, then `o_data = reg_bank[i_raddr]`.\n\n**Modify** the module `event_storage` so that it is fully parameterizable. The parameters for this block are:\n\n- `NBW_STR`: Defines the bit width of the input and output data, as well as the bit width of each register in the register bank.\n- `NS_EVT`: Defines the number of parallel events stored by the module.\n- `NBW_EVT`: Defines the bit width of the read address used to select one of the event counters in `reg_bank`.\n\n----------\n\nThe `event_array` module implements a **2D pipeline of event processors** (called `event_storage` units), structured as a grid of **NS_ROWS \u00d7 NS_COLS**. Each processor operates on a stream of input data and associated events, performing updates and passing data to the next row in the same column. **All of the top module connections are fully combinational**. A testbench for it is provided.\n\n**Create** an `event_array` module in the rtl directory, and make sure it is fully parameterizable.\n\n### Specifications\n\n- **Module Name**: `event_array`\n\n- **Parameters**:\n    - `NS_ROWS`: Number of rows in the 2D processing array.\n        - Default value: 4.\n        - Related interface signals: `i_en_overflow`, `i_event`, `i_bypass`.\n    - `NS_COLS`: Number of columns in the 2D processing array.\n        - Default value: 4. Must always be $`2^{NBW\\_COL}`$\n        - Related interface signals: `i_en_overflow`, `i_event`, `i_data`, `i_col_sel`.\n    - `NBW_COL`: Bit width of the column selection signal.\n        - Default value: 2.\n        - Related interface signals: `i_col_sel`.\n    - `NBW_STR`: Bit width of the data processed in each `event_storage`.\n        - Default value: 8.\n        - Related interface signals: `i_data`, `o_data`.\n    - `NS_EVT`: Number of event bits handled by each `event_storage`.\n        - Default value: 8. Must always be $`2^{NBW\\_EVT}`$\n        - Related interface signals: `i_event`.\n    - `NBW_EVT`: Bit width of the read address used for event selection inside each `event_storage`.\n        - Default value: 3.\n        - Related interface signals: `i_raddr`.\n\n### Interface Signals\n\n- **Clock** (`clk`): Synchronizes operation at the rising edge.\n- **Reset** (`rst_async_n`): Active-low asynchronous reset. Resets the internal storage elements.\n- **Column Select** (`[NBW_COL-1:0] i_col_sel`): Selects which column\u2019s output from the last row will be assigned to `o_data`.\n- **Overflow Enable** (`[NS_ROWS*NS_COLS-1:0] i_en_overflow`): One-bit flag per `event_storage`. When high, enables overflow in `event_storage`'s internal registers.\n- **Event Input** (`[(NS_ROWS*NS_COLS*NS_EVT)-1:0] i_event`): All events (flattened) to be applied across the array. Each `event_storage` receives `NS_EVT` bits.\n- **Input Data** (`[(NS_COLS*NBW_STR)-1:0] i_data`): Parallel input data for the **first row only**, one value per column.\n- **Bypass Control** (`[NS_ROWS-1:0] i_bypass`): One bit per row. When high, it bypasses the event logic in that row's `event_storage`.\n- **Read Address** (`[NBW_EVT-1:0] i_raddr`): Address input used to read specific event-mapped data from each `event_storage`.\n- **Output Data** (`[NBW_STR-1:0] o_data`): Output from the selected column in the **last row**.\n\n### Functional Description\n\nThe `event_array` module is structured as a **2D pipeline** of `event_storage` units. Each unit represents a processing cell that performs bit-based updates to its internal data register according to the received `i_event` bits and the `i_en_overflow` flag.\n\nThe array is organized as `NS_ROWS` rows and `NS_COLS` columns.\n\n#### Input Flow:\n- Input data (`i_data`) is injected only into the **first row** of the array.\n- Each subsequent row receives the processed output from the `event_storage` directly above it in the same column.\n- All `event_storage` receive a unique slice of the flattened `i_event` and `i_en_overflow` arrays:\n   - In `event_array`, the `i_event` input is a flat vector that holds all event bits for every cell in the grid, with each `event_storage` requiring `NS_EVT` bits. The module slices this vector by assigning `NS_EVT` bits to each `event_storage` based on its row and column. The slicing starts from the most significant bit and moves left to right across columns, then top to bottom across rows \u2014 like reading a table row by row. This way, each cell gets exactly the bits intended for its position in the array.\n      - For example, if `NS_ROWS = 2`, `NS_COLS = 2`, and `NS_EVT = 4`, then `i_event` is 16 bits wide. The cell at row 0, column 0 gets the top 4 bits `[15:12]`, row 0, column 1 gets `[11:8]`, row 1, column 0 gets `[7:4]`, and row 1, column 1 gets the lowest 4 bits `[3:0]`.\n\n   - The `i_en_overflow` input is a flat bit vector with one bit per `event_storage` in the grid. The vector is sliced using a row-major order: starting from the least significant bit, it maps left to right across columns, then top to bottom across rows.\n      - For example, if `NS_ROWS = 2` and `NS_COLS = 2`, then `i_en_overflow` is 4 bits wide. The cell at row 0, column 0 gets bit `[0]`, row 0, column 1 gets bit `[1]`, row 1, column 0 gets bit `[2]`, and row 1, column 1 gets bit `[3]`.\n\n\n#### Output Logic:\n- After data has propagated through all rows, each column's final output is collected:\n   - A `data_col_sel` signal is constructed by collecting the output data from each column in the last row of the array. For each column, the module takes the `data_out` of the `event_storage` cell at row `NS_ROWS - 1` and column `col`. These outputs are concatenated from **left to right** in **increasing column index order**, meaning **column 0 goes into the most significant bits**, and **column `NS_COLS - 1` goes into the least significant bits**. This signal is then connected to the input of the `column_selector` module.\n      - For example, if `NS_COLS = 4` and `NBW_STR = 8`, then `data_col_sel` is 32 bits wide. The output from column 0 goes into bits `[31:24]`, column 1 into `[23:16]`, column 2 into `[15:8]`, and column 3 into `[7:0]`.\n\n- The `column_selector` submodule then selects one column based on `i_col_sel` to produce the module's final output `o_data`.\n\n", "context": {"rtl/column_selector.sv": "module column_selector #(\n    parameter NBW_STR = 'd8,\n    parameter NBW_COL = 'd2,\n    parameter NS_COLS = 'd4\n) (\n    input  logic [NBW_COL-1:0]           i_col_sel,\n    input  logic [(NBW_STR*NS_COLS)-1:0] i_data,\n    output logic [NBW_STR-1:0]           o_data\n);\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_STR-1:0] data [0:NS_COLS-1];\n\n// ----------------------------------------\n// - Unpack input data\n// ----------------------------------------\ngenerate\n    for(genvar i = 0; i < NS_COLS; i++) begin : unpack_data\n        assign data[i] = i_data[(NBW_STR*NS_COLS)-i*NBW_STR-1-:NBW_STR];\n    end\nendgenerate\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nalways_comb begin : output_assignment\n    o_data = data[i_col_sel];\nend\n\nendmodule : column_selector", "rtl/event_storage.sv": "module event_storage #(\n    parameter NBW_STR = 'd4,\n    parameter NS_EVT  = 'd4,\n    parameter NBW_EVT = 'd2\n) (\n    input  logic       clk,\n    input  logic       rst_async_n,\n    input  logic       i_en_overflow,\n    input  logic [3:0] i_event,\n    input  logic [3:0] i_data,\n    input  logic       i_bypass,\n    input  logic [1:0] i_raddr,\n    output logic [3:0] o_data\n);\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [3:0] reg_bank [0:3];\n\n// ----------------------------------------\n// - Block logic\n// ----------------------------------------\ngenerate\n    for (genvar i = 0; i < 4; i++) begin : instantiate_regs\n        always_ff @ (posedge clk or negedge rst_async_n) begin\n            if(!rst_async_n) begin\n                reg_bank[i] <= 0;\n            end else begin\n                if(i_en_overflow) begin\n                    reg_bank[i] <= reg_bank[i] + i_event[i];\n                end else begin\n                    if(reg_bank[i] == 4'd15) begin\n                        reg_bank[i] <= reg_bank[i];\n                    end else begin\n                        reg_bank[i] <= reg_bank[i] + i_event[i];\n                    end\n                end\n            end\n        end\n    end\nendgenerate\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nalways_comb begin : output_assignment\n    if(i_bypass) begin\n        o_data = i_data;\n    end else begin\n        o_data = reg_bank[i_raddr];\n    end\nend\n\nendmodule : event_storage", "verif/tb.sv": "module tb;\n\nlocalparam NS_ROWS = 'd4;\nlocalparam NS_COLS = 'd4;\nlocalparam NBW_COL = 'd2;\nlocalparam NBW_STR = 'd8;\nlocalparam NS_EVT  = 'd8;\nlocalparam NBW_EVT = 'd3;\n\nlogic                                clk;\nlogic                                rst_async_n;\nlogic [NBW_COL-1:0]                  i_col_sel;\nlogic [NS_ROWS*NS_COLS-1:0]          i_en_overflow;\nlogic [(NS_ROWS*NS_COLS*NS_EVT)-1:0] i_event;\nlogic [(NS_ROWS*NBW_STR)-1:0]        i_data;\nlogic [NS_ROWS-1:0]                  i_bypass;\nlogic [NBW_EVT-1:0]                  i_raddr;\nlogic [NBW_STR-1:0]                  o_data;\n\nevent_array #(\n    .NS_ROWS(NS_ROWS),\n    .NS_COLS(NS_COLS),\n    .NBW_COL(NBW_COL),\n    .NBW_STR(NBW_STR),\n    .NS_EVT(NS_EVT),\n    .NBW_EVT(NBW_EVT)\n) uu_event_array (\n    .clk          (clk          ),\n    .rst_async_n  (rst_async_n  ),\n    .i_col_sel    (i_col_sel    ),\n    .i_en_overflow(i_en_overflow),\n    .i_event      (i_event      ),\n    .i_data       (i_data       ),\n    .i_bypass     (i_bypass     ),\n    .i_raddr      (i_raddr      ),\n    .o_data       (o_data       )\n);\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb);\nend\n\ntask SimpleTest(int line_to_read, int col_to_read, int r_addr);\n    $display(\"---------------\");\n    $display(\"Running test reading row %2d, column %2d, address %2d\", line_to_read, col_to_read, r_addr);\n    @(negedge clk);\n    i_en_overflow = 0;\n    i_bypass = {NS_ROWS{1'b1}};\n    i_bypass[line_to_read] = 1'b0;\n    i_raddr = r_addr;\n    i_col_sel = col_to_read;\n    i_event = 0;\n\n    for(int i = 1; i <= NS_ROWS*NS_COLS*NS_EVT; i++) begin\n        for(int j = 0; j < i; j++) begin\n            i_event[NS_ROWS*NS_COLS*NS_EVT-i] = 1'b1;\n            @(negedge clk);\n        end\n        i_event = 0;\n    end\n\n    @(negedge clk);\n\n    if((NS_EVT - r_addr + line_to_read*NS_COLS*NS_EVT + col_to_read*NS_EVT) > 2**NBW_STR - 1) begin\n        if(o_data != 2**NBW_STR - 1) begin\n            $display(\"FAIL! Received o_data = %2d, when it should have been %2d\", o_data, 2**NBW_STR - 1);\n        end else begin\n            $display(\"PASS! Received o_data = %2d\", o_data);\n        end\n    end else begin\n        if(o_data != (NS_EVT - r_addr + line_to_read*NS_COLS*NS_EVT + col_to_read*NS_EVT)) begin\n            $display(\"FAIL! Received o_data = %d, when it should have been %2d\", o_data, (NS_EVT - r_addr + line_to_read*NS_COLS*NS_EVT + col_to_read*NS_EVT));\n        end else begin\n            $display(\"PASS! Received o_data = %d\", o_data);\n        end\n    end\nendtask\n\ntask Reset();\n    i_col_sel     = 0;\n    i_en_overflow = 0;\n    i_event       = 0;\n    i_data        = 0;\n    i_bypass      = 0;\n    i_raddr       = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\nendtask\n\ntask TestOverflow(logic overflow);\n    $display(\"---------------\");\n    $display(\"Testing overflow in row 0, column 0, address 0\");\n    @(negedge clk);\n    i_en_overflow = overflow;\n    i_bypass = {NS_ROWS{1'b1}};\n    i_bypass[0] = 1'b0;\n    i_raddr = 0;\n    i_col_sel = 0;\n    i_event = 0;\n\n    for(int i = 0; i <= 2**NBW_STR; i++) begin\n        i_event[NS_ROWS*NS_COLS*NS_EVT-NS_EVT] = 1'b1;\n        @(negedge clk);\n    end\n    i_event = 0;\n\n    @(negedge clk);\n\n    if(overflow == 0) begin\n        if(o_data != 2**NBW_STR - 1) begin\n            $display(\"FAIL! Received o_data = %2d, when it should have been %2d\", o_data, 2**NBW_STR - 1);\n        end else begin\n            $display(\"PASS! Received o_data = %2d\", o_data);\n        end\n    end else begin\n        if(o_data != 1) begin\n            $display(\"FAIL! Received o_data = %2d, when it should have been %2d\", o_data, 1);\n        end else begin\n            $display(\"PASS! Received o_data = %2d\", o_data);\n        end\n    end\nendtask\n\nalways #5 clk = ~clk;\n\nint value;\n\ninitial begin\n    clk = 0;\n    value = 1;\n    Reset();\n\n    $display(\"----------------------\");\n    $display(\"This testbench writes:\");\n    for(int row = 0; row < NS_ROWS; row++) begin\n        for(int col = 0; col < NS_COLS; col++) begin\n            for(int addr = NS_EVT-1; addr >= 0; addr--) begin\n                $display(\"%2d in row %2d, col %2d, address %2d\", value, row, col, addr);\n                value++;\n            end\n        end\n    end\n\n    $display(\"----------------------\");\n    $display(\"Note that, if any of those values are bigger than %2d, it will saturate when i_en_overflow = 0, and wrap around when i_en_overflow = 1.\", 2**NBW_STR - 1);\n    $display(\"----------------------\");\n\n    // Tasks go here\n    SimpleTest(0, 0, 0);\n    Reset();\n    SimpleTest(1, 0, 0);\n    Reset();\n    SimpleTest(0, 1, 0);\n    Reset();\n    SimpleTest(0, 0, 1);\n    Reset();\n    SimpleTest(2, 1, 0);\n    Reset();\n    SimpleTest(1, 2, 2);\n    Reset();\n    SimpleTest(1, 2, 7);\n    Reset();\n    TestOverflow(1'b0);\n    Reset();\n    TestOverflow(1'b1);\n    Reset();\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/event_array.sv": "", "rtl/event_storage.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner_event_array.py -s -v -o cache_dir=/rundir/harness/.cache\n\n  storage_sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env_event_storage\n    command     : pytest /src/test_runner_event_storage.py -s -v -o cache_dir=/rundir/harness/.cache\n", "src/.env": "VERILOG_SOURCES = /code/rtl/event_array.sv /code/rtl/column_selector.sv /code/rtl/event_storage.sv \nTOPLEVEL        = event_array\nMODULE          = test_event_array\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 1-modify-event-storage-and-create-event-array\nWAVE            = true", "src/.env_event_storage": "VERILOG_SOURCES = /code/rtl/event_storage.sv\nTOPLEVEL        = event_storage\nMODULE          = test_event_storage\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 1-modify-event-storage-and-create-event-array\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass EventArray:\n    def __init__(self, NS_ROWS=4, NS_COLS=4, NBW_STR=8, NS_EVT=8):\n        self.NS_ROWS = NS_ROWS\n        self.NS_COLS = NS_COLS\n        self.NBW_STR = NBW_STR\n        self.NS_EVT  = NS_EVT\n        self.reset()\n\n    def reset(self):\n        self.reg_bank = [[[0 for _ in range(self.NS_EVT)]\n                          for _ in range(self.NS_COLS)]\n                         for _ in range(self.NS_ROWS)]\n        self.o_data = 0\n\n    def event_update(self, i_event, i_en_overflow):\n        total_bits = self.NS_ROWS * self.NS_COLS * self.NS_EVT\n        bin_event = bin(i_event)[2:].zfill(total_bits)  # MSB-first\n\n        MAX_VAL = (1 << self.NBW_STR) - 1\n\n        byte_index = 0\n        for row in range(self.NS_ROWS):\n            for col in range(self.NS_COLS):\n                # Calculate flat index for this (row, col)\n                flat_index = row * self.NS_COLS + col\n                overflow_en = (i_en_overflow >> (flat_index)) & 1\n\n                for evt in range(self.NS_EVT):\n                    bit_index = byte_index * self.NS_EVT + evt\n                    if bin_event[bit_index] == '1':\n                        current_val = self.reg_bank[row][col][self.NS_EVT - 1 - evt]\n                        if overflow_en:\n                            self.reg_bank[row][col][self.NS_EVT - 1 - evt] = (current_val + 1) & MAX_VAL\n                        else:\n                            if current_val < MAX_VAL:\n                                self.reg_bank[row][col][self.NS_EVT - 1 - evt] += 1\n                byte_index += 1\n\n\n    def read_data(self, bypass, r_addr, col_sel, i_data):\n        # Convert i_data to array of NBW_STR slices (MSB to LSB)\n        array_i_data = []\n        mask = (1 << self.NBW_STR) - 1\n        for i in range(self.NS_COLS):\n            shift = self.NBW_STR * (self.NS_COLS - 1 - i)\n            array_i_data.append((i_data >> shift) & mask)\n\n        selected_row = None\n\n        # Priority decoder tree: walk MSB \u2192 LSB, match original behavior\n        for row in range(self.NS_ROWS):\n            bit = (bypass >> (self.NS_ROWS - 1 - row)) & 1\n            if bit == 0:\n                selected_row = self.NS_ROWS - 1 - row\n                break\n\n        # All bypass bits = 1 \u2192 use i_data\n        if selected_row is None:\n            out_row = array_i_data\n        else:\n            out_row = [self.reg_bank[selected_row][i][r_addr] for i in range(self.NS_COLS)]\n\n        self.o_data = out_row[col_sel]\n", "src/test_event_array.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_data.value.to_unsigned()\n\n    model_data = model.o_data\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\ndef row_to_bypass(row, ns_rows):\n    if row < 0 or row >= ns_rows:\n        raise ValueError(\"Invalid row index\")\n\n    # Full set of 1s: (1 << ns_rows) - 1\n    # Clear the bit at (ns_rows - row - 1)\n    return ((1 << ns_rows) - 1) ^ (1 << (ns_rows - row - 1))\n\n@cocotb.test()\nasync def test_event_array(dut):\n    \"\"\"Test the event_array module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Retrieve parameters from the DUT\n    NS_ROWS = dut.NS_ROWS.value.to_unsigned()\n    NS_COLS = dut.NS_COLS.value.to_unsigned()\n    NBW_STR = dut.NBW_STR.value.to_unsigned()\n    NS_EVT  = dut.NS_EVT.value.to_unsigned()\n\n    model = hrs_lb.EventArray(NS_ROWS, NS_COLS, NBW_STR, NS_EVT)\n\n    resets = 4\n    runs = 2**(NBW_STR+1) # Run it 2 times the 2**NBW_STR so it's very likely that there will be an overflow and no overflow\n\n    event_min = 0\n    event_max = 2**(NS_ROWS*NS_COLS*NS_EVT) - 1\n\n    data_min = 0\n    data_max = 2**(NS_COLS*NBW_STR) - 1\n\n    overflow_min = 0\n    overflow_max = 2**(NS_ROWS*NS_COLS) - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_col_sel.value     = 0\n        dut.i_en_overflow.value = 0\n        dut.i_event.value       = 0\n        dut.i_data.value        = 0\n        dut.i_bypass.value      = 0\n        dut.i_raddr.value       = 0\n        dut.rst_async_n.value   = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        en_overflow = random.randint(overflow_min, overflow_max)\n        for j in range(runs):\n            event = random.randint(event_min, event_max)\n\n            dut.i_en_overflow.value = en_overflow\n            dut.i_event.value       = event\n            model.event_update(event, en_overflow)\n\n            await RisingEdge(dut.clk)\n        \n        dut.i_event.value = 0\n        # Compare all values\n        # First compare the full bypass\n        data = random.randint(data_min, data_max)\n        for col in range(NS_COLS):\n            for addr in range(NS_EVT):\n                bypass = (1 << NS_ROWS) - 1\n                model.read_data(bypass, addr, col, data)\n                dut.i_col_sel.value     = col\n                dut.i_data.value        = data\n                dut.i_bypass.value      = bypass\n                dut.i_raddr.value       = addr\n                await RisingEdge(dut.clk)\n                compare_values(dut, model)\n\n        for col in range(NS_COLS):\n            for row in range(NS_ROWS):\n                for addr in range(NS_EVT):\n                    bypass = row_to_bypass(row, NS_ROWS)\n                    model.read_data(bypass, addr, col, data)\n                    dut.i_col_sel.value     = col\n                    dut.i_data.value        = data\n                    dut.i_bypass.value      = bypass\n                    dut.i_raddr.value       = addr\n                    await RisingEdge(dut.clk)\n                    compare_values(dut, model)\n", "src/test_event_storage.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_data.value.to_unsigned()\n\n    model_data = model.o_data\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\ndef row_to_bypass(row, ns_rows):\n    if row < 0 or row >= ns_rows:\n        raise ValueError(\"Invalid row index\")\n\n    # Full set of 1s: (1 << ns_rows) - 1\n    # Clear the bit at (ns_rows - row - 1)\n    return ((1 << ns_rows) - 1) ^ (1 << (ns_rows - row - 1))\n\n@cocotb.test()\nasync def test_event_storage(dut):\n    \"\"\"Test the event_storage module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Retrieve parameters from the DUT\n    NS_ROWS = 1\n    NS_COLS = 1\n    NBW_STR = dut.NBW_STR.value.to_unsigned()\n    NS_EVT  = dut.NS_EVT.value.to_unsigned()\n\n    model = hrs_lb.EventArray(NS_ROWS, NS_COLS, NBW_STR, NS_EVT)\n\n    resets = 4\n    runs = 2**(NBW_STR+1) # Run it 2 times the 2**NBW_STR so it's very likely that there will be an overflow and no overflow\n\n    event_min = 0\n    event_max = 2**(NS_ROWS*NS_COLS*NS_EVT) - 1\n\n    data_min = 0\n    data_max = 2**(NS_COLS*NBW_STR) - 1\n\n    overflow_min = 0\n    overflow_max = 2**(NS_ROWS*NS_COLS) - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_en_overflow.value = 0\n        dut.i_event.value       = 0\n        dut.i_data.value        = 0\n        dut.i_bypass.value      = 0\n        dut.i_raddr.value       = 0\n        dut.rst_async_n.value   = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        en_overflow = random.randint(overflow_min, overflow_max)\n        for j in range(runs):\n            event = random.randint(event_min, event_max)\n\n            dut.i_en_overflow.value = en_overflow\n            dut.i_event.value       = event\n            model.event_update(event, en_overflow)\n\n            await RisingEdge(dut.clk)\n        \n        dut.i_event.value = 0\n        # Compare all values\n        # First compare the full bypass\n        data = random.randint(data_min, data_max)\n        for col in range(NS_COLS):\n            for addr in range(NS_EVT):\n                bypass = (1 << NS_ROWS) - 1\n                model.read_data(bypass, addr, col, data)\n                dut.i_data.value        = data\n                dut.i_bypass.value      = bypass\n                dut.i_raddr.value       = addr\n                await RisingEdge(dut.clk)\n                compare_values(dut, model)\n\n        for col in range(NS_COLS):\n            for row in range(NS_ROWS):\n                for addr in range(NS_EVT):\n                    bypass = row_to_bypass(row, NS_ROWS)\n                    model.read_data(bypass, addr, col, data)\n                    dut.i_data.value        = data\n                    dut.i_bypass.value      = bypass\n                    dut.i_raddr.value       = addr\n                    await RisingEdge(dut.clk)\n                    compare_values(dut, model)\n", "src/test_runner_event_array.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(NS_ROWS: int = 4, NS_COLS: int = 4, NBW_COL: int = 2, NBW_STR: int = 8, NS_EVT: int = 8, NBW_EVT: int = 3):\n\n    parameter = {\n        \"NS_ROWS\": NS_ROWS,\n        \"NS_COLS\": NS_COLS,\n        \"NBW_COL\": NBW_COL,\n        \"NBW_STR\": NBW_STR,\n        \"NS_EVT\": NS_EVT,\n        \"NBW_EVT\": NBW_EVT\n    }\n\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Generate minimum and more random sizes\nrandom_nbw_rows = [2] + [random.randint(3, 4) for _ in range(1)]\nrandom_nbw_cols = [2] + [random.randint(3, 4) for _ in range(1)]\nrandom_nbw_str  = [4] + [random.randint(5, 8) for _ in range(1)]\nrandom_nbw_evt  = [2] + [random.randint(3, 4) for _ in range(1)]\n\n@pytest.mark.parametrize(\"NBW_ROWS\", random_nbw_rows)\n@pytest.mark.parametrize(\"NBW_COLS\", random_nbw_cols)\n@pytest.mark.parametrize(\"NBW_STR\", random_nbw_str)\n@pytest.mark.parametrize(\"NBW_EVT\", random_nbw_evt)\ndef test_data(NBW_ROWS, NBW_COLS, NBW_STR, NBW_EVT):\n    NS_COLS = 2**NBW_COLS\n    NS_ROWS = 2**NBW_ROWS\n    NS_EVT  = 2**NBW_EVT\n    # Run the simulation with specified parameters\n    runner(NS_ROWS=NS_ROWS, NS_COLS=NS_COLS, NBW_COL=NBW_COLS, NBW_STR=NBW_STR, NS_EVT=NS_EVT, NBW_EVT=NBW_EVT)", "src/test_runner_event_storage.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(NBW_STR: int = 8, NS_EVT: int = 8, NBW_EVT: int = 3):\n\n    parameter = {\n        \"NBW_STR\": NBW_STR,\n        \"NS_EVT\": NS_EVT,\n        \"NBW_EVT\": NBW_EVT\n    }\n\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Generate minimum and more random sizes\nrandom_nbw_str  = [4] + [random.randint(5, 8) for _ in range(1)]\nrandom_nbw_evt  = [2] + [random.randint(3, 5) for _ in range(1)]\n\n@pytest.mark.parametrize(\"NBW_STR\", random_nbw_str)\n@pytest.mark.parametrize(\"NBW_EVT\", random_nbw_evt)\ndef test_data(NBW_STR, NBW_EVT):\n    NS_EVT  = 2**NBW_EVT\n    # Run the simulation with specified parameters\n    runner(NBW_STR=NBW_STR, NS_EVT=NS_EVT, NBW_EVT=NBW_EVT)"}}
{"id": "cvdp_agentic_horizon_whisper_panther_1434", "categories": ["cid004", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "The original `phase_lut` module has `i_data_i` and `i_data_q` as inputs (each 6 bits wide) and `o_phase` as a 9-bit output. The output is generated based on the inputs, which are used to access an internal lookup table (LUT). For each pair of input values, the module produces an output using a `case` statement that covers all possible input combinations.\n\nThe **phase_lut** module must be updated with the following interface and internal behavior:\n\n---\n\n### Interface Modifications\n\n- Add **2 input ports**:\n\n  - A **clock input** for sequential logic: `clk`.\n  - An **asynchronous active-low reset input**: `rst_async_n`.\n\n- Add **2 new parameters**:\n  - A parameter to define the number of **integer bits** in the input data (fixed value: `1`): `NBI_IN`.\n  - A parameter to define the number of **integer bits** in the output phase (fixed value: `1`): `NBI_PHASE`.\n\n- The existing parameters are fixed as:\n  - Input width (`NBW_IN`): `6` bits.\n  - Output width (`NBW_PHASE`): `9` bits.\n\n---\n\n### Derived Configuration (fixed values)\n\n- The number of **fractional bits** in the inputs is `5`.\n- The number of **fractional bits** in the output is `8`.\n\n- The LUT will only store phase values corresponding to the **first quadrant** of the trigonometric circle.\n\n- The LUT must have **1089 entries**, each representing a **normalized approximation of the arctangent function** between two positive fixed-point values.\n\n- This number of entries is derived from all possible combinations of two 5-bit unsigned fractional values (representing the absolute values of the inputs), computed as:\n\n  ```\n  LUT_SIZE = 2^(2 \u00d7 NBF_IN) + 2 \u00d7 (2^NBF_IN) + 1\n           = 2^10 + 2 \u00d7 2^5 + 1\n           = 1024 + 64 + 1\n           = 1089 entries\n  ```\n\n- These terms correspond to:\n  - All combinations of I and Q: `2^10 = 1024`\n  - Horizontal and vertical axis cases: `2 \u00d7 2^5 = 64`\n  - One special case for zero input: `1`\n\n---\n\n### Combinational Logic\n\n- Determine the **sign** of each input component.\n- Compute the **absolute values** of both input components to map the vector into the first quadrant.\n- Use a mathematical expression to generate a normalized index from the absolute values. This index must represent all combinations of two unsigned fixed-point numbers with `5` fractional bits each.\n- Use this index to access a lookup table that contains **only the first-quadrant phase values**.\n- With the signs previously captured, determine the **actual quadrant** of the original vector.\n- Based on the quadrant, apply a **mathematical adjustment** to the LUT output:\n  - If both components are **positive**, use the LUT value **directly**.\n  - If the first component is **positive** and the second is **negative**, output the **negative** of the LUT value.\n  - If the first component is **negative** and the second is **positive**, output the **difference between a full-scale constant and the LUT value**.\n  - If both components are **negative**, output the **LUT value minus the full-scale constant**.\n\n---\n\n### Sequential Logic\n\n- Register the calculated LUT index.\n- Register the sign of each input component.\n- On the rising edge of the clock, store these values to be used in the phase adjustment logic.\n- On asynchronous reset (active low), all stored values must be cleared to `0`.\n\n---\n\n### LUT Construction\n\n- The LUT must store precomputed values of the **arctangent function**, using only positive unsigned values for both input components.\n- Each entry must be **normalized** to match the output format defined by the module parameters.\n- The LUT can be generated using a fixed-point representation of the angle between two fractional inputs in the first quadrant.\n- By using trigonometric symmetry, the LUT size is significantly reduced, and the output is reconstructed accurately across all four quadrants using simple transformations.\n\nUnable to extract datapoint. Appear to have an binary file as part of the context/solution.\n", "context": {"rtl/phase_lut.sv": "module phase_lut #(\n   parameter NBW_IN    = 6,\n   parameter NBW_PHASE = 9\n)\n(\n   input logic signed [NBW_IN-1:0]     i_data_i,\n   input logic signed [NBW_IN-1:0]     i_data_q,\n   output logic signed [NBW_PHASE-1:0] o_phase\n);\n\nlocalparam LUT_IDX = 2*NBW_IN;\nlogic [LUT_IDX-1:0] lut_index;\n\nassign lut_index = {$unsigned(i_data_i),$unsigned(i_data_q)};\n\nalways_comb begin\n\tcase(lut_index)\n\t0: o_phase = +9'd0;\t //LUT[0] \tphase : 0.000000\t(data_i, data_q): (0.000000,0.000000)\n\t1: o_phase = +9'd128;\t //LUT[1] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.031250)\n\t2: o_phase = +9'd128;\t //LUT[2] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.062500)\n\t3: o_phase = +9'd128;\t //LUT[3] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.093750)\n\t4: o_phase = +9'd128;\t //LUT[4] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.125000)\n\t5: o_phase = +9'd128;\t //LUT[5] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.156250)\n\t6: o_phase = +9'd128;\t //LUT[6] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.187500)\n\t7: o_phase = +9'd128;\t //LUT[7] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.218750)\n\t8: o_phase = +9'd128;\t //LUT[8] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.250000)\n\t9: o_phase = +9'd128;\t //LUT[9] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.281250)\n\t10: o_phase = +9'd128;\t //LUT[10] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.312500)\n\t11: o_phase = +9'd128;\t //LUT[11] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.343750)\n\t12: o_phase = +9'd128;\t //LUT[12] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.375000)\n\t13: o_phase = +9'd128;\t //LUT[13] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.406250)\n\t14: o_phase = +9'd128;\t //LUT[14] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.437500)\n\t15: o_phase = +9'd128;\t //LUT[15] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.468750)\n\t16: o_phase = +9'd128;\t //LUT[16] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.500000)\n\t17: o_phase = +9'd128;\t //LUT[17] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.531250)\n\t18: o_phase = +9'd128;\t //LUT[18] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.562500)\n\t19: o_phase = +9'd128;\t //LUT[19] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.593750)\n\t20: o_phase = +9'd128;\t //LUT[20] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.625000)\n\t21: o_phase = +9'd128;\t //LUT[21] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.656250)\n\t22: o_phase = +9'd128;\t //LUT[22] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.687500)\n\t23: o_phase = +9'd128;\t //LUT[23] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.718750)\n\t24: o_phase = +9'd128;\t //LUT[24] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.750000)\n\t25: o_phase = +9'd128;\t //LUT[25] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.781250)\n\t26: o_phase = +9'd128;\t //LUT[26] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.812500)\n\t27: o_phase = +9'd128;\t //LUT[27] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.843750)\n\t28: o_phase = +9'd128;\t //LUT[28] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.875000)\n\t29: o_phase = +9'd128;\t //LUT[29] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.906250)\n\t30: o_phase = +9'd128;\t //LUT[30] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.937500)\n\t31: o_phase = +9'd128;\t //LUT[31] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.968750)\n\t32: o_phase = -9'd128;\t //LUT[32] \tphase : -0.500000\t(data_i, data_q): (0.000000,-1.000000)\n\t33: o_phase = -9'd128;\t //LUT[33] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.968750)\n\t34: o_phase = -9'd128;\t //LUT[34] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.937500)\n\t35: o_phase = -9'd128;\t //LUT[35] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.906250)\n\t36: o_phase = -9'd128;\t //LUT[36] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.875000)\n\t37: o_phase = -9'd128;\t //LUT[37] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.843750)\n\t38: o_phase = -9'd128;\t //LUT[38] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.812500)\n\t39: o_phase = -9'd128;\t //LUT[39] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.781250)\n\t40: o_phase = -9'd128;\t //LUT[40] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.750000)\n\t41: o_phase = -9'd128;\t //LUT[41] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.718750)\n\t42: o_phase = -9'd128;\t //LUT[42] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.687500)\n\t43: o_phase = -9'd128;\t //LUT[43] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.656250)\n\t44: o_phase = -9'd128;\t //LUT[44] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.625000)\n\t45: o_phase = -9'd128;\t //LUT[45] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.593750)\n\t46: o_phase = -9'd128;\t //LUT[46] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.562500)\n\t47: o_phase = -9'd128;\t //LUT[47] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.531250)\n\t48: o_phase = -9'd128;\t //LUT[48] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.500000)\n\t49: o_phase = -9'd128;\t //LUT[49] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.468750)\n\t50: o_phase = -9'd128;\t //LUT[50] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.437500)\n\t51: o_phase = -9'd128;\t //LUT[51] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.406250)\n\t52: o_phase = -9'd128;\t //LUT[52] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.375000)\n\t53: o_phase = -9'd128;\t //LUT[53] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.343750)\n\t54: o_phase = -9'd128;\t //LUT[54] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.312500)\n\t55: o_phase = -9'd128;\t //LUT[55] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.281250)\n\t56: o_phase = -9'd128;\t //LUT[56] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.250000)\n\t57: o_phase = -9'd128;\t //LUT[57] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.218750)\n\t58: o_phase = -9'd128;\t //LUT[58] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.187500)\n\t59: o_phase = -9'd128;\t //LUT[59] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.156250)\n\t60: o_phase = -9'd128;\t //LUT[60] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.125000)\n\t61: o_phase = -9'd128;\t //LUT[61] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.093750)\n\t62: o_phase = -9'd128;\t //LUT[62] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.062500)\n\t63: o_phase = -9'd128;\t //LUT[63] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.031250)\n\t64: o_phase = +9'd0;\t //LUT[64] \tphase : 0.000000\t(data_i, data_q): (0.031250,0.000000)\n\t65: o_phase = +9'd64;\t //LUT[65] \tphase : 0.250000\t(data_i, data_q): (0.031250,0.031250)\n\t66: o_phase = +9'd90;\t //LUT[66] \tphase : 0.351562\t(data_i, data_q): (0.031250,0.062500)\n\t67: o_phase = +9'd102;\t //LUT[67] \tphase : 0.398438\t(data_i, data_q): (0.031250,0.093750)\n\t68: o_phase = +9'd108;\t //LUT[68] \tphase : 0.421875\t(data_i, data_q): (0.031250,0.125000)\n\t69: o_phase = +9'd112;\t //LUT[69] \tphase : 0.437500\t(data_i, data_q): (0.031250,0.156250)\n\t70: o_phase = +9'd115;\t //LUT[70] \tphase : 0.449219\t(data_i, data_q): (0.031250,0.187500)\n\t71: o_phase = +9'd116;\t //LUT[71] \tphase : 0.453125\t(data_i, data_q): (0.031250,0.218750)\n\t72: o_phase = +9'd118;\t //LUT[72] \tphase : 0.460938\t(data_i, data_q): (0.031250,0.250000)\n\t73: o_phase = +9'd119;\t //LUT[73] \tphase : 0.464844\t(data_i, data_q): (0.031250,0.281250)\n\t74: o_phase = +9'd120;\t //LUT[74] \tphase : 0.468750\t(data_i, data_q): (0.031250,0.312500)\n\t75: o_phase = +9'd121;\t //LUT[75] \tphase : 0.472656\t(data_i, data_q): (0.031250,0.343750)\n\t76: o_phase = +9'd121;\t //LUT[76] \tphase : 0.472656\t(data_i, data_q): (0.031250,0.375000)\n\t77: o_phase = +9'd122;\t //LUT[77] \tphase : 0.476562\t(data_i, data_q): (0.031250,0.406250)\n\t78: o_phase = +9'd122;\t //LUT[78] \tphase : 0.476562\t(data_i, data_q): (0.031250,0.437500)\n\t79: o_phase = +9'd123;\t //LUT[79] \tphase : 0.480469\t(data_i, data_q): (0.031250,0.468750)\n\t80: o_phase = +9'd123;\t //LUT[80] \tphase : 0.480469\t(data_i, data_q): (0.031250,0.500000)\n\t81: o_phase = +9'd123;\t //LUT[81] \tphase : 0.480469\t(data_i, data_q): (0.031250,0.531250)\n\t82: o_phase = +9'd123;\t //LUT[82] \tphase : 0.480469\t(data_i, data_q): (0.031250,0.562500)\n\t83: o_phase = +9'd124;\t //LUT[83] \tphase : 0.484375\t(data_i, data_q): (0.031250,0.593750)\n\t84: o_phase = +9'd124;\t //LUT[84] \tphase : 0.484375\t(data_i, data_q): (0.031250,0.625000)\n\t85: o_phase = +9'd124;\t //LUT[85] \tphase : 0.484375\t(data_i, data_q): (0.031250,0.656250)\n\t86: o_phase = +9'd124;\t //LUT[86] \tphase : 0.484375\t(data_i, data_q): (0.031250,0.687500)\n\t87: o_phase = +9'd124;\t //LUT[87] \tphase : 0.484375\t(data_i, data_q): (0.031250,0.718750)\n\t88: o_phase = +9'd125;\t //LUT[88] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.750000)\n\t89: o_phase = +9'd125;\t //LUT[89] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.781250)\n\t90: o_phase = +9'd125;\t //LUT[90] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.812500)\n\t91: o_phase = +9'd125;\t //LUT[91] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.843750)\n\t92: o_phase = +9'd125;\t //LUT[92] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.875000)\n\t93: o_phase = +9'd125;\t //LUT[93] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.906250)\n\t94: o_phase = +9'd125;\t //LUT[94] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.937500)\n\t95: o_phase = +9'd125;\t //LUT[95] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.968750)\n\t96: o_phase = -9'd125;\t //LUT[96] \tphase : -0.488281\t(data_i, data_q): (0.031250,-1.000000)\n\t97: o_phase = -9'd125;\t //LUT[97] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.968750)\n\t98: o_phase = -9'd125;\t //LUT[98] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.937500)\n\t99: o_phase = -9'd125;\t //LUT[99] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.906250)\n\t100: o_phase = -9'd125;\t //LUT[100] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.875000)\n\t101: o_phase = -9'd125;\t //LUT[101] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.843750)\n\t102: o_phase = -9'd125;\t //LUT[102] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.812500)\n\t103: o_phase = -9'd125;\t //LUT[103] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.781250)\n\t104: o_phase = -9'd125;\t //LUT[104] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.750000)\n\t105: o_phase = -9'd124;\t //LUT[105] \tphase : -0.484375\t(data_i, data_q): (0.031250,-0.718750)\n\t106: o_phase = -9'd124;\t //LUT[106] \tphase : -0.484375\t(data_i, data_q): (0.031250,-0.687500)\n\t107: o_phase = -9'd124;\t //LUT[107] \tphase : -0.484375\t(data_i, data_q): (0.031250,-0.656250)\n\t108: o_phase = -9'd124;\t //LUT[108] \tphase : -0.484375\t(data_i, data_q): (0.031250,-0.625000)\n\t109: o_phase = -9'd124;\t //LUT[109] \tphase : -0.484375\t(data_i, data_q): (0.031250,-0.593750)\n\t110: o_phase = -9'd123;\t //LUT[110] \tphase : -0.480469\t(data_i, data_q): (0.031250,-0.562500)\n\t111: o_phase = -9'd123;\t //LUT[111] \tphase : -0.480469\t(data_i, data_q): (0.031250,-0.531250)\n\t112: o_phase = -9'd123;\t //LUT[112] \tphase : -0.480469\t(data_i, data_q): (0.031250,-0.500000)\n\t113: o_phase = -9'd123;\t //LUT[113] \tphase : -0.480469\t(data_i, data_q): (0.031250,-0.468750)\n\t114: o_phase = -9'd122;\t //LUT[114] \tphase : -0.476562\t(data_i, data_q): (0.031250,-0.437500)\n\t115: o_phase = -9'd122;\t //LUT[115] \tphase : -0.476562\t(data_i, data_q): (0.031250,-0.406250)\n\t116: o_phase = -9'd121;\t //LUT[116] \tphase : -0.472656\t(data_i, data_q): (0.031250,-0.375000)\n\t117: o_phase = -9'd121;\t //LUT[117] \tphase : -0.472656\t(data_i, data_q): (0.031250,-0.343750)\n\t118: o_phase = -9'd120;\t //LUT[118] \tphase : -0.468750\t(data_i, data_q): (0.031250,-0.312500)\n\t119: o_phase = -9'd119;\t //LUT[119] \tphase : -0.464844\t(data_i, data_q): (0.031250,-0.281250)\n\t120: o_phase = -9'd118;\t //LUT[120] \tphase : -0.460938\t(data_i, data_q): (0.031250,-0.250000)\n\t121: o_phase = -9'd116;\t //LUT[121] \tphase : -0.453125\t(data_i, data_q): (0.031250,-0.218750)\n\t122: o_phase = -9'd115;\t //LUT[122] \tphase : -0.449219\t(data_i, data_q): (0.031250,-0.187500)\n\t123: o_phase = -9'd112;\t //LUT[123] \tphase : -0.437500\t(data_i, data_q): (0.031250,-0.156250)\n\t124: o_phase = -9'd108;\t //LUT[124] \tphase : -0.421875\t(data_i, data_q): (0.031250,-0.125000)\n\t125: o_phase = -9'd102;\t //LUT[125] \tphase : -0.398438\t(data_i, data_q): (0.031250,-0.093750)\n\t126: o_phase = -9'd90;\t //LUT[126] \tphase : -0.351562\t(data_i, data_q): (0.031250,-0.062500)\n\t127: o_phase = -9'd64;\t //LUT[127] \tphase : -0.250000\t(data_i, data_q): (0.031250,-0.031250)\n\t128: o_phase = +9'd0;\t //LUT[128] \tphase : 0.000000\t(data_i, data_q): (0.062500,0.000000)\n\t129: o_phase = +9'd38;\t //LUT[129] \tphase : 0.148438\t(data_i, data_q): (0.062500,0.031250)\n\t130: o_phase = +9'd64;\t //LUT[130] \tphase : 0.250000\t(data_i, data_q): (0.062500,0.062500)\n\t131: o_phase = +9'd80;\t //LUT[131] \tphase : 0.312500\t(data_i, data_q): (0.062500,0.093750)\n\t132: o_phase = +9'd90;\t //LUT[132] \tphase : 0.351562\t(data_i, data_q): (0.062500,0.125000)\n\t133: o_phase = +9'd97;\t //LUT[133] \tphase : 0.378906\t(data_i, data_q): (0.062500,0.156250)\n\t134: o_phase = +9'd102;\t //LUT[134] \tphase : 0.398438\t(data_i, data_q): (0.062500,0.187500)\n\t135: o_phase = +9'd105;\t //LUT[135] \tphase : 0.410156\t(data_i, data_q): (0.062500,0.218750)\n\t136: o_phase = +9'd108;\t //LUT[136] \tphase : 0.421875\t(data_i, data_q): (0.062500,0.250000)\n\t137: o_phase = +9'd110;\t //LUT[137] \tphase : 0.429688\t(data_i, data_q): (0.062500,0.281250)\n\t138: o_phase = +9'd112;\t //LUT[138] \tphase : 0.437500\t(data_i, data_q): (0.062500,0.312500)\n\t139: o_phase = +9'd113;\t //LUT[139] \tphase : 0.441406\t(data_i, data_q): (0.062500,0.343750)\n\t140: o_phase = +9'd115;\t //LUT[140] \tphase : 0.449219\t(data_i, data_q): (0.062500,0.375000)\n\t141: o_phase = +9'd116;\t //LUT[141] \tphase : 0.453125\t(data_i, data_q): (0.062500,0.406250)\n\t142: o_phase = +9'd116;\t //LUT[142] \tphase : 0.453125\t(data_i, data_q): (0.062500,0.437500)\n\t143: o_phase = +9'd117;\t //LUT[143] \tphase : 0.457031\t(data_i, data_q): (0.062500,0.468750)\n\t144: o_phase = +9'd118;\t //LUT[144] \tphase : 0.460938\t(data_i, data_q): (0.062500,0.500000)\n\t145: o_phase = +9'd118;\t //LUT[145] \tphase : 0.460938\t(data_i, data_q): (0.062500,0.531250)\n\t146: o_phase = +9'd119;\t //LUT[146] \tphase : 0.464844\t(data_i, data_q): (0.062500,0.562500)\n\t147: o_phase = +9'd119;\t //LUT[147] \tphase : 0.464844\t(data_i, data_q): (0.062500,0.593750)\n\t148: o_phase = +9'd120;\t //LUT[148] \tphase : 0.468750\t(data_i, data_q): (0.062500,0.625000)\n\t149: o_phase = +9'd120;\t //LUT[149] \tphase : 0.468750\t(data_i, data_q): (0.062500,0.656250)\n\t150: o_phase = +9'd121;\t //LUT[150] \tphase : 0.472656\t(data_i, data_q): (0.062500,0.687500)\n\t151: o_phase = +9'd121;\t //LUT[151] \tphase : 0.472656\t(data_i, data_q): (0.062500,0.718750)\n\t152: o_phase = +9'd121;\t //LUT[152] \tphase : 0.472656\t(data_i, data_q): (0.062500,0.750000)\n\t153: o_phase = +9'd121;\t //LUT[153] \tphase : 0.472656\t(data_i, data_q): (0.062500,0.781250)\n\t154: o_phase = +9'd122;\t //LUT[154] \tphase : 0.476562\t(data_i, data_q): (0.062500,0.812500)\n\t155: o_phase = +9'd122;\t //LUT[155] \tphase : 0.476562\t(data_i, data_q): (0.062500,0.843750)\n\t156: o_phase = +9'd122;\t //LUT[156] \tphase : 0.476562\t(data_i, data_q): (0.062500,0.875000)\n\t157: o_phase = +9'd122;\t //LUT[157] \tphase : 0.476562\t(data_i, data_q): (0.062500,0.906250)\n\t158: o_phase = +9'd123;\t //LUT[158] \tphase : 0.480469\t(data_i, data_q): (0.062500,0.937500)\n\t159: o_phase = +9'd123;\t //LUT[159] \tphase : 0.480469\t(data_i, data_q): (0.062500,0.968750)\n\t160: o_phase = -9'd123;\t //LUT[160] \tphase : -0.480469\t(data_i, data_q): (0.062500,-1.000000)\n\t161: o_phase = -9'd123;\t //LUT[161] \tphase : -0.480469\t(data_i, data_q): (0.062500,-0.968750)\n\t162: o_phase = -9'd123;\t //LUT[162] \tphase : -0.480469\t(data_i, data_q): (0.062500,-0.937500)\n\t163: o_phase = -9'd122;\t //LUT[163] \tphase : -0.476562\t(data_i, data_q): (0.062500,-0.906250)\n\t164: o_phase = -9'd122;\t //LUT[164] \tphase : -0.476562\t(data_i, data_q): (0.062500,-0.875000)\n\t165: o_phase = -9'd122;\t //LUT[165] \tphase : -0.476562\t(data_i, data_q): (0.062500,-0.843750)\n\t166: o_phase = -9'd122;\t //LUT[166] \tphase : -0.476562\t(data_i, data_q): (0.062500,-0.812500)\n\t167: o_phase = -9'd121;\t //LUT[167] \tphase : -0.472656\t(data_i, data_q): (0.062500,-0.781250)\n\t168: o_phase = -9'd121;\t //LUT[168] \tphase : -0.472656\t(data_i, data_q): (0.062500,-0.750000)\n\t169: o_phase = -9'd121;\t //LUT[169] \tphase : -0.472656\t(data_i, data_q): (0.062500,-0.718750)\n\t170: o_phase = -9'd121;\t //LUT[170] \tphase : -0.472656\t(data_i, data_q): (0.062500,-0.687500)\n\t171: o_phase = -9'd120;\t //LUT[171] \tphase : -0.468750\t(data_i, data_q): (0.062500,-0.656250)\n\t172: o_phase = -9'd120;\t //LUT[172] \tphase : -0.468750\t(data_i, data_q): (0.062500,-0.625000)\n\t173: o_phase = -9'd119;\t //LUT[173] \tphase : -0.464844\t(data_i, data_q): (0.062500,-0.593750)\n\t174: o_phase = -9'd119;\t //LUT[174] \tphase : -0.464844\t(data_i, data_q): (0.062500,-0.562500)\n\t175: o_phase = -9'd118;\t //LUT[175] \tphase : -0.460938\t(data_i, data_q): (0.062500,-0.531250)\n\t176: o_phase = -9'd118;\t //LUT[176] \tphase : -0.460938\t(data_i, data_q): (0.062500,-0.500000)\n\t177: o_phase = -9'd117;\t //LUT[177] \tphase : -0.457031\t(data_i, data_q): (0.062500,-0.468750)\n\t178: o_phase = -9'd116;\t //LUT[178] \tphase : -0.453125\t(data_i, data_q): (0.062500,-0.437500)\n\t179: o_phase = -9'd116;\t //LUT[179] \tphase : -0.453125\t(data_i, data_q): (0.062500,-0.406250)\n\t180: o_phase = -9'd115;\t //LUT[180] \tphase : -0.449219\t(data_i, data_q): (0.062500,-0.375000)\n\t181: o_phase = -9'd113;\t //LUT[181] \tphase : -0.441406\t(data_i, data_q): (0.062500,-0.343750)\n\t182: o_phase = -9'd112;\t //LUT[182] \tphase : -0.437500\t(data_i, data_q): (0.062500,-0.312500)\n\t183: o_phase = -9'd110;\t //LUT[183] \tphase : -0.429688\t(data_i, data_q): (0.062500,-0.281250)\n\t184: o_phase = -9'd108;\t //LUT[184] \tphase : -0.421875\t(data_i, data_q): (0.062500,-0.250000)\n\t185: o_phase = -9'd105;\t //LUT[185] \tphase : -0.410156\t(data_i, data_q): (0.062500,-0.218750)\n\t186: o_phase = -9'd102;\t //LUT[186] \tphase : -0.398438\t(data_i, data_q): (0.062500,-0.187500)\n\t187: o_phase = -9'd97;\t //LUT[187] \tphase : -0.378906\t(data_i, data_q): (0.062500,-0.156250)\n\t188: o_phase = -9'd90;\t //LUT[188] \tphase : -0.351562\t(data_i, data_q): (0.062500,-0.125000)\n\t189: o_phase = -9'd80;\t //LUT[189] \tphase : -0.312500\t(data_i, data_q): (0.062500,-0.093750)\n\t190: o_phase = -9'd64;\t //LUT[190] \tphase : -0.250000\t(data_i, data_q): (0.062500,-0.062500)\n\t191: o_phase = -9'd38;\t //LUT[191] \tphase : -0.148438\t(data_i, data_q): (0.062500,-0.031250)\n\t192: o_phase = +9'd0;\t //LUT[192] \tphase : 0.000000\t(data_i, data_q): (0.093750,0.000000)\n\t193: o_phase = +9'd26;\t //LUT[193] \tphase : 0.101562\t(data_i, data_q): (0.093750,0.031250)\n\t194: o_phase = +9'd48;\t //LUT[194] \tphase : 0.187500\t(data_i, data_q): (0.093750,0.062500)\n\t195: o_phase = +9'd64;\t //LUT[195] \tphase : 0.250000\t(data_i, data_q): (0.093750,0.093750)\n\t196: o_phase = +9'd76;\t //LUT[196] \tphase : 0.296875\t(data_i, data_q): (0.093750,0.125000)\n\t197: o_phase = +9'd84;\t //LUT[197] \tphase : 0.328125\t(data_i, data_q): (0.093750,0.156250)\n\t198: o_phase = +9'd90;\t //LUT[198] \tphase : 0.351562\t(data_i, data_q): (0.093750,0.187500)\n\t199: o_phase = +9'd95;\t //LUT[199] \tphase : 0.371094\t(data_i, data_q): (0.093750,0.218750)\n\t200: o_phase = +9'd99;\t //LUT[200] \tphase : 0.386719\t(data_i, data_q): (0.093750,0.250000)\n\t201: o_phase = +9'd102;\t //LUT[201] \tphase : 0.398438\t(data_i, data_q): (0.093750,0.281250)\n\t202: o_phase = +9'd104;\t //LUT[202] \tphase : 0.406250\t(data_i, data_q): (0.093750,0.312500)\n\t203: o_phase = +9'd106;\t //LUT[203] \tphase : 0.414062\t(data_i, data_q): (0.093750,0.343750)\n\t204: o_phase = +9'd108;\t //LUT[204] \tphase : 0.421875\t(data_i, data_q): (0.093750,0.375000)\n\t205: o_phase = +9'd110;\t //LUT[205] \tphase : 0.429688\t(data_i, data_q): (0.093750,0.406250)\n\t206: o_phase = +9'd111;\t //LUT[206] \tphase : 0.433594\t(data_i, data_q): (0.093750,0.437500)\n\t207: o_phase = +9'd112;\t //LUT[207] \tphase : 0.437500\t(data_i, data_q): (0.093750,0.468750)\n\t208: o_phase = +9'd113;\t //LUT[208] \tphase : 0.441406\t(data_i, data_q): (0.093750,0.500000)\n\t209: o_phase = +9'd114;\t //LUT[209] \tphase : 0.445312\t(data_i, data_q): (0.093750,0.531250)\n\t210: o_phase = +9'd115;\t //LUT[210] \tphase : 0.449219\t(data_i, data_q): (0.093750,0.562500)\n\t211: o_phase = +9'd115;\t //LUT[211] \tphase : 0.449219\t(data_i, data_q): (0.093750,0.593750)\n\t212: o_phase = +9'd116;\t //LUT[212] \tphase : 0.453125\t(data_i, data_q): (0.093750,0.625000)\n\t213: o_phase = +9'd116;\t //LUT[213] \tphase : 0.453125\t(data_i, data_q): (0.093750,0.656250)\n\t214: o_phase = +9'd117;\t //LUT[214] \tphase : 0.457031\t(data_i, data_q): (0.093750,0.687500)\n\t215: o_phase = +9'd117;\t //LUT[215] \tphase : 0.457031\t(data_i, data_q): (0.093750,0.718750)\n\t216: o_phase = +9'd118;\t //LUT[216] \tphase : 0.460938\t(data_i, data_q): (0.093750,0.750000)\n\t217: o_phase = +9'd118;\t //LUT[217] \tphase : 0.460938\t(data_i, data_q): (0.093750,0.781250)\n\t218: o_phase = +9'd119;\t //LUT[218] \tphase : 0.464844\t(data_i, data_q): (0.093750,0.812500)\n\t219: o_phase = +9'd119;\t //LUT[219] \tphase : 0.464844\t(data_i, data_q): (0.093750,0.843750)\n\t220: o_phase = +9'd119;\t //LUT[220] \tphase : 0.464844\t(data_i, data_q): (0.093750,0.875000)\n\t221: o_phase = +9'd120;\t //LUT[221] \tphase : 0.468750\t(data_i, data_q): (0.093750,0.906250)\n\t222: o_phase = +9'd120;\t //LUT[222] \tphase : 0.468750\t(data_i, data_q): (0.093750,0.937500)\n\t223: o_phase = +9'd120;\t //LUT[223] \tphase : 0.468750\t(data_i, data_q): (0.093750,0.968750)\n\t224: o_phase = -9'd120;\t //LUT[224] \tphase : -0.468750\t(data_i, data_q): (0.093750,-1.000000)\n\t225: o_phase = -9'd120;\t //LUT[225] \tphase : -0.468750\t(data_i, data_q): (0.093750,-0.968750)\n\t226: o_phase = -9'd120;\t //LUT[226] \tphase : -0.468750\t(data_i, data_q): (0.093750,-0.937500)\n\t227: o_phase = -9'd120;\t //LUT[227] \tphase : -0.468750\t(data_i, data_q): (0.093750,-0.906250)\n\t228: o_phase = -9'd119;\t //LUT[228] \tphase : -0.464844\t(data_i, data_q): (0.093750,-0.875000)\n\t229: o_phase = -9'd119;\t //LUT[229] \tphase : -0.464844\t(data_i, data_q): (0.093750,-0.843750)\n\t230: o_phase = -9'd119;\t //LUT[230] \tphase : -0.464844\t(data_i, data_q): (0.093750,-0.812500)\n\t231: o_phase = -9'd118;\t //LUT[231] \tphase : -0.460938\t(data_i, data_q): (0.093750,-0.781250)\n\t232: o_phase = -9'd118;\t //LUT[232] \tphase : -0.460938\t(data_i, data_q): (0.093750,-0.750000)\n\t233: o_phase = -9'd117;\t //LUT[233] \tphase : -0.457031\t(data_i, data_q): (0.093750,-0.718750)\n\t234: o_phase = -9'd117;\t //LUT[234] \tphase : -0.457031\t(data_i, data_q): (0.093750,-0.687500)\n\t235: o_phase = -9'd116;\t //LUT[235] \tphase : -0.453125\t(data_i, data_q): (0.093750,-0.656250)\n\t236: o_phase = -9'd116;\t //LUT[236] \tphase : -0.453125\t(data_i, data_q): (0.093750,-0.625000)\n\t237: o_phase = -9'd115;\t //LUT[237] \tphase : -0.449219\t(data_i, data_q): (0.093750,-0.593750)\n\t238: o_phase = -9'd115;\t //LUT[238] \tphase : -0.449219\t(data_i, data_q): (0.093750,-0.562500)\n\t239: o_phase = -9'd114;\t //LUT[239] \tphase : -0.445312\t(data_i, data_q): (0.093750,-0.531250)\n\t240: o_phase = -9'd113;\t //LUT[240] \tphase : -0.441406\t(data_i, data_q): (0.093750,-0.500000)\n\t241: o_phase = -9'd112;\t //LUT[241] \tphase : -0.437500\t(data_i, data_q): (0.093750,-0.468750)\n\t242: o_phase = -9'd111;\t //LUT[242] \tphase : -0.433594\t(data_i, data_q): (0.093750,-0.437500)\n\t243: o_phase = -9'd110;\t //LUT[243] \tphase : -0.429688\t(data_i, data_q): (0.093750,-0.406250)\n\t244: o_phase = -9'd108;\t //LUT[244] \tphase : -0.421875\t(data_i, data_q): (0.093750,-0.375000)\n\t245: o_phase = -9'd106;\t //LUT[245] \tphase : -0.414062\t(data_i, data_q): (0.093750,-0.343750)\n\t246: o_phase = -9'd104;\t //LUT[246] \tphase : -0.406250\t(data_i, data_q): (0.093750,-0.312500)\n\t247: o_phase = -9'd102;\t //LUT[247] \tphase : -0.398438\t(data_i, data_q): (0.093750,-0.281250)\n\t248: o_phase = -9'd99;\t //LUT[248] \tphase : -0.386719\t(data_i, data_q): (0.093750,-0.250000)\n\t249: o_phase = -9'd95;\t //LUT[249] \tphase : -0.371094\t(data_i, data_q): (0.093750,-0.218750)\n\t250: o_phase = -9'd90;\t //LUT[250] \tphase : -0.351562\t(data_i, data_q): (0.093750,-0.187500)\n\t251: o_phase = -9'd84;\t //LUT[251] \tphase : -0.328125\t(data_i, data_q): (0.093750,-0.156250)\n\t252: o_phase = -9'd76;\t //LUT[252] \tphase : -0.296875\t(data_i, data_q): (0.093750,-0.125000)\n\t253: o_phase = -9'd64;\t //LUT[253] \tphase : -0.250000\t(data_i, data_q): (0.093750,-0.093750)\n\t254: o_phase = -9'd48;\t //LUT[254] \tphase : -0.187500\t(data_i, data_q): (0.093750,-0.062500)\n\t255: o_phase = -9'd26;\t //LUT[255] \tphase : -0.101562\t(data_i, data_q): (0.093750,-0.031250)\n\t256: o_phase = +9'd0;\t //LUT[256] \tphase : 0.000000\t(data_i, data_q): (0.125000,0.000000)\n\t257: o_phase = +9'd20;\t //LUT[257] \tphase : 0.078125\t(data_i, data_q): (0.125000,0.031250)\n\t258: o_phase = +9'd38;\t //LUT[258] \tphase : 0.148438\t(data_i, data_q): (0.125000,0.062500)\n\t259: o_phase = +9'd52;\t //LUT[259] \tphase : 0.203125\t(data_i, data_q): (0.125000,0.093750)\n\t260: o_phase = +9'd64;\t //LUT[260] \tphase : 0.250000\t(data_i, data_q): (0.125000,0.125000)\n\t261: o_phase = +9'd73;\t //LUT[261] \tphase : 0.285156\t(data_i, data_q): (0.125000,0.156250)\n\t262: o_phase = +9'd80;\t //LUT[262] \tphase : 0.312500\t(data_i, data_q): (0.125000,0.187500)\n\t263: o_phase = +9'd86;\t //LUT[263] \tphase : 0.335938\t(data_i, data_q): (0.125000,0.218750)\n\t264: o_phase = +9'd90;\t //LUT[264] \tphase : 0.351562\t(data_i, data_q): (0.125000,0.250000)\n\t265: o_phase = +9'd94;\t //LUT[265] \tphase : 0.367188\t(data_i, data_q): (0.125000,0.281250)\n\t266: o_phase = +9'd97;\t //LUT[266] \tphase : 0.378906\t(data_i, data_q): (0.125000,0.312500)\n\t267: o_phase = +9'd100;\t //LUT[267] \tphase : 0.390625\t(data_i, data_q): (0.125000,0.343750)\n\t268: o_phase = +9'd102;\t //LUT[268] \tphase : 0.398438\t(data_i, data_q): (0.125000,0.375000)\n\t269: o_phase = +9'd104;\t //LUT[269] \tphase : 0.406250\t(data_i, data_q): (0.125000,0.406250)\n\t270: o_phase = +9'd105;\t //LUT[270] \tphase : 0.410156\t(data_i, data_q): (0.125000,0.437500)\n\t271: o_phase = +9'd107;\t //LUT[271] \tphase : 0.417969\t(data_i, data_q): (0.125000,0.468750)\n\t272: o_phase = +9'd108;\t //LUT[272] \tphase : 0.421875\t(data_i, data_q): (0.125000,0.500000)\n\t273: o_phase = +9'd109;\t //LUT[273] \tphase : 0.425781\t(data_i, data_q): (0.125000,0.531250)\n\t274: o_phase = +9'd110;\t //LUT[274] \tphase : 0.429688\t(data_i, data_q): (0.125000,0.562500)\n\t275: o_phase = +9'd111;\t //LUT[275] \tphase : 0.433594\t(data_i, data_q): (0.125000,0.593750)\n\t276: o_phase = +9'd112;\t //LUT[276] \tphase : 0.437500\t(data_i, data_q): (0.125000,0.625000)\n\t277: o_phase = +9'd113;\t //LUT[277] \tphase : 0.441406\t(data_i, data_q): (0.125000,0.656250)\n\t278: o_phase = +9'd113;\t //LUT[278] \tphase : 0.441406\t(data_i, data_q): (0.125000,0.687500)\n\t279: o_phase = +9'd114;\t //LUT[279] \tphase : 0.445312\t(data_i, data_q): (0.125000,0.718750)\n\t280: o_phase = +9'd115;\t //LUT[280] \tphase : 0.449219\t(data_i, data_q): (0.125000,0.750000)\n\t281: o_phase = +9'd115;\t //LUT[281] \tphase : 0.449219\t(data_i, data_q): (0.125000,0.781250)\n\t282: o_phase = +9'd116;\t //LUT[282] \tphase : 0.453125\t(data_i, data_q): (0.125000,0.812500)\n\t283: o_phase = +9'd116;\t //LUT[283] \tphase : 0.453125\t(data_i, data_q): (0.125000,0.843750)\n\t284: o_phase = +9'd116;\t //LUT[284] \tphase : 0.453125\t(data_i, data_q): (0.125000,0.875000)\n\t285: o_phase = +9'd117;\t //LUT[285] \tphase : 0.457031\t(data_i, data_q): (0.125000,0.906250)\n\t286: o_phase = +9'd117;\t //LUT[286] \tphase : 0.457031\t(data_i, data_q): (0.125000,0.937500)\n\t287: o_phase = +9'd118;\t //LUT[287] \tphase : 0.460938\t(data_i, data_q): (0.125000,0.968750)\n\t288: o_phase = -9'd118;\t //LUT[288] \tphase : -0.460938\t(data_i, data_q): (0.125000,-1.000000)\n\t289: o_phase = -9'd118;\t //LUT[289] \tphase : -0.460938\t(data_i, data_q): (0.125000,-0.968750)\n\t290: o_phase = -9'd117;\t //LUT[290] \tphase : -0.457031\t(data_i, data_q): (0.125000,-0.937500)\n\t291: o_phase = -9'd117;\t //LUT[291] \tphase : -0.457031\t(data_i, data_q): (0.125000,-0.906250)\n\t292: o_phase = -9'd116;\t //LUT[292] \tphase : -0.453125\t(data_i, data_q): (0.125000,-0.875000)\n\t293: o_phase = -9'd116;\t //LUT[293] \tphase : -0.453125\t(data_i, data_q): (0.125000,-0.843750)\n\t294: o_phase = -9'd116;\t //LUT[294] \tphase : -0.453125\t(data_i, data_q): (0.125000,-0.812500)\n\t295: o_phase = -9'd115;\t //LUT[295] \tphase : -0.449219\t(data_i, data_q): (0.125000,-0.781250)\n\t296: o_phase = -9'd115;\t //LUT[296] \tphase : -0.449219\t(data_i, data_q): (0.125000,-0.750000)\n\t297: o_phase = -9'd114;\t //LUT[297] \tphase : -0.445312\t(data_i, data_q): (0.125000,-0.718750)\n\t298: o_phase = -9'd113;\t //LUT[298] \tphase : -0.441406\t(data_i, data_q): (0.125000,-0.687500)\n\t299: o_phase = -9'd113;\t //LUT[299] \tphase : -0.441406\t(data_i, data_q): (0.125000,-0.656250)\n\t300: o_phase = -9'd112;\t //LUT[300] \tphase : -0.437500\t(data_i, data_q): (0.125000,-0.625000)\n\t301: o_phase = -9'd111;\t //LUT[301] \tphase : -0.433594\t(data_i, data_q): (0.125000,-0.593750)\n\t302: o_phase = -9'd110;\t //LUT[302] \tphase : -0.429688\t(data_i, data_q): (0.125000,-0.562500)\n\t303: o_phase = -9'd109;\t //LUT[303] \tphase : -0.425781\t(data_i, data_q): (0.125000,-0.531250)\n\t304: o_phase = -9'd108;\t //LUT[304] \tphase : -0.421875\t(data_i, data_q): (0.125000,-0.500000)\n\t305: o_phase = -9'd107;\t //LUT[305] \tphase : -0.417969\t(data_i, data_q): (0.125000,-0.468750)\n\t306: o_phase = -9'd105;\t //LUT[306] \tphase : -0.410156\t(data_i, data_q): (0.125000,-0.437500)\n\t307: o_phase = -9'd104;\t //LUT[307] \tphase : -0.406250\t(data_i, data_q): (0.125000,-0.406250)\n\t308: o_phase = -9'd102;\t //LUT[308] \tphase : -0.398438\t(data_i, data_q): (0.125000,-0.375000)\n\t309: o_phase = -9'd100;\t //LUT[309] \tphase : -0.390625\t(data_i, data_q): (0.125000,-0.343750)\n\t310: o_phase = -9'd97;\t //LUT[310] \tphase : -0.378906\t(data_i, data_q): (0.125000,-0.312500)\n\t311: o_phase = -9'd94;\t //LUT[311] \tphase : -0.367188\t(data_i, data_q): (0.125000,-0.281250)\n\t312: o_phase = -9'd90;\t //LUT[312] \tphase : -0.351562\t(data_i, data_q): (0.125000,-0.250000)\n\t313: o_phase = -9'd86;\t //LUT[313] \tphase : -0.335938\t(data_i, data_q): (0.125000,-0.218750)\n\t314: o_phase = -9'd80;\t //LUT[314] \tphase : -0.312500\t(data_i, data_q): (0.125000,-0.187500)\n\t315: o_phase = -9'd73;\t //LUT[315] \tphase : -0.285156\t(data_i, data_q): (0.125000,-0.156250)\n\t316: o_phase = -9'd64;\t //LUT[316] \tphase : -0.250000\t(data_i, data_q): (0.125000,-0.125000)\n\t317: o_phase = -9'd52;\t //LUT[317] \tphase : -0.203125\t(data_i, data_q): (0.125000,-0.093750)\n\t318: o_phase = -9'd38;\t //LUT[318] \tphase : -0.148438\t(data_i, data_q): (0.125000,-0.062500)\n\t319: o_phase = -9'd20;\t //LUT[319] \tphase : -0.078125\t(data_i, data_q): (0.125000,-0.031250)\n\t320: o_phase = +9'd0;\t //LUT[320] \tphase : 0.000000\t(data_i, data_q): (0.156250,0.000000)\n\t321: o_phase = +9'd16;\t //LUT[321] \tphase : 0.062500\t(data_i, data_q): (0.156250,0.031250)\n\t322: o_phase = +9'd31;\t //LUT[322] \tphase : 0.121094\t(data_i, data_q): (0.156250,0.062500)\n\t323: o_phase = +9'd44;\t //LUT[323] \tphase : 0.171875\t(data_i, data_q): (0.156250,0.093750)\n\t324: o_phase = +9'd55;\t //LUT[324] \tphase : 0.214844\t(data_i, data_q): (0.156250,0.125000)\n\t325: o_phase = +9'd64;\t //LUT[325] \tphase : 0.250000\t(data_i, data_q): (0.156250,0.156250)\n\t326: o_phase = +9'd71;\t //LUT[326] \tphase : 0.277344\t(data_i, data_q): (0.156250,0.187500)\n\t327: o_phase = +9'd77;\t //LUT[327] \tphase : 0.300781\t(data_i, data_q): (0.156250,0.218750)\n\t328: o_phase = +9'd82;\t //LUT[328] \tphase : 0.320312\t(data_i, data_q): (0.156250,0.250000)\n\t329: o_phase = +9'd87;\t //LUT[329] \tphase : 0.339844\t(data_i, data_q): (0.156250,0.281250)\n\t330: o_phase = +9'd90;\t //LUT[330] \tphase : 0.351562\t(data_i, data_q): (0.156250,0.312500)\n\t331: o_phase = +9'd93;\t //LUT[331] \tphase : 0.363281\t(data_i, data_q): (0.156250,0.343750)\n\t332: o_phase = +9'd96;\t //LUT[332] \tphase : 0.375000\t(data_i, data_q): (0.156250,0.375000)\n\t333: o_phase = +9'd98;\t //LUT[333] \tphase : 0.382812\t(data_i, data_q): (0.156250,0.406250)\n\t334: o_phase = +9'd100;\t //LUT[334] \tphase : 0.390625\t(data_i, data_q): (0.156250,0.437500)\n\t335: o_phase = +9'd102;\t //LUT[335] \tphase : 0.398438\t(data_i, data_q): (0.156250,0.468750)\n\t336: o_phase = +9'd103;\t //LUT[336] \tphase : 0.402344\t(data_i, data_q): (0.156250,0.500000)\n\t337: o_phase = +9'd105;\t //LUT[337] \tphase : 0.410156\t(data_i, data_q): (0.156250,0.531250)\n\t338: o_phase = +9'd106;\t //LUT[338] \tphase : 0.414062\t(data_i, data_q): (0.156250,0.562500)\n\t339: o_phase = +9'd107;\t //LUT[339] \tphase : 0.417969\t(data_i, data_q): (0.156250,0.593750)\n\t340: o_phase = +9'd108;\t //LUT[340] \tphase : 0.421875\t(data_i, data_q): (0.156250,0.625000)\n\t341: o_phase = +9'd109;\t //LUT[341] \tphase : 0.425781\t(data_i, data_q): (0.156250,0.656250)\n\t342: o_phase = +9'd110;\t //LUT[342] \tphase : 0.429688\t(data_i, data_q): (0.156250,0.687500)\n\t343: o_phase = +9'd111;\t //LUT[343] \tphase : 0.433594\t(data_i, data_q): (0.156250,0.718750)\n\t344: o_phase = +9'd111;\t //LUT[344] \tphase : 0.433594\t(data_i, data_q): (0.156250,0.750000)\n\t345: o_phase = +9'd112;\t //LUT[345] \tphase : 0.437500\t(data_i, data_q): (0.156250,0.781250)\n\t346: o_phase = +9'd113;\t //LUT[346] \tphase : 0.441406\t(data_i, data_q): (0.156250,0.812500)\n\t347: o_phase = +9'd113;\t //LUT[347] \tphase : 0.441406\t(data_i, data_q): (0.156250,0.843750)\n\t348: o_phase = +9'd114;\t //LUT[348] \tphase : 0.445312\t(data_i, data_q): (0.156250,0.875000)\n\t349: o_phase = +9'd114;\t //LUT[349] \tphase : 0.445312\t(data_i, data_q): (0.156250,0.906250)\n\t350: o_phase = +9'd115;\t //LUT[350] \tphase : 0.449219\t(data_i, data_q): (0.156250,0.937500)\n\t351: o_phase = +9'd115;\t //LUT[351] \tphase : 0.449219\t(data_i, data_q): (0.156250,0.968750)\n\t352: o_phase = -9'd115;\t //LUT[352] \tphase : -0.449219\t(data_i, data_q): (0.156250,-1.000000)\n\t353: o_phase = -9'd115;\t //LUT[353] \tphase : -0.449219\t(data_i, data_q): (0.156250,-0.968750)\n\t354: o_phase = -9'd115;\t //LUT[354] \tphase : -0.449219\t(data_i, data_q): (0.156250,-0.937500)\n\t355: o_phase = -9'd114;\t //LUT[355] \tphase : -0.445312\t(data_i, data_q): (0.156250,-0.906250)\n\t356: o_phase = -9'd114;\t //LUT[356] \tphase : -0.445312\t(data_i, data_q): (0.156250,-0.875000)\n\t357: o_phase = -9'd113;\t //LUT[357] \tphase : -0.441406\t(data_i, data_q): (0.156250,-0.843750)\n\t358: o_phase = -9'd113;\t //LUT[358] \tphase : -0.441406\t(data_i, data_q): (0.156250,-0.812500)\n\t359: o_phase = -9'd112;\t //LUT[359] \tphase : -0.437500\t(data_i, data_q): (0.156250,-0.781250)\n\t360: o_phase = -9'd111;\t //LUT[360] \tphase : -0.433594\t(data_i, data_q): (0.156250,-0.750000)\n\t361: o_phase = -9'd111;\t //LUT[361] \tphase : -0.433594\t(data_i, data_q): (0.156250,-0.718750)\n\t362: o_phase = -9'd110;\t //LUT[362] \tphase : -0.429688\t(data_i, data_q): (0.156250,-0.687500)\n\t363: o_phase = -9'd109;\t //LUT[363] \tphase : -0.425781\t(data_i, data_q): (0.156250,-0.656250)\n\t364: o_phase = -9'd108;\t //LUT[364] \tphase : -0.421875\t(data_i, data_q): (0.156250,-0.625000)\n\t365: o_phase = -9'd107;\t //LUT[365] \tphase : -0.417969\t(data_i, data_q): (0.156250,-0.593750)\n\t366: o_phase = -9'd106;\t //LUT[366] \tphase : -0.414062\t(data_i, data_q): (0.156250,-0.562500)\n\t367: o_phase = -9'd105;\t //LUT[367] \tphase : -0.410156\t(data_i, data_q): (0.156250,-0.531250)\n\t368: o_phase = -9'd103;\t //LUT[368] \tphase : -0.402344\t(data_i, data_q): (0.156250,-0.500000)\n\t369: o_phase = -9'd102;\t //LUT[369] \tphase : -0.398438\t(data_i, data_q): (0.156250,-0.468750)\n\t370: o_phase = -9'd100;\t //LUT[370] \tphase : -0.390625\t(data_i, data_q): (0.156250,-0.437500)\n\t371: o_phase = -9'd98;\t //LUT[371] \tphase : -0.382812\t(data_i, data_q): (0.156250,-0.406250)\n\t372: o_phase = -9'd96;\t //LUT[372] \tphase : -0.375000\t(data_i, data_q): (0.156250,-0.375000)\n\t373: o_phase = -9'd93;\t //LUT[373] \tphase : -0.363281\t(data_i, data_q): (0.156250,-0.343750)\n\t374: o_phase = -9'd90;\t //LUT[374] \tphase : -0.351562\t(data_i, data_q): (0.156250,-0.312500)\n\t375: o_phase = -9'd87;\t //LUT[375] \tphase : -0.339844\t(data_i, data_q): (0.156250,-0.281250)\n\t376: o_phase = -9'd82;\t //LUT[376] \tphase : -0.320312\t(data_i, data_q): (0.156250,-0.250000)\n\t377: o_phase = -9'd77;\t //LUT[377] \tphase : -0.300781\t(data_i, data_q): (0.156250,-0.218750)\n\t378: o_phase = -9'd71;\t //LUT[378] \tphase : -0.277344\t(data_i, data_q): (0.156250,-0.187500)\n\t379: o_phase = -9'd64;\t //LUT[379] \tphase : -0.250000\t(data_i, data_q): (0.156250,-0.156250)\n\t380: o_phase = -9'd55;\t //LUT[380] \tphase : -0.214844\t(data_i, data_q): (0.156250,-0.125000)\n\t381: o_phase = -9'd44;\t //LUT[381] \tphase : -0.171875\t(data_i, data_q): (0.156250,-0.093750)\n\t382: o_phase = -9'd31;\t //LUT[382] \tphase : -0.121094\t(data_i, data_q): (0.156250,-0.062500)\n\t383: o_phase = -9'd16;\t //LUT[383] \tphase : -0.062500\t(data_i, data_q): (0.156250,-0.031250)\n\t384: o_phase = +9'd0;\t //LUT[384] \tphase : 0.000000\t(data_i, data_q): (0.187500,0.000000)\n\t385: o_phase = +9'd13;\t //LUT[385] \tphase : 0.050781\t(data_i, data_q): (0.187500,0.031250)\n\t386: o_phase = +9'd26;\t //LUT[386] \tphase : 0.101562\t(data_i, data_q): (0.187500,0.062500)\n\t387: o_phase = +9'd38;\t //LUT[387] \tphase : 0.148438\t(data_i, data_q): (0.187500,0.093750)\n\t388: o_phase = +9'd48;\t //LUT[388] \tphase : 0.187500\t(data_i, data_q): (0.187500,0.125000)\n\t389: o_phase = +9'd57;\t //LUT[389] \tphase : 0.222656\t(data_i, data_q): (0.187500,0.156250)\n\t390: o_phase = +9'd64;\t //LUT[390] \tphase : 0.250000\t(data_i, data_q): (0.187500,0.187500)\n\t391: o_phase = +9'd70;\t //LUT[391] \tphase : 0.273438\t(data_i, data_q): (0.187500,0.218750)\n\t392: o_phase = +9'd76;\t //LUT[392] \tphase : 0.296875\t(data_i, data_q): (0.187500,0.250000)\n\t393: o_phase = +9'd80;\t //LUT[393] \tphase : 0.312500\t(data_i, data_q): (0.187500,0.281250)\n\t394: o_phase = +9'd84;\t //LUT[394] \tphase : 0.328125\t(data_i, data_q): (0.187500,0.312500)\n\t395: o_phase = +9'd87;\t //LUT[395] \tphase : 0.339844\t(data_i, data_q): (0.187500,0.343750)\n\t396: o_phase = +9'd90;\t //LUT[396] \tphase : 0.351562\t(data_i, data_q): (0.187500,0.375000)\n\t397: o_phase = +9'd93;\t //LUT[397] \tphase : 0.363281\t(data_i, data_q): (0.187500,0.406250)\n\t398: o_phase = +9'd95;\t //LUT[398] \tphase : 0.371094\t(data_i, data_q): (0.187500,0.437500)\n\t399: o_phase = +9'd97;\t //LUT[399] \tphase : 0.378906\t(data_i, data_q): (0.187500,0.468750)\n\t400: o_phase = +9'd99;\t //LUT[400] \tphase : 0.386719\t(data_i, data_q): (0.187500,0.500000)\n\t401: o_phase = +9'd100;\t //LUT[401] \tphase : 0.390625\t(data_i, data_q): (0.187500,0.531250)\n\t402: o_phase = +9'd102;\t //LUT[402] \tphase : 0.398438\t(data_i, data_q): (0.187500,0.562500)\n\t403: o_phase = +9'd103;\t //LUT[403] \tphase : 0.402344\t(data_i, data_q): (0.187500,0.593750)\n\t404: o_phase = +9'd104;\t //LUT[404] \tphase : 0.406250\t(data_i, data_q): (0.187500,0.625000)\n\t405: o_phase = +9'd105;\t //LUT[405] \tphase : 0.410156\t(data_i, data_q): (0.187500,0.656250)\n\t406: o_phase = +9'd106;\t //LUT[406] \tphase : 0.414062\t(data_i, data_q): (0.187500,0.687500)\n\t407: o_phase = +9'd107;\t //LUT[407] \tphase : 0.417969\t(data_i, data_q): (0.187500,0.718750)\n\t408: o_phase = +9'd108;\t //LUT[408] \tphase : 0.421875\t(data_i, data_q): (0.187500,0.750000)\n\t409: o_phase = +9'd109;\t //LUT[409] \tphase : 0.425781\t(data_i, data_q): (0.187500,0.781250)\n\t410: o_phase = +9'd110;\t //LUT[410] \tphase : 0.429688\t(data_i, data_q): (0.187500,0.812500)\n\t411: o_phase = +9'd110;\t //LUT[411] \tphase : 0.429688\t(data_i, data_q): (0.187500,0.843750)\n\t412: o_phase = +9'd111;\t //LUT[412] \tphase : 0.433594\t(data_i, data_q): (0.187500,0.875000)\n\t413: o_phase = +9'd111;\t //LUT[413] \tphase : 0.433594\t(data_i, data_q): (0.187500,0.906250)\n\t414: o_phase = +9'd112;\t //LUT[414] \tphase : 0.437500\t(data_i, data_q): (0.187500,0.937500)\n\t415: o_phase = +9'd112;\t //LUT[415] \tphase : 0.437500\t(data_i, data_q): (0.187500,0.968750)\n\t416: o_phase = -9'd113;\t //LUT[416] \tphase : -0.441406\t(data_i, data_q): (0.187500,-1.000000)\n\t417: o_phase = -9'd112;\t //LUT[417] \tphase : -0.437500\t(data_i, data_q): (0.187500,-0.968750)\n\t418: o_phase = -9'd112;\t //LUT[418] \tphase : -0.437500\t(data_i, data_q): (0.187500,-0.937500)\n\t419: o_phase = -9'd111;\t //LUT[419] \tphase : -0.433594\t(data_i, data_q): (0.187500,-0.906250)\n\t420: o_phase = -9'd111;\t //LUT[420] \tphase : -0.433594\t(data_i, data_q): (0.187500,-0.875000)\n\t421: o_phase = -9'd110;\t //LUT[421] \tphase : -0.429688\t(data_i, data_q): (0.187500,-0.843750)\n\t422: o_phase = -9'd110;\t //LUT[422] \tphase : -0.429688\t(data_i, data_q): (0.187500,-0.812500)\n\t423: o_phase = -9'd109;\t //LUT[423] \tphase : -0.425781\t(data_i, data_q): (0.187500,-0.781250)\n\t424: o_phase = -9'd108;\t //LUT[424] \tphase : -0.421875\t(data_i, data_q): (0.187500,-0.750000)\n\t425: o_phase = -9'd107;\t //LUT[425] \tphase : -0.417969\t(data_i, data_q): (0.187500,-0.718750)\n\t426: o_phase = -9'd106;\t //LUT[426] \tphase : -0.414062\t(data_i, data_q): (0.187500,-0.687500)\n\t427: o_phase = -9'd105;\t //LUT[427] \tphase : -0.410156\t(data_i, data_q): (0.187500,-0.656250)\n\t428: o_phase = -9'd104;\t //LUT[428] \tphase : -0.406250\t(data_i, data_q): (0.187500,-0.625000)\n\t429: o_phase = -9'd103;\t //LUT[429] \tphase : -0.402344\t(data_i, data_q): (0.187500,-0.593750)\n\t430: o_phase = -9'd102;\t //LUT[430] \tphase : -0.398438\t(data_i, data_q): (0.187500,-0.562500)\n\t431: o_phase = -9'd100;\t //LUT[431] \tphase : -0.390625\t(data_i, data_q): (0.187500,-0.531250)\n\t432: o_phase = -9'd99;\t //LUT[432] \tphase : -0.386719\t(data_i, data_q): (0.187500,-0.500000)\n\t433: o_phase = -9'd97;\t //LUT[433] \tphase : -0.378906\t(data_i, data_q): (0.187500,-0.468750)\n\t434: o_phase = -9'd95;\t //LUT[434] \tphase : -0.371094\t(data_i, data_q): (0.187500,-0.437500)\n\t435: o_phase = -9'd93;\t //LUT[435] \tphase : -0.363281\t(data_i, data_q): (0.187500,-0.406250)\n\t436: o_phase = -9'd90;\t //LUT[436] \tphase : -0.351562\t(data_i, data_q): (0.187500,-0.375000)\n\t437: o_phase = -9'd87;\t //LUT[437] \tphase : -0.339844\t(data_i, data_q): (0.187500,-0.343750)\n\t438: o_phase = -9'd84;\t //LUT[438] \tphase : -0.328125\t(data_i, data_q): (0.187500,-0.312500)\n\t439: o_phase = -9'd80;\t //LUT[439] \tphase : -0.312500\t(data_i, data_q): (0.187500,-0.281250)\n\t440: o_phase = -9'd76;\t //LUT[440] \tphase : -0.296875\t(data_i, data_q): (0.187500,-0.250000)\n\t441: o_phase = -9'd70;\t //LUT[441] \tphase : -0.273438\t(data_i, data_q): (0.187500,-0.218750)\n\t442: o_phase = -9'd64;\t //LUT[442] \tphase : -0.250000\t(data_i, data_q): (0.187500,-0.187500)\n\t443: o_phase = -9'd57;\t //LUT[443] \tphase : -0.222656\t(data_i, data_q): (0.187500,-0.156250)\n\t444: o_phase = -9'd48;\t //LUT[444] \tphase : -0.187500\t(data_i, data_q): (0.187500,-0.125000)\n\t445: o_phase = -9'd38;\t //LUT[445] \tphase : -0.148438\t(data_i, data_q): (0.187500,-0.093750)\n\t446: o_phase = -9'd26;\t //LUT[446] \tphase : -0.101562\t(data_i, data_q): (0.187500,-0.062500)\n\t447: o_phase = -9'd13;\t //LUT[447] \tphase : -0.050781\t(data_i, data_q): (0.187500,-0.031250)\n\t448: o_phase = +9'd0;\t //LUT[448] \tphase : 0.000000\t(data_i, data_q): (0.218750,0.000000)\n\t449: o_phase = +9'd12;\t //LUT[449] \tphase : 0.046875\t(data_i, data_q): (0.218750,0.031250)\n\t450: o_phase = +9'd23;\t //LUT[450] \tphase : 0.089844\t(data_i, data_q): (0.218750,0.062500)\n\t451: o_phase = +9'd33;\t //LUT[451] \tphase : 0.128906\t(data_i, data_q): (0.218750,0.093750)\n\t452: o_phase = +9'd42;\t //LUT[452] \tphase : 0.164062\t(data_i, data_q): (0.218750,0.125000)\n\t453: o_phase = +9'd51;\t //LUT[453] \tphase : 0.199219\t(data_i, data_q): (0.218750,0.156250)\n\t454: o_phase = +9'd58;\t //LUT[454] \tphase : 0.226562\t(data_i, data_q): (0.218750,0.187500)\n\t455: o_phase = +9'd64;\t //LUT[455] \tphase : 0.250000\t(data_i, data_q): (0.218750,0.218750)\n\t456: o_phase = +9'd69;\t //LUT[456] \tphase : 0.269531\t(data_i, data_q): (0.218750,0.250000)\n\t457: o_phase = +9'd74;\t //LUT[457] \tphase : 0.289062\t(data_i, data_q): (0.218750,0.281250)\n\t458: o_phase = +9'd78;\t //LUT[458] \tphase : 0.304688\t(data_i, data_q): (0.218750,0.312500)\n\t459: o_phase = +9'd82;\t //LUT[459] \tphase : 0.320312\t(data_i, data_q): (0.218750,0.343750)\n\t460: o_phase = +9'd85;\t //LUT[460] \tphase : 0.332031\t(data_i, data_q): (0.218750,0.375000)\n\t461: o_phase = +9'd88;\t //LUT[461] \tphase : 0.343750\t(data_i, data_q): (0.218750,0.406250)\n\t462: o_phase = +9'd90;\t //LUT[462] \tphase : 0.351562\t(data_i, data_q): (0.218750,0.437500)\n\t463: o_phase = +9'd92;\t //LUT[463] \tphase : 0.359375\t(data_i, data_q): (0.218750,0.468750)\n\t464: o_phase = +9'd94;\t //LUT[464] \tphase : 0.367188\t(data_i, data_q): (0.218750,0.500000)\n\t465: o_phase = +9'd96;\t //LUT[465] \tphase : 0.375000\t(data_i, data_q): (0.218750,0.531250)\n\t466: o_phase = +9'd98;\t //LUT[466] \tphase : 0.382812\t(data_i, data_q): (0.218750,0.562500)\n\t467: o_phase = +9'd99;\t //LUT[467] \tphase : 0.386719\t(data_i, data_q): (0.218750,0.593750)\n\t468: o_phase = +9'd101;\t //LUT[468] \tphase : 0.394531\t(data_i, data_q): (0.218750,0.625000)\n\t469: o_phase = +9'd102;\t //LUT[469] \tphase : 0.398438\t(data_i, data_q): (0.218750,0.656250)\n\t470: o_phase = +9'd103;\t //LUT[470] \tphase : 0.402344\t(data_i, data_q): (0.218750,0.687500)\n\t471: o_phase = +9'd104;\t //LUT[471] \tphase : 0.406250\t(data_i, data_q): (0.218750,0.718750)\n\t472: o_phase = +9'd105;\t //LUT[472] \tphase : 0.410156\t(data_i, data_q): (0.218750,0.750000)\n\t473: o_phase = +9'd106;\t //LUT[473] \tphase : 0.414062\t(data_i, data_q): (0.218750,0.781250)\n\t474: o_phase = +9'd107;\t //LUT[474] \tphase : 0.417969\t(data_i, data_q): (0.218750,0.812500)\n\t475: o_phase = +9'd107;\t //LUT[475] \tphase : 0.417969\t(data_i, data_q): (0.218750,0.843750)\n\t476: o_phase = +9'd108;\t //LUT[476] \tphase : 0.421875\t(data_i, data_q): (0.218750,0.875000)\n\t477: o_phase = +9'd109;\t //LUT[477] \tphase : 0.425781\t(data_i, data_q): (0.218750,0.906250)\n\t478: o_phase = +9'd109;\t //LUT[478] \tphase : 0.425781\t(data_i, data_q): (0.218750,0.937500)\n\t479: o_phase = +9'd110;\t //LUT[479] \tphase : 0.429688\t(data_i, data_q): (0.218750,0.968750)\n\t480: o_phase = -9'd110;\t //LUT[480] \tphase : -0.429688\t(data_i, data_q): (0.218750,-1.000000)\n\t481: o_phase = -9'd110;\t //LUT[481] \tphase : -0.429688\t(data_i, data_q): (0.218750,-0.968750)\n\t482: o_phase = -9'd109;\t //LUT[482] \tphase : -0.425781\t(data_i, data_q): (0.218750,-0.937500)\n\t483: o_phase = -9'd109;\t //LUT[483] \tphase : -0.425781\t(data_i, data_q): (0.218750,-0.906250)\n\t484: o_phase = -9'd108;\t //LUT[484] \tphase : -0.421875\t(data_i, data_q): (0.218750,-0.875000)\n\t485: o_phase = -9'd107;\t //LUT[485] \tphase : -0.417969\t(data_i, data_q): (0.218750,-0.843750)\n\t486: o_phase = -9'd107;\t //LUT[486] \tphase : -0.417969\t(data_i, data_q): (0.218750,-0.812500)\n\t487: o_phase = -9'd106;\t //LUT[487] \tphase : -0.414062\t(data_i, data_q): (0.218750,-0.781250)\n\t488: o_phase = -9'd105;\t //LUT[488] \tphase : -0.410156\t(data_i, data_q): (0.218750,-0.750000)\n\t489: o_phase = -9'd104;\t //LUT[489] \tphase : -0.406250\t(data_i, data_q): (0.218750,-0.718750)\n\t490: o_phase = -9'd103;\t //LUT[490] \tphase : -0.402344\t(data_i, data_q): (0.218750,-0.687500)\n\t491: o_phase = -9'd102;\t //LUT[491] \tphase : -0.398438\t(data_i, data_q): (0.218750,-0.656250)\n\t492: o_phase = -9'd101;\t //LUT[492] \tphase : -0.394531\t(data_i, data_q): (0.218750,-0.625000)\n\t493: o_phase = -9'd99;\t //LUT[493] \tphase : -0.386719\t(data_i, data_q): (0.218750,-0.593750)\n\t494: o_phase = -9'd98;\t //LUT[494] \tphase : -0.382812\t(data_i, data_q): (0.218750,-0.562500)\n\t495: o_phase = -9'd96;\t //LUT[495] \tphase : -0.375000\t(data_i, data_q): (0.218750,-0.531250)\n\t496: o_phase = -9'd94;\t //LUT[496] \tphase : -0.367188\t(data_i, data_q): (0.218750,-0.500000)\n\t497: o_phase = -9'd92;\t //LUT[497] \tphase : -0.359375\t(data_i, data_q): (0.218750,-0.468750)\n\t498: o_phase = -9'd90;\t //LUT[498] \tphase : -0.351562\t(data_i, data_q): (0.218750,-0.437500)\n\t499: o_phase = -9'd88;\t //LUT[499] \tphase : -0.343750\t(data_i, data_q): (0.218750,-0.406250)\n\t500: o_phase = -9'd85;\t //LUT[500] \tphase : -0.332031\t(data_i, data_q): (0.218750,-0.375000)\n\t501: o_phase = -9'd82;\t //LUT[501] \tphase : -0.320312\t(data_i, data_q): (0.218750,-0.343750)\n\t502: o_phase = -9'd78;\t //LUT[502] \tphase : -0.304688\t(data_i, data_q): (0.218750,-0.312500)\n\t503: o_phase = -9'd74;\t //LUT[503] \tphase : -0.289062\t(data_i, data_q): (0.218750,-0.281250)\n\t504: o_phase = -9'd69;\t //LUT[504] \tphase : -0.269531\t(data_i, data_q): (0.218750,-0.250000)\n\t505: o_phase = -9'd64;\t //LUT[505] \tphase : -0.250000\t(data_i, data_q): (0.218750,-0.218750)\n\t506: o_phase = -9'd58;\t //LUT[506] \tphase : -0.226562\t(data_i, data_q): (0.218750,-0.187500)\n\t507: o_phase = -9'd51;\t //LUT[507] \tphase : -0.199219\t(data_i, data_q): (0.218750,-0.156250)\n\t508: o_phase = -9'd42;\t //LUT[508] \tphase : -0.164062\t(data_i, data_q): (0.218750,-0.125000)\n\t509: o_phase = -9'd33;\t //LUT[509] \tphase : -0.128906\t(data_i, data_q): (0.218750,-0.093750)\n\t510: o_phase = -9'd23;\t //LUT[510] \tphase : -0.089844\t(data_i, data_q): (0.218750,-0.062500)\n\t511: o_phase = -9'd12;\t //LUT[511] \tphase : -0.046875\t(data_i, data_q): (0.218750,-0.031250)\n\t512: o_phase = +9'd0;\t //LUT[512] \tphase : 0.000000\t(data_i, data_q): (0.250000,0.000000)\n\t513: o_phase = +9'd10;\t //LUT[513] \tphase : 0.039062\t(data_i, data_q): (0.250000,0.031250)\n\t514: o_phase = +9'd20;\t //LUT[514] \tphase : 0.078125\t(data_i, data_q): (0.250000,0.062500)\n\t515: o_phase = +9'd29;\t //LUT[515] \tphase : 0.113281\t(data_i, data_q): (0.250000,0.093750)\n\t516: o_phase = +9'd38;\t //LUT[516] \tphase : 0.148438\t(data_i, data_q): (0.250000,0.125000)\n\t517: o_phase = +9'd46;\t //LUT[517] \tphase : 0.179688\t(data_i, data_q): (0.250000,0.156250)\n\t518: o_phase = +9'd52;\t //LUT[518] \tphase : 0.203125\t(data_i, data_q): (0.250000,0.187500)\n\t519: o_phase = +9'd59;\t //LUT[519] \tphase : 0.230469\t(data_i, data_q): (0.250000,0.218750)\n\t520: o_phase = +9'd64;\t //LUT[520] \tphase : 0.250000\t(data_i, data_q): (0.250000,0.250000)\n\t521: o_phase = +9'd69;\t //LUT[521] \tphase : 0.269531\t(data_i, data_q): (0.250000,0.281250)\n\t522: o_phase = +9'd73;\t //LUT[522] \tphase : 0.285156\t(data_i, data_q): (0.250000,0.312500)\n\t523: o_phase = +9'd77;\t //LUT[523] \tphase : 0.300781\t(data_i, data_q): (0.250000,0.343750)\n\t524: o_phase = +9'd80;\t //LUT[524] \tphase : 0.312500\t(data_i, data_q): (0.250000,0.375000)\n\t525: o_phase = +9'd83;\t //LUT[525] \tphase : 0.324219\t(data_i, data_q): (0.250000,0.406250)\n\t526: o_phase = +9'd86;\t //LUT[526] \tphase : 0.335938\t(data_i, data_q): (0.250000,0.437500)\n\t527: o_phase = +9'd88;\t //LUT[527] \tphase : 0.343750\t(data_i, data_q): (0.250000,0.468750)\n\t528: o_phase = +9'd90;\t //LUT[528] \tphase : 0.351562\t(data_i, data_q): (0.250000,0.500000)\n\t529: o_phase = +9'd92;\t //LUT[529] \tphase : 0.359375\t(data_i, data_q): (0.250000,0.531250)\n\t530: o_phase = +9'd94;\t //LUT[530] \tphase : 0.367188\t(data_i, data_q): (0.250000,0.562500)\n\t531: o_phase = +9'd96;\t //LUT[531] \tphase : 0.375000\t(data_i, data_q): (0.250000,0.593750)\n\t532: o_phase = +9'd97;\t //LUT[532] \tphase : 0.378906\t(data_i, data_q): (0.250000,0.625000)\n\t533: o_phase = +9'd98;\t //LUT[533] \tphase : 0.382812\t(data_i, data_q): (0.250000,0.656250)\n\t534: o_phase = +9'd100;\t //LUT[534] \tphase : 0.390625\t(data_i, data_q): (0.250000,0.687500)\n\t535: o_phase = +9'd101;\t //LUT[535] \tphase : 0.394531\t(data_i, data_q): (0.250000,0.718750)\n\t536: o_phase = +9'd102;\t //LUT[536] \tphase : 0.398438\t(data_i, data_q): (0.250000,0.750000)\n\t537: o_phase = +9'd103;\t //LUT[537] \tphase : 0.402344\t(data_i, data_q): (0.250000,0.781250)\n\t538: o_phase = +9'd104;\t //LUT[538] \tphase : 0.406250\t(data_i, data_q): (0.250000,0.812500)\n\t539: o_phase = +9'd105;\t //LUT[539] \tphase : 0.410156\t(data_i, data_q): (0.250000,0.843750)\n\t540: o_phase = +9'd105;\t //LUT[540] \tphase : 0.410156\t(data_i, data_q): (0.250000,0.875000)\n\t541: o_phase = +9'd106;\t //LUT[541] \tphase : 0.414062\t(data_i, data_q): (0.250000,0.906250)\n\t542: o_phase = +9'd107;\t //LUT[542] \tphase : 0.417969\t(data_i, data_q): (0.250000,0.937500)\n\t543: o_phase = +9'd107;\t //LUT[543] \tphase : 0.417969\t(data_i, data_q): (0.250000,0.968750)\n\t544: o_phase = -9'd108;\t //LUT[544] \tphase : -0.421875\t(data_i, data_q): (0.250000,-1.000000)\n\t545: o_phase = -9'd107;\t //LUT[545] \tphase : -0.417969\t(data_i, data_q): (0.250000,-0.968750)\n\t546: o_phase = -9'd107;\t //LUT[546] \tphase : -0.417969\t(data_i, data_q): (0.250000,-0.937500)\n\t547: o_phase = -9'd106;\t //LUT[547] \tphase : -0.414062\t(data_i, data_q): (0.250000,-0.906250)\n\t548: o_phase = -9'd105;\t //LUT[548] \tphase : -0.410156\t(data_i, data_q): (0.250000,-0.875000)\n\t549: o_phase = -9'd105;\t //LUT[549] \tphase : -0.410156\t(data_i, data_q): (0.250000,-0.843750)\n\t550: o_phase = -9'd104;\t //LUT[550] \tphase : -0.406250\t(data_i, data_q): (0.250000,-0.812500)\n\t551: o_phase = -9'd103;\t //LUT[551] \tphase : -0.402344\t(data_i, data_q): (0.250000,-0.781250)\n\t552: o_phase = -9'd102;\t //LUT[552] \tphase : -0.398438\t(data_i, data_q): (0.250000,-0.750000)\n\t553: o_phase = -9'd101;\t //LUT[553] \tphase : -0.394531\t(data_i, data_q): (0.250000,-0.718750)\n\t554: o_phase = -9'd100;\t //LUT[554] \tphase : -0.390625\t(data_i, data_q): (0.250000,-0.687500)\n\t555: o_phase = -9'd98;\t //LUT[555] \tphase : -0.382812\t(data_i, data_q): (0.250000,-0.656250)\n\t556: o_phase = -9'd97;\t //LUT[556] \tphase : -0.378906\t(data_i, data_q): (0.250000,-0.625000)\n\t557: o_phase = -9'd96;\t //LUT[557] \tphase : -0.375000\t(data_i, data_q): (0.250000,-0.593750)\n\t558: o_phase = -9'd94;\t //LUT[558] \tphase : -0.367188\t(data_i, data_q): (0.250000,-0.562500)\n\t559: o_phase = -9'd92;\t //LUT[559] \tphase : -0.359375\t(data_i, data_q): (0.250000,-0.531250)\n\t560: o_phase = -9'd90;\t //LUT[560] \tphase : -0.351562\t(data_i, data_q): (0.250000,-0.500000)\n\t561: o_phase = -9'd88;\t //LUT[561] \tphase : -0.343750\t(data_i, data_q): (0.250000,-0.468750)\n\t562: o_phase = -9'd86;\t //LUT[562] \tphase : -0.335938\t(data_i, data_q): (0.250000,-0.437500)\n\t563: o_phase = -9'd83;\t //LUT[563] \tphase : -0.324219\t(data_i, data_q): (0.250000,-0.406250)\n\t564: o_phase = -9'd80;\t //LUT[564] \tphase : -0.312500\t(data_i, data_q): (0.250000,-0.375000)\n\t565: o_phase = -9'd77;\t //LUT[565] \tphase : -0.300781\t(data_i, data_q): (0.250000,-0.343750)\n\t566: o_phase = -9'd73;\t //LUT[566] \tphase : -0.285156\t(data_i, data_q): (0.250000,-0.312500)\n\t567: o_phase = -9'd69;\t //LUT[567] \tphase : -0.269531\t(data_i, data_q): (0.250000,-0.281250)\n\t568: o_phase = -9'd64;\t //LUT[568] \tphase : -0.250000\t(data_i, data_q): (0.250000,-0.250000)\n\t569: o_phase = -9'd59;\t //LUT[569] \tphase : -0.230469\t(data_i, data_q): (0.250000,-0.218750)\n\t570: o_phase = -9'd52;\t //LUT[570] \tphase : -0.203125\t(data_i, data_q): (0.250000,-0.187500)\n\t571: o_phase = -9'd46;\t //LUT[571] \tphase : -0.179688\t(data_i, data_q): (0.250000,-0.156250)\n\t572: o_phase = -9'd38;\t //LUT[572] \tphase : -0.148438\t(data_i, data_q): (0.250000,-0.125000)\n\t573: o_phase = -9'd29;\t //LUT[573] \tphase : -0.113281\t(data_i, data_q): (0.250000,-0.093750)\n\t574: o_phase = -9'd20;\t //LUT[574] \tphase : -0.078125\t(data_i, data_q): (0.250000,-0.062500)\n\t575: o_phase = -9'd10;\t //LUT[575] \tphase : -0.039062\t(data_i, data_q): (0.250000,-0.031250)\n\t576: o_phase = +9'd0;\t //LUT[576] \tphase : 0.000000\t(data_i, data_q): (0.281250,0.000000)\n\t577: o_phase = +9'd9;\t //LUT[577] \tphase : 0.035156\t(data_i, data_q): (0.281250,0.031250)\n\t578: o_phase = +9'd18;\t //LUT[578] \tphase : 0.070312\t(data_i, data_q): (0.281250,0.062500)\n\t579: o_phase = +9'd26;\t //LUT[579] \tphase : 0.101562\t(data_i, data_q): (0.281250,0.093750)\n\t580: o_phase = +9'd34;\t //LUT[580] \tphase : 0.132812\t(data_i, data_q): (0.281250,0.125000)\n\t581: o_phase = +9'd41;\t //LUT[581] \tphase : 0.160156\t(data_i, data_q): (0.281250,0.156250)\n\t582: o_phase = +9'd48;\t //LUT[582] \tphase : 0.187500\t(data_i, data_q): (0.281250,0.187500)\n\t583: o_phase = +9'd54;\t //LUT[583] \tphase : 0.210938\t(data_i, data_q): (0.281250,0.218750)\n\t584: o_phase = +9'd59;\t //LUT[584] \tphase : 0.230469\t(data_i, data_q): (0.281250,0.250000)\n\t585: o_phase = +9'd64;\t //LUT[585] \tphase : 0.250000\t(data_i, data_q): (0.281250,0.281250)\n\t586: o_phase = +9'd68;\t //LUT[586] \tphase : 0.265625\t(data_i, data_q): (0.281250,0.312500)\n\t587: o_phase = +9'd72;\t //LUT[587] \tphase : 0.281250\t(data_i, data_q): (0.281250,0.343750)\n\t588: o_phase = +9'd76;\t //LUT[588] \tphase : 0.296875\t(data_i, data_q): (0.281250,0.375000)\n\t589: o_phase = +9'd79;\t //LUT[589] \tphase : 0.308594\t(data_i, data_q): (0.281250,0.406250)\n\t590: o_phase = +9'd81;\t //LUT[590] \tphase : 0.316406\t(data_i, data_q): (0.281250,0.437500)\n\t591: o_phase = +9'd84;\t //LUT[591] \tphase : 0.328125\t(data_i, data_q): (0.281250,0.468750)\n\t592: o_phase = +9'd86;\t //LUT[592] \tphase : 0.335938\t(data_i, data_q): (0.281250,0.500000)\n\t593: o_phase = +9'd88;\t //LUT[593] \tphase : 0.343750\t(data_i, data_q): (0.281250,0.531250)\n\t594: o_phase = +9'd90;\t //LUT[594] \tphase : 0.351562\t(data_i, data_q): (0.281250,0.562500)\n\t595: o_phase = +9'd92;\t //LUT[595] \tphase : 0.359375\t(data_i, data_q): (0.281250,0.593750)\n\t596: o_phase = +9'd94;\t //LUT[596] \tphase : 0.367188\t(data_i, data_q): (0.281250,0.625000)\n\t597: o_phase = +9'd95;\t //LUT[597] \tphase : 0.371094\t(data_i, data_q): (0.281250,0.656250)\n\t598: o_phase = +9'd96;\t //LUT[598] \tphase : 0.375000\t(data_i, data_q): (0.281250,0.687500)\n\t599: o_phase = +9'd98;\t //LUT[599] \tphase : 0.382812\t(data_i, data_q): (0.281250,0.718750)\n\t600: o_phase = +9'd99;\t //LUT[600] \tphase : 0.386719\t(data_i, data_q): (0.281250,0.750000)\n\t601: o_phase = +9'd100;\t //LUT[601] \tphase : 0.390625\t(data_i, data_q): (0.281250,0.781250)\n\t602: o_phase = +9'd101;\t //LUT[602] \tphase : 0.394531\t(data_i, data_q): (0.281250,0.812500)\n\t603: o_phase = +9'd102;\t //LUT[603] \tphase : 0.398438\t(data_i, data_q): (0.281250,0.843750)\n\t604: o_phase = +9'd103;\t //LUT[604] \tphase : 0.402344\t(data_i, data_q): (0.281250,0.875000)\n\t605: o_phase = +9'd103;\t //LUT[605] \tphase : 0.402344\t(data_i, data_q): (0.281250,0.906250)\n\t606: o_phase = +9'd104;\t //LUT[606] \tphase : 0.406250\t(data_i, data_q): (0.281250,0.937500)\n\t607: o_phase = +9'd105;\t //LUT[607] \tphase : 0.410156\t(data_i, data_q): (0.281250,0.968750)\n\t608: o_phase = -9'd106;\t //LUT[608] \tphase : -0.414062\t(data_i, data_q): (0.281250,-1.000000)\n\t609: o_phase = -9'd105;\t //LUT[609] \tphase : -0.410156\t(data_i, data_q): (0.281250,-0.968750)\n\t610: o_phase = -9'd104;\t //LUT[610] \tphase : -0.406250\t(data_i, data_q): (0.281250,-0.937500)\n\t611: o_phase = -9'd103;\t //LUT[611] \tphase : -0.402344\t(data_i, data_q): (0.281250,-0.906250)\n\t612: o_phase = -9'd103;\t //LUT[612] \tphase : -0.402344\t(data_i, data_q): (0.281250,-0.875000)\n\t613: o_phase = -9'd102;\t //LUT[613] \tphase : -0.398438\t(data_i, data_q): (0.281250,-0.843750)\n\t614: o_phase = -9'd101;\t //LUT[614] \tphase : -0.394531\t(data_i, data_q): (0.281250,-0.812500)\n\t615: o_phase = -9'd100;\t //LUT[615] \tphase : -0.390625\t(data_i, data_q): (0.281250,-0.781250)\n\t616: o_phase = -9'd99;\t //LUT[616] \tphase : -0.386719\t(data_i, data_q): (0.281250,-0.750000)\n\t617: o_phase = -9'd98;\t //LUT[617] \tphase : -0.382812\t(data_i, data_q): (0.281250,-0.718750)\n\t618: o_phase = -9'd96;\t //LUT[618] \tphase : -0.375000\t(data_i, data_q): (0.281250,-0.687500)\n\t619: o_phase = -9'd95;\t //LUT[619] \tphase : -0.371094\t(data_i, data_q): (0.281250,-0.656250)\n\t620: o_phase = -9'd94;\t //LUT[620] \tphase : -0.367188\t(data_i, data_q): (0.281250,-0.625000)\n\t621: o_phase = -9'd92;\t //LUT[621] \tphase : -0.359375\t(data_i, data_q): (0.281250,-0.593750)\n\t622: o_phase = -9'd90;\t //LUT[622] \tphase : -0.351562\t(data_i, data_q): (0.281250,-0.562500)\n\t623: o_phase = -9'd88;\t //LUT[623] \tphase : -0.343750\t(data_i, data_q): (0.281250,-0.531250)\n\t624: o_phase = -9'd86;\t //LUT[624] \tphase : -0.335938\t(data_i, data_q): (0.281250,-0.500000)\n\t625: o_phase = -9'd84;\t //LUT[625] \tphase : -0.328125\t(data_i, data_q): (0.281250,-0.468750)\n\t626: o_phase = -9'd81;\t //LUT[626] \tphase : -0.316406\t(data_i, data_q): (0.281250,-0.437500)\n\t627: o_phase = -9'd79;\t //LUT[627] \tphase : -0.308594\t(data_i, data_q): (0.281250,-0.406250)\n\t628: o_phase = -9'd76;\t //LUT[628] \tphase : -0.296875\t(data_i, data_q): (0.281250,-0.375000)\n\t629: o_phase = -9'd72;\t //LUT[629] \tphase : -0.281250\t(data_i, data_q): (0.281250,-0.343750)\n\t630: o_phase = -9'd68;\t //LUT[630] \tphase : -0.265625\t(data_i, data_q): (0.281250,-0.312500)\n\t631: o_phase = -9'd64;\t //LUT[631] \tphase : -0.250000\t(data_i, data_q): (0.281250,-0.281250)\n\t632: o_phase = -9'd59;\t //LUT[632] \tphase : -0.230469\t(data_i, data_q): (0.281250,-0.250000)\n\t633: o_phase = -9'd54;\t //LUT[633] \tphase : -0.210938\t(data_i, data_q): (0.281250,-0.218750)\n\t634: o_phase = -9'd48;\t //LUT[634] \tphase : -0.187500\t(data_i, data_q): (0.281250,-0.187500)\n\t635: o_phase = -9'd41;\t //LUT[635] \tphase : -0.160156\t(data_i, data_q): (0.281250,-0.156250)\n\t636: o_phase = -9'd34;\t //LUT[636] \tphase : -0.132812\t(data_i, data_q): (0.281250,-0.125000)\n\t637: o_phase = -9'd26;\t //LUT[637] \tphase : -0.101562\t(data_i, data_q): (0.281250,-0.093750)\n\t638: o_phase = -9'd18;\t //LUT[638] \tphase : -0.070312\t(data_i, data_q): (0.281250,-0.062500)\n\t639: o_phase = -9'd9;\t //LUT[639] \tphase : -0.035156\t(data_i, data_q): (0.281250,-0.031250)\n\t640: o_phase = +9'd0;\t //LUT[640] \tphase : 0.000000\t(data_i, data_q): (0.312500,0.000000)\n\t641: o_phase = +9'd8;\t //LUT[641] \tphase : 0.031250\t(data_i, data_q): (0.312500,0.031250)\n\t642: o_phase = +9'd16;\t //LUT[642] \tphase : 0.062500\t(data_i, data_q): (0.312500,0.062500)\n\t643: o_phase = +9'd24;\t //LUT[643] \tphase : 0.093750\t(data_i, data_q): (0.312500,0.093750)\n\t644: o_phase = +9'd31;\t //LUT[644] \tphase : 0.121094\t(data_i, data_q): (0.312500,0.125000)\n\t645: o_phase = +9'd38;\t //LUT[645] \tphase : 0.148438\t(data_i, data_q): (0.312500,0.156250)\n\t646: o_phase = +9'd44;\t //LUT[646] \tphase : 0.171875\t(data_i, data_q): (0.312500,0.187500)\n\t647: o_phase = +9'd50;\t //LUT[647] \tphase : 0.195312\t(data_i, data_q): (0.312500,0.218750)\n\t648: o_phase = +9'd55;\t //LUT[648] \tphase : 0.214844\t(data_i, data_q): (0.312500,0.250000)\n\t649: o_phase = +9'd60;\t //LUT[649] \tphase : 0.234375\t(data_i, data_q): (0.312500,0.281250)\n\t650: o_phase = +9'd64;\t //LUT[650] \tphase : 0.250000\t(data_i, data_q): (0.312500,0.312500)\n\t651: o_phase = +9'd68;\t //LUT[651] \tphase : 0.265625\t(data_i, data_q): (0.312500,0.343750)\n\t652: o_phase = +9'd71;\t //LUT[652] \tphase : 0.277344\t(data_i, data_q): (0.312500,0.375000)\n\t653: o_phase = +9'd75;\t //LUT[653] \tphase : 0.292969\t(data_i, data_q): (0.312500,0.406250)\n\t654: o_phase = +9'd77;\t //LUT[654] \tphase : 0.300781\t(data_i, data_q): (0.312500,0.437500)\n\t655: o_phase = +9'd80;\t //LUT[655] \tphase : 0.312500\t(data_i, data_q): (0.312500,0.468750)\n\t656: o_phase = +9'd82;\t //LUT[656] \tphase : 0.320312\t(data_i, data_q): (0.312500,0.500000)\n\t657: o_phase = +9'd85;\t //LUT[657] \tphase : 0.332031\t(data_i, data_q): (0.312500,0.531250)\n\t658: o_phase = +9'd87;\t //LUT[658] \tphase : 0.339844\t(data_i, data_q): (0.312500,0.562500)\n\t659: o_phase = +9'd89;\t //LUT[659] \tphase : 0.347656\t(data_i, data_q): (0.312500,0.593750)\n\t660: o_phase = +9'd90;\t //LUT[660] \tphase : 0.351562\t(data_i, data_q): (0.312500,0.625000)\n\t661: o_phase = +9'd92;\t //LUT[661] \tphase : 0.359375\t(data_i, data_q): (0.312500,0.656250)\n\t662: o_phase = +9'd93;\t //LUT[662] \tphase : 0.363281\t(data_i, data_q): (0.312500,0.687500)\n\t663: o_phase = +9'd95;\t //LUT[663] \tphase : 0.371094\t(data_i, data_q): (0.312500,0.718750)\n\t664: o_phase = +9'd96;\t //LUT[664] \tphase : 0.375000\t(data_i, data_q): (0.312500,0.750000)\n\t665: o_phase = +9'd97;\t //LUT[665] \tphase : 0.378906\t(data_i, data_q): (0.312500,0.781250)\n\t666: o_phase = +9'd98;\t //LUT[666] \tphase : 0.382812\t(data_i, data_q): (0.312500,0.812500)\n\t667: o_phase = +9'd99;\t //LUT[667] \tphase : 0.386719\t(data_i, data_q): (0.312500,0.843750)\n\t668: o_phase = +9'd100;\t //LUT[668] \tphase : 0.390625\t(data_i, data_q): (0.312500,0.875000)\n\t669: o_phase = +9'd101;\t //LUT[669] \tphase : 0.394531\t(data_i, data_q): (0.312500,0.906250)\n\t670: o_phase = +9'd102;\t //LUT[670] \tphase : 0.398438\t(data_i, data_q): (0.312500,0.937500)\n\t671: o_phase = +9'd103;\t //LUT[671] \tphase : 0.402344\t(data_i, data_q): (0.312500,0.968750)\n\t672: o_phase = -9'd103;\t //LUT[672] \tphase : -0.402344\t(data_i, data_q): (0.312500,-1.000000)\n\t673: o_phase = -9'd103;\t //LUT[673] \tphase : -0.402344\t(data_i, data_q): (0.312500,-0.968750)\n\t674: o_phase = -9'd102;\t //LUT[674] \tphase : -0.398438\t(data_i, data_q): (0.312500,-0.937500)\n\t675: o_phase = -9'd101;\t //LUT[675] \tphase : -0.394531\t(data_i, data_q): (0.312500,-0.906250)\n\t676: o_phase = -9'd100;\t //LUT[676] \tphase : -0.390625\t(data_i, data_q): (0.312500,-0.875000)\n\t677: o_phase = -9'd99;\t //LUT[677] \tphase : -0.386719\t(data_i, data_q): (0.312500,-0.843750)\n\t678: o_phase = -9'd98;\t //LUT[678] \tphase : -0.382812\t(data_i, data_q): (0.312500,-0.812500)\n\t679: o_phase = -9'd97;\t //LUT[679] \tphase : -0.378906\t(data_i, data_q): (0.312500,-0.781250)\n\t680: o_phase = -9'd96;\t //LUT[680] \tphase : -0.375000\t(data_i, data_q): (0.312500,-0.750000)\n\t681: o_phase = -9'd95;\t //LUT[681] \tphase : -0.371094\t(data_i, data_q): (0.312500,-0.718750)\n\t682: o_phase = -9'd93;\t //LUT[682] \tphase : -0.363281\t(data_i, data_q): (0.312500,-0.687500)\n\t683: o_phase = -9'd92;\t //LUT[683] \tphase : -0.359375\t(data_i, data_q): (0.312500,-0.656250)\n\t684: o_phase = -9'd90;\t //LUT[684] \tphase : -0.351562\t(data_i, data_q): (0.312500,-0.625000)\n\t685: o_phase = -9'd89;\t //LUT[685] \tphase : -0.347656\t(data_i, data_q): (0.312500,-0.593750)\n\t686: o_phase = -9'd87;\t //LUT[686] \tphase : -0.339844\t(data_i, data_q): (0.312500,-0.562500)\n\t687: o_phase = -9'd85;\t //LUT[687] \tphase : -0.332031\t(data_i, data_q): (0.312500,-0.531250)\n\t688: o_phase = -9'd82;\t //LUT[688] \tphase : -0.320312\t(data_i, data_q): (0.312500,-0.500000)\n\t689: o_phase = -9'd80;\t //LUT[689] \tphase : -0.312500\t(data_i, data_q): (0.312500,-0.468750)\n\t690: o_phase = -9'd77;\t //LUT[690] \tphase : -0.300781\t(data_i, data_q): (0.312500,-0.437500)\n\t691: o_phase = -9'd75;\t //LUT[691] \tphase : -0.292969\t(data_i, data_q): (0.312500,-0.406250)\n\t692: o_phase = -9'd71;\t //LUT[692] \tphase : -0.277344\t(data_i, data_q): (0.312500,-0.375000)\n\t693: o_phase = -9'd68;\t //LUT[693] \tphase : -0.265625\t(data_i, data_q): (0.312500,-0.343750)\n\t694: o_phase = -9'd64;\t //LUT[694] \tphase : -0.250000\t(data_i, data_q): (0.312500,-0.312500)\n\t695: o_phase = -9'd60;\t //LUT[695] \tphase : -0.234375\t(data_i, data_q): (0.312500,-0.281250)\n\t696: o_phase = -9'd55;\t //LUT[696] \tphase : -0.214844\t(data_i, data_q): (0.312500,-0.250000)\n\t697: o_phase = -9'd50;\t //LUT[697] \tphase : -0.195312\t(data_i, data_q): (0.312500,-0.218750)\n\t698: o_phase = -9'd44;\t //LUT[698] \tphase : -0.171875\t(data_i, data_q): (0.312500,-0.187500)\n\t699: o_phase = -9'd38;\t //LUT[699] \tphase : -0.148438\t(data_i, data_q): (0.312500,-0.156250)\n\t700: o_phase = -9'd31;\t //LUT[700] \tphase : -0.121094\t(data_i, data_q): (0.312500,-0.125000)\n\t701: o_phase = -9'd24;\t //LUT[701] \tphase : -0.093750\t(data_i, data_q): (0.312500,-0.093750)\n\t702: o_phase = -9'd16;\t //LUT[702] \tphase : -0.062500\t(data_i, data_q): (0.312500,-0.062500)\n\t703: o_phase = -9'd8;\t //LUT[703] \tphase : -0.031250\t(data_i, data_q): (0.312500,-0.031250)\n\t704: o_phase = +9'd0;\t //LUT[704] \tphase : 0.000000\t(data_i, data_q): (0.343750,0.000000)\n\t705: o_phase = +9'd7;\t //LUT[705] \tphase : 0.027344\t(data_i, data_q): (0.343750,0.031250)\n\t706: o_phase = +9'd15;\t //LUT[706] \tphase : 0.058594\t(data_i, data_q): (0.343750,0.062500)\n\t707: o_phase = +9'd22;\t //LUT[707] \tphase : 0.085938\t(data_i, data_q): (0.343750,0.093750)\n\t708: o_phase = +9'd28;\t //LUT[708] \tphase : 0.109375\t(data_i, data_q): (0.343750,0.125000)\n\t709: o_phase = +9'd35;\t //LUT[709] \tphase : 0.136719\t(data_i, data_q): (0.343750,0.156250)\n\t710: o_phase = +9'd41;\t //LUT[710] \tphase : 0.160156\t(data_i, data_q): (0.343750,0.187500)\n\t711: o_phase = +9'd46;\t //LUT[711] \tphase : 0.179688\t(data_i, data_q): (0.343750,0.218750)\n\t712: o_phase = +9'd51;\t //LUT[712] \tphase : 0.199219\t(data_i, data_q): (0.343750,0.250000)\n\t713: o_phase = +9'd56;\t //LUT[713] \tphase : 0.218750\t(data_i, data_q): (0.343750,0.281250)\n\t714: o_phase = +9'd60;\t //LUT[714] \tphase : 0.234375\t(data_i, data_q): (0.343750,0.312500)\n\t715: o_phase = +9'd64;\t //LUT[715] \tphase : 0.250000\t(data_i, data_q): (0.343750,0.343750)\n\t716: o_phase = +9'd68;\t //LUT[716] \tphase : 0.265625\t(data_i, data_q): (0.343750,0.375000)\n\t717: o_phase = +9'd71;\t //LUT[717] \tphase : 0.277344\t(data_i, data_q): (0.343750,0.406250)\n\t718: o_phase = +9'd74;\t //LUT[718] \tphase : 0.289062\t(data_i, data_q): (0.343750,0.437500)\n\t719: o_phase = +9'd76;\t //LUT[719] \tphase : 0.296875\t(data_i, data_q): (0.343750,0.468750)\n\t720: o_phase = +9'd79;\t //LUT[720] \tphase : 0.308594\t(data_i, data_q): (0.343750,0.500000)\n\t721: o_phase = +9'd81;\t //LUT[721] \tphase : 0.316406\t(data_i, data_q): (0.343750,0.531250)\n\t722: o_phase = +9'd83;\t //LUT[722] \tphase : 0.324219\t(data_i, data_q): (0.343750,0.562500)\n\t723: o_phase = +9'd85;\t //LUT[723] \tphase : 0.332031\t(data_i, data_q): (0.343750,0.593750)\n\t724: o_phase = +9'd87;\t //LUT[724] \tphase : 0.339844\t(data_i, data_q): (0.343750,0.625000)\n\t725: o_phase = +9'd89;\t //LUT[725] \tphase : 0.347656\t(data_i, data_q): (0.343750,0.656250)\n\t726: o_phase = +9'd90;\t //LUT[726] \tphase : 0.351562\t(data_i, data_q): (0.343750,0.687500)\n\t727: o_phase = +9'd92;\t //LUT[727] \tphase : 0.359375\t(data_i, data_q): (0.343750,0.718750)\n\t728: o_phase = +9'd93;\t //LUT[728] \tphase : 0.363281\t(data_i, data_q): (0.343750,0.750000)\n\t729: o_phase = +9'd94;\t //LUT[729] \tphase : 0.367188\t(data_i, data_q): (0.343750,0.781250)\n\t730: o_phase = +9'd95;\t //LUT[730] \tphase : 0.371094\t(data_i, data_q): (0.343750,0.812500)\n\t731: o_phase = +9'd96;\t //LUT[731] \tphase : 0.375000\t(data_i, data_q): (0.343750,0.843750)\n\t732: o_phase = +9'd97;\t //LUT[732] \tphase : 0.378906\t(data_i, data_q): (0.343750,0.875000)\n\t733: o_phase = +9'd98;\t //LUT[733] \tphase : 0.382812\t(data_i, data_q): (0.343750,0.906250)\n\t734: o_phase = +9'd99;\t //LUT[734] \tphase : 0.386719\t(data_i, data_q): (0.343750,0.937500)\n\t735: o_phase = +9'd100;\t //LUT[735] \tphase : 0.390625\t(data_i, data_q): (0.343750,0.968750)\n\t736: o_phase = -9'd101;\t //LUT[736] \tphase : -0.394531\t(data_i, data_q): (0.343750,-1.000000)\n\t737: o_phase = -9'd100;\t //LUT[737] \tphase : -0.390625\t(data_i, data_q): (0.343750,-0.968750)\n\t738: o_phase = -9'd99;\t //LUT[738] \tphase : -0.386719\t(data_i, data_q): (0.343750,-0.937500)\n\t739: o_phase = -9'd98;\t //LUT[739] \tphase : -0.382812\t(data_i, data_q): (0.343750,-0.906250)\n\t740: o_phase = -9'd97;\t //LUT[740] \tphase : -0.378906\t(data_i, data_q): (0.343750,-0.875000)\n\t741: o_phase = -9'd96;\t //LUT[741] \tphase : -0.375000\t(data_i, data_q): (0.343750,-0.843750)\n\t742: o_phase = -9'd95;\t //LUT[742] \tphase : -0.371094\t(data_i, data_q): (0.343750,-0.812500)\n\t743: o_phase = -9'd94;\t //LUT[743] \tphase : -0.367188\t(data_i, data_q): (0.343750,-0.781250)\n\t744: o_phase = -9'd93;\t //LUT[744] \tphase : -0.363281\t(data_i, data_q): (0.343750,-0.750000)\n\t745: o_phase = -9'd92;\t //LUT[745] \tphase : -0.359375\t(data_i, data_q): (0.343750,-0.718750)\n\t746: o_phase = -9'd90;\t //LUT[746] \tphase : -0.351562\t(data_i, data_q): (0.343750,-0.687500)\n\t747: o_phase = -9'd89;\t //LUT[747] \tphase : -0.347656\t(data_i, data_q): (0.343750,-0.656250)\n\t748: o_phase = -9'd87;\t //LUT[748] \tphase : -0.339844\t(data_i, data_q): (0.343750,-0.625000)\n\t749: o_phase = -9'd85;\t //LUT[749] \tphase : -0.332031\t(data_i, data_q): (0.343750,-0.593750)\n\t750: o_phase = -9'd83;\t //LUT[750] \tphase : -0.324219\t(data_i, data_q): (0.343750,-0.562500)\n\t751: o_phase = -9'd81;\t //LUT[751] \tphase : -0.316406\t(data_i, data_q): (0.343750,-0.531250)\n\t752: o_phase = -9'd79;\t //LUT[752] \tphase : -0.308594\t(data_i, data_q): (0.343750,-0.500000)\n\t753: o_phase = -9'd76;\t //LUT[753] \tphase : -0.296875\t(data_i, data_q): (0.343750,-0.468750)\n\t754: o_phase = -9'd74;\t //LUT[754] \tphase : -0.289062\t(data_i, data_q): (0.343750,-0.437500)\n\t755: o_phase = -9'd71;\t //LUT[755] \tphase : -0.277344\t(data_i, data_q): (0.343750,-0.406250)\n\t756: o_phase = -9'd68;\t //LUT[756] \tphase : -0.265625\t(data_i, data_q): (0.343750,-0.375000)\n\t757: o_phase = -9'd64;\t //LUT[757] \tphase : -0.250000\t(data_i, data_q): (0.343750,-0.343750)\n\t758: o_phase = -9'd60;\t //LUT[758] \tphase : -0.234375\t(data_i, data_q): (0.343750,-0.312500)\n\t759: o_phase = -9'd56;\t //LUT[759] \tphase : -0.218750\t(data_i, data_q): (0.343750,-0.281250)\n\t760: o_phase = -9'd51;\t //LUT[760] \tphase : -0.199219\t(data_i, data_q): (0.343750,-0.250000)\n\t761: o_phase = -9'd46;\t //LUT[761] \tphase : -0.179688\t(data_i, data_q): (0.343750,-0.218750)\n\t762: o_phase = -9'd41;\t //LUT[762] \tphase : -0.160156\t(data_i, data_q): (0.343750,-0.187500)\n\t763: o_phase = -9'd35;\t //LUT[763] \tphase : -0.136719\t(data_i, data_q): (0.343750,-0.156250)\n\t764: o_phase = -9'd28;\t //LUT[764] \tphase : -0.109375\t(data_i, data_q): (0.343750,-0.125000)\n\t765: o_phase = -9'd22;\t //LUT[765] \tphase : -0.085938\t(data_i, data_q): (0.343750,-0.093750)\n\t766: o_phase = -9'd15;\t //LUT[766] \tphase : -0.058594\t(data_i, data_q): (0.343750,-0.062500)\n\t767: o_phase = -9'd7;\t //LUT[767] \tphase : -0.027344\t(data_i, data_q): (0.343750,-0.031250)\n\t768: o_phase = +9'd0;\t //LUT[768] \tphase : 0.000000\t(data_i, data_q): (0.375000,0.000000)\n\t769: o_phase = +9'd7;\t //LUT[769] \tphase : 0.027344\t(data_i, data_q): (0.375000,0.031250)\n\t770: o_phase = +9'd13;\t //LUT[770] \tphase : 0.050781\t(data_i, data_q): (0.375000,0.062500)\n\t771: o_phase = +9'd20;\t //LUT[771] \tphase : 0.078125\t(data_i, data_q): (0.375000,0.093750)\n\t772: o_phase = +9'd26;\t //LUT[772] \tphase : 0.101562\t(data_i, data_q): (0.375000,0.125000)\n\t773: o_phase = +9'd32;\t //LUT[773] \tphase : 0.125000\t(data_i, data_q): (0.375000,0.156250)\n\t774: o_phase = +9'd38;\t //LUT[774] \tphase : 0.148438\t(data_i, data_q): (0.375000,0.187500)\n\t775: o_phase = +9'd43;\t //LUT[775] \tphase : 0.167969\t(data_i, data_q): (0.375000,0.218750)\n\t776: o_phase = +9'd48;\t //LUT[776] \tphase : 0.187500\t(data_i, data_q): (0.375000,0.250000)\n\t777: o_phase = +9'd52;\t //LUT[777] \tphase : 0.203125\t(data_i, data_q): (0.375000,0.281250)\n\t778: o_phase = +9'd57;\t //LUT[778] \tphase : 0.222656\t(data_i, data_q): (0.375000,0.312500)\n\t779: o_phase = +9'd60;\t //LUT[779] \tphase : 0.234375\t(data_i, data_q): (0.375000,0.343750)\n\t780: o_phase = +9'd64;\t //LUT[780] \tphase : 0.250000\t(data_i, data_q): (0.375000,0.375000)\n\t781: o_phase = +9'd67;\t //LUT[781] \tphase : 0.261719\t(data_i, data_q): (0.375000,0.406250)\n\t782: o_phase = +9'd70;\t //LUT[782] \tphase : 0.273438\t(data_i, data_q): (0.375000,0.437500)\n\t783: o_phase = +9'd73;\t //LUT[783] \tphase : 0.285156\t(data_i, data_q): (0.375000,0.468750)\n\t784: o_phase = +9'd76;\t //LUT[784] \tphase : 0.296875\t(data_i, data_q): (0.375000,0.500000)\n\t785: o_phase = +9'd78;\t //LUT[785] \tphase : 0.304688\t(data_i, data_q): (0.375000,0.531250)\n\t786: o_phase = +9'd80;\t //LUT[786] \tphase : 0.312500\t(data_i, data_q): (0.375000,0.562500)\n\t787: o_phase = +9'd82;\t //LUT[787] \tphase : 0.320312\t(data_i, data_q): (0.375000,0.593750)\n\t788: o_phase = +9'd84;\t //LUT[788] \tphase : 0.328125\t(data_i, data_q): (0.375000,0.625000)\n\t789: o_phase = +9'd86;\t //LUT[789] \tphase : 0.335938\t(data_i, data_q): (0.375000,0.656250)\n\t790: o_phase = +9'd87;\t //LUT[790] \tphase : 0.339844\t(data_i, data_q): (0.375000,0.687500)\n\t791: o_phase = +9'd89;\t //LUT[791] \tphase : 0.347656\t(data_i, data_q): (0.375000,0.718750)\n\t792: o_phase = +9'd90;\t //LUT[792] \tphase : 0.351562\t(data_i, data_q): (0.375000,0.750000)\n\t793: o_phase = +9'd92;\t //LUT[793] \tphase : 0.359375\t(data_i, data_q): (0.375000,0.781250)\n\t794: o_phase = +9'd93;\t //LUT[794] \tphase : 0.363281\t(data_i, data_q): (0.375000,0.812500)\n\t795: o_phase = +9'd94;\t //LUT[795] \tphase : 0.367188\t(data_i, data_q): (0.375000,0.843750)\n\t796: o_phase = +9'd95;\t //LUT[796] \tphase : 0.371094\t(data_i, data_q): (0.375000,0.875000)\n\t797: o_phase = +9'd96;\t //LUT[797] \tphase : 0.375000\t(data_i, data_q): (0.375000,0.906250)\n\t798: o_phase = +9'd97;\t //LUT[798] \tphase : 0.378906\t(data_i, data_q): (0.375000,0.937500)\n\t799: o_phase = +9'd98;\t //LUT[799] \tphase : 0.382812\t(data_i, data_q): (0.375000,0.968750)\n\t800: o_phase = -9'd99;\t //LUT[800] \tphase : -0.386719\t(data_i, data_q): (0.375000,-1.000000)\n\t801: o_phase = -9'd98;\t //LUT[801] \tphase : -0.382812\t(data_i, data_q): (0.375000,-0.968750)\n\t802: o_phase = -9'd97;\t //LUT[802] \tphase : -0.378906\t(data_i, data_q): (0.375000,-0.937500)\n\t803: o_phase = -9'd96;\t //LUT[803] \tphase : -0.375000\t(data_i, data_q): (0.375000,-0.906250)\n\t804: o_phase = -9'd95;\t //LUT[804] \tphase : -0.371094\t(data_i, data_q): (0.375000,-0.875000)\n\t805: o_phase = -9'd94;\t //LUT[805] \tphase : -0.367188\t(data_i, data_q): (0.375000,-0.843750)\n\t806: o_phase = -9'd93;\t //LUT[806] \tphase : -0.363281\t(data_i, data_q): (0.375000,-0.812500)\n\t807: o_phase = -9'd92;\t //LUT[807] \tphase : -0.359375\t(data_i, data_q): (0.375000,-0.781250)\n\t808: o_phase = -9'd90;\t //LUT[808] \tphase : -0.351562\t(data_i, data_q): (0.375000,-0.750000)\n\t809: o_phase = -9'd89;\t //LUT[809] \tphase : -0.347656\t(data_i, data_q): (0.375000,-0.718750)\n\t810: o_phase = -9'd87;\t //LUT[810] \tphase : -0.339844\t(data_i, data_q): (0.375000,-0.687500)\n\t811: o_phase = -9'd86;\t //LUT[811] \tphase : -0.335938\t(data_i, data_q): (0.375000,-0.656250)\n\t812: o_phase = -9'd84;\t //LUT[812] \tphase : -0.328125\t(data_i, data_q): (0.375000,-0.625000)\n\t813: o_phase = -9'd82;\t //LUT[813] \tphase : -0.320312\t(data_i, data_q): (0.375000,-0.593750)\n\t814: o_phase = -9'd80;\t //LUT[814] \tphase : -0.312500\t(data_i, data_q): (0.375000,-0.562500)\n\t815: o_phase = -9'd78;\t //LUT[815] \tphase : -0.304688\t(data_i, data_q): (0.375000,-0.531250)\n\t816: o_phase = -9'd76;\t //LUT[816] \tphase : -0.296875\t(data_i, data_q): (0.375000,-0.500000)\n\t817: o_phase = -9'd73;\t //LUT[817] \tphase : -0.285156\t(data_i, data_q): (0.375000,-0.468750)\n\t818: o_phase = -9'd70;\t //LUT[818] \tphase : -0.273438\t(data_i, data_q): (0.375000,-0.437500)\n\t819: o_phase = -9'd67;\t //LUT[819] \tphase : -0.261719\t(data_i, data_q): (0.375000,-0.406250)\n\t820: o_phase = -9'd64;\t //LUT[820] \tphase : -0.250000\t(data_i, data_q): (0.375000,-0.375000)\n\t821: o_phase = -9'd60;\t //LUT[821] \tphase : -0.234375\t(data_i, data_q): (0.375000,-0.343750)\n\t822: o_phase = -9'd57;\t //LUT[822] \tphase : -0.222656\t(data_i, data_q): (0.375000,-0.312500)\n\t823: o_phase = -9'd52;\t //LUT[823] \tphase : -0.203125\t(data_i, data_q): (0.375000,-0.281250)\n\t824: o_phase = -9'd48;\t //LUT[824] \tphase : -0.187500\t(data_i, data_q): (0.375000,-0.250000)\n\t825: o_phase = -9'd43;\t //LUT[825] \tphase : -0.167969\t(data_i, data_q): (0.375000,-0.218750)\n\t826: o_phase = -9'd38;\t //LUT[826] \tphase : -0.148438\t(data_i, data_q): (0.375000,-0.187500)\n\t827: o_phase = -9'd32;\t //LUT[827] \tphase : -0.125000\t(data_i, data_q): (0.375000,-0.156250)\n\t828: o_phase = -9'd26;\t //LUT[828] \tphase : -0.101562\t(data_i, data_q): (0.375000,-0.125000)\n\t829: o_phase = -9'd20;\t //LUT[829] \tphase : -0.078125\t(data_i, data_q): (0.375000,-0.093750)\n\t830: o_phase = -9'd13;\t //LUT[830] \tphase : -0.050781\t(data_i, data_q): (0.375000,-0.062500)\n\t831: o_phase = -9'd7;\t //LUT[831] \tphase : -0.027344\t(data_i, data_q): (0.375000,-0.031250)\n\t832: o_phase = +9'd0;\t //LUT[832] \tphase : 0.000000\t(data_i, data_q): (0.406250,0.000000)\n\t833: o_phase = +9'd6;\t //LUT[833] \tphase : 0.023438\t(data_i, data_q): (0.406250,0.031250)\n\t834: o_phase = +9'd12;\t //LUT[834] \tphase : 0.046875\t(data_i, data_q): (0.406250,0.062500)\n\t835: o_phase = +9'd18;\t //LUT[835] \tphase : 0.070312\t(data_i, data_q): (0.406250,0.093750)\n\t836: o_phase = +9'd24;\t //LUT[836] \tphase : 0.093750\t(data_i, data_q): (0.406250,0.125000)\n\t837: o_phase = +9'd30;\t //LUT[837] \tphase : 0.117188\t(data_i, data_q): (0.406250,0.156250)\n\t838: o_phase = +9'd35;\t //LUT[838] \tphase : 0.136719\t(data_i, data_q): (0.406250,0.187500)\n\t839: o_phase = +9'd40;\t //LUT[839] \tphase : 0.156250\t(data_i, data_q): (0.406250,0.218750)\n\t840: o_phase = +9'd45;\t //LUT[840] \tphase : 0.175781\t(data_i, data_q): (0.406250,0.250000)\n\t841: o_phase = +9'd49;\t //LUT[841] \tphase : 0.191406\t(data_i, data_q): (0.406250,0.281250)\n\t842: o_phase = +9'd53;\t //LUT[842] \tphase : 0.207031\t(data_i, data_q): (0.406250,0.312500)\n\t843: o_phase = +9'd57;\t //LUT[843] \tphase : 0.222656\t(data_i, data_q): (0.406250,0.343750)\n\t844: o_phase = +9'd61;\t //LUT[844] \tphase : 0.238281\t(data_i, data_q): (0.406250,0.375000)\n\t845: o_phase = +9'd64;\t //LUT[845] \tphase : 0.250000\t(data_i, data_q): (0.406250,0.406250)\n\t846: o_phase = +9'd67;\t //LUT[846] \tphase : 0.261719\t(data_i, data_q): (0.406250,0.437500)\n\t847: o_phase = +9'd70;\t //LUT[847] \tphase : 0.273438\t(data_i, data_q): (0.406250,0.468750)\n\t848: o_phase = +9'd72;\t //LUT[848] \tphase : 0.281250\t(data_i, data_q): (0.406250,0.500000)\n\t849: o_phase = +9'd75;\t //LUT[849] \tphase : 0.292969\t(data_i, data_q): (0.406250,0.531250)\n\t850: o_phase = +9'd77;\t //LUT[850] \tphase : 0.300781\t(data_i, data_q): (0.406250,0.562500)\n\t851: o_phase = +9'd79;\t //LUT[851] \tphase : 0.308594\t(data_i, data_q): (0.406250,0.593750)\n\t852: o_phase = +9'd81;\t //LUT[852] \tphase : 0.316406\t(data_i, data_q): (0.406250,0.625000)\n\t853: o_phase = +9'd83;\t //LUT[853] \tphase : 0.324219\t(data_i, data_q): (0.406250,0.656250)\n\t854: o_phase = +9'd85;\t //LUT[854] \tphase : 0.332031\t(data_i, data_q): (0.406250,0.687500)\n\t855: o_phase = +9'd86;\t //LUT[855] \tphase : 0.335938\t(data_i, data_q): (0.406250,0.718750)\n\t856: o_phase = +9'd88;\t //LUT[856] \tphase : 0.343750\t(data_i, data_q): (0.406250,0.750000)\n\t857: o_phase = +9'd89;\t //LUT[857] \tphase : 0.347656\t(data_i, data_q): (0.406250,0.781250)\n\t858: o_phase = +9'd90;\t //LUT[858] \tphase : 0.351562\t(data_i, data_q): (0.406250,0.812500)\n\t859: o_phase = +9'd91;\t //LUT[859] \tphase : 0.355469\t(data_i, data_q): (0.406250,0.843750)\n\t860: o_phase = +9'd93;\t //LUT[860] \tphase : 0.363281\t(data_i, data_q): (0.406250,0.875000)\n\t861: o_phase = +9'd94;\t //LUT[861] \tphase : 0.367188\t(data_i, data_q): (0.406250,0.906250)\n\t862: o_phase = +9'd95;\t //LUT[862] \tphase : 0.371094\t(data_i, data_q): (0.406250,0.937500)\n\t863: o_phase = +9'd96;\t //LUT[863] \tphase : 0.375000\t(data_i, data_q): (0.406250,0.968750)\n\t864: o_phase = -9'd97;\t //LUT[864] \tphase : -0.378906\t(data_i, data_q): (0.406250,-1.000000)\n\t865: o_phase = -9'd96;\t //LUT[865] \tphase : -0.375000\t(data_i, data_q): (0.406250,-0.968750)\n\t866: o_phase = -9'd95;\t //LUT[866] \tphase : -0.371094\t(data_i, data_q): (0.406250,-0.937500)\n\t867: o_phase = -9'd94;\t //LUT[867] \tphase : -0.367188\t(data_i, data_q): (0.406250,-0.906250)\n\t868: o_phase = -9'd93;\t //LUT[868] \tphase : -0.363281\t(data_i, data_q): (0.406250,-0.875000)\n\t869: o_phase = -9'd91;\t //LUT[869] \tphase : -0.355469\t(data_i, data_q): (0.406250,-0.843750)\n\t870: o_phase = -9'd90;\t //LUT[870] \tphase : -0.351562\t(data_i, data_q): (0.406250,-0.812500)\n\t871: o_phase = -9'd89;\t //LUT[871] \tphase : -0.347656\t(data_i, data_q): (0.406250,-0.781250)\n\t872: o_phase = -9'd88;\t //LUT[872] \tphase : -0.343750\t(data_i, data_q): (0.406250,-0.750000)\n\t873: o_phase = -9'd86;\t //LUT[873] \tphase : -0.335938\t(data_i, data_q): (0.406250,-0.718750)\n\t874: o_phase = -9'd85;\t //LUT[874] \tphase : -0.332031\t(data_i, data_q): (0.406250,-0.687500)\n\t875: o_phase = -9'd83;\t //LUT[875] \tphase : -0.324219\t(data_i, data_q): (0.406250,-0.656250)\n\t876: o_phase = -9'd81;\t //LUT[876] \tphase : -0.316406\t(data_i, data_q): (0.406250,-0.625000)\n\t877: o_phase = -9'd79;\t //LUT[877] \tphase : -0.308594\t(data_i, data_q): (0.406250,-0.593750)\n\t878: o_phase = -9'd77;\t //LUT[878] \tphase : -0.300781\t(data_i, data_q): (0.406250,-0.562500)\n\t879: o_phase = -9'd75;\t //LUT[879] \tphase : -0.292969\t(data_i, data_q): (0.406250,-0.531250)\n\t880: o_phase = -9'd72;\t //LUT[880] \tphase : -0.281250\t(data_i, data_q): (0.406250,-0.500000)\n\t881: o_phase = -9'd70;\t //LUT[881] \tphase : -0.273438\t(data_i, data_q): (0.406250,-0.468750)\n\t882: o_phase = -9'd67;\t //LUT[882] \tphase : -0.261719\t(data_i, data_q): (0.406250,-0.437500)\n\t883: o_phase = -9'd64;\t //LUT[883] \tphase : -0.250000\t(data_i, data_q): (0.406250,-0.406250)\n\t884: o_phase = -9'd61;\t //LUT[884] \tphase : -0.238281\t(data_i, data_q): (0.406250,-0.375000)\n\t885: o_phase = -9'd57;\t //LUT[885] \tphase : -0.222656\t(data_i, data_q): (0.406250,-0.343750)\n\t886: o_phase = -9'd53;\t //LUT[886] \tphase : -0.207031\t(data_i, data_q): (0.406250,-0.312500)\n\t887: o_phase = -9'd49;\t //LUT[887] \tphase : -0.191406\t(data_i, data_q): (0.406250,-0.281250)\n\t888: o_phase = -9'd45;\t //LUT[888] \tphase : -0.175781\t(data_i, data_q): (0.406250,-0.250000)\n\t889: o_phase = -9'd40;\t //LUT[889] \tphase : -0.156250\t(data_i, data_q): (0.406250,-0.218750)\n\t890: o_phase = -9'd35;\t //LUT[890] \tphase : -0.136719\t(data_i, data_q): (0.406250,-0.187500)\n\t891: o_phase = -9'd30;\t //LUT[891] \tphase : -0.117188\t(data_i, data_q): (0.406250,-0.156250)\n\t892: o_phase = -9'd24;\t //LUT[892] \tphase : -0.093750\t(data_i, data_q): (0.406250,-0.125000)\n\t893: o_phase = -9'd18;\t //LUT[893] \tphase : -0.070312\t(data_i, data_q): (0.406250,-0.093750)\n\t894: o_phase = -9'd12;\t //LUT[894] \tphase : -0.046875\t(data_i, data_q): (0.406250,-0.062500)\n\t895: o_phase = -9'd6;\t //LUT[895] \tphase : -0.023438\t(data_i, data_q): (0.406250,-0.031250)\n\t896: o_phase = +9'd0;\t //LUT[896] \tphase : 0.000000\t(data_i, data_q): (0.437500,0.000000)\n\t897: o_phase = +9'd6;\t //LUT[897] \tphase : 0.023438\t(data_i, data_q): (0.437500,0.031250)\n\t898: o_phase = +9'd12;\t //LUT[898] \tphase : 0.046875\t(data_i, data_q): (0.437500,0.062500)\n\t899: o_phase = +9'd17;\t //LUT[899] \tphase : 0.066406\t(data_i, data_q): (0.437500,0.093750)\n\t900: o_phase = +9'd23;\t //LUT[900] \tphase : 0.089844\t(data_i, data_q): (0.437500,0.125000)\n\t901: o_phase = +9'd28;\t //LUT[901] \tphase : 0.109375\t(data_i, data_q): (0.437500,0.156250)\n\t902: o_phase = +9'd33;\t //LUT[902] \tphase : 0.128906\t(data_i, data_q): (0.437500,0.187500)\n\t903: o_phase = +9'd38;\t //LUT[903] \tphase : 0.148438\t(data_i, data_q): (0.437500,0.218750)\n\t904: o_phase = +9'd42;\t //LUT[904] \tphase : 0.164062\t(data_i, data_q): (0.437500,0.250000)\n\t905: o_phase = +9'd47;\t //LUT[905] \tphase : 0.183594\t(data_i, data_q): (0.437500,0.281250)\n\t906: o_phase = +9'd51;\t //LUT[906] \tphase : 0.199219\t(data_i, data_q): (0.437500,0.312500)\n\t907: o_phase = +9'd54;\t //LUT[907] \tphase : 0.210938\t(data_i, data_q): (0.437500,0.343750)\n\t908: o_phase = +9'd58;\t //LUT[908] \tphase : 0.226562\t(data_i, data_q): (0.437500,0.375000)\n\t909: o_phase = +9'd61;\t //LUT[909] \tphase : 0.238281\t(data_i, data_q): (0.437500,0.406250)\n\t910: o_phase = +9'd64;\t //LUT[910] \tphase : 0.250000\t(data_i, data_q): (0.437500,0.437500)\n\t911: o_phase = +9'd67;\t //LUT[911] \tphase : 0.261719\t(data_i, data_q): (0.437500,0.468750)\n\t912: o_phase = +9'd69;\t //LUT[912] \tphase : 0.269531\t(data_i, data_q): (0.437500,0.500000)\n\t913: o_phase = +9'd72;\t //LUT[913] \tphase : 0.281250\t(data_i, data_q): (0.437500,0.531250)\n\t914: o_phase = +9'd74;\t //LUT[914] \tphase : 0.289062\t(data_i, data_q): (0.437500,0.562500)\n\t915: o_phase = +9'd76;\t //LUT[915] \tphase : 0.296875\t(data_i, data_q): (0.437500,0.593750)\n\t916: o_phase = +9'd78;\t //LUT[916] \tphase : 0.304688\t(data_i, data_q): (0.437500,0.625000)\n\t917: o_phase = +9'd80;\t //LUT[917] \tphase : 0.312500\t(data_i, data_q): (0.437500,0.656250)\n\t918: o_phase = +9'd82;\t //LUT[918] \tphase : 0.320312\t(data_i, data_q): (0.437500,0.687500)\n\t919: o_phase = +9'd83;\t //LUT[919] \tphase : 0.324219\t(data_i, data_q): (0.437500,0.718750)\n\t920: o_phase = +9'd85;\t //LUT[920] \tphase : 0.332031\t(data_i, data_q): (0.437500,0.750000)\n\t921: o_phase = +9'd86;\t //LUT[921] \tphase : 0.335938\t(data_i, data_q): (0.437500,0.781250)\n\t922: o_phase = +9'd88;\t //LUT[922] \tphase : 0.343750\t(data_i, data_q): (0.437500,0.812500)\n\t923: o_phase = +9'd89;\t //LUT[923] \tphase : 0.347656\t(data_i, data_q): (0.437500,0.843750)\n\t924: o_phase = +9'd90;\t //LUT[924] \tphase : 0.351562\t(data_i, data_q): (0.437500,0.875000)\n\t925: o_phase = +9'd91;\t //LUT[925] \tphase : 0.355469\t(data_i, data_q): (0.437500,0.906250)\n\t926: o_phase = +9'd92;\t //LUT[926] \tphase : 0.359375\t(data_i, data_q): (0.437500,0.937500)\n\t927: o_phase = +9'd93;\t //LUT[927] \tphase : 0.363281\t(data_i, data_q): (0.437500,0.968750)\n\t928: o_phase = -9'd94;\t //LUT[928] \tphase : -0.367188\t(data_i, data_q): (0.437500,-1.000000)\n\t929: o_phase = -9'd93;\t //LUT[929] \tphase : -0.363281\t(data_i, data_q): (0.437500,-0.968750)\n\t930: o_phase = -9'd92;\t //LUT[930] \tphase : -0.359375\t(data_i, data_q): (0.437500,-0.937500)\n\t931: o_phase = -9'd91;\t //LUT[931] \tphase : -0.355469\t(data_i, data_q): (0.437500,-0.906250)\n\t932: o_phase = -9'd90;\t //LUT[932] \tphase : -0.351562\t(data_i, data_q): (0.437500,-0.875000)\n\t933: o_phase = -9'd89;\t //LUT[933] \tphase : -0.347656\t(data_i, data_q): (0.437500,-0.843750)\n\t934: o_phase = -9'd88;\t //LUT[934] \tphase : -0.343750\t(data_i, data_q): (0.437500,-0.812500)\n\t935: o_phase = -9'd86;\t //LUT[935] \tphase : -0.335938\t(data_i, data_q): (0.437500,-0.781250)\n\t936: o_phase = -9'd85;\t //LUT[936] \tphase : -0.332031\t(data_i, data_q): (0.437500,-0.750000)\n\t937: o_phase = -9'd83;\t //LUT[937] \tphase : -0.324219\t(data_i, data_q): (0.437500,-0.718750)\n\t938: o_phase = -9'd82;\t //LUT[938] \tphase : -0.320312\t(data_i, data_q): (0.437500,-0.687500)\n\t939: o_phase = -9'd80;\t //LUT[939] \tphase : -0.312500\t(data_i, data_q): (0.437500,-0.656250)\n\t940: o_phase = -9'd78;\t //LUT[940] \tphase : -0.304688\t(data_i, data_q): (0.437500,-0.625000)\n\t941: o_phase = -9'd76;\t //LUT[941] \tphase : -0.296875\t(data_i, data_q): (0.437500,-0.593750)\n\t942: o_phase = -9'd74;\t //LUT[942] \tphase : -0.289062\t(data_i, data_q): (0.437500,-0.562500)\n\t943: o_phase = -9'd72;\t //LUT[943] \tphase : -0.281250\t(data_i, data_q): (0.437500,-0.531250)\n\t944: o_phase = -9'd69;\t //LUT[944] \tphase : -0.269531\t(data_i, data_q): (0.437500,-0.500000)\n\t945: o_phase = -9'd67;\t //LUT[945] \tphase : -0.261719\t(data_i, data_q): (0.437500,-0.468750)\n\t946: o_phase = -9'd64;\t //LUT[946] \tphase : -0.250000\t(data_i, data_q): (0.437500,-0.437500)\n\t947: o_phase = -9'd61;\t //LUT[947] \tphase : -0.238281\t(data_i, data_q): (0.437500,-0.406250)\n\t948: o_phase = -9'd58;\t //LUT[948] \tphase : -0.226562\t(data_i, data_q): (0.437500,-0.375000)\n\t949: o_phase = -9'd54;\t //LUT[949] \tphase : -0.210938\t(data_i, data_q): (0.437500,-0.343750)\n\t950: o_phase = -9'd51;\t //LUT[950] \tphase : -0.199219\t(data_i, data_q): (0.437500,-0.312500)\n\t951: o_phase = -9'd47;\t //LUT[951] \tphase : -0.183594\t(data_i, data_q): (0.437500,-0.281250)\n\t952: o_phase = -9'd42;\t //LUT[952] \tphase : -0.164062\t(data_i, data_q): (0.437500,-0.250000)\n\t953: o_phase = -9'd38;\t //LUT[953] \tphase : -0.148438\t(data_i, data_q): (0.437500,-0.218750)\n\t954: o_phase = -9'd33;\t //LUT[954] \tphase : -0.128906\t(data_i, data_q): (0.437500,-0.187500)\n\t955: o_phase = -9'd28;\t //LUT[955] \tphase : -0.109375\t(data_i, data_q): (0.437500,-0.156250)\n\t956: o_phase = -9'd23;\t //LUT[956] \tphase : -0.089844\t(data_i, data_q): (0.437500,-0.125000)\n\t957: o_phase = -9'd17;\t //LUT[957] \tphase : -0.066406\t(data_i, data_q): (0.437500,-0.093750)\n\t958: o_phase = -9'd12;\t //LUT[958] \tphase : -0.046875\t(data_i, data_q): (0.437500,-0.062500)\n\t959: o_phase = -9'd6;\t //LUT[959] \tphase : -0.023438\t(data_i, data_q): (0.437500,-0.031250)\n\t960: o_phase = +9'd0;\t //LUT[960] \tphase : 0.000000\t(data_i, data_q): (0.468750,0.000000)\n\t961: o_phase = +9'd5;\t //LUT[961] \tphase : 0.019531\t(data_i, data_q): (0.468750,0.031250)\n\t962: o_phase = +9'd11;\t //LUT[962] \tphase : 0.042969\t(data_i, data_q): (0.468750,0.062500)\n\t963: o_phase = +9'd16;\t //LUT[963] \tphase : 0.062500\t(data_i, data_q): (0.468750,0.093750)\n\t964: o_phase = +9'd21;\t //LUT[964] \tphase : 0.082031\t(data_i, data_q): (0.468750,0.125000)\n\t965: o_phase = +9'd26;\t //LUT[965] \tphase : 0.101562\t(data_i, data_q): (0.468750,0.156250)\n\t966: o_phase = +9'd31;\t //LUT[966] \tphase : 0.121094\t(data_i, data_q): (0.468750,0.187500)\n\t967: o_phase = +9'd36;\t //LUT[967] \tphase : 0.140625\t(data_i, data_q): (0.468750,0.218750)\n\t968: o_phase = +9'd40;\t //LUT[968] \tphase : 0.156250\t(data_i, data_q): (0.468750,0.250000)\n\t969: o_phase = +9'd44;\t //LUT[969] \tphase : 0.171875\t(data_i, data_q): (0.468750,0.281250)\n\t970: o_phase = +9'd48;\t //LUT[970] \tphase : 0.187500\t(data_i, data_q): (0.468750,0.312500)\n\t971: o_phase = +9'd52;\t //LUT[971] \tphase : 0.203125\t(data_i, data_q): (0.468750,0.343750)\n\t972: o_phase = +9'd55;\t //LUT[972] \tphase : 0.214844\t(data_i, data_q): (0.468750,0.375000)\n\t973: o_phase = +9'd58;\t //LUT[973] \tphase : 0.226562\t(data_i, data_q): (0.468750,0.406250)\n\t974: o_phase = +9'd61;\t //LUT[974] \tphase : 0.238281\t(data_i, data_q): (0.468750,0.437500)\n\t975: o_phase = +9'd64;\t //LUT[975] \tphase : 0.250000\t(data_i, data_q): (0.468750,0.468750)\n\t976: o_phase = +9'd67;\t //LUT[976] \tphase : 0.261719\t(data_i, data_q): (0.468750,0.500000)\n\t977: o_phase = +9'd69;\t //LUT[977] \tphase : 0.269531\t(data_i, data_q): (0.468750,0.531250)\n\t978: o_phase = +9'd71;\t //LUT[978] \tphase : 0.277344\t(data_i, data_q): (0.468750,0.562500)\n\t979: o_phase = +9'd74;\t //LUT[979] \tphase : 0.289062\t(data_i, data_q): (0.468750,0.593750)\n\t980: o_phase = +9'd76;\t //LUT[980] \tphase : 0.296875\t(data_i, data_q): (0.468750,0.625000)\n\t981: o_phase = +9'd77;\t //LUT[981] \tphase : 0.300781\t(data_i, data_q): (0.468750,0.656250)\n\t982: o_phase = +9'd79;\t //LUT[982] \tphase : 0.308594\t(data_i, data_q): (0.468750,0.687500)\n\t983: o_phase = +9'd81;\t //LUT[983] \tphase : 0.316406\t(data_i, data_q): (0.468750,0.718750)\n\t984: o_phase = +9'd82;\t //LUT[984] \tphase : 0.320312\t(data_i, data_q): (0.468750,0.750000)\n\t985: o_phase = +9'd84;\t //LUT[985] \tphase : 0.328125\t(data_i, data_q): (0.468750,0.781250)\n\t986: o_phase = +9'd85;\t //LUT[986] \tphase : 0.332031\t(data_i, data_q): (0.468750,0.812500)\n\t987: o_phase = +9'd87;\t //LUT[987] \tphase : 0.339844\t(data_i, data_q): (0.468750,0.843750)\n\t988: o_phase = +9'd88;\t //LUT[988] \tphase : 0.343750\t(data_i, data_q): (0.468750,0.875000)\n\t989: o_phase = +9'd89;\t //LUT[989] \tphase : 0.347656\t(data_i, data_q): (0.468750,0.906250)\n\t990: o_phase = +9'd90;\t //LUT[990] \tphase : 0.351562\t(data_i, data_q): (0.468750,0.937500)\n\t991: o_phase = +9'd91;\t //LUT[991] \tphase : 0.355469\t(data_i, data_q): (0.468750,0.968750)\n\t992: o_phase = -9'd92;\t //LUT[992] \tphase : -0.359375\t(data_i, data_q): (0.468750,-1.000000)\n\t993: o_phase = -9'd91;\t //LUT[993] \tphase : -0.355469\t(data_i, data_q): (0.468750,-0.968750)\n\t994: o_phase = -9'd90;\t //LUT[994] \tphase : -0.351562\t(data_i, data_q): (0.468750,-0.937500)\n\t995: o_phase = -9'd89;\t //LUT[995] \tphase : -0.347656\t(data_i, data_q): (0.468750,-0.906250)\n\t996: o_phase = -9'd88;\t //LUT[996] \tphase : -0.343750\t(data_i, data_q): (0.468750,-0.875000)\n\t997: o_phase = -9'd87;\t //LUT[997] \tphase : -0.339844\t(data_i, data_q): (0.468750,-0.843750)\n\t998: o_phase = -9'd85;\t //LUT[998] \tphase : -0.332031\t(data_i, data_q): (0.468750,-0.812500)\n\t999: o_phase = -9'd84;\t //LUT[999] \tphase : -0.328125\t(data_i, data_q): (0.468750,-0.781250)\n\t1000: o_phase = -9'd82;\t //LUT[1000] \tphase : -0.320312\t(data_i, data_q): (0.468750,-0.750000)\n\t1001: o_phase = -9'd81;\t //LUT[1001] \tphase : -0.316406\t(data_i, data_q): (0.468750,-0.718750)\n\t1002: o_phase = -9'd79;\t //LUT[1002] \tphase : -0.308594\t(data_i, data_q): (0.468750,-0.687500)\n\t1003: o_phase = -9'd77;\t //LUT[1003] \tphase : -0.300781\t(data_i, data_q): (0.468750,-0.656250)\n\t1004: o_phase = -9'd76;\t //LUT[1004] \tphase : -0.296875\t(data_i, data_q): (0.468750,-0.625000)\n\t1005: o_phase = -9'd74;\t //LUT[1005] \tphase : -0.289062\t(data_i, data_q): (0.468750,-0.593750)\n\t1006: o_phase = -9'd71;\t //LUT[1006] \tphase : -0.277344\t(data_i, data_q): (0.468750,-0.562500)\n\t1007: o_phase = -9'd69;\t //LUT[1007] \tphase : -0.269531\t(data_i, data_q): (0.468750,-0.531250)\n\t1008: o_phase = -9'd67;\t //LUT[1008] \tphase : -0.261719\t(data_i, data_q): (0.468750,-0.500000)\n\t1009: o_phase = -9'd64;\t //LUT[1009] \tphase : -0.250000\t(data_i, data_q): (0.468750,-0.468750)\n\t1010: o_phase = -9'd61;\t //LUT[1010] \tphase : -0.238281\t(data_i, data_q): (0.468750,-0.437500)\n\t1011: o_phase = -9'd58;\t //LUT[1011] \tphase : -0.226562\t(data_i, data_q): (0.468750,-0.406250)\n\t1012: o_phase = -9'd55;\t //LUT[1012] \tphase : -0.214844\t(data_i, data_q): (0.468750,-0.375000)\n\t1013: o_phase = -9'd52;\t //LUT[1013] \tphase : -0.203125\t(data_i, data_q): (0.468750,-0.343750)\n\t1014: o_phase = -9'd48;\t //LUT[1014] \tphase : -0.187500\t(data_i, data_q): (0.468750,-0.312500)\n\t1015: o_phase = -9'd44;\t //LUT[1015] \tphase : -0.171875\t(data_i, data_q): (0.468750,-0.281250)\n\t1016: o_phase = -9'd40;\t //LUT[1016] \tphase : -0.156250\t(data_i, data_q): (0.468750,-0.250000)\n\t1017: o_phase = -9'd36;\t //LUT[1017] \tphase : -0.140625\t(data_i, data_q): (0.468750,-0.218750)\n\t1018: o_phase = -9'd31;\t //LUT[1018] \tphase : -0.121094\t(data_i, data_q): (0.468750,-0.187500)\n\t1019: o_phase = -9'd26;\t //LUT[1019] \tphase : -0.101562\t(data_i, data_q): (0.468750,-0.156250)\n\t1020: o_phase = -9'd21;\t //LUT[1020] \tphase : -0.082031\t(data_i, data_q): (0.468750,-0.125000)\n\t1021: o_phase = -9'd16;\t //LUT[1021] \tphase : -0.062500\t(data_i, data_q): (0.468750,-0.093750)\n\t1022: o_phase = -9'd11;\t //LUT[1022] \tphase : -0.042969\t(data_i, data_q): (0.468750,-0.062500)\n\t1023: o_phase = -9'd5;\t //LUT[1023] \tphase : -0.019531\t(data_i, data_q): (0.468750,-0.031250)\n\t1024: o_phase = +9'd0;\t //LUT[1024] \tphase : 0.000000\t(data_i, data_q): (0.500000,0.000000)\n\t1025: o_phase = +9'd5;\t //LUT[1025] \tphase : 0.019531\t(data_i, data_q): (0.500000,0.031250)\n\t1026: o_phase = +9'd10;\t //LUT[1026] \tphase : 0.039062\t(data_i, data_q): (0.500000,0.062500)\n\t1027: o_phase = +9'd15;\t //LUT[1027] \tphase : 0.058594\t(data_i, data_q): (0.500000,0.093750)\n\t1028: o_phase = +9'd20;\t //LUT[1028] \tphase : 0.078125\t(data_i, data_q): (0.500000,0.125000)\n\t1029: o_phase = +9'd25;\t //LUT[1029] \tphase : 0.097656\t(data_i, data_q): (0.500000,0.156250)\n\t1030: o_phase = +9'd29;\t //LUT[1030] \tphase : 0.113281\t(data_i, data_q): (0.500000,0.187500)\n\t1031: o_phase = +9'd34;\t //LUT[1031] \tphase : 0.132812\t(data_i, data_q): (0.500000,0.218750)\n\t1032: o_phase = +9'd38;\t //LUT[1032] \tphase : 0.148438\t(data_i, data_q): (0.500000,0.250000)\n\t1033: o_phase = +9'd42;\t //LUT[1033] \tphase : 0.164062\t(data_i, data_q): (0.500000,0.281250)\n\t1034: o_phase = +9'd46;\t //LUT[1034] \tphase : 0.179688\t(data_i, data_q): (0.500000,0.312500)\n\t1035: o_phase = +9'd49;\t //LUT[1035] \tphase : 0.191406\t(data_i, data_q): (0.500000,0.343750)\n\t1036: o_phase = +9'd52;\t //LUT[1036] \tphase : 0.203125\t(data_i, data_q): (0.500000,0.375000)\n\t1037: o_phase = +9'd56;\t //LUT[1037] \tphase : 0.218750\t(data_i, data_q): (0.500000,0.406250)\n\t1038: o_phase = +9'd59;\t //LUT[1038] \tphase : 0.230469\t(data_i, data_q): (0.500000,0.437500)\n\t1039: o_phase = +9'd61;\t //LUT[1039] \tphase : 0.238281\t(data_i, data_q): (0.500000,0.468750)\n\t1040: o_phase = +9'd64;\t //LUT[1040] \tphase : 0.250000\t(data_i, data_q): (0.500000,0.500000)\n\t1041: o_phase = +9'd66;\t //LUT[1041] \tphase : 0.257812\t(data_i, data_q): (0.500000,0.531250)\n\t1042: o_phase = +9'd69;\t //LUT[1042] \tphase : 0.269531\t(data_i, data_q): (0.500000,0.562500)\n\t1043: o_phase = +9'd71;\t //LUT[1043] \tphase : 0.277344\t(data_i, data_q): (0.500000,0.593750)\n\t1044: o_phase = +9'd73;\t //LUT[1044] \tphase : 0.285156\t(data_i, data_q): (0.500000,0.625000)\n\t1045: o_phase = +9'd75;\t //LUT[1045] \tphase : 0.292969\t(data_i, data_q): (0.500000,0.656250)\n\t1046: o_phase = +9'd77;\t //LUT[1046] \tphase : 0.300781\t(data_i, data_q): (0.500000,0.687500)\n\t1047: o_phase = +9'd78;\t //LUT[1047] \tphase : 0.304688\t(data_i, data_q): (0.500000,0.718750)\n\t1048: o_phase = +9'd80;\t //LUT[1048] \tphase : 0.312500\t(data_i, data_q): (0.500000,0.750000)\n\t1049: o_phase = +9'd82;\t //LUT[1049] \tphase : 0.320312\t(data_i, data_q): (0.500000,0.781250)\n\t1050: o_phase = +9'd83;\t //LUT[1050] \tphase : 0.324219\t(data_i, data_q): (0.500000,0.812500)\n\t1051: o_phase = +9'd84;\t //LUT[1051] \tphase : 0.328125\t(data_i, data_q): (0.500000,0.843750)\n\t1052: o_phase = +9'd86;\t //LUT[1052] \tphase : 0.335938\t(data_i, data_q): (0.500000,0.875000)\n\t1053: o_phase = +9'd87;\t //LUT[1053] \tphase : 0.339844\t(data_i, data_q): (0.500000,0.906250)\n\t1054: o_phase = +9'd88;\t //LUT[1054] \tphase : 0.343750\t(data_i, data_q): (0.500000,0.937500)\n\t1055: o_phase = +9'd89;\t //LUT[1055] \tphase : 0.347656\t(data_i, data_q): (0.500000,0.968750)\n\t1056: o_phase = -9'd90;\t //LUT[1056] \tphase : -0.351562\t(data_i, data_q): (0.500000,-1.000000)\n\t1057: o_phase = -9'd89;\t //LUT[1057] \tphase : -0.347656\t(data_i, data_q): (0.500000,-0.968750)\n\t1058: o_phase = -9'd88;\t //LUT[1058] \tphase : -0.343750\t(data_i, data_q): (0.500000,-0.937500)\n\t1059: o_phase = -9'd87;\t //LUT[1059] \tphase : -0.339844\t(data_i, data_q): (0.500000,-0.906250)\n\t1060: o_phase = -9'd86;\t //LUT[1060] \tphase : -0.335938\t(data_i, data_q): (0.500000,-0.875000)\n\t1061: o_phase = -9'd84;\t //LUT[1061] \tphase : -0.328125\t(data_i, data_q): (0.500000,-0.843750)\n\t1062: o_phase = -9'd83;\t //LUT[1062] \tphase : -0.324219\t(data_i, data_q): (0.500000,-0.812500)\n\t1063: o_phase = -9'd82;\t //LUT[1063] \tphase : -0.320312\t(data_i, data_q): (0.500000,-0.781250)\n\t1064: o_phase = -9'd80;\t //LUT[1064] \tphase : -0.312500\t(data_i, data_q): (0.500000,-0.750000)\n\t1065: o_phase = -9'd78;\t //LUT[1065] \tphase : -0.304688\t(data_i, data_q): (0.500000,-0.718750)\n\t1066: o_phase = -9'd77;\t //LUT[1066] \tphase : -0.300781\t(data_i, data_q): (0.500000,-0.687500)\n\t1067: o_phase = -9'd75;\t //LUT[1067] \tphase : -0.292969\t(data_i, data_q): (0.500000,-0.656250)\n\t1068: o_phase = -9'd73;\t //LUT[1068] \tphase : -0.285156\t(data_i, data_q): (0.500000,-0.625000)\n\t1069: o_phase = -9'd71;\t //LUT[1069] \tphase : -0.277344\t(data_i, data_q): (0.500000,-0.593750)\n\t1070: o_phase = -9'd69;\t //LUT[1070] \tphase : -0.269531\t(data_i, data_q): (0.500000,-0.562500)\n\t1071: o_phase = -9'd66;\t //LUT[1071] \tphase : -0.257812\t(data_i, data_q): (0.500000,-0.531250)\n\t1072: o_phase = -9'd64;\t //LUT[1072] \tphase : -0.250000\t(data_i, data_q): (0.500000,-0.500000)\n\t1073: o_phase = -9'd61;\t //LUT[1073] \tphase : -0.238281\t(data_i, data_q): (0.500000,-0.468750)\n\t1074: o_phase = -9'd59;\t //LUT[1074] \tphase : -0.230469\t(data_i, data_q): (0.500000,-0.437500)\n\t1075: o_phase = -9'd56;\t //LUT[1075] \tphase : -0.218750\t(data_i, data_q): (0.500000,-0.406250)\n\t1076: o_phase = -9'd52;\t //LUT[1076] \tphase : -0.203125\t(data_i, data_q): (0.500000,-0.375000)\n\t1077: o_phase = -9'd49;\t //LUT[1077] \tphase : -0.191406\t(data_i, data_q): (0.500000,-0.343750)\n\t1078: o_phase = -9'd46;\t //LUT[1078] \tphase : -0.179688\t(data_i, data_q): (0.500000,-0.312500)\n\t1079: o_phase = -9'd42;\t //LUT[1079] \tphase : -0.164062\t(data_i, data_q): (0.500000,-0.281250)\n\t1080: o_phase = -9'd38;\t //LUT[1080] \tphase : -0.148438\t(data_i, data_q): (0.500000,-0.250000)\n\t1081: o_phase = -9'd34;\t //LUT[1081] \tphase : -0.132812\t(data_i, data_q): (0.500000,-0.218750)\n\t1082: o_phase = -9'd29;\t //LUT[1082] \tphase : -0.113281\t(data_i, data_q): (0.500000,-0.187500)\n\t1083: o_phase = -9'd25;\t //LUT[1083] \tphase : -0.097656\t(data_i, data_q): (0.500000,-0.156250)\n\t1084: o_phase = -9'd20;\t //LUT[1084] \tphase : -0.078125\t(data_i, data_q): (0.500000,-0.125000)\n\t1085: o_phase = -9'd15;\t //LUT[1085] \tphase : -0.058594\t(data_i, data_q): (0.500000,-0.093750)\n\t1086: o_phase = -9'd10;\t //LUT[1086] \tphase : -0.039062\t(data_i, data_q): (0.500000,-0.062500)\n\t1087: o_phase = -9'd5;\t //LUT[1087] \tphase : -0.019531\t(data_i, data_q): (0.500000,-0.031250)\n\t1088: o_phase = +9'd0;\t //LUT[1088] \tphase : 0.000000\t(data_i, data_q): (0.531250,0.000000)\n\t1089: o_phase = +9'd5;\t //LUT[1089] \tphase : 0.019531\t(data_i, data_q): (0.531250,0.031250)\n\t1090: o_phase = +9'd10;\t //LUT[1090] \tphase : 0.039062\t(data_i, data_q): (0.531250,0.062500)\n\t1091: o_phase = +9'd14;\t //LUT[1091] \tphase : 0.054688\t(data_i, data_q): (0.531250,0.093750)\n\t1092: o_phase = +9'd19;\t //LUT[1092] \tphase : 0.074219\t(data_i, data_q): (0.531250,0.125000)\n\t1093: o_phase = +9'd23;\t //LUT[1093] \tphase : 0.089844\t(data_i, data_q): (0.531250,0.156250)\n\t1094: o_phase = +9'd28;\t //LUT[1094] \tphase : 0.109375\t(data_i, data_q): (0.531250,0.187500)\n\t1095: o_phase = +9'd32;\t //LUT[1095] \tphase : 0.125000\t(data_i, data_q): (0.531250,0.218750)\n\t1096: o_phase = +9'd36;\t //LUT[1096] \tphase : 0.140625\t(data_i, data_q): (0.531250,0.250000)\n\t1097: o_phase = +9'd40;\t //LUT[1097] \tphase : 0.156250\t(data_i, data_q): (0.531250,0.281250)\n\t1098: o_phase = +9'd43;\t //LUT[1098] \tphase : 0.167969\t(data_i, data_q): (0.531250,0.312500)\n\t1099: o_phase = +9'd47;\t //LUT[1099] \tphase : 0.183594\t(data_i, data_q): (0.531250,0.343750)\n\t1100: o_phase = +9'd50;\t //LUT[1100] \tphase : 0.195312\t(data_i, data_q): (0.531250,0.375000)\n\t1101: o_phase = +9'd53;\t //LUT[1101] \tphase : 0.207031\t(data_i, data_q): (0.531250,0.406250)\n\t1102: o_phase = +9'd56;\t //LUT[1102] \tphase : 0.218750\t(data_i, data_q): (0.531250,0.437500)\n\t1103: o_phase = +9'd59;\t //LUT[1103] \tphase : 0.230469\t(data_i, data_q): (0.531250,0.468750)\n\t1104: o_phase = +9'd62;\t //LUT[1104] \tphase : 0.242188\t(data_i, data_q): (0.531250,0.500000)\n\t1105: o_phase = +9'd64;\t //LUT[1105] \tphase : 0.250000\t(data_i, data_q): (0.531250,0.531250)\n\t1106: o_phase = +9'd66;\t //LUT[1106] \tphase : 0.257812\t(data_i, data_q): (0.531250,0.562500)\n\t1107: o_phase = +9'd69;\t //LUT[1107] \tphase : 0.269531\t(data_i, data_q): (0.531250,0.593750)\n\t1108: o_phase = +9'd71;\t //LUT[1108] \tphase : 0.277344\t(data_i, data_q): (0.531250,0.625000)\n\t1109: o_phase = +9'd73;\t //LUT[1109] \tphase : 0.285156\t(data_i, data_q): (0.531250,0.656250)\n\t1110: o_phase = +9'd74;\t //LUT[1110] \tphase : 0.289062\t(data_i, data_q): (0.531250,0.687500)\n\t1111: o_phase = +9'd76;\t //LUT[1111] \tphase : 0.296875\t(data_i, data_q): (0.531250,0.718750)\n\t1112: o_phase = +9'd78;\t //LUT[1112] \tphase : 0.304688\t(data_i, data_q): (0.531250,0.750000)\n\t1113: o_phase = +9'd79;\t //LUT[1113] \tphase : 0.308594\t(data_i, data_q): (0.531250,0.781250)\n\t1114: o_phase = +9'd81;\t //LUT[1114] \tphase : 0.316406\t(data_i, data_q): (0.531250,0.812500)\n\t1115: o_phase = +9'd82;\t //LUT[1115] \tphase : 0.320312\t(data_i, data_q): (0.531250,0.843750)\n\t1116: o_phase = +9'd84;\t //LUT[1116] \tphase : 0.328125\t(data_i, data_q): (0.531250,0.875000)\n\t1117: o_phase = +9'd85;\t //LUT[1117] \tphase : 0.332031\t(data_i, data_q): (0.531250,0.906250)\n\t1118: o_phase = +9'd86;\t //LUT[1118] \tphase : 0.335938\t(data_i, data_q): (0.531250,0.937500)\n\t1119: o_phase = +9'd87;\t //LUT[1119] \tphase : 0.339844\t(data_i, data_q): (0.531250,0.968750)\n\t1120: o_phase = -9'd88;\t //LUT[1120] \tphase : -0.343750\t(data_i, data_q): (0.531250,-1.000000)\n\t1121: o_phase = -9'd87;\t //LUT[1121] \tphase : -0.339844\t(data_i, data_q): (0.531250,-0.968750)\n\t1122: o_phase = -9'd86;\t //LUT[1122] \tphase : -0.335938\t(data_i, data_q): (0.531250,-0.937500)\n\t1123: o_phase = -9'd85;\t //LUT[1123] \tphase : -0.332031\t(data_i, data_q): (0.531250,-0.906250)\n\t1124: o_phase = -9'd84;\t //LUT[1124] \tphase : -0.328125\t(data_i, data_q): (0.531250,-0.875000)\n\t1125: o_phase = -9'd82;\t //LUT[1125] \tphase : -0.320312\t(data_i, data_q): (0.531250,-0.843750)\n\t1126: o_phase = -9'd81;\t //LUT[1126] \tphase : -0.316406\t(data_i, data_q): (0.531250,-0.812500)\n\t1127: o_phase = -9'd79;\t //LUT[1127] \tphase : -0.308594\t(data_i, data_q): (0.531250,-0.781250)\n\t1128: o_phase = -9'd78;\t //LUT[1128] \tphase : -0.304688\t(data_i, data_q): (0.531250,-0.750000)\n\t1129: o_phase = -9'd76;\t //LUT[1129] \tphase : -0.296875\t(data_i, data_q): (0.531250,-0.718750)\n\t1130: o_phase = -9'd74;\t //LUT[1130] \tphase : -0.289062\t(data_i, data_q): (0.531250,-0.687500)\n\t1131: o_phase = -9'd73;\t //LUT[1131] \tphase : -0.285156\t(data_i, data_q): (0.531250,-0.656250)\n\t1132: o_phase = -9'd71;\t //LUT[1132] \tphase : -0.277344\t(data_i, data_q): (0.531250,-0.625000)\n\t1133: o_phase = -9'd69;\t //LUT[1133] \tphase : -0.269531\t(data_i, data_q): (0.531250,-0.593750)\n\t1134: o_phase = -9'd66;\t //LUT[1134] \tphase : -0.257812\t(data_i, data_q): (0.531250,-0.562500)\n\t1135: o_phase = -9'd64;\t //LUT[1135] \tphase : -0.250000\t(data_i, data_q): (0.531250,-0.531250)\n\t1136: o_phase = -9'd62;\t //LUT[1136] \tphase : -0.242188\t(data_i, data_q): (0.531250,-0.500000)\n\t1137: o_phase = -9'd59;\t //LUT[1137] \tphase : -0.230469\t(data_i, data_q): (0.531250,-0.468750)\n\t1138: o_phase = -9'd56;\t //LUT[1138] \tphase : -0.218750\t(data_i, data_q): (0.531250,-0.437500)\n\t1139: o_phase = -9'd53;\t //LUT[1139] \tphase : -0.207031\t(data_i, data_q): (0.531250,-0.406250)\n\t1140: o_phase = -9'd50;\t //LUT[1140] \tphase : -0.195312\t(data_i, data_q): (0.531250,-0.375000)\n\t1141: o_phase = -9'd47;\t //LUT[1141] \tphase : -0.183594\t(data_i, data_q): (0.531250,-0.343750)\n\t1142: o_phase = -9'd43;\t //LUT[1142] \tphase : -0.167969\t(data_i, data_q): (0.531250,-0.312500)\n\t1143: o_phase = -9'd40;\t //LUT[1143] \tphase : -0.156250\t(data_i, data_q): (0.531250,-0.281250)\n\t1144: o_phase = -9'd36;\t //LUT[1144] \tphase : -0.140625\t(data_i, data_q): (0.531250,-0.250000)\n\t1145: o_phase = -9'd32;\t //LUT[1145] \tphase : -0.125000\t(data_i, data_q): (0.531250,-0.218750)\n\t1146: o_phase = -9'd28;\t //LUT[1146] \tphase : -0.109375\t(data_i, data_q): (0.531250,-0.187500)\n\t1147: o_phase = -9'd23;\t //LUT[1147] \tphase : -0.089844\t(data_i, data_q): (0.531250,-0.156250)\n\t1148: o_phase = -9'd19;\t //LUT[1148] \tphase : -0.074219\t(data_i, data_q): (0.531250,-0.125000)\n\t1149: o_phase = -9'd14;\t //LUT[1149] \tphase : -0.054688\t(data_i, data_q): (0.531250,-0.093750)\n\t1150: o_phase = -9'd10;\t //LUT[1150] \tphase : -0.039062\t(data_i, data_q): (0.531250,-0.062500)\n\t1151: o_phase = -9'd5;\t //LUT[1151] \tphase : -0.019531\t(data_i, data_q): (0.531250,-0.031250)\n\t1152: o_phase = +9'd0;\t //LUT[1152] \tphase : 0.000000\t(data_i, data_q): (0.562500,0.000000)\n\t1153: o_phase = +9'd5;\t //LUT[1153] \tphase : 0.019531\t(data_i, data_q): (0.562500,0.031250)\n\t1154: o_phase = +9'd9;\t //LUT[1154] \tphase : 0.035156\t(data_i, data_q): (0.562500,0.062500)\n\t1155: o_phase = +9'd13;\t //LUT[1155] \tphase : 0.050781\t(data_i, data_q): (0.562500,0.093750)\n\t1156: o_phase = +9'd18;\t //LUT[1156] \tphase : 0.070312\t(data_i, data_q): (0.562500,0.125000)\n\t1157: o_phase = +9'd22;\t //LUT[1157] \tphase : 0.085938\t(data_i, data_q): (0.562500,0.156250)\n\t1158: o_phase = +9'd26;\t //LUT[1158] \tphase : 0.101562\t(data_i, data_q): (0.562500,0.187500)\n\t1159: o_phase = +9'd30;\t //LUT[1159] \tphase : 0.117188\t(data_i, data_q): (0.562500,0.218750)\n\t1160: o_phase = +9'd34;\t //LUT[1160] \tphase : 0.132812\t(data_i, data_q): (0.562500,0.250000)\n\t1161: o_phase = +9'd38;\t //LUT[1161] \tphase : 0.148438\t(data_i, data_q): (0.562500,0.281250)\n\t1162: o_phase = +9'd41;\t //LUT[1162] \tphase : 0.160156\t(data_i, data_q): (0.562500,0.312500)\n\t1163: o_phase = +9'd45;\t //LUT[1163] \tphase : 0.175781\t(data_i, data_q): (0.562500,0.343750)\n\t1164: o_phase = +9'd48;\t //LUT[1164] \tphase : 0.187500\t(data_i, data_q): (0.562500,0.375000)\n\t1165: o_phase = +9'd51;\t //LUT[1165] \tphase : 0.199219\t(data_i, data_q): (0.562500,0.406250)\n\t1166: o_phase = +9'd54;\t //LUT[1166] \tphase : 0.210938\t(data_i, data_q): (0.562500,0.437500)\n\t1167: o_phase = +9'd57;\t //LUT[1167] \tphase : 0.222656\t(data_i, data_q): (0.562500,0.468750)\n\t1168: o_phase = +9'd59;\t //LUT[1168] \tphase : 0.230469\t(data_i, data_q): (0.562500,0.500000)\n\t1169: o_phase = +9'd62;\t //LUT[1169] \tphase : 0.242188\t(data_i, data_q): (0.562500,0.531250)\n\t1170: o_phase = +9'd64;\t //LUT[1170] \tphase : 0.250000\t(data_i, data_q): (0.562500,0.562500)\n\t1171: o_phase = +9'd66;\t //LUT[1171] \tphase : 0.257812\t(data_i, data_q): (0.562500,0.593750)\n\t1172: o_phase = +9'd68;\t //LUT[1172] \tphase : 0.265625\t(data_i, data_q): (0.562500,0.625000)\n\t1173: o_phase = +9'd70;\t //LUT[1173] \tphase : 0.273438\t(data_i, data_q): (0.562500,0.656250)\n\t1174: o_phase = +9'd72;\t //LUT[1174] \tphase : 0.281250\t(data_i, data_q): (0.562500,0.687500)\n\t1175: o_phase = +9'd74;\t //LUT[1175] \tphase : 0.289062\t(data_i, data_q): (0.562500,0.718750)\n\t1176: o_phase = +9'd76;\t //LUT[1176] \tphase : 0.296875\t(data_i, data_q): (0.562500,0.750000)\n\t1177: o_phase = +9'd77;\t //LUT[1177] \tphase : 0.300781\t(data_i, data_q): (0.562500,0.781250)\n\t1178: o_phase = +9'd79;\t //LUT[1178] \tphase : 0.308594\t(data_i, data_q): (0.562500,0.812500)\n\t1179: o_phase = +9'd80;\t //LUT[1179] \tphase : 0.312500\t(data_i, data_q): (0.562500,0.843750)\n\t1180: o_phase = +9'd81;\t //LUT[1180] \tphase : 0.316406\t(data_i, data_q): (0.562500,0.875000)\n\t1181: o_phase = +9'd83;\t //LUT[1181] \tphase : 0.324219\t(data_i, data_q): (0.562500,0.906250)\n\t1182: o_phase = +9'd84;\t //LUT[1182] \tphase : 0.328125\t(data_i, data_q): (0.562500,0.937500)\n\t1183: o_phase = +9'd85;\t //LUT[1183] \tphase : 0.332031\t(data_i, data_q): (0.562500,0.968750)\n\t1184: o_phase = -9'd86;\t //LUT[1184] \tphase : -0.335938\t(data_i, data_q): (0.562500,-1.000000)\n\t1185: o_phase = -9'd85;\t //LUT[1185] \tphase : -0.332031\t(data_i, data_q): (0.562500,-0.968750)\n\t1186: o_phase = -9'd84;\t //LUT[1186] \tphase : -0.328125\t(data_i, data_q): (0.562500,-0.937500)\n\t1187: o_phase = -9'd83;\t //LUT[1187] \tphase : -0.324219\t(data_i, data_q): (0.562500,-0.906250)\n\t1188: o_phase = -9'd81;\t //LUT[1188] \tphase : -0.316406\t(data_i, data_q): (0.562500,-0.875000)\n\t1189: o_phase = -9'd80;\t //LUT[1189] \tphase : -0.312500\t(data_i, data_q): (0.562500,-0.843750)\n\t1190: o_phase = -9'd79;\t //LUT[1190] \tphase : -0.308594\t(data_i, data_q): (0.562500,-0.812500)\n\t1191: o_phase = -9'd77;\t //LUT[1191] \tphase : -0.300781\t(data_i, data_q): (0.562500,-0.781250)\n\t1192: o_phase = -9'd76;\t //LUT[1192] \tphase : -0.296875\t(data_i, data_q): (0.562500,-0.750000)\n\t1193: o_phase = -9'd74;\t //LUT[1193] \tphase : -0.289062\t(data_i, data_q): (0.562500,-0.718750)\n\t1194: o_phase = -9'd72;\t //LUT[1194] \tphase : -0.281250\t(data_i, data_q): (0.562500,-0.687500)\n\t1195: o_phase = -9'd70;\t //LUT[1195] \tphase : -0.273438\t(data_i, data_q): (0.562500,-0.656250)\n\t1196: o_phase = -9'd68;\t //LUT[1196] \tphase : -0.265625\t(data_i, data_q): (0.562500,-0.625000)\n\t1197: o_phase = -9'd66;\t //LUT[1197] \tphase : -0.257812\t(data_i, data_q): (0.562500,-0.593750)\n\t1198: o_phase = -9'd64;\t //LUT[1198] \tphase : -0.250000\t(data_i, data_q): (0.562500,-0.562500)\n\t1199: o_phase = -9'd62;\t //LUT[1199] \tphase : -0.242188\t(data_i, data_q): (0.562500,-0.531250)\n\t1200: o_phase = -9'd59;\t //LUT[1200] \tphase : -0.230469\t(data_i, data_q): (0.562500,-0.500000)\n\t1201: o_phase = -9'd57;\t //LUT[1201] \tphase : -0.222656\t(data_i, data_q): (0.562500,-0.468750)\n\t1202: o_phase = -9'd54;\t //LUT[1202] \tphase : -0.210938\t(data_i, data_q): (0.562500,-0.437500)\n\t1203: o_phase = -9'd51;\t //LUT[1203] \tphase : -0.199219\t(data_i, data_q): (0.562500,-0.406250)\n\t1204: o_phase = -9'd48;\t //LUT[1204] \tphase : -0.187500\t(data_i, data_q): (0.562500,-0.375000)\n\t1205: o_phase = -9'd45;\t //LUT[1205] \tphase : -0.175781\t(data_i, data_q): (0.562500,-0.343750)\n\t1206: o_phase = -9'd41;\t //LUT[1206] \tphase : -0.160156\t(data_i, data_q): (0.562500,-0.312500)\n\t1207: o_phase = -9'd38;\t //LUT[1207] \tphase : -0.148438\t(data_i, data_q): (0.562500,-0.281250)\n\t1208: o_phase = -9'd34;\t //LUT[1208] \tphase : -0.132812\t(data_i, data_q): (0.562500,-0.250000)\n\t1209: o_phase = -9'd30;\t //LUT[1209] \tphase : -0.117188\t(data_i, data_q): (0.562500,-0.218750)\n\t1210: o_phase = -9'd26;\t //LUT[1210] \tphase : -0.101562\t(data_i, data_q): (0.562500,-0.187500)\n\t1211: o_phase = -9'd22;\t //LUT[1211] \tphase : -0.085938\t(data_i, data_q): (0.562500,-0.156250)\n\t1212: o_phase = -9'd18;\t //LUT[1212] \tphase : -0.070312\t(data_i, data_q): (0.562500,-0.125000)\n\t1213: o_phase = -9'd13;\t //LUT[1213] \tphase : -0.050781\t(data_i, data_q): (0.562500,-0.093750)\n\t1214: o_phase = -9'd9;\t //LUT[1214] \tphase : -0.035156\t(data_i, data_q): (0.562500,-0.062500)\n\t1215: o_phase = -9'd5;\t //LUT[1215] \tphase : -0.019531\t(data_i, data_q): (0.562500,-0.031250)\n\t1216: o_phase = +9'd0;\t //LUT[1216] \tphase : 0.000000\t(data_i, data_q): (0.593750,0.000000)\n\t1217: o_phase = +9'd4;\t //LUT[1217] \tphase : 0.015625\t(data_i, data_q): (0.593750,0.031250)\n\t1218: o_phase = +9'd9;\t //LUT[1218] \tphase : 0.035156\t(data_i, data_q): (0.593750,0.062500)\n\t1219: o_phase = +9'd13;\t //LUT[1219] \tphase : 0.050781\t(data_i, data_q): (0.593750,0.093750)\n\t1220: o_phase = +9'd17;\t //LUT[1220] \tphase : 0.066406\t(data_i, data_q): (0.593750,0.125000)\n\t1221: o_phase = +9'd21;\t //LUT[1221] \tphase : 0.082031\t(data_i, data_q): (0.593750,0.156250)\n\t1222: o_phase = +9'd25;\t //LUT[1222] \tphase : 0.097656\t(data_i, data_q): (0.593750,0.187500)\n\t1223: o_phase = +9'd29;\t //LUT[1223] \tphase : 0.113281\t(data_i, data_q): (0.593750,0.218750)\n\t1224: o_phase = +9'd32;\t //LUT[1224] \tphase : 0.125000\t(data_i, data_q): (0.593750,0.250000)\n\t1225: o_phase = +9'd36;\t //LUT[1225] \tphase : 0.140625\t(data_i, data_q): (0.593750,0.281250)\n\t1226: o_phase = +9'd39;\t //LUT[1226] \tphase : 0.152344\t(data_i, data_q): (0.593750,0.312500)\n\t1227: o_phase = +9'd43;\t //LUT[1227] \tphase : 0.167969\t(data_i, data_q): (0.593750,0.343750)\n\t1228: o_phase = +9'd46;\t //LUT[1228] \tphase : 0.179688\t(data_i, data_q): (0.593750,0.375000)\n\t1229: o_phase = +9'd49;\t //LUT[1229] \tphase : 0.191406\t(data_i, data_q): (0.593750,0.406250)\n\t1230: o_phase = +9'd52;\t //LUT[1230] \tphase : 0.203125\t(data_i, data_q): (0.593750,0.437500)\n\t1231: o_phase = +9'd54;\t //LUT[1231] \tphase : 0.210938\t(data_i, data_q): (0.593750,0.468750)\n\t1232: o_phase = +9'd57;\t //LUT[1232] \tphase : 0.222656\t(data_i, data_q): (0.593750,0.500000)\n\t1233: o_phase = +9'd59;\t //LUT[1233] \tphase : 0.230469\t(data_i, data_q): (0.593750,0.531250)\n\t1234: o_phase = +9'd62;\t //LUT[1234] \tphase : 0.242188\t(data_i, data_q): (0.593750,0.562500)\n\t1235: o_phase = +9'd64;\t //LUT[1235] \tphase : 0.250000\t(data_i, data_q): (0.593750,0.593750)\n\t1236: o_phase = +9'd66;\t //LUT[1236] \tphase : 0.257812\t(data_i, data_q): (0.593750,0.625000)\n\t1237: o_phase = +9'd68;\t //LUT[1237] \tphase : 0.265625\t(data_i, data_q): (0.593750,0.656250)\n\t1238: o_phase = +9'd70;\t //LUT[1238] \tphase : 0.273438\t(data_i, data_q): (0.593750,0.687500)\n\t1239: o_phase = +9'd72;\t //LUT[1239] \tphase : 0.281250\t(data_i, data_q): (0.593750,0.718750)\n\t1240: o_phase = +9'd73;\t //LUT[1240] \tphase : 0.285156\t(data_i, data_q): (0.593750,0.750000)\n\t1241: o_phase = +9'd75;\t //LUT[1241] \tphase : 0.292969\t(data_i, data_q): (0.593750,0.781250)\n\t1242: o_phase = +9'd77;\t //LUT[1242] \tphase : 0.300781\t(data_i, data_q): (0.593750,0.812500)\n\t1243: o_phase = +9'd78;\t //LUT[1243] \tphase : 0.304688\t(data_i, data_q): (0.593750,0.843750)\n\t1244: o_phase = +9'd79;\t //LUT[1244] \tphase : 0.308594\t(data_i, data_q): (0.593750,0.875000)\n\t1245: o_phase = +9'd81;\t //LUT[1245] \tphase : 0.316406\t(data_i, data_q): (0.593750,0.906250)\n\t1246: o_phase = +9'd82;\t //LUT[1246] \tphase : 0.320312\t(data_i, data_q): (0.593750,0.937500)\n\t1247: o_phase = +9'd83;\t //LUT[1247] \tphase : 0.324219\t(data_i, data_q): (0.593750,0.968750)\n\t1248: o_phase = -9'd84;\t //LUT[1248] \tphase : -0.328125\t(data_i, data_q): (0.593750,-1.000000)\n\t1249: o_phase = -9'd83;\t //LUT[1249] \tphase : -0.324219\t(data_i, data_q): (0.593750,-0.968750)\n\t1250: o_phase = -9'd82;\t //LUT[1250] \tphase : -0.320312\t(data_i, data_q): (0.593750,-0.937500)\n\t1251: o_phase = -9'd81;\t //LUT[1251] \tphase : -0.316406\t(data_i, data_q): (0.593750,-0.906250)\n\t1252: o_phase = -9'd79;\t //LUT[1252] \tphase : -0.308594\t(data_i, data_q): (0.593750,-0.875000)\n\t1253: o_phase = -9'd78;\t //LUT[1253] \tphase : -0.304688\t(data_i, data_q): (0.593750,-0.843750)\n\t1254: o_phase = -9'd77;\t //LUT[1254] \tphase : -0.300781\t(data_i, data_q): (0.593750,-0.812500)\n\t1255: o_phase = -9'd75;\t //LUT[1255] \tphase : -0.292969\t(data_i, data_q): (0.593750,-0.781250)\n\t1256: o_phase = -9'd73;\t //LUT[1256] \tphase : -0.285156\t(data_i, data_q): (0.593750,-0.750000)\n\t1257: o_phase = -9'd72;\t //LUT[1257] \tphase : -0.281250\t(data_i, data_q): (0.593750,-0.718750)\n\t1258: o_phase = -9'd70;\t //LUT[1258] \tphase : -0.273438\t(data_i, data_q): (0.593750,-0.687500)\n\t1259: o_phase = -9'd68;\t //LUT[1259] \tphase : -0.265625\t(data_i, data_q): (0.593750,-0.656250)\n\t1260: o_phase = -9'd66;\t //LUT[1260] \tphase : -0.257812\t(data_i, data_q): (0.593750,-0.625000)\n\t1261: o_phase = -9'd64;\t //LUT[1261] \tphase : -0.250000\t(data_i, data_q): (0.593750,-0.593750)\n\t1262: o_phase = -9'd62;\t //LUT[1262] \tphase : -0.242188\t(data_i, data_q): (0.593750,-0.562500)\n\t1263: o_phase = -9'd59;\t //LUT[1263] \tphase : -0.230469\t(data_i, data_q): (0.593750,-0.531250)\n\t1264: o_phase = -9'd57;\t //LUT[1264] \tphase : -0.222656\t(data_i, data_q): (0.593750,-0.500000)\n\t1265: o_phase = -9'd54;\t //LUT[1265] \tphase : -0.210938\t(data_i, data_q): (0.593750,-0.468750)\n\t1266: o_phase = -9'd52;\t //LUT[1266] \tphase : -0.203125\t(data_i, data_q): (0.593750,-0.437500)\n\t1267: o_phase = -9'd49;\t //LUT[1267] \tphase : -0.191406\t(data_i, data_q): (0.593750,-0.406250)\n\t1268: o_phase = -9'd46;\t //LUT[1268] \tphase : -0.179688\t(data_i, data_q): (0.593750,-0.375000)\n\t1269: o_phase = -9'd43;\t //LUT[1269] \tphase : -0.167969\t(data_i, data_q): (0.593750,-0.343750)\n\t1270: o_phase = -9'd39;\t //LUT[1270] \tphase : -0.152344\t(data_i, data_q): (0.593750,-0.312500)\n\t1271: o_phase = -9'd36;\t //LUT[1271] \tphase : -0.140625\t(data_i, data_q): (0.593750,-0.281250)\n\t1272: o_phase = -9'd32;\t //LUT[1272] \tphase : -0.125000\t(data_i, data_q): (0.593750,-0.250000)\n\t1273: o_phase = -9'd29;\t //LUT[1273] \tphase : -0.113281\t(data_i, data_q): (0.593750,-0.218750)\n\t1274: o_phase = -9'd25;\t //LUT[1274] \tphase : -0.097656\t(data_i, data_q): (0.593750,-0.187500)\n\t1275: o_phase = -9'd21;\t //LUT[1275] \tphase : -0.082031\t(data_i, data_q): (0.593750,-0.156250)\n\t1276: o_phase = -9'd17;\t //LUT[1276] \tphase : -0.066406\t(data_i, data_q): (0.593750,-0.125000)\n\t1277: o_phase = -9'd13;\t //LUT[1277] \tphase : -0.050781\t(data_i, data_q): (0.593750,-0.093750)\n\t1278: o_phase = -9'd9;\t //LUT[1278] \tphase : -0.035156\t(data_i, data_q): (0.593750,-0.062500)\n\t1279: o_phase = -9'd4;\t //LUT[1279] \tphase : -0.015625\t(data_i, data_q): (0.593750,-0.031250)\n\t1280: o_phase = +9'd0;\t //LUT[1280] \tphase : 0.000000\t(data_i, data_q): (0.625000,0.000000)\n\t1281: o_phase = +9'd4;\t //LUT[1281] \tphase : 0.015625\t(data_i, data_q): (0.625000,0.031250)\n\t1282: o_phase = +9'd8;\t //LUT[1282] \tphase : 0.031250\t(data_i, data_q): (0.625000,0.062500)\n\t1283: o_phase = +9'd12;\t //LUT[1283] \tphase : 0.046875\t(data_i, data_q): (0.625000,0.093750)\n\t1284: o_phase = +9'd16;\t //LUT[1284] \tphase : 0.062500\t(data_i, data_q): (0.625000,0.125000)\n\t1285: o_phase = +9'd20;\t //LUT[1285] \tphase : 0.078125\t(data_i, data_q): (0.625000,0.156250)\n\t1286: o_phase = +9'd24;\t //LUT[1286] \tphase : 0.093750\t(data_i, data_q): (0.625000,0.187500)\n\t1287: o_phase = +9'd27;\t //LUT[1287] \tphase : 0.105469\t(data_i, data_q): (0.625000,0.218750)\n\t1288: o_phase = +9'd31;\t //LUT[1288] \tphase : 0.121094\t(data_i, data_q): (0.625000,0.250000)\n\t1289: o_phase = +9'd34;\t //LUT[1289] \tphase : 0.132812\t(data_i, data_q): (0.625000,0.281250)\n\t1290: o_phase = +9'd38;\t //LUT[1290] \tphase : 0.148438\t(data_i, data_q): (0.625000,0.312500)\n\t1291: o_phase = +9'd41;\t //LUT[1291] \tphase : 0.160156\t(data_i, data_q): (0.625000,0.343750)\n\t1292: o_phase = +9'd44;\t //LUT[1292] \tphase : 0.171875\t(data_i, data_q): (0.625000,0.375000)\n\t1293: o_phase = +9'd47;\t //LUT[1293] \tphase : 0.183594\t(data_i, data_q): (0.625000,0.406250)\n\t1294: o_phase = +9'd50;\t //LUT[1294] \tphase : 0.195312\t(data_i, data_q): (0.625000,0.437500)\n\t1295: o_phase = +9'd52;\t //LUT[1295] \tphase : 0.203125\t(data_i, data_q): (0.625000,0.468750)\n\t1296: o_phase = +9'd55;\t //LUT[1296] \tphase : 0.214844\t(data_i, data_q): (0.625000,0.500000)\n\t1297: o_phase = +9'd57;\t //LUT[1297] \tphase : 0.222656\t(data_i, data_q): (0.625000,0.531250)\n\t1298: o_phase = +9'd60;\t //LUT[1298] \tphase : 0.234375\t(data_i, data_q): (0.625000,0.562500)\n\t1299: o_phase = +9'd62;\t //LUT[1299] \tphase : 0.242188\t(data_i, data_q): (0.625000,0.593750)\n\t1300: o_phase = +9'd64;\t //LUT[1300] \tphase : 0.250000\t(data_i, data_q): (0.625000,0.625000)\n\t1301: o_phase = +9'd66;\t //LUT[1301] \tphase : 0.257812\t(data_i, data_q): (0.625000,0.656250)\n\t1302: o_phase = +9'd68;\t //LUT[1302] \tphase : 0.265625\t(data_i, data_q): (0.625000,0.687500)\n\t1303: o_phase = +9'd70;\t //LUT[1303] \tphase : 0.273438\t(data_i, data_q): (0.625000,0.718750)\n\t1304: o_phase = +9'd71;\t //LUT[1304] \tphase : 0.277344\t(data_i, data_q): (0.625000,0.750000)\n\t1305: o_phase = +9'd73;\t //LUT[1305] \tphase : 0.285156\t(data_i, data_q): (0.625000,0.781250)\n\t1306: o_phase = +9'd75;\t //LUT[1306] \tphase : 0.292969\t(data_i, data_q): (0.625000,0.812500)\n\t1307: o_phase = +9'd76;\t //LUT[1307] \tphase : 0.296875\t(data_i, data_q): (0.625000,0.843750)\n\t1308: o_phase = +9'd77;\t //LUT[1308] \tphase : 0.300781\t(data_i, data_q): (0.625000,0.875000)\n\t1309: o_phase = +9'd79;\t //LUT[1309] \tphase : 0.308594\t(data_i, data_q): (0.625000,0.906250)\n\t1310: o_phase = +9'd80;\t //LUT[1310] \tphase : 0.312500\t(data_i, data_q): (0.625000,0.937500)\n\t1311: o_phase = +9'd81;\t //LUT[1311] \tphase : 0.316406\t(data_i, data_q): (0.625000,0.968750)\n\t1312: o_phase = -9'd82;\t //LUT[1312] \tphase : -0.320312\t(data_i, data_q): (0.625000,-1.000000)\n\t1313: o_phase = -9'd81;\t //LUT[1313] \tphase : -0.316406\t(data_i, data_q): (0.625000,-0.968750)\n\t1314: o_phase = -9'd80;\t //LUT[1314] \tphase : -0.312500\t(data_i, data_q): (0.625000,-0.937500)\n\t1315: o_phase = -9'd79;\t //LUT[1315] \tphase : -0.308594\t(data_i, data_q): (0.625000,-0.906250)\n\t1316: o_phase = -9'd77;\t //LUT[1316] \tphase : -0.300781\t(data_i, data_q): (0.625000,-0.875000)\n\t1317: o_phase = -9'd76;\t //LUT[1317] \tphase : -0.296875\t(data_i, data_q): (0.625000,-0.843750)\n\t1318: o_phase = -9'd75;\t //LUT[1318] \tphase : -0.292969\t(data_i, data_q): (0.625000,-0.812500)\n\t1319: o_phase = -9'd73;\t //LUT[1319] \tphase : -0.285156\t(data_i, data_q): (0.625000,-0.781250)\n\t1320: o_phase = -9'd71;\t //LUT[1320] \tphase : -0.277344\t(data_i, data_q): (0.625000,-0.750000)\n\t1321: o_phase = -9'd70;\t //LUT[1321] \tphase : -0.273438\t(data_i, data_q): (0.625000,-0.718750)\n\t1322: o_phase = -9'd68;\t //LUT[1322] \tphase : -0.265625\t(data_i, data_q): (0.625000,-0.687500)\n\t1323: o_phase = -9'd66;\t //LUT[1323] \tphase : -0.257812\t(data_i, data_q): (0.625000,-0.656250)\n\t1324: o_phase = -9'd64;\t //LUT[1324] \tphase : -0.250000\t(data_i, data_q): (0.625000,-0.625000)\n\t1325: o_phase = -9'd62;\t //LUT[1325] \tphase : -0.242188\t(data_i, data_q): (0.625000,-0.593750)\n\t1326: o_phase = -9'd60;\t //LUT[1326] \tphase : -0.234375\t(data_i, data_q): (0.625000,-0.562500)\n\t1327: o_phase = -9'd57;\t //LUT[1327] \tphase : -0.222656\t(data_i, data_q): (0.625000,-0.531250)\n\t1328: o_phase = -9'd55;\t //LUT[1328] \tphase : -0.214844\t(data_i, data_q): (0.625000,-0.500000)\n\t1329: o_phase = -9'd52;\t //LUT[1329] \tphase : -0.203125\t(data_i, data_q): (0.625000,-0.468750)\n\t1330: o_phase = -9'd50;\t //LUT[1330] \tphase : -0.195312\t(data_i, data_q): (0.625000,-0.437500)\n\t1331: o_phase = -9'd47;\t //LUT[1331] \tphase : -0.183594\t(data_i, data_q): (0.625000,-0.406250)\n\t1332: o_phase = -9'd44;\t //LUT[1332] \tphase : -0.171875\t(data_i, data_q): (0.625000,-0.375000)\n\t1333: o_phase = -9'd41;\t //LUT[1333] \tphase : -0.160156\t(data_i, data_q): (0.625000,-0.343750)\n\t1334: o_phase = -9'd38;\t //LUT[1334] \tphase : -0.148438\t(data_i, data_q): (0.625000,-0.312500)\n\t1335: o_phase = -9'd34;\t //LUT[1335] \tphase : -0.132812\t(data_i, data_q): (0.625000,-0.281250)\n\t1336: o_phase = -9'd31;\t //LUT[1336] \tphase : -0.121094\t(data_i, data_q): (0.625000,-0.250000)\n\t1337: o_phase = -9'd27;\t //LUT[1337] \tphase : -0.105469\t(data_i, data_q): (0.625000,-0.218750)\n\t1338: o_phase = -9'd24;\t //LUT[1338] \tphase : -0.093750\t(data_i, data_q): (0.625000,-0.187500)\n\t1339: o_phase = -9'd20;\t //LUT[1339] \tphase : -0.078125\t(data_i, data_q): (0.625000,-0.156250)\n\t1340: o_phase = -9'd16;\t //LUT[1340] \tphase : -0.062500\t(data_i, data_q): (0.625000,-0.125000)\n\t1341: o_phase = -9'd12;\t //LUT[1341] \tphase : -0.046875\t(data_i, data_q): (0.625000,-0.093750)\n\t1342: o_phase = -9'd8;\t //LUT[1342] \tphase : -0.031250\t(data_i, data_q): (0.625000,-0.062500)\n\t1343: o_phase = -9'd4;\t //LUT[1343] \tphase : -0.015625\t(data_i, data_q): (0.625000,-0.031250)\n\t1344: o_phase = +9'd0;\t //LUT[1344] \tphase : 0.000000\t(data_i, data_q): (0.656250,0.000000)\n\t1345: o_phase = +9'd4;\t //LUT[1345] \tphase : 0.015625\t(data_i, data_q): (0.656250,0.031250)\n\t1346: o_phase = +9'd8;\t //LUT[1346] \tphase : 0.031250\t(data_i, data_q): (0.656250,0.062500)\n\t1347: o_phase = +9'd12;\t //LUT[1347] \tphase : 0.046875\t(data_i, data_q): (0.656250,0.093750)\n\t1348: o_phase = +9'd15;\t //LUT[1348] \tphase : 0.058594\t(data_i, data_q): (0.656250,0.125000)\n\t1349: o_phase = +9'd19;\t //LUT[1349] \tphase : 0.074219\t(data_i, data_q): (0.656250,0.156250)\n\t1350: o_phase = +9'd23;\t //LUT[1350] \tphase : 0.089844\t(data_i, data_q): (0.656250,0.187500)\n\t1351: o_phase = +9'd26;\t //LUT[1351] \tphase : 0.101562\t(data_i, data_q): (0.656250,0.218750)\n\t1352: o_phase = +9'd30;\t //LUT[1352] \tphase : 0.117188\t(data_i, data_q): (0.656250,0.250000)\n\t1353: o_phase = +9'd33;\t //LUT[1353] \tphase : 0.128906\t(data_i, data_q): (0.656250,0.281250)\n\t1354: o_phase = +9'd36;\t //LUT[1354] \tphase : 0.140625\t(data_i, data_q): (0.656250,0.312500)\n\t1355: o_phase = +9'd39;\t //LUT[1355] \tphase : 0.152344\t(data_i, data_q): (0.656250,0.343750)\n\t1356: o_phase = +9'd42;\t //LUT[1356] \tphase : 0.164062\t(data_i, data_q): (0.656250,0.375000)\n\t1357: o_phase = +9'd45;\t //LUT[1357] \tphase : 0.175781\t(data_i, data_q): (0.656250,0.406250)\n\t1358: o_phase = +9'd48;\t //LUT[1358] \tphase : 0.187500\t(data_i, data_q): (0.656250,0.437500)\n\t1359: o_phase = +9'd51;\t //LUT[1359] \tphase : 0.199219\t(data_i, data_q): (0.656250,0.468750)\n\t1360: o_phase = +9'd53;\t //LUT[1360] \tphase : 0.207031\t(data_i, data_q): (0.656250,0.500000)\n\t1361: o_phase = +9'd55;\t //LUT[1361] \tphase : 0.214844\t(data_i, data_q): (0.656250,0.531250)\n\t1362: o_phase = +9'd58;\t //LUT[1362] \tphase : 0.226562\t(data_i, data_q): (0.656250,0.562500)\n\t1363: o_phase = +9'd60;\t //LUT[1363] \tphase : 0.234375\t(data_i, data_q): (0.656250,0.593750)\n\t1364: o_phase = +9'd62;\t //LUT[1364] \tphase : 0.242188\t(data_i, data_q): (0.656250,0.625000)\n\t1365: o_phase = +9'd64;\t //LUT[1365] \tphase : 0.250000\t(data_i, data_q): (0.656250,0.656250)\n\t1366: o_phase = +9'd66;\t //LUT[1366] \tphase : 0.257812\t(data_i, data_q): (0.656250,0.687500)\n\t1367: o_phase = +9'd68;\t //LUT[1367] \tphase : 0.265625\t(data_i, data_q): (0.656250,0.718750)\n\t1368: o_phase = +9'd69;\t //LUT[1368] \tphase : 0.269531\t(data_i, data_q): (0.656250,0.750000)\n\t1369: o_phase = +9'd71;\t //LUT[1369] \tphase : 0.277344\t(data_i, data_q): (0.656250,0.781250)\n\t1370: o_phase = +9'd73;\t //LUT[1370] \tphase : 0.285156\t(data_i, data_q): (0.656250,0.812500)\n\t1371: o_phase = +9'd74;\t //LUT[1371] \tphase : 0.289062\t(data_i, data_q): (0.656250,0.843750)\n\t1372: o_phase = +9'd76;\t //LUT[1372] \tphase : 0.296875\t(data_i, data_q): (0.656250,0.875000)\n\t1373: o_phase = +9'd77;\t //LUT[1373] \tphase : 0.300781\t(data_i, data_q): (0.656250,0.906250)\n\t1374: o_phase = +9'd78;\t //LUT[1374] \tphase : 0.304688\t(data_i, data_q): (0.656250,0.937500)\n\t1375: o_phase = +9'd79;\t //LUT[1375] \tphase : 0.308594\t(data_i, data_q): (0.656250,0.968750)\n\t1376: o_phase = -9'd81;\t //LUT[1376] \tphase : -0.316406\t(data_i, data_q): (0.656250,-1.000000)\n\t1377: o_phase = -9'd79;\t //LUT[1377] \tphase : -0.308594\t(data_i, data_q): (0.656250,-0.968750)\n\t1378: o_phase = -9'd78;\t //LUT[1378] \tphase : -0.304688\t(data_i, data_q): (0.656250,-0.937500)\n\t1379: o_phase = -9'd77;\t //LUT[1379] \tphase : -0.300781\t(data_i, data_q): (0.656250,-0.906250)\n\t1380: o_phase = -9'd76;\t //LUT[1380] \tphase : -0.296875\t(data_i, data_q): (0.656250,-0.875000)\n\t1381: o_phase = -9'd74;\t //LUT[1381] \tphase : -0.289062\t(data_i, data_q): (0.656250,-0.843750)\n\t1382: o_phase = -9'd73;\t //LUT[1382] \tphase : -0.285156\t(data_i, data_q): (0.656250,-0.812500)\n\t1383: o_phase = -9'd71;\t //LUT[1383] \tphase : -0.277344\t(data_i, data_q): (0.656250,-0.781250)\n\t1384: o_phase = -9'd69;\t //LUT[1384] \tphase : -0.269531\t(data_i, data_q): (0.656250,-0.750000)\n\t1385: o_phase = -9'd68;\t //LUT[1385] \tphase : -0.265625\t(data_i, data_q): (0.656250,-0.718750)\n\t1386: o_phase = -9'd66;\t //LUT[1386] \tphase : -0.257812\t(data_i, data_q): (0.656250,-0.687500)\n\t1387: o_phase = -9'd64;\t //LUT[1387] \tphase : -0.250000\t(data_i, data_q): (0.656250,-0.656250)\n\t1388: o_phase = -9'd62;\t //LUT[1388] \tphase : -0.242188\t(data_i, data_q): (0.656250,-0.625000)\n\t1389: o_phase = -9'd60;\t //LUT[1389] \tphase : -0.234375\t(data_i, data_q): (0.656250,-0.593750)\n\t1390: o_phase = -9'd58;\t //LUT[1390] \tphase : -0.226562\t(data_i, data_q): (0.656250,-0.562500)\n\t1391: o_phase = -9'd55;\t //LUT[1391] \tphase : -0.214844\t(data_i, data_q): (0.656250,-0.531250)\n\t1392: o_phase = -9'd53;\t //LUT[1392] \tphase : -0.207031\t(data_i, data_q): (0.656250,-0.500000)\n\t1393: o_phase = -9'd51;\t //LUT[1393] \tphase : -0.199219\t(data_i, data_q): (0.656250,-0.468750)\n\t1394: o_phase = -9'd48;\t //LUT[1394] \tphase : -0.187500\t(data_i, data_q): (0.656250,-0.437500)\n\t1395: o_phase = -9'd45;\t //LUT[1395] \tphase : -0.175781\t(data_i, data_q): (0.656250,-0.406250)\n\t1396: o_phase = -9'd42;\t //LUT[1396] \tphase : -0.164062\t(data_i, data_q): (0.656250,-0.375000)\n\t1397: o_phase = -9'd39;\t //LUT[1397] \tphase : -0.152344\t(data_i, data_q): (0.656250,-0.343750)\n\t1398: o_phase = -9'd36;\t //LUT[1398] \tphase : -0.140625\t(data_i, data_q): (0.656250,-0.312500)\n\t1399: o_phase = -9'd33;\t //LUT[1399] \tphase : -0.128906\t(data_i, data_q): (0.656250,-0.281250)\n\t1400: o_phase = -9'd30;\t //LUT[1400] \tphase : -0.117188\t(data_i, data_q): (0.656250,-0.250000)\n\t1401: o_phase = -9'd26;\t //LUT[1401] \tphase : -0.101562\t(data_i, data_q): (0.656250,-0.218750)\n\t1402: o_phase = -9'd23;\t //LUT[1402] \tphase : -0.089844\t(data_i, data_q): (0.656250,-0.187500)\n\t1403: o_phase = -9'd19;\t //LUT[1403] \tphase : -0.074219\t(data_i, data_q): (0.656250,-0.156250)\n\t1404: o_phase = -9'd15;\t //LUT[1404] \tphase : -0.058594\t(data_i, data_q): (0.656250,-0.125000)\n\t1405: o_phase = -9'd12;\t //LUT[1405] \tphase : -0.046875\t(data_i, data_q): (0.656250,-0.093750)\n\t1406: o_phase = -9'd8;\t //LUT[1406] \tphase : -0.031250\t(data_i, data_q): (0.656250,-0.062500)\n\t1407: o_phase = -9'd4;\t //LUT[1407] \tphase : -0.015625\t(data_i, data_q): (0.656250,-0.031250)\n\t1408: o_phase = +9'd0;\t //LUT[1408] \tphase : 0.000000\t(data_i, data_q): (0.687500,0.000000)\n\t1409: o_phase = +9'd4;\t //LUT[1409] \tphase : 0.015625\t(data_i, data_q): (0.687500,0.031250)\n\t1410: o_phase = +9'd7;\t //LUT[1410] \tphase : 0.027344\t(data_i, data_q): (0.687500,0.062500)\n\t1411: o_phase = +9'd11;\t //LUT[1411] \tphase : 0.042969\t(data_i, data_q): (0.687500,0.093750)\n\t1412: o_phase = +9'd15;\t //LUT[1412] \tphase : 0.058594\t(data_i, data_q): (0.687500,0.125000)\n\t1413: o_phase = +9'd18;\t //LUT[1413] \tphase : 0.070312\t(data_i, data_q): (0.687500,0.156250)\n\t1414: o_phase = +9'd22;\t //LUT[1414] \tphase : 0.085938\t(data_i, data_q): (0.687500,0.187500)\n\t1415: o_phase = +9'd25;\t //LUT[1415] \tphase : 0.097656\t(data_i, data_q): (0.687500,0.218750)\n\t1416: o_phase = +9'd28;\t //LUT[1416] \tphase : 0.109375\t(data_i, data_q): (0.687500,0.250000)\n\t1417: o_phase = +9'd32;\t //LUT[1417] \tphase : 0.125000\t(data_i, data_q): (0.687500,0.281250)\n\t1418: o_phase = +9'd35;\t //LUT[1418] \tphase : 0.136719\t(data_i, data_q): (0.687500,0.312500)\n\t1419: o_phase = +9'd38;\t //LUT[1419] \tphase : 0.148438\t(data_i, data_q): (0.687500,0.343750)\n\t1420: o_phase = +9'd41;\t //LUT[1420] \tphase : 0.160156\t(data_i, data_q): (0.687500,0.375000)\n\t1421: o_phase = +9'd43;\t //LUT[1421] \tphase : 0.167969\t(data_i, data_q): (0.687500,0.406250)\n\t1422: o_phase = +9'd46;\t //LUT[1422] \tphase : 0.179688\t(data_i, data_q): (0.687500,0.437500)\n\t1423: o_phase = +9'd49;\t //LUT[1423] \tphase : 0.191406\t(data_i, data_q): (0.687500,0.468750)\n\t1424: o_phase = +9'd51;\t //LUT[1424] \tphase : 0.199219\t(data_i, data_q): (0.687500,0.500000)\n\t1425: o_phase = +9'd54;\t //LUT[1425] \tphase : 0.210938\t(data_i, data_q): (0.687500,0.531250)\n\t1426: o_phase = +9'd56;\t //LUT[1426] \tphase : 0.218750\t(data_i, data_q): (0.687500,0.562500)\n\t1427: o_phase = +9'd58;\t //LUT[1427] \tphase : 0.226562\t(data_i, data_q): (0.687500,0.593750)\n\t1428: o_phase = +9'd60;\t //LUT[1428] \tphase : 0.234375\t(data_i, data_q): (0.687500,0.625000)\n\t1429: o_phase = +9'd62;\t //LUT[1429] \tphase : 0.242188\t(data_i, data_q): (0.687500,0.656250)\n\t1430: o_phase = +9'd64;\t //LUT[1430] \tphase : 0.250000\t(data_i, data_q): (0.687500,0.687500)\n\t1431: o_phase = +9'd66;\t //LUT[1431] \tphase : 0.257812\t(data_i, data_q): (0.687500,0.718750)\n\t1432: o_phase = +9'd68;\t //LUT[1432] \tphase : 0.265625\t(data_i, data_q): (0.687500,0.750000)\n\t1433: o_phase = +9'd69;\t //LUT[1433] \tphase : 0.269531\t(data_i, data_q): (0.687500,0.781250)\n\t1434: o_phase = +9'd71;\t //LUT[1434] \tphase : 0.277344\t(data_i, data_q): (0.687500,0.812500)\n\t1435: o_phase = +9'd72;\t //LUT[1435] \tphase : 0.281250\t(data_i, data_q): (0.687500,0.843750)\n\t1436: o_phase = +9'd74;\t //LUT[1436] \tphase : 0.289062\t(data_i, data_q): (0.687500,0.875000)\n\t1437: o_phase = +9'd75;\t //LUT[1437] \tphase : 0.292969\t(data_i, data_q): (0.687500,0.906250)\n\t1438: o_phase = +9'd76;\t //LUT[1438] \tphase : 0.296875\t(data_i, data_q): (0.687500,0.937500)\n\t1439: o_phase = +9'd78;\t //LUT[1439] \tphase : 0.304688\t(data_i, data_q): (0.687500,0.968750)\n\t1440: o_phase = -9'd79;\t //LUT[1440] \tphase : -0.308594\t(data_i, data_q): (0.687500,-1.000000)\n\t1441: o_phase = -9'd78;\t //LUT[1441] \tphase : -0.304688\t(data_i, data_q): (0.687500,-0.968750)\n\t1442: o_phase = -9'd76;\t //LUT[1442] \tphase : -0.296875\t(data_i, data_q): (0.687500,-0.937500)\n\t1443: o_phase = -9'd75;\t //LUT[1443] \tphase : -0.292969\t(data_i, data_q): (0.687500,-0.906250)\n\t1444: o_phase = -9'd74;\t //LUT[1444] \tphase : -0.289062\t(data_i, data_q): (0.687500,-0.875000)\n\t1445: o_phase = -9'd72;\t //LUT[1445] \tphase : -0.281250\t(data_i, data_q): (0.687500,-0.843750)\n\t1446: o_phase = -9'd71;\t //LUT[1446] \tphase : -0.277344\t(data_i, data_q): (0.687500,-0.812500)\n\t1447: o_phase = -9'd69;\t //LUT[1447] \tphase : -0.269531\t(data_i, data_q): (0.687500,-0.781250)\n\t1448: o_phase = -9'd68;\t //LUT[1448] \tphase : -0.265625\t(data_i, data_q): (0.687500,-0.750000)\n\t1449: o_phase = -9'd66;\t //LUT[1449] \tphase : -0.257812\t(data_i, data_q): (0.687500,-0.718750)\n\t1450: o_phase = -9'd64;\t //LUT[1450] \tphase : -0.250000\t(data_i, data_q): (0.687500,-0.687500)\n\t1451: o_phase = -9'd62;\t //LUT[1451] \tphase : -0.242188\t(data_i, data_q): (0.687500,-0.656250)\n\t1452: o_phase = -9'd60;\t //LUT[1452] \tphase : -0.234375\t(data_i, data_q): (0.687500,-0.625000)\n\t1453: o_phase = -9'd58;\t //LUT[1453] \tphase : -0.226562\t(data_i, data_q): (0.687500,-0.593750)\n\t1454: o_phase = -9'd56;\t //LUT[1454] \tphase : -0.218750\t(data_i, data_q): (0.687500,-0.562500)\n\t1455: o_phase = -9'd54;\t //LUT[1455] \tphase : -0.210938\t(data_i, data_q): (0.687500,-0.531250)\n\t1456: o_phase = -9'd51;\t //LUT[1456] \tphase : -0.199219\t(data_i, data_q): (0.687500,-0.500000)\n\t1457: o_phase = -9'd49;\t //LUT[1457] \tphase : -0.191406\t(data_i, data_q): (0.687500,-0.468750)\n\t1458: o_phase = -9'd46;\t //LUT[1458] \tphase : -0.179688\t(data_i, data_q): (0.687500,-0.437500)\n\t1459: o_phase = -9'd43;\t //LUT[1459] \tphase : -0.167969\t(data_i, data_q): (0.687500,-0.406250)\n\t1460: o_phase = -9'd41;\t //LUT[1460] \tphase : -0.160156\t(data_i, data_q): (0.687500,-0.375000)\n\t1461: o_phase = -9'd38;\t //LUT[1461] \tphase : -0.148438\t(data_i, data_q): (0.687500,-0.343750)\n\t1462: o_phase = -9'd35;\t //LUT[1462] \tphase : -0.136719\t(data_i, data_q): (0.687500,-0.312500)\n\t1463: o_phase = -9'd32;\t //LUT[1463] \tphase : -0.125000\t(data_i, data_q): (0.687500,-0.281250)\n\t1464: o_phase = -9'd28;\t //LUT[1464] \tphase : -0.109375\t(data_i, data_q): (0.687500,-0.250000)\n\t1465: o_phase = -9'd25;\t //LUT[1465] \tphase : -0.097656\t(data_i, data_q): (0.687500,-0.218750)\n\t1466: o_phase = -9'd22;\t //LUT[1466] \tphase : -0.085938\t(data_i, data_q): (0.687500,-0.187500)\n\t1467: o_phase = -9'd18;\t //LUT[1467] \tphase : -0.070312\t(data_i, data_q): (0.687500,-0.156250)\n\t1468: o_phase = -9'd15;\t //LUT[1468] \tphase : -0.058594\t(data_i, data_q): (0.687500,-0.125000)\n\t1469: o_phase = -9'd11;\t //LUT[1469] \tphase : -0.042969\t(data_i, data_q): (0.687500,-0.093750)\n\t1470: o_phase = -9'd7;\t //LUT[1470] \tphase : -0.027344\t(data_i, data_q): (0.687500,-0.062500)\n\t1471: o_phase = -9'd4;\t //LUT[1471] \tphase : -0.015625\t(data_i, data_q): (0.687500,-0.031250)\n\t1472: o_phase = +9'd0;\t //LUT[1472] \tphase : 0.000000\t(data_i, data_q): (0.718750,0.000000)\n\t1473: o_phase = +9'd4;\t //LUT[1473] \tphase : 0.015625\t(data_i, data_q): (0.718750,0.031250)\n\t1474: o_phase = +9'd7;\t //LUT[1474] \tphase : 0.027344\t(data_i, data_q): (0.718750,0.062500)\n\t1475: o_phase = +9'd11;\t //LUT[1475] \tphase : 0.042969\t(data_i, data_q): (0.718750,0.093750)\n\t1476: o_phase = +9'd14;\t //LUT[1476] \tphase : 0.054688\t(data_i, data_q): (0.718750,0.125000)\n\t1477: o_phase = +9'd17;\t //LUT[1477] \tphase : 0.066406\t(data_i, data_q): (0.718750,0.156250)\n\t1478: o_phase = +9'd21;\t //LUT[1478] \tphase : 0.082031\t(data_i, data_q): (0.718750,0.187500)\n\t1479: o_phase = +9'd24;\t //LUT[1479] \tphase : 0.093750\t(data_i, data_q): (0.718750,0.218750)\n\t1480: o_phase = +9'd27;\t //LUT[1480] \tphase : 0.105469\t(data_i, data_q): (0.718750,0.250000)\n\t1481: o_phase = +9'd30;\t //LUT[1481] \tphase : 0.117188\t(data_i, data_q): (0.718750,0.281250)\n\t1482: o_phase = +9'd33;\t //LUT[1482] \tphase : 0.128906\t(data_i, data_q): (0.718750,0.312500)\n\t1483: o_phase = +9'd36;\t //LUT[1483] \tphase : 0.140625\t(data_i, data_q): (0.718750,0.343750)\n\t1484: o_phase = +9'd39;\t //LUT[1484] \tphase : 0.152344\t(data_i, data_q): (0.718750,0.375000)\n\t1485: o_phase = +9'd42;\t //LUT[1485] \tphase : 0.164062\t(data_i, data_q): (0.718750,0.406250)\n\t1486: o_phase = +9'd45;\t //LUT[1486] \tphase : 0.175781\t(data_i, data_q): (0.718750,0.437500)\n\t1487: o_phase = +9'd47;\t //LUT[1487] \tphase : 0.183594\t(data_i, data_q): (0.718750,0.468750)\n\t1488: o_phase = +9'd50;\t //LUT[1488] \tphase : 0.195312\t(data_i, data_q): (0.718750,0.500000)\n\t1489: o_phase = +9'd52;\t //LUT[1489] \tphase : 0.203125\t(data_i, data_q): (0.718750,0.531250)\n\t1490: o_phase = +9'd54;\t //LUT[1490] \tphase : 0.210938\t(data_i, data_q): (0.718750,0.562500)\n\t1491: o_phase = +9'd56;\t //LUT[1491] \tphase : 0.218750\t(data_i, data_q): (0.718750,0.593750)\n\t1492: o_phase = +9'd58;\t //LUT[1492] \tphase : 0.226562\t(data_i, data_q): (0.718750,0.625000)\n\t1493: o_phase = +9'd60;\t //LUT[1493] \tphase : 0.234375\t(data_i, data_q): (0.718750,0.656250)\n\t1494: o_phase = +9'd62;\t //LUT[1494] \tphase : 0.242188\t(data_i, data_q): (0.718750,0.687500)\n\t1495: o_phase = +9'd64;\t //LUT[1495] \tphase : 0.250000\t(data_i, data_q): (0.718750,0.718750)\n\t1496: o_phase = +9'd66;\t //LUT[1496] \tphase : 0.257812\t(data_i, data_q): (0.718750,0.750000)\n\t1497: o_phase = +9'd67;\t //LUT[1497] \tphase : 0.261719\t(data_i, data_q): (0.718750,0.781250)\n\t1498: o_phase = +9'd69;\t //LUT[1498] \tphase : 0.269531\t(data_i, data_q): (0.718750,0.812500)\n\t1499: o_phase = +9'd71;\t //LUT[1499] \tphase : 0.277344\t(data_i, data_q): (0.718750,0.843750)\n\t1500: o_phase = +9'd72;\t //LUT[1500] \tphase : 0.281250\t(data_i, data_q): (0.718750,0.875000)\n\t1501: o_phase = +9'd73;\t //LUT[1501] \tphase : 0.285156\t(data_i, data_q): (0.718750,0.906250)\n\t1502: o_phase = +9'd75;\t //LUT[1502] \tphase : 0.292969\t(data_i, data_q): (0.718750,0.937500)\n\t1503: o_phase = +9'd76;\t //LUT[1503] \tphase : 0.296875\t(data_i, data_q): (0.718750,0.968750)\n\t1504: o_phase = -9'd77;\t //LUT[1504] \tphase : -0.300781\t(data_i, data_q): (0.718750,-1.000000)\n\t1505: o_phase = -9'd76;\t //LUT[1505] \tphase : -0.296875\t(data_i, data_q): (0.718750,-0.968750)\n\t1506: o_phase = -9'd75;\t //LUT[1506] \tphase : -0.292969\t(data_i, data_q): (0.718750,-0.937500)\n\t1507: o_phase = -9'd73;\t //LUT[1507] \tphase : -0.285156\t(data_i, data_q): (0.718750,-0.906250)\n\t1508: o_phase = -9'd72;\t //LUT[1508] \tphase : -0.281250\t(data_i, data_q): (0.718750,-0.875000)\n\t1509: o_phase = -9'd71;\t //LUT[1509] \tphase : -0.277344\t(data_i, data_q): (0.718750,-0.843750)\n\t1510: o_phase = -9'd69;\t //LUT[1510] \tphase : -0.269531\t(data_i, data_q): (0.718750,-0.812500)\n\t1511: o_phase = -9'd67;\t //LUT[1511] \tphase : -0.261719\t(data_i, data_q): (0.718750,-0.781250)\n\t1512: o_phase = -9'd66;\t //LUT[1512] \tphase : -0.257812\t(data_i, data_q): (0.718750,-0.750000)\n\t1513: o_phase = -9'd64;\t //LUT[1513] \tphase : -0.250000\t(data_i, data_q): (0.718750,-0.718750)\n\t1514: o_phase = -9'd62;\t //LUT[1514] \tphase : -0.242188\t(data_i, data_q): (0.718750,-0.687500)\n\t1515: o_phase = -9'd60;\t //LUT[1515] \tphase : -0.234375\t(data_i, data_q): (0.718750,-0.656250)\n\t1516: o_phase = -9'd58;\t //LUT[1516] \tphase : -0.226562\t(data_i, data_q): (0.718750,-0.625000)\n\t1517: o_phase = -9'd56;\t //LUT[1517] \tphase : -0.218750\t(data_i, data_q): (0.718750,-0.593750)\n\t1518: o_phase = -9'd54;\t //LUT[1518] \tphase : -0.210938\t(data_i, data_q): (0.718750,-0.562500)\n\t1519: o_phase = -9'd52;\t //LUT[1519] \tphase : -0.203125\t(data_i, data_q): (0.718750,-0.531250)\n\t1520: o_phase = -9'd50;\t //LUT[1520] \tphase : -0.195312\t(data_i, data_q): (0.718750,-0.500000)\n\t1521: o_phase = -9'd47;\t //LUT[1521] \tphase : -0.183594\t(data_i, data_q): (0.718750,-0.468750)\n\t1522: o_phase = -9'd45;\t //LUT[1522] \tphase : -0.175781\t(data_i, data_q): (0.718750,-0.437500)\n\t1523: o_phase = -9'd42;\t //LUT[1523] \tphase : -0.164062\t(data_i, data_q): (0.718750,-0.406250)\n\t1524: o_phase = -9'd39;\t //LUT[1524] \tphase : -0.152344\t(data_i, data_q): (0.718750,-0.375000)\n\t1525: o_phase = -9'd36;\t //LUT[1525] \tphase : -0.140625\t(data_i, data_q): (0.718750,-0.343750)\n\t1526: o_phase = -9'd33;\t //LUT[1526] \tphase : -0.128906\t(data_i, data_q): (0.718750,-0.312500)\n\t1527: o_phase = -9'd30;\t //LUT[1527] \tphase : -0.117188\t(data_i, data_q): (0.718750,-0.281250)\n\t1528: o_phase = -9'd27;\t //LUT[1528] \tphase : -0.105469\t(data_i, data_q): (0.718750,-0.250000)\n\t1529: o_phase = -9'd24;\t //LUT[1529] \tphase : -0.093750\t(data_i, data_q): (0.718750,-0.218750)\n\t1530: o_phase = -9'd21;\t //LUT[1530] \tphase : -0.082031\t(data_i, data_q): (0.718750,-0.187500)\n\t1531: o_phase = -9'd17;\t //LUT[1531] \tphase : -0.066406\t(data_i, data_q): (0.718750,-0.156250)\n\t1532: o_phase = -9'd14;\t //LUT[1532] \tphase : -0.054688\t(data_i, data_q): (0.718750,-0.125000)\n\t1533: o_phase = -9'd11;\t //LUT[1533] \tphase : -0.042969\t(data_i, data_q): (0.718750,-0.093750)\n\t1534: o_phase = -9'd7;\t //LUT[1534] \tphase : -0.027344\t(data_i, data_q): (0.718750,-0.062500)\n\t1535: o_phase = -9'd4;\t //LUT[1535] \tphase : -0.015625\t(data_i, data_q): (0.718750,-0.031250)\n\t1536: o_phase = +9'd0;\t //LUT[1536] \tphase : 0.000000\t(data_i, data_q): (0.750000,0.000000)\n\t1537: o_phase = +9'd3;\t //LUT[1537] \tphase : 0.011719\t(data_i, data_q): (0.750000,0.031250)\n\t1538: o_phase = +9'd7;\t //LUT[1538] \tphase : 0.027344\t(data_i, data_q): (0.750000,0.062500)\n\t1539: o_phase = +9'd10;\t //LUT[1539] \tphase : 0.039062\t(data_i, data_q): (0.750000,0.093750)\n\t1540: o_phase = +9'd13;\t //LUT[1540] \tphase : 0.050781\t(data_i, data_q): (0.750000,0.125000)\n\t1541: o_phase = +9'd17;\t //LUT[1541] \tphase : 0.066406\t(data_i, data_q): (0.750000,0.156250)\n\t1542: o_phase = +9'd20;\t //LUT[1542] \tphase : 0.078125\t(data_i, data_q): (0.750000,0.187500)\n\t1543: o_phase = +9'd23;\t //LUT[1543] \tphase : 0.089844\t(data_i, data_q): (0.750000,0.218750)\n\t1544: o_phase = +9'd26;\t //LUT[1544] \tphase : 0.101562\t(data_i, data_q): (0.750000,0.250000)\n\t1545: o_phase = +9'd29;\t //LUT[1545] \tphase : 0.113281\t(data_i, data_q): (0.750000,0.281250)\n\t1546: o_phase = +9'd32;\t //LUT[1546] \tphase : 0.125000\t(data_i, data_q): (0.750000,0.312500)\n\t1547: o_phase = +9'd35;\t //LUT[1547] \tphase : 0.136719\t(data_i, data_q): (0.750000,0.343750)\n\t1548: o_phase = +9'd38;\t //LUT[1548] \tphase : 0.148438\t(data_i, data_q): (0.750000,0.375000)\n\t1549: o_phase = +9'd40;\t //LUT[1549] \tphase : 0.156250\t(data_i, data_q): (0.750000,0.406250)\n\t1550: o_phase = +9'd43;\t //LUT[1550] \tphase : 0.167969\t(data_i, data_q): (0.750000,0.437500)\n\t1551: o_phase = +9'd46;\t //LUT[1551] \tphase : 0.179688\t(data_i, data_q): (0.750000,0.468750)\n\t1552: o_phase = +9'd48;\t //LUT[1552] \tphase : 0.187500\t(data_i, data_q): (0.750000,0.500000)\n\t1553: o_phase = +9'd50;\t //LUT[1553] \tphase : 0.195312\t(data_i, data_q): (0.750000,0.531250)\n\t1554: o_phase = +9'd52;\t //LUT[1554] \tphase : 0.203125\t(data_i, data_q): (0.750000,0.562500)\n\t1555: o_phase = +9'd55;\t //LUT[1555] \tphase : 0.214844\t(data_i, data_q): (0.750000,0.593750)\n\t1556: o_phase = +9'd57;\t //LUT[1556] \tphase : 0.222656\t(data_i, data_q): (0.750000,0.625000)\n\t1557: o_phase = +9'd59;\t //LUT[1557] \tphase : 0.230469\t(data_i, data_q): (0.750000,0.656250)\n\t1558: o_phase = +9'd60;\t //LUT[1558] \tphase : 0.234375\t(data_i, data_q): (0.750000,0.687500)\n\t1559: o_phase = +9'd62;\t //LUT[1559] \tphase : 0.242188\t(data_i, data_q): (0.750000,0.718750)\n\t1560: o_phase = +9'd64;\t //LUT[1560] \tphase : 0.250000\t(data_i, data_q): (0.750000,0.750000)\n\t1561: o_phase = +9'd66;\t //LUT[1561] \tphase : 0.257812\t(data_i, data_q): (0.750000,0.781250)\n\t1562: o_phase = +9'd67;\t //LUT[1562] \tphase : 0.261719\t(data_i, data_q): (0.750000,0.812500)\n\t1563: o_phase = +9'd69;\t //LUT[1563] \tphase : 0.269531\t(data_i, data_q): (0.750000,0.843750)\n\t1564: o_phase = +9'd70;\t //LUT[1564] \tphase : 0.273438\t(data_i, data_q): (0.750000,0.875000)\n\t1565: o_phase = +9'd72;\t //LUT[1565] \tphase : 0.281250\t(data_i, data_q): (0.750000,0.906250)\n\t1566: o_phase = +9'd73;\t //LUT[1566] \tphase : 0.285156\t(data_i, data_q): (0.750000,0.937500)\n\t1567: o_phase = +9'd74;\t //LUT[1567] \tphase : 0.289062\t(data_i, data_q): (0.750000,0.968750)\n\t1568: o_phase = -9'd76;\t //LUT[1568] \tphase : -0.296875\t(data_i, data_q): (0.750000,-1.000000)\n\t1569: o_phase = -9'd74;\t //LUT[1569] \tphase : -0.289062\t(data_i, data_q): (0.750000,-0.968750)\n\t1570: o_phase = -9'd73;\t //LUT[1570] \tphase : -0.285156\t(data_i, data_q): (0.750000,-0.937500)\n\t1571: o_phase = -9'd72;\t //LUT[1571] \tphase : -0.281250\t(data_i, data_q): (0.750000,-0.906250)\n\t1572: o_phase = -9'd70;\t //LUT[1572] \tphase : -0.273438\t(data_i, data_q): (0.750000,-0.875000)\n\t1573: o_phase = -9'd69;\t //LUT[1573] \tphase : -0.269531\t(data_i, data_q): (0.750000,-0.843750)\n\t1574: o_phase = -9'd67;\t //LUT[1574] \tphase : -0.261719\t(data_i, data_q): (0.750000,-0.812500)\n\t1575: o_phase = -9'd66;\t //LUT[1575] \tphase : -0.257812\t(data_i, data_q): (0.750000,-0.781250)\n\t1576: o_phase = -9'd64;\t //LUT[1576] \tphase : -0.250000\t(data_i, data_q): (0.750000,-0.750000)\n\t1577: o_phase = -9'd62;\t //LUT[1577] \tphase : -0.242188\t(data_i, data_q): (0.750000,-0.718750)\n\t1578: o_phase = -9'd60;\t //LUT[1578] \tphase : -0.234375\t(data_i, data_q): (0.750000,-0.687500)\n\t1579: o_phase = -9'd59;\t //LUT[1579] \tphase : -0.230469\t(data_i, data_q): (0.750000,-0.656250)\n\t1580: o_phase = -9'd57;\t //LUT[1580] \tphase : -0.222656\t(data_i, data_q): (0.750000,-0.625000)\n\t1581: o_phase = -9'd55;\t //LUT[1581] \tphase : -0.214844\t(data_i, data_q): (0.750000,-0.593750)\n\t1582: o_phase = -9'd52;\t //LUT[1582] \tphase : -0.203125\t(data_i, data_q): (0.750000,-0.562500)\n\t1583: o_phase = -9'd50;\t //LUT[1583] \tphase : -0.195312\t(data_i, data_q): (0.750000,-0.531250)\n\t1584: o_phase = -9'd48;\t //LUT[1584] \tphase : -0.187500\t(data_i, data_q): (0.750000,-0.500000)\n\t1585: o_phase = -9'd46;\t //LUT[1585] \tphase : -0.179688\t(data_i, data_q): (0.750000,-0.468750)\n\t1586: o_phase = -9'd43;\t //LUT[1586] \tphase : -0.167969\t(data_i, data_q): (0.750000,-0.437500)\n\t1587: o_phase = -9'd40;\t //LUT[1587] \tphase : -0.156250\t(data_i, data_q): (0.750000,-0.406250)\n\t1588: o_phase = -9'd38;\t //LUT[1588] \tphase : -0.148438\t(data_i, data_q): (0.750000,-0.375000)\n\t1589: o_phase = -9'd35;\t //LUT[1589] \tphase : -0.136719\t(data_i, data_q): (0.750000,-0.343750)\n\t1590: o_phase = -9'd32;\t //LUT[1590] \tphase : -0.125000\t(data_i, data_q): (0.750000,-0.312500)\n\t1591: o_phase = -9'd29;\t //LUT[1591] \tphase : -0.113281\t(data_i, data_q): (0.750000,-0.281250)\n\t1592: o_phase = -9'd26;\t //LUT[1592] \tphase : -0.101562\t(data_i, data_q): (0.750000,-0.250000)\n\t1593: o_phase = -9'd23;\t //LUT[1593] \tphase : -0.089844\t(data_i, data_q): (0.750000,-0.218750)\n\t1594: o_phase = -9'd20;\t //LUT[1594] \tphase : -0.078125\t(data_i, data_q): (0.750000,-0.187500)\n\t1595: o_phase = -9'd17;\t //LUT[1595] \tphase : -0.066406\t(data_i, data_q): (0.750000,-0.156250)\n\t1596: o_phase = -9'd13;\t //LUT[1596] \tphase : -0.050781\t(data_i, data_q): (0.750000,-0.125000)\n\t1597: o_phase = -9'd10;\t //LUT[1597] \tphase : -0.039062\t(data_i, data_q): (0.750000,-0.093750)\n\t1598: o_phase = -9'd7;\t //LUT[1598] \tphase : -0.027344\t(data_i, data_q): (0.750000,-0.062500)\n\t1599: o_phase = -9'd3;\t //LUT[1599] \tphase : -0.011719\t(data_i, data_q): (0.750000,-0.031250)\n\t1600: o_phase = +9'd0;\t //LUT[1600] \tphase : 0.000000\t(data_i, data_q): (0.781250,0.000000)\n\t1601: o_phase = +9'd3;\t //LUT[1601] \tphase : 0.011719\t(data_i, data_q): (0.781250,0.031250)\n\t1602: o_phase = +9'd7;\t //LUT[1602] \tphase : 0.027344\t(data_i, data_q): (0.781250,0.062500)\n\t1603: o_phase = +9'd10;\t //LUT[1603] \tphase : 0.039062\t(data_i, data_q): (0.781250,0.093750)\n\t1604: o_phase = +9'd13;\t //LUT[1604] \tphase : 0.050781\t(data_i, data_q): (0.781250,0.125000)\n\t1605: o_phase = +9'd16;\t //LUT[1605] \tphase : 0.062500\t(data_i, data_q): (0.781250,0.156250)\n\t1606: o_phase = +9'd19;\t //LUT[1606] \tphase : 0.074219\t(data_i, data_q): (0.781250,0.187500)\n\t1607: o_phase = +9'd22;\t //LUT[1607] \tphase : 0.085938\t(data_i, data_q): (0.781250,0.218750)\n\t1608: o_phase = +9'd25;\t //LUT[1608] \tphase : 0.097656\t(data_i, data_q): (0.781250,0.250000)\n\t1609: o_phase = +9'd28;\t //LUT[1609] \tphase : 0.109375\t(data_i, data_q): (0.781250,0.281250)\n\t1610: o_phase = +9'd31;\t //LUT[1610] \tphase : 0.121094\t(data_i, data_q): (0.781250,0.312500)\n\t1611: o_phase = +9'd34;\t //LUT[1611] \tphase : 0.132812\t(data_i, data_q): (0.781250,0.343750)\n\t1612: o_phase = +9'd36;\t //LUT[1612] \tphase : 0.140625\t(data_i, data_q): (0.781250,0.375000)\n\t1613: o_phase = +9'd39;\t //LUT[1613] \tphase : 0.152344\t(data_i, data_q): (0.781250,0.406250)\n\t1614: o_phase = +9'd42;\t //LUT[1614] \tphase : 0.164062\t(data_i, data_q): (0.781250,0.437500)\n\t1615: o_phase = +9'd44;\t //LUT[1615] \tphase : 0.171875\t(data_i, data_q): (0.781250,0.468750)\n\t1616: o_phase = +9'd46;\t //LUT[1616] \tphase : 0.179688\t(data_i, data_q): (0.781250,0.500000)\n\t1617: o_phase = +9'd49;\t //LUT[1617] \tphase : 0.191406\t(data_i, data_q): (0.781250,0.531250)\n\t1618: o_phase = +9'd51;\t //LUT[1618] \tphase : 0.199219\t(data_i, data_q): (0.781250,0.562500)\n\t1619: o_phase = +9'd53;\t //LUT[1619] \tphase : 0.207031\t(data_i, data_q): (0.781250,0.593750)\n\t1620: o_phase = +9'd55;\t //LUT[1620] \tphase : 0.214844\t(data_i, data_q): (0.781250,0.625000)\n\t1621: o_phase = +9'd57;\t //LUT[1621] \tphase : 0.222656\t(data_i, data_q): (0.781250,0.656250)\n\t1622: o_phase = +9'd59;\t //LUT[1622] \tphase : 0.230469\t(data_i, data_q): (0.781250,0.687500)\n\t1623: o_phase = +9'd61;\t //LUT[1623] \tphase : 0.238281\t(data_i, data_q): (0.781250,0.718750)\n\t1624: o_phase = +9'd62;\t //LUT[1624] \tphase : 0.242188\t(data_i, data_q): (0.781250,0.750000)\n\t1625: o_phase = +9'd64;\t //LUT[1625] \tphase : 0.250000\t(data_i, data_q): (0.781250,0.781250)\n\t1626: o_phase = +9'd66;\t //LUT[1626] \tphase : 0.257812\t(data_i, data_q): (0.781250,0.812500)\n\t1627: o_phase = +9'd67;\t //LUT[1627] \tphase : 0.261719\t(data_i, data_q): (0.781250,0.843750)\n\t1628: o_phase = +9'd69;\t //LUT[1628] \tphase : 0.269531\t(data_i, data_q): (0.781250,0.875000)\n\t1629: o_phase = +9'd70;\t //LUT[1629] \tphase : 0.273438\t(data_i, data_q): (0.781250,0.906250)\n\t1630: o_phase = +9'd71;\t //LUT[1630] \tphase : 0.277344\t(data_i, data_q): (0.781250,0.937500)\n\t1631: o_phase = +9'd73;\t //LUT[1631] \tphase : 0.285156\t(data_i, data_q): (0.781250,0.968750)\n\t1632: o_phase = -9'd74;\t //LUT[1632] \tphase : -0.289062\t(data_i, data_q): (0.781250,-1.000000)\n\t1633: o_phase = -9'd73;\t //LUT[1633] \tphase : -0.285156\t(data_i, data_q): (0.781250,-0.968750)\n\t1634: o_phase = -9'd71;\t //LUT[1634] \tphase : -0.277344\t(data_i, data_q): (0.781250,-0.937500)\n\t1635: o_phase = -9'd70;\t //LUT[1635] \tphase : -0.273438\t(data_i, data_q): (0.781250,-0.906250)\n\t1636: o_phase = -9'd69;\t //LUT[1636] \tphase : -0.269531\t(data_i, data_q): (0.781250,-0.875000)\n\t1637: o_phase = -9'd67;\t //LUT[1637] \tphase : -0.261719\t(data_i, data_q): (0.781250,-0.843750)\n\t1638: o_phase = -9'd66;\t //LUT[1638] \tphase : -0.257812\t(data_i, data_q): (0.781250,-0.812500)\n\t1639: o_phase = -9'd64;\t //LUT[1639] \tphase : -0.250000\t(data_i, data_q): (0.781250,-0.781250)\n\t1640: o_phase = -9'd62;\t //LUT[1640] \tphase : -0.242188\t(data_i, data_q): (0.781250,-0.750000)\n\t1641: o_phase = -9'd61;\t //LUT[1641] \tphase : -0.238281\t(data_i, data_q): (0.781250,-0.718750)\n\t1642: o_phase = -9'd59;\t //LUT[1642] \tphase : -0.230469\t(data_i, data_q): (0.781250,-0.687500)\n\t1643: o_phase = -9'd57;\t //LUT[1643] \tphase : -0.222656\t(data_i, data_q): (0.781250,-0.656250)\n\t1644: o_phase = -9'd55;\t //LUT[1644] \tphase : -0.214844\t(data_i, data_q): (0.781250,-0.625000)\n\t1645: o_phase = -9'd53;\t //LUT[1645] \tphase : -0.207031\t(data_i, data_q): (0.781250,-0.593750)\n\t1646: o_phase = -9'd51;\t //LUT[1646] \tphase : -0.199219\t(data_i, data_q): (0.781250,-0.562500)\n\t1647: o_phase = -9'd49;\t //LUT[1647] \tphase : -0.191406\t(data_i, data_q): (0.781250,-0.531250)\n\t1648: o_phase = -9'd46;\t //LUT[1648] \tphase : -0.179688\t(data_i, data_q): (0.781250,-0.500000)\n\t1649: o_phase = -9'd44;\t //LUT[1649] \tphase : -0.171875\t(data_i, data_q): (0.781250,-0.468750)\n\t1650: o_phase = -9'd42;\t //LUT[1650] \tphase : -0.164062\t(data_i, data_q): (0.781250,-0.437500)\n\t1651: o_phase = -9'd39;\t //LUT[1651] \tphase : -0.152344\t(data_i, data_q): (0.781250,-0.406250)\n\t1652: o_phase = -9'd36;\t //LUT[1652] \tphase : -0.140625\t(data_i, data_q): (0.781250,-0.375000)\n\t1653: o_phase = -9'd34;\t //LUT[1653] \tphase : -0.132812\t(data_i, data_q): (0.781250,-0.343750)\n\t1654: o_phase = -9'd31;\t //LUT[1654] \tphase : -0.121094\t(data_i, data_q): (0.781250,-0.312500)\n\t1655: o_phase = -9'd28;\t //LUT[1655] \tphase : -0.109375\t(data_i, data_q): (0.781250,-0.281250)\n\t1656: o_phase = -9'd25;\t //LUT[1656] \tphase : -0.097656\t(data_i, data_q): (0.781250,-0.250000)\n\t1657: o_phase = -9'd22;\t //LUT[1657] \tphase : -0.085938\t(data_i, data_q): (0.781250,-0.218750)\n\t1658: o_phase = -9'd19;\t //LUT[1658] \tphase : -0.074219\t(data_i, data_q): (0.781250,-0.187500)\n\t1659: o_phase = -9'd16;\t //LUT[1659] \tphase : -0.062500\t(data_i, data_q): (0.781250,-0.156250)\n\t1660: o_phase = -9'd13;\t //LUT[1660] \tphase : -0.050781\t(data_i, data_q): (0.781250,-0.125000)\n\t1661: o_phase = -9'd10;\t //LUT[1661] \tphase : -0.039062\t(data_i, data_q): (0.781250,-0.093750)\n\t1662: o_phase = -9'd7;\t //LUT[1662] \tphase : -0.027344\t(data_i, data_q): (0.781250,-0.062500)\n\t1663: o_phase = -9'd3;\t //LUT[1663] \tphase : -0.011719\t(data_i, data_q): (0.781250,-0.031250)\n\t1664: o_phase = +9'd0;\t //LUT[1664] \tphase : 0.000000\t(data_i, data_q): (0.812500,0.000000)\n\t1665: o_phase = +9'd3;\t //LUT[1665] \tphase : 0.011719\t(data_i, data_q): (0.812500,0.031250)\n\t1666: o_phase = +9'd6;\t //LUT[1666] \tphase : 0.023438\t(data_i, data_q): (0.812500,0.062500)\n\t1667: o_phase = +9'd9;\t //LUT[1667] \tphase : 0.035156\t(data_i, data_q): (0.812500,0.093750)\n\t1668: o_phase = +9'd12;\t //LUT[1668] \tphase : 0.046875\t(data_i, data_q): (0.812500,0.125000)\n\t1669: o_phase = +9'd15;\t //LUT[1669] \tphase : 0.058594\t(data_i, data_q): (0.812500,0.156250)\n\t1670: o_phase = +9'd18;\t //LUT[1670] \tphase : 0.070312\t(data_i, data_q): (0.812500,0.187500)\n\t1671: o_phase = +9'd21;\t //LUT[1671] \tphase : 0.082031\t(data_i, data_q): (0.812500,0.218750)\n\t1672: o_phase = +9'd24;\t //LUT[1672] \tphase : 0.093750\t(data_i, data_q): (0.812500,0.250000)\n\t1673: o_phase = +9'd27;\t //LUT[1673] \tphase : 0.105469\t(data_i, data_q): (0.812500,0.281250)\n\t1674: o_phase = +9'd30;\t //LUT[1674] \tphase : 0.117188\t(data_i, data_q): (0.812500,0.312500)\n\t1675: o_phase = +9'd33;\t //LUT[1675] \tphase : 0.128906\t(data_i, data_q): (0.812500,0.343750)\n\t1676: o_phase = +9'd35;\t //LUT[1676] \tphase : 0.136719\t(data_i, data_q): (0.812500,0.375000)\n\t1677: o_phase = +9'd38;\t //LUT[1677] \tphase : 0.148438\t(data_i, data_q): (0.812500,0.406250)\n\t1678: o_phase = +9'd40;\t //LUT[1678] \tphase : 0.156250\t(data_i, data_q): (0.812500,0.437500)\n\t1679: o_phase = +9'd43;\t //LUT[1679] \tphase : 0.167969\t(data_i, data_q): (0.812500,0.468750)\n\t1680: o_phase = +9'd45;\t //LUT[1680] \tphase : 0.175781\t(data_i, data_q): (0.812500,0.500000)\n\t1681: o_phase = +9'd47;\t //LUT[1681] \tphase : 0.183594\t(data_i, data_q): (0.812500,0.531250)\n\t1682: o_phase = +9'd49;\t //LUT[1682] \tphase : 0.191406\t(data_i, data_q): (0.812500,0.562500)\n\t1683: o_phase = +9'd51;\t //LUT[1683] \tphase : 0.199219\t(data_i, data_q): (0.812500,0.593750)\n\t1684: o_phase = +9'd53;\t //LUT[1684] \tphase : 0.207031\t(data_i, data_q): (0.812500,0.625000)\n\t1685: o_phase = +9'd55;\t //LUT[1685] \tphase : 0.214844\t(data_i, data_q): (0.812500,0.656250)\n\t1686: o_phase = +9'd57;\t //LUT[1686] \tphase : 0.222656\t(data_i, data_q): (0.812500,0.687500)\n\t1687: o_phase = +9'd59;\t //LUT[1687] \tphase : 0.230469\t(data_i, data_q): (0.812500,0.718750)\n\t1688: o_phase = +9'd61;\t //LUT[1688] \tphase : 0.238281\t(data_i, data_q): (0.812500,0.750000)\n\t1689: o_phase = +9'd62;\t //LUT[1689] \tphase : 0.242188\t(data_i, data_q): (0.812500,0.781250)\n\t1690: o_phase = +9'd64;\t //LUT[1690] \tphase : 0.250000\t(data_i, data_q): (0.812500,0.812500)\n\t1691: o_phase = +9'd66;\t //LUT[1691] \tphase : 0.257812\t(data_i, data_q): (0.812500,0.843750)\n\t1692: o_phase = +9'd67;\t //LUT[1692] \tphase : 0.261719\t(data_i, data_q): (0.812500,0.875000)\n\t1693: o_phase = +9'd68;\t //LUT[1693] \tphase : 0.265625\t(data_i, data_q): (0.812500,0.906250)\n\t1694: o_phase = +9'd70;\t //LUT[1694] \tphase : 0.273438\t(data_i, data_q): (0.812500,0.937500)\n\t1695: o_phase = +9'd71;\t //LUT[1695] \tphase : 0.277344\t(data_i, data_q): (0.812500,0.968750)\n\t1696: o_phase = -9'd72;\t //LUT[1696] \tphase : -0.281250\t(data_i, data_q): (0.812500,-1.000000)\n\t1697: o_phase = -9'd71;\t //LUT[1697] \tphase : -0.277344\t(data_i, data_q): (0.812500,-0.968750)\n\t1698: o_phase = -9'd70;\t //LUT[1698] \tphase : -0.273438\t(data_i, data_q): (0.812500,-0.937500)\n\t1699: o_phase = -9'd68;\t //LUT[1699] \tphase : -0.265625\t(data_i, data_q): (0.812500,-0.906250)\n\t1700: o_phase = -9'd67;\t //LUT[1700] \tphase : -0.261719\t(data_i, data_q): (0.812500,-0.875000)\n\t1701: o_phase = -9'd66;\t //LUT[1701] \tphase : -0.257812\t(data_i, data_q): (0.812500,-0.843750)\n\t1702: o_phase = -9'd64;\t //LUT[1702] \tphase : -0.250000\t(data_i, data_q): (0.812500,-0.812500)\n\t1703: o_phase = -9'd62;\t //LUT[1703] \tphase : -0.242188\t(data_i, data_q): (0.812500,-0.781250)\n\t1704: o_phase = -9'd61;\t //LUT[1704] \tphase : -0.238281\t(data_i, data_q): (0.812500,-0.750000)\n\t1705: o_phase = -9'd59;\t //LUT[1705] \tphase : -0.230469\t(data_i, data_q): (0.812500,-0.718750)\n\t1706: o_phase = -9'd57;\t //LUT[1706] \tphase : -0.222656\t(data_i, data_q): (0.812500,-0.687500)\n\t1707: o_phase = -9'd55;\t //LUT[1707] \tphase : -0.214844\t(data_i, data_q): (0.812500,-0.656250)\n\t1708: o_phase = -9'd53;\t //LUT[1708] \tphase : -0.207031\t(data_i, data_q): (0.812500,-0.625000)\n\t1709: o_phase = -9'd51;\t //LUT[1709] \tphase : -0.199219\t(data_i, data_q): (0.812500,-0.593750)\n\t1710: o_phase = -9'd49;\t //LUT[1710] \tphase : -0.191406\t(data_i, data_q): (0.812500,-0.562500)\n\t1711: o_phase = -9'd47;\t //LUT[1711] \tphase : -0.183594\t(data_i, data_q): (0.812500,-0.531250)\n\t1712: o_phase = -9'd45;\t //LUT[1712] \tphase : -0.175781\t(data_i, data_q): (0.812500,-0.500000)\n\t1713: o_phase = -9'd43;\t //LUT[1713] \tphase : -0.167969\t(data_i, data_q): (0.812500,-0.468750)\n\t1714: o_phase = -9'd40;\t //LUT[1714] \tphase : -0.156250\t(data_i, data_q): (0.812500,-0.437500)\n\t1715: o_phase = -9'd38;\t //LUT[1715] \tphase : -0.148438\t(data_i, data_q): (0.812500,-0.406250)\n\t1716: o_phase = -9'd35;\t //LUT[1716] \tphase : -0.136719\t(data_i, data_q): (0.812500,-0.375000)\n\t1717: o_phase = -9'd33;\t //LUT[1717] \tphase : -0.128906\t(data_i, data_q): (0.812500,-0.343750)\n\t1718: o_phase = -9'd30;\t //LUT[1718] \tphase : -0.117188\t(data_i, data_q): (0.812500,-0.312500)\n\t1719: o_phase = -9'd27;\t //LUT[1719] \tphase : -0.105469\t(data_i, data_q): (0.812500,-0.281250)\n\t1720: o_phase = -9'd24;\t //LUT[1720] \tphase : -0.093750\t(data_i, data_q): (0.812500,-0.250000)\n\t1721: o_phase = -9'd21;\t //LUT[1721] \tphase : -0.082031\t(data_i, data_q): (0.812500,-0.218750)\n\t1722: o_phase = -9'd18;\t //LUT[1722] \tphase : -0.070312\t(data_i, data_q): (0.812500,-0.187500)\n\t1723: o_phase = -9'd15;\t //LUT[1723] \tphase : -0.058594\t(data_i, data_q): (0.812500,-0.156250)\n\t1724: o_phase = -9'd12;\t //LUT[1724] \tphase : -0.046875\t(data_i, data_q): (0.812500,-0.125000)\n\t1725: o_phase = -9'd9;\t //LUT[1725] \tphase : -0.035156\t(data_i, data_q): (0.812500,-0.093750)\n\t1726: o_phase = -9'd6;\t //LUT[1726] \tphase : -0.023438\t(data_i, data_q): (0.812500,-0.062500)\n\t1727: o_phase = -9'd3;\t //LUT[1727] \tphase : -0.011719\t(data_i, data_q): (0.812500,-0.031250)\n\t1728: o_phase = +9'd0;\t //LUT[1728] \tphase : 0.000000\t(data_i, data_q): (0.843750,0.000000)\n\t1729: o_phase = +9'd3;\t //LUT[1729] \tphase : 0.011719\t(data_i, data_q): (0.843750,0.031250)\n\t1730: o_phase = +9'd6;\t //LUT[1730] \tphase : 0.023438\t(data_i, data_q): (0.843750,0.062500)\n\t1731: o_phase = +9'd9;\t //LUT[1731] \tphase : 0.035156\t(data_i, data_q): (0.843750,0.093750)\n\t1732: o_phase = +9'd12;\t //LUT[1732] \tphase : 0.046875\t(data_i, data_q): (0.843750,0.125000)\n\t1733: o_phase = +9'd15;\t //LUT[1733] \tphase : 0.058594\t(data_i, data_q): (0.843750,0.156250)\n\t1734: o_phase = +9'd18;\t //LUT[1734] \tphase : 0.070312\t(data_i, data_q): (0.843750,0.187500)\n\t1735: o_phase = +9'd21;\t //LUT[1735] \tphase : 0.082031\t(data_i, data_q): (0.843750,0.218750)\n\t1736: o_phase = +9'd23;\t //LUT[1736] \tphase : 0.089844\t(data_i, data_q): (0.843750,0.250000)\n\t1737: o_phase = +9'd26;\t //LUT[1737] \tphase : 0.101562\t(data_i, data_q): (0.843750,0.281250)\n\t1738: o_phase = +9'd29;\t //LUT[1738] \tphase : 0.113281\t(data_i, data_q): (0.843750,0.312500)\n\t1739: o_phase = +9'd32;\t //LUT[1739] \tphase : 0.125000\t(data_i, data_q): (0.843750,0.343750)\n\t1740: o_phase = +9'd34;\t //LUT[1740] \tphase : 0.132812\t(data_i, data_q): (0.843750,0.375000)\n\t1741: o_phase = +9'd37;\t //LUT[1741] \tphase : 0.144531\t(data_i, data_q): (0.843750,0.406250)\n\t1742: o_phase = +9'd39;\t //LUT[1742] \tphase : 0.152344\t(data_i, data_q): (0.843750,0.437500)\n\t1743: o_phase = +9'd41;\t //LUT[1743] \tphase : 0.160156\t(data_i, data_q): (0.843750,0.468750)\n\t1744: o_phase = +9'd44;\t //LUT[1744] \tphase : 0.171875\t(data_i, data_q): (0.843750,0.500000)\n\t1745: o_phase = +9'd46;\t //LUT[1745] \tphase : 0.179688\t(data_i, data_q): (0.843750,0.531250)\n\t1746: o_phase = +9'd48;\t //LUT[1746] \tphase : 0.187500\t(data_i, data_q): (0.843750,0.562500)\n\t1747: o_phase = +9'd50;\t //LUT[1747] \tphase : 0.195312\t(data_i, data_q): (0.843750,0.593750)\n\t1748: o_phase = +9'd52;\t //LUT[1748] \tphase : 0.203125\t(data_i, data_q): (0.843750,0.625000)\n\t1749: o_phase = +9'd54;\t //LUT[1749] \tphase : 0.210938\t(data_i, data_q): (0.843750,0.656250)\n\t1750: o_phase = +9'd56;\t //LUT[1750] \tphase : 0.218750\t(data_i, data_q): (0.843750,0.687500)\n\t1751: o_phase = +9'd57;\t //LUT[1751] \tphase : 0.222656\t(data_i, data_q): (0.843750,0.718750)\n\t1752: o_phase = +9'd59;\t //LUT[1752] \tphase : 0.230469\t(data_i, data_q): (0.843750,0.750000)\n\t1753: o_phase = +9'd61;\t //LUT[1753] \tphase : 0.238281\t(data_i, data_q): (0.843750,0.781250)\n\t1754: o_phase = +9'd62;\t //LUT[1754] \tphase : 0.242188\t(data_i, data_q): (0.843750,0.812500)\n\t1755: o_phase = +9'd64;\t //LUT[1755] \tphase : 0.250000\t(data_i, data_q): (0.843750,0.843750)\n\t1756: o_phase = +9'd65;\t //LUT[1756] \tphase : 0.253906\t(data_i, data_q): (0.843750,0.875000)\n\t1757: o_phase = +9'd67;\t //LUT[1757] \tphase : 0.261719\t(data_i, data_q): (0.843750,0.906250)\n\t1758: o_phase = +9'd68;\t //LUT[1758] \tphase : 0.265625\t(data_i, data_q): (0.843750,0.937500)\n\t1759: o_phase = +9'd70;\t //LUT[1759] \tphase : 0.273438\t(data_i, data_q): (0.843750,0.968750)\n\t1760: o_phase = -9'd71;\t //LUT[1760] \tphase : -0.277344\t(data_i, data_q): (0.843750,-1.000000)\n\t1761: o_phase = -9'd70;\t //LUT[1761] \tphase : -0.273438\t(data_i, data_q): (0.843750,-0.968750)\n\t1762: o_phase = -9'd68;\t //LUT[1762] \tphase : -0.265625\t(data_i, data_q): (0.843750,-0.937500)\n\t1763: o_phase = -9'd67;\t //LUT[1763] \tphase : -0.261719\t(data_i, data_q): (0.843750,-0.906250)\n\t1764: o_phase = -9'd65;\t //LUT[1764] \tphase : -0.253906\t(data_i, data_q): (0.843750,-0.875000)\n\t1765: o_phase = -9'd64;\t //LUT[1765] \tphase : -0.250000\t(data_i, data_q): (0.843750,-0.843750)\n\t1766: o_phase = -9'd62;\t //LUT[1766] \tphase : -0.242188\t(data_i, data_q): (0.843750,-0.812500)\n\t1767: o_phase = -9'd61;\t //LUT[1767] \tphase : -0.238281\t(data_i, data_q): (0.843750,-0.781250)\n\t1768: o_phase = -9'd59;\t //LUT[1768] \tphase : -0.230469\t(data_i, data_q): (0.843750,-0.750000)\n\t1769: o_phase = -9'd57;\t //LUT[1769] \tphase : -0.222656\t(data_i, data_q): (0.843750,-0.718750)\n\t1770: o_phase = -9'd56;\t //LUT[1770] \tphase : -0.218750\t(data_i, data_q): (0.843750,-0.687500)\n\t1771: o_phase = -9'd54;\t //LUT[1771] \tphase : -0.210938\t(data_i, data_q): (0.843750,-0.656250)\n\t1772: o_phase = -9'd52;\t //LUT[1772] \tphase : -0.203125\t(data_i, data_q): (0.843750,-0.625000)\n\t1773: o_phase = -9'd50;\t //LUT[1773] \tphase : -0.195312\t(data_i, data_q): (0.843750,-0.593750)\n\t1774: o_phase = -9'd48;\t //LUT[1774] \tphase : -0.187500\t(data_i, data_q): (0.843750,-0.562500)\n\t1775: o_phase = -9'd46;\t //LUT[1775] \tphase : -0.179688\t(data_i, data_q): (0.843750,-0.531250)\n\t1776: o_phase = -9'd44;\t //LUT[1776] \tphase : -0.171875\t(data_i, data_q): (0.843750,-0.500000)\n\t1777: o_phase = -9'd41;\t //LUT[1777] \tphase : -0.160156\t(data_i, data_q): (0.843750,-0.468750)\n\t1778: o_phase = -9'd39;\t //LUT[1778] \tphase : -0.152344\t(data_i, data_q): (0.843750,-0.437500)\n\t1779: o_phase = -9'd37;\t //LUT[1779] \tphase : -0.144531\t(data_i, data_q): (0.843750,-0.406250)\n\t1780: o_phase = -9'd34;\t //LUT[1780] \tphase : -0.132812\t(data_i, data_q): (0.843750,-0.375000)\n\t1781: o_phase = -9'd32;\t //LUT[1781] \tphase : -0.125000\t(data_i, data_q): (0.843750,-0.343750)\n\t1782: o_phase = -9'd29;\t //LUT[1782] \tphase : -0.113281\t(data_i, data_q): (0.843750,-0.312500)\n\t1783: o_phase = -9'd26;\t //LUT[1783] \tphase : -0.101562\t(data_i, data_q): (0.843750,-0.281250)\n\t1784: o_phase = -9'd23;\t //LUT[1784] \tphase : -0.089844\t(data_i, data_q): (0.843750,-0.250000)\n\t1785: o_phase = -9'd21;\t //LUT[1785] \tphase : -0.082031\t(data_i, data_q): (0.843750,-0.218750)\n\t1786: o_phase = -9'd18;\t //LUT[1786] \tphase : -0.070312\t(data_i, data_q): (0.843750,-0.187500)\n\t1787: o_phase = -9'd15;\t //LUT[1787] \tphase : -0.058594\t(data_i, data_q): (0.843750,-0.156250)\n\t1788: o_phase = -9'd12;\t //LUT[1788] \tphase : -0.046875\t(data_i, data_q): (0.843750,-0.125000)\n\t1789: o_phase = -9'd9;\t //LUT[1789] \tphase : -0.035156\t(data_i, data_q): (0.843750,-0.093750)\n\t1790: o_phase = -9'd6;\t //LUT[1790] \tphase : -0.023438\t(data_i, data_q): (0.843750,-0.062500)\n\t1791: o_phase = -9'd3;\t //LUT[1791] \tphase : -0.011719\t(data_i, data_q): (0.843750,-0.031250)\n\t1792: o_phase = +9'd0;\t //LUT[1792] \tphase : 0.000000\t(data_i, data_q): (0.875000,0.000000)\n\t1793: o_phase = +9'd3;\t //LUT[1793] \tphase : 0.011719\t(data_i, data_q): (0.875000,0.031250)\n\t1794: o_phase = +9'd6;\t //LUT[1794] \tphase : 0.023438\t(data_i, data_q): (0.875000,0.062500)\n\t1795: o_phase = +9'd9;\t //LUT[1795] \tphase : 0.035156\t(data_i, data_q): (0.875000,0.093750)\n\t1796: o_phase = +9'd12;\t //LUT[1796] \tphase : 0.046875\t(data_i, data_q): (0.875000,0.125000)\n\t1797: o_phase = +9'd14;\t //LUT[1797] \tphase : 0.054688\t(data_i, data_q): (0.875000,0.156250)\n\t1798: o_phase = +9'd17;\t //LUT[1798] \tphase : 0.066406\t(data_i, data_q): (0.875000,0.187500)\n\t1799: o_phase = +9'd20;\t //LUT[1799] \tphase : 0.078125\t(data_i, data_q): (0.875000,0.218750)\n\t1800: o_phase = +9'd23;\t //LUT[1800] \tphase : 0.089844\t(data_i, data_q): (0.875000,0.250000)\n\t1801: o_phase = +9'd25;\t //LUT[1801] \tphase : 0.097656\t(data_i, data_q): (0.875000,0.281250)\n\t1802: o_phase = +9'd28;\t //LUT[1802] \tphase : 0.109375\t(data_i, data_q): (0.875000,0.312500)\n\t1803: o_phase = +9'd31;\t //LUT[1803] \tphase : 0.121094\t(data_i, data_q): (0.875000,0.343750)\n\t1804: o_phase = +9'd33;\t //LUT[1804] \tphase : 0.128906\t(data_i, data_q): (0.875000,0.375000)\n\t1805: o_phase = +9'd35;\t //LUT[1805] \tphase : 0.136719\t(data_i, data_q): (0.875000,0.406250)\n\t1806: o_phase = +9'd38;\t //LUT[1806] \tphase : 0.148438\t(data_i, data_q): (0.875000,0.437500)\n\t1807: o_phase = +9'd40;\t //LUT[1807] \tphase : 0.156250\t(data_i, data_q): (0.875000,0.468750)\n\t1808: o_phase = +9'd42;\t //LUT[1808] \tphase : 0.164062\t(data_i, data_q): (0.875000,0.500000)\n\t1809: o_phase = +9'd44;\t //LUT[1809] \tphase : 0.171875\t(data_i, data_q): (0.875000,0.531250)\n\t1810: o_phase = +9'd47;\t //LUT[1810] \tphase : 0.183594\t(data_i, data_q): (0.875000,0.562500)\n\t1811: o_phase = +9'd49;\t //LUT[1811] \tphase : 0.191406\t(data_i, data_q): (0.875000,0.593750)\n\t1812: o_phase = +9'd51;\t //LUT[1812] \tphase : 0.199219\t(data_i, data_q): (0.875000,0.625000)\n\t1813: o_phase = +9'd52;\t //LUT[1813] \tphase : 0.203125\t(data_i, data_q): (0.875000,0.656250)\n\t1814: o_phase = +9'd54;\t //LUT[1814] \tphase : 0.210938\t(data_i, data_q): (0.875000,0.687500)\n\t1815: o_phase = +9'd56;\t //LUT[1815] \tphase : 0.218750\t(data_i, data_q): (0.875000,0.718750)\n\t1816: o_phase = +9'd58;\t //LUT[1816] \tphase : 0.226562\t(data_i, data_q): (0.875000,0.750000)\n\t1817: o_phase = +9'd59;\t //LUT[1817] \tphase : 0.230469\t(data_i, data_q): (0.875000,0.781250)\n\t1818: o_phase = +9'd61;\t //LUT[1818] \tphase : 0.238281\t(data_i, data_q): (0.875000,0.812500)\n\t1819: o_phase = +9'd63;\t //LUT[1819] \tphase : 0.246094\t(data_i, data_q): (0.875000,0.843750)\n\t1820: o_phase = +9'd64;\t //LUT[1820] \tphase : 0.250000\t(data_i, data_q): (0.875000,0.875000)\n\t1821: o_phase = +9'd65;\t //LUT[1821] \tphase : 0.253906\t(data_i, data_q): (0.875000,0.906250)\n\t1822: o_phase = +9'd67;\t //LUT[1822] \tphase : 0.261719\t(data_i, data_q): (0.875000,0.937500)\n\t1823: o_phase = +9'd68;\t //LUT[1823] \tphase : 0.265625\t(data_i, data_q): (0.875000,0.968750)\n\t1824: o_phase = -9'd69;\t //LUT[1824] \tphase : -0.269531\t(data_i, data_q): (0.875000,-1.000000)\n\t1825: o_phase = -9'd68;\t //LUT[1825] \tphase : -0.265625\t(data_i, data_q): (0.875000,-0.968750)\n\t1826: o_phase = -9'd67;\t //LUT[1826] \tphase : -0.261719\t(data_i, data_q): (0.875000,-0.937500)\n\t1827: o_phase = -9'd65;\t //LUT[1827] \tphase : -0.253906\t(data_i, data_q): (0.875000,-0.906250)\n\t1828: o_phase = -9'd64;\t //LUT[1828] \tphase : -0.250000\t(data_i, data_q): (0.875000,-0.875000)\n\t1829: o_phase = -9'd63;\t //LUT[1829] \tphase : -0.246094\t(data_i, data_q): (0.875000,-0.843750)\n\t1830: o_phase = -9'd61;\t //LUT[1830] \tphase : -0.238281\t(data_i, data_q): (0.875000,-0.812500)\n\t1831: o_phase = -9'd59;\t //LUT[1831] \tphase : -0.230469\t(data_i, data_q): (0.875000,-0.781250)\n\t1832: o_phase = -9'd58;\t //LUT[1832] \tphase : -0.226562\t(data_i, data_q): (0.875000,-0.750000)\n\t1833: o_phase = -9'd56;\t //LUT[1833] \tphase : -0.218750\t(data_i, data_q): (0.875000,-0.718750)\n\t1834: o_phase = -9'd54;\t //LUT[1834] \tphase : -0.210938\t(data_i, data_q): (0.875000,-0.687500)\n\t1835: o_phase = -9'd52;\t //LUT[1835] \tphase : -0.203125\t(data_i, data_q): (0.875000,-0.656250)\n\t1836: o_phase = -9'd51;\t //LUT[1836] \tphase : -0.199219\t(data_i, data_q): (0.875000,-0.625000)\n\t1837: o_phase = -9'd49;\t //LUT[1837] \tphase : -0.191406\t(data_i, data_q): (0.875000,-0.593750)\n\t1838: o_phase = -9'd47;\t //LUT[1838] \tphase : -0.183594\t(data_i, data_q): (0.875000,-0.562500)\n\t1839: o_phase = -9'd44;\t //LUT[1839] \tphase : -0.171875\t(data_i, data_q): (0.875000,-0.531250)\n\t1840: o_phase = -9'd42;\t //LUT[1840] \tphase : -0.164062\t(data_i, data_q): (0.875000,-0.500000)\n\t1841: o_phase = -9'd40;\t //LUT[1841] \tphase : -0.156250\t(data_i, data_q): (0.875000,-0.468750)\n\t1842: o_phase = -9'd38;\t //LUT[1842] \tphase : -0.148438\t(data_i, data_q): (0.875000,-0.437500)\n\t1843: o_phase = -9'd35;\t //LUT[1843] \tphase : -0.136719\t(data_i, data_q): (0.875000,-0.406250)\n\t1844: o_phase = -9'd33;\t //LUT[1844] \tphase : -0.128906\t(data_i, data_q): (0.875000,-0.375000)\n\t1845: o_phase = -9'd31;\t //LUT[1845] \tphase : -0.121094\t(data_i, data_q): (0.875000,-0.343750)\n\t1846: o_phase = -9'd28;\t //LUT[1846] \tphase : -0.109375\t(data_i, data_q): (0.875000,-0.312500)\n\t1847: o_phase = -9'd25;\t //LUT[1847] \tphase : -0.097656\t(data_i, data_q): (0.875000,-0.281250)\n\t1848: o_phase = -9'd23;\t //LUT[1848] \tphase : -0.089844\t(data_i, data_q): (0.875000,-0.250000)\n\t1849: o_phase = -9'd20;\t //LUT[1849] \tphase : -0.078125\t(data_i, data_q): (0.875000,-0.218750)\n\t1850: o_phase = -9'd17;\t //LUT[1850] \tphase : -0.066406\t(data_i, data_q): (0.875000,-0.187500)\n\t1851: o_phase = -9'd14;\t //LUT[1851] \tphase : -0.054688\t(data_i, data_q): (0.875000,-0.156250)\n\t1852: o_phase = -9'd12;\t //LUT[1852] \tphase : -0.046875\t(data_i, data_q): (0.875000,-0.125000)\n\t1853: o_phase = -9'd9;\t //LUT[1853] \tphase : -0.035156\t(data_i, data_q): (0.875000,-0.093750)\n\t1854: o_phase = -9'd6;\t //LUT[1854] \tphase : -0.023438\t(data_i, data_q): (0.875000,-0.062500)\n\t1855: o_phase = -9'd3;\t //LUT[1855] \tphase : -0.011719\t(data_i, data_q): (0.875000,-0.031250)\n\t1856: o_phase = +9'd0;\t //LUT[1856] \tphase : 0.000000\t(data_i, data_q): (0.906250,0.000000)\n\t1857: o_phase = +9'd3;\t //LUT[1857] \tphase : 0.011719\t(data_i, data_q): (0.906250,0.031250)\n\t1858: o_phase = +9'd6;\t //LUT[1858] \tphase : 0.023438\t(data_i, data_q): (0.906250,0.062500)\n\t1859: o_phase = +9'd8;\t //LUT[1859] \tphase : 0.031250\t(data_i, data_q): (0.906250,0.093750)\n\t1860: o_phase = +9'd11;\t //LUT[1860] \tphase : 0.042969\t(data_i, data_q): (0.906250,0.125000)\n\t1861: o_phase = +9'd14;\t //LUT[1861] \tphase : 0.054688\t(data_i, data_q): (0.906250,0.156250)\n\t1862: o_phase = +9'd17;\t //LUT[1862] \tphase : 0.066406\t(data_i, data_q): (0.906250,0.187500)\n\t1863: o_phase = +9'd19;\t //LUT[1863] \tphase : 0.074219\t(data_i, data_q): (0.906250,0.218750)\n\t1864: o_phase = +9'd22;\t //LUT[1864] \tphase : 0.085938\t(data_i, data_q): (0.906250,0.250000)\n\t1865: o_phase = +9'd25;\t //LUT[1865] \tphase : 0.097656\t(data_i, data_q): (0.906250,0.281250)\n\t1866: o_phase = +9'd27;\t //LUT[1866] \tphase : 0.105469\t(data_i, data_q): (0.906250,0.312500)\n\t1867: o_phase = +9'd30;\t //LUT[1867] \tphase : 0.117188\t(data_i, data_q): (0.906250,0.343750)\n\t1868: o_phase = +9'd32;\t //LUT[1868] \tphase : 0.125000\t(data_i, data_q): (0.906250,0.375000)\n\t1869: o_phase = +9'd34;\t //LUT[1869] \tphase : 0.132812\t(data_i, data_q): (0.906250,0.406250)\n\t1870: o_phase = +9'd37;\t //LUT[1870] \tphase : 0.144531\t(data_i, data_q): (0.906250,0.437500)\n\t1871: o_phase = +9'd39;\t //LUT[1871] \tphase : 0.152344\t(data_i, data_q): (0.906250,0.468750)\n\t1872: o_phase = +9'd41;\t //LUT[1872] \tphase : 0.160156\t(data_i, data_q): (0.906250,0.500000)\n\t1873: o_phase = +9'd43;\t //LUT[1873] \tphase : 0.167969\t(data_i, data_q): (0.906250,0.531250)\n\t1874: o_phase = +9'd45;\t //LUT[1874] \tphase : 0.175781\t(data_i, data_q): (0.906250,0.562500)\n\t1875: o_phase = +9'd47;\t //LUT[1875] \tphase : 0.183594\t(data_i, data_q): (0.906250,0.593750)\n\t1876: o_phase = +9'd49;\t //LUT[1876] \tphase : 0.191406\t(data_i, data_q): (0.906250,0.625000)\n\t1877: o_phase = +9'd51;\t //LUT[1877] \tphase : 0.199219\t(data_i, data_q): (0.906250,0.656250)\n\t1878: o_phase = +9'd53;\t //LUT[1878] \tphase : 0.207031\t(data_i, data_q): (0.906250,0.687500)\n\t1879: o_phase = +9'd55;\t //LUT[1879] \tphase : 0.214844\t(data_i, data_q): (0.906250,0.718750)\n\t1880: o_phase = +9'd56;\t //LUT[1880] \tphase : 0.218750\t(data_i, data_q): (0.906250,0.750000)\n\t1881: o_phase = +9'd58;\t //LUT[1881] \tphase : 0.226562\t(data_i, data_q): (0.906250,0.781250)\n\t1882: o_phase = +9'd60;\t //LUT[1882] \tphase : 0.234375\t(data_i, data_q): (0.906250,0.812500)\n\t1883: o_phase = +9'd61;\t //LUT[1883] \tphase : 0.238281\t(data_i, data_q): (0.906250,0.843750)\n\t1884: o_phase = +9'd63;\t //LUT[1884] \tphase : 0.246094\t(data_i, data_q): (0.906250,0.875000)\n\t1885: o_phase = +9'd64;\t //LUT[1885] \tphase : 0.250000\t(data_i, data_q): (0.906250,0.906250)\n\t1886: o_phase = +9'd65;\t //LUT[1886] \tphase : 0.253906\t(data_i, data_q): (0.906250,0.937500)\n\t1887: o_phase = +9'd67;\t //LUT[1887] \tphase : 0.261719\t(data_i, data_q): (0.906250,0.968750)\n\t1888: o_phase = -9'd68;\t //LUT[1888] \tphase : -0.265625\t(data_i, data_q): (0.906250,-1.000000)\n\t1889: o_phase = -9'd67;\t //LUT[1889] \tphase : -0.261719\t(data_i, data_q): (0.906250,-0.968750)\n\t1890: o_phase = -9'd65;\t //LUT[1890] \tphase : -0.253906\t(data_i, data_q): (0.906250,-0.937500)\n\t1891: o_phase = -9'd64;\t //LUT[1891] \tphase : -0.250000\t(data_i, data_q): (0.906250,-0.906250)\n\t1892: o_phase = -9'd63;\t //LUT[1892] \tphase : -0.246094\t(data_i, data_q): (0.906250,-0.875000)\n\t1893: o_phase = -9'd61;\t //LUT[1893] \tphase : -0.238281\t(data_i, data_q): (0.906250,-0.843750)\n\t1894: o_phase = -9'd60;\t //LUT[1894] \tphase : -0.234375\t(data_i, data_q): (0.906250,-0.812500)\n\t1895: o_phase = -9'd58;\t //LUT[1895] \tphase : -0.226562\t(data_i, data_q): (0.906250,-0.781250)\n\t1896: o_phase = -9'd56;\t //LUT[1896] \tphase : -0.218750\t(data_i, data_q): (0.906250,-0.750000)\n\t1897: o_phase = -9'd55;\t //LUT[1897] \tphase : -0.214844\t(data_i, data_q): (0.906250,-0.718750)\n\t1898: o_phase = -9'd53;\t //LUT[1898] \tphase : -0.207031\t(data_i, data_q): (0.906250,-0.687500)\n\t1899: o_phase = -9'd51;\t //LUT[1899] \tphase : -0.199219\t(data_i, data_q): (0.906250,-0.656250)\n\t1900: o_phase = -9'd49;\t //LUT[1900] \tphase : -0.191406\t(data_i, data_q): (0.906250,-0.625000)\n\t1901: o_phase = -9'd47;\t //LUT[1901] \tphase : -0.183594\t(data_i, data_q): (0.906250,-0.593750)\n\t1902: o_phase = -9'd45;\t //LUT[1902] \tphase : -0.175781\t(data_i, data_q): (0.906250,-0.562500)\n\t1903: o_phase = -9'd43;\t //LUT[1903] \tphase : -0.167969\t(data_i, data_q): (0.906250,-0.531250)\n\t1904: o_phase = -9'd41;\t //LUT[1904] \tphase : -0.160156\t(data_i, data_q): (0.906250,-0.500000)\n\t1905: o_phase = -9'd39;\t //LUT[1905] \tphase : -0.152344\t(data_i, data_q): (0.906250,-0.468750)\n\t1906: o_phase = -9'd37;\t //LUT[1906] \tphase : -0.144531\t(data_i, data_q): (0.906250,-0.437500)\n\t1907: o_phase = -9'd34;\t //LUT[1907] \tphase : -0.132812\t(data_i, data_q): (0.906250,-0.406250)\n\t1908: o_phase = -9'd32;\t //LUT[1908] \tphase : -0.125000\t(data_i, data_q): (0.906250,-0.375000)\n\t1909: o_phase = -9'd30;\t //LUT[1909] \tphase : -0.117188\t(data_i, data_q): (0.906250,-0.343750)\n\t1910: o_phase = -9'd27;\t //LUT[1910] \tphase : -0.105469\t(data_i, data_q): (0.906250,-0.312500)\n\t1911: o_phase = -9'd25;\t //LUT[1911] \tphase : -0.097656\t(data_i, data_q): (0.906250,-0.281250)\n\t1912: o_phase = -9'd22;\t //LUT[1912] \tphase : -0.085938\t(data_i, data_q): (0.906250,-0.250000)\n\t1913: o_phase = -9'd19;\t //LUT[1913] \tphase : -0.074219\t(data_i, data_q): (0.906250,-0.218750)\n\t1914: o_phase = -9'd17;\t //LUT[1914] \tphase : -0.066406\t(data_i, data_q): (0.906250,-0.187500)\n\t1915: o_phase = -9'd14;\t //LUT[1915] \tphase : -0.054688\t(data_i, data_q): (0.906250,-0.156250)\n\t1916: o_phase = -9'd11;\t //LUT[1916] \tphase : -0.042969\t(data_i, data_q): (0.906250,-0.125000)\n\t1917: o_phase = -9'd8;\t //LUT[1917] \tphase : -0.031250\t(data_i, data_q): (0.906250,-0.093750)\n\t1918: o_phase = -9'd6;\t //LUT[1918] \tphase : -0.023438\t(data_i, data_q): (0.906250,-0.062500)\n\t1919: o_phase = -9'd3;\t //LUT[1919] \tphase : -0.011719\t(data_i, data_q): (0.906250,-0.031250)\n\t1920: o_phase = +9'd0;\t //LUT[1920] \tphase : 0.000000\t(data_i, data_q): (0.937500,0.000000)\n\t1921: o_phase = +9'd3;\t //LUT[1921] \tphase : 0.011719\t(data_i, data_q): (0.937500,0.031250)\n\t1922: o_phase = +9'd5;\t //LUT[1922] \tphase : 0.019531\t(data_i, data_q): (0.937500,0.062500)\n\t1923: o_phase = +9'd8;\t //LUT[1923] \tphase : 0.031250\t(data_i, data_q): (0.937500,0.093750)\n\t1924: o_phase = +9'd11;\t //LUT[1924] \tphase : 0.042969\t(data_i, data_q): (0.937500,0.125000)\n\t1925: o_phase = +9'd13;\t //LUT[1925] \tphase : 0.050781\t(data_i, data_q): (0.937500,0.156250)\n\t1926: o_phase = +9'd16;\t //LUT[1926] \tphase : 0.062500\t(data_i, data_q): (0.937500,0.187500)\n\t1927: o_phase = +9'd19;\t //LUT[1927] \tphase : 0.074219\t(data_i, data_q): (0.937500,0.218750)\n\t1928: o_phase = +9'd21;\t //LUT[1928] \tphase : 0.082031\t(data_i, data_q): (0.937500,0.250000)\n\t1929: o_phase = +9'd24;\t //LUT[1929] \tphase : 0.093750\t(data_i, data_q): (0.937500,0.281250)\n\t1930: o_phase = +9'd26;\t //LUT[1930] \tphase : 0.101562\t(data_i, data_q): (0.937500,0.312500)\n\t1931: o_phase = +9'd29;\t //LUT[1931] \tphase : 0.113281\t(data_i, data_q): (0.937500,0.343750)\n\t1932: o_phase = +9'd31;\t //LUT[1932] \tphase : 0.121094\t(data_i, data_q): (0.937500,0.375000)\n\t1933: o_phase = +9'd33;\t //LUT[1933] \tphase : 0.128906\t(data_i, data_q): (0.937500,0.406250)\n\t1934: o_phase = +9'd36;\t //LUT[1934] \tphase : 0.140625\t(data_i, data_q): (0.937500,0.437500)\n\t1935: o_phase = +9'd38;\t //LUT[1935] \tphase : 0.148438\t(data_i, data_q): (0.937500,0.468750)\n\t1936: o_phase = +9'd40;\t //LUT[1936] \tphase : 0.156250\t(data_i, data_q): (0.937500,0.500000)\n\t1937: o_phase = +9'd42;\t //LUT[1937] \tphase : 0.164062\t(data_i, data_q): (0.937500,0.531250)\n\t1938: o_phase = +9'd44;\t //LUT[1938] \tphase : 0.171875\t(data_i, data_q): (0.937500,0.562500)\n\t1939: o_phase = +9'd46;\t //LUT[1939] \tphase : 0.179688\t(data_i, data_q): (0.937500,0.593750)\n\t1940: o_phase = +9'd48;\t //LUT[1940] \tphase : 0.187500\t(data_i, data_q): (0.937500,0.625000)\n\t1941: o_phase = +9'd50;\t //LUT[1941] \tphase : 0.195312\t(data_i, data_q): (0.937500,0.656250)\n\t1942: o_phase = +9'd52;\t //LUT[1942] \tphase : 0.203125\t(data_i, data_q): (0.937500,0.687500)\n\t1943: o_phase = +9'd53;\t //LUT[1943] \tphase : 0.207031\t(data_i, data_q): (0.937500,0.718750)\n\t1944: o_phase = +9'd55;\t //LUT[1944] \tphase : 0.214844\t(data_i, data_q): (0.937500,0.750000)\n\t1945: o_phase = +9'd57;\t //LUT[1945] \tphase : 0.222656\t(data_i, data_q): (0.937500,0.781250)\n\t1946: o_phase = +9'd58;\t //LUT[1946] \tphase : 0.226562\t(data_i, data_q): (0.937500,0.812500)\n\t1947: o_phase = +9'd60;\t //LUT[1947] \tphase : 0.234375\t(data_i, data_q): (0.937500,0.843750)\n\t1948: o_phase = +9'd61;\t //LUT[1948] \tphase : 0.238281\t(data_i, data_q): (0.937500,0.875000)\n\t1949: o_phase = +9'd63;\t //LUT[1949] \tphase : 0.246094\t(data_i, data_q): (0.937500,0.906250)\n\t1950: o_phase = +9'd64;\t //LUT[1950] \tphase : 0.250000\t(data_i, data_q): (0.937500,0.937500)\n\t1951: o_phase = +9'd65;\t //LUT[1951] \tphase : 0.253906\t(data_i, data_q): (0.937500,0.968750)\n\t1952: o_phase = -9'd67;\t //LUT[1952] \tphase : -0.261719\t(data_i, data_q): (0.937500,-1.000000)\n\t1953: o_phase = -9'd65;\t //LUT[1953] \tphase : -0.253906\t(data_i, data_q): (0.937500,-0.968750)\n\t1954: o_phase = -9'd64;\t //LUT[1954] \tphase : -0.250000\t(data_i, data_q): (0.937500,-0.937500)\n\t1955: o_phase = -9'd63;\t //LUT[1955] \tphase : -0.246094\t(data_i, data_q): (0.937500,-0.906250)\n\t1956: o_phase = -9'd61;\t //LUT[1956] \tphase : -0.238281\t(data_i, data_q): (0.937500,-0.875000)\n\t1957: o_phase = -9'd60;\t //LUT[1957] \tphase : -0.234375\t(data_i, data_q): (0.937500,-0.843750)\n\t1958: o_phase = -9'd58;\t //LUT[1958] \tphase : -0.226562\t(data_i, data_q): (0.937500,-0.812500)\n\t1959: o_phase = -9'd57;\t //LUT[1959] \tphase : -0.222656\t(data_i, data_q): (0.937500,-0.781250)\n\t1960: o_phase = -9'd55;\t //LUT[1960] \tphase : -0.214844\t(data_i, data_q): (0.937500,-0.750000)\n\t1961: o_phase = -9'd53;\t //LUT[1961] \tphase : -0.207031\t(data_i, data_q): (0.937500,-0.718750)\n\t1962: o_phase = -9'd52;\t //LUT[1962] \tphase : -0.203125\t(data_i, data_q): (0.937500,-0.687500)\n\t1963: o_phase = -9'd50;\t //LUT[1963] \tphase : -0.195312\t(data_i, data_q): (0.937500,-0.656250)\n\t1964: o_phase = -9'd48;\t //LUT[1964] \tphase : -0.187500\t(data_i, data_q): (0.937500,-0.625000)\n\t1965: o_phase = -9'd46;\t //LUT[1965] \tphase : -0.179688\t(data_i, data_q): (0.937500,-0.593750)\n\t1966: o_phase = -9'd44;\t //LUT[1966] \tphase : -0.171875\t(data_i, data_q): (0.937500,-0.562500)\n\t1967: o_phase = -9'd42;\t //LUT[1967] \tphase : -0.164062\t(data_i, data_q): (0.937500,-0.531250)\n\t1968: o_phase = -9'd40;\t //LUT[1968] \tphase : -0.156250\t(data_i, data_q): (0.937500,-0.500000)\n\t1969: o_phase = -9'd38;\t //LUT[1969] \tphase : -0.148438\t(data_i, data_q): (0.937500,-0.468750)\n\t1970: o_phase = -9'd36;\t //LUT[1970] \tphase : -0.140625\t(data_i, data_q): (0.937500,-0.437500)\n\t1971: o_phase = -9'd33;\t //LUT[1971] \tphase : -0.128906\t(data_i, data_q): (0.937500,-0.406250)\n\t1972: o_phase = -9'd31;\t //LUT[1972] \tphase : -0.121094\t(data_i, data_q): (0.937500,-0.375000)\n\t1973: o_phase = -9'd29;\t //LUT[1973] \tphase : -0.113281\t(data_i, data_q): (0.937500,-0.343750)\n\t1974: o_phase = -9'd26;\t //LUT[1974] \tphase : -0.101562\t(data_i, data_q): (0.937500,-0.312500)\n\t1975: o_phase = -9'd24;\t //LUT[1975] \tphase : -0.093750\t(data_i, data_q): (0.937500,-0.281250)\n\t1976: o_phase = -9'd21;\t //LUT[1976] \tphase : -0.082031\t(data_i, data_q): (0.937500,-0.250000)\n\t1977: o_phase = -9'd19;\t //LUT[1977] \tphase : -0.074219\t(data_i, data_q): (0.937500,-0.218750)\n\t1978: o_phase = -9'd16;\t //LUT[1978] \tphase : -0.062500\t(data_i, data_q): (0.937500,-0.187500)\n\t1979: o_phase = -9'd13;\t //LUT[1979] \tphase : -0.050781\t(data_i, data_q): (0.937500,-0.156250)\n\t1980: o_phase = -9'd11;\t //LUT[1980] \tphase : -0.042969\t(data_i, data_q): (0.937500,-0.125000)\n\t1981: o_phase = -9'd8;\t //LUT[1981] \tphase : -0.031250\t(data_i, data_q): (0.937500,-0.093750)\n\t1982: o_phase = -9'd5;\t //LUT[1982] \tphase : -0.019531\t(data_i, data_q): (0.937500,-0.062500)\n\t1983: o_phase = -9'd3;\t //LUT[1983] \tphase : -0.011719\t(data_i, data_q): (0.937500,-0.031250)\n\t1984: o_phase = +9'd0;\t //LUT[1984] \tphase : 0.000000\t(data_i, data_q): (0.968750,0.000000)\n\t1985: o_phase = +9'd3;\t //LUT[1985] \tphase : 0.011719\t(data_i, data_q): (0.968750,0.031250)\n\t1986: o_phase = +9'd5;\t //LUT[1986] \tphase : 0.019531\t(data_i, data_q): (0.968750,0.062500)\n\t1987: o_phase = +9'd8;\t //LUT[1987] \tphase : 0.031250\t(data_i, data_q): (0.968750,0.093750)\n\t1988: o_phase = +9'd10;\t //LUT[1988] \tphase : 0.039062\t(data_i, data_q): (0.968750,0.125000)\n\t1989: o_phase = +9'd13;\t //LUT[1989] \tphase : 0.050781\t(data_i, data_q): (0.968750,0.156250)\n\t1990: o_phase = +9'd16;\t //LUT[1990] \tphase : 0.062500\t(data_i, data_q): (0.968750,0.187500)\n\t1991: o_phase = +9'd18;\t //LUT[1991] \tphase : 0.070312\t(data_i, data_q): (0.968750,0.218750)\n\t1992: o_phase = +9'd21;\t //LUT[1992] \tphase : 0.082031\t(data_i, data_q): (0.968750,0.250000)\n\t1993: o_phase = +9'd23;\t //LUT[1993] \tphase : 0.089844\t(data_i, data_q): (0.968750,0.281250)\n\t1994: o_phase = +9'd25;\t //LUT[1994] \tphase : 0.097656\t(data_i, data_q): (0.968750,0.312500)\n\t1995: o_phase = +9'd28;\t //LUT[1995] \tphase : 0.109375\t(data_i, data_q): (0.968750,0.343750)\n\t1996: o_phase = +9'd30;\t //LUT[1996] \tphase : 0.117188\t(data_i, data_q): (0.968750,0.375000)\n\t1997: o_phase = +9'd32;\t //LUT[1997] \tphase : 0.125000\t(data_i, data_q): (0.968750,0.406250)\n\t1998: o_phase = +9'd35;\t //LUT[1998] \tphase : 0.136719\t(data_i, data_q): (0.968750,0.437500)\n\t1999: o_phase = +9'd37;\t //LUT[1999] \tphase : 0.144531\t(data_i, data_q): (0.968750,0.468750)\n\t2000: o_phase = +9'd39;\t //LUT[2000] \tphase : 0.152344\t(data_i, data_q): (0.968750,0.500000)\n\t2001: o_phase = +9'd41;\t //LUT[2001] \tphase : 0.160156\t(data_i, data_q): (0.968750,0.531250)\n\t2002: o_phase = +9'd43;\t //LUT[2002] \tphase : 0.167969\t(data_i, data_q): (0.968750,0.562500)\n\t2003: o_phase = +9'd45;\t //LUT[2003] \tphase : 0.175781\t(data_i, data_q): (0.968750,0.593750)\n\t2004: o_phase = +9'd47;\t //LUT[2004] \tphase : 0.183594\t(data_i, data_q): (0.968750,0.625000)\n\t2005: o_phase = +9'd49;\t //LUT[2005] \tphase : 0.191406\t(data_i, data_q): (0.968750,0.656250)\n\t2006: o_phase = +9'd50;\t //LUT[2006] \tphase : 0.195312\t(data_i, data_q): (0.968750,0.687500)\n\t2007: o_phase = +9'd52;\t //LUT[2007] \tphase : 0.203125\t(data_i, data_q): (0.968750,0.718750)\n\t2008: o_phase = +9'd54;\t //LUT[2008] \tphase : 0.210938\t(data_i, data_q): (0.968750,0.750000)\n\t2009: o_phase = +9'd55;\t //LUT[2009] \tphase : 0.214844\t(data_i, data_q): (0.968750,0.781250)\n\t2010: o_phase = +9'd57;\t //LUT[2010] \tphase : 0.222656\t(data_i, data_q): (0.968750,0.812500)\n\t2011: o_phase = +9'd58;\t //LUT[2011] \tphase : 0.226562\t(data_i, data_q): (0.968750,0.843750)\n\t2012: o_phase = +9'd60;\t //LUT[2012] \tphase : 0.234375\t(data_i, data_q): (0.968750,0.875000)\n\t2013: o_phase = +9'd61;\t //LUT[2013] \tphase : 0.238281\t(data_i, data_q): (0.968750,0.906250)\n\t2014: o_phase = +9'd63;\t //LUT[2014] \tphase : 0.246094\t(data_i, data_q): (0.968750,0.937500)\n\t2015: o_phase = +9'd64;\t //LUT[2015] \tphase : 0.250000\t(data_i, data_q): (0.968750,0.968750)\n\t2016: o_phase = -9'd65;\t //LUT[2016] \tphase : -0.253906\t(data_i, data_q): (0.968750,-1.000000)\n\t2017: o_phase = -9'd64;\t //LUT[2017] \tphase : -0.250000\t(data_i, data_q): (0.968750,-0.968750)\n\t2018: o_phase = -9'd63;\t //LUT[2018] \tphase : -0.246094\t(data_i, data_q): (0.968750,-0.937500)\n\t2019: o_phase = -9'd61;\t //LUT[2019] \tphase : -0.238281\t(data_i, data_q): (0.968750,-0.906250)\n\t2020: o_phase = -9'd60;\t //LUT[2020] \tphase : -0.234375\t(data_i, data_q): (0.968750,-0.875000)\n\t2021: o_phase = -9'd58;\t //LUT[2021] \tphase : -0.226562\t(data_i, data_q): (0.968750,-0.843750)\n\t2022: o_phase = -9'd57;\t //LUT[2022] \tphase : -0.222656\t(data_i, data_q): (0.968750,-0.812500)\n\t2023: o_phase = -9'd55;\t //LUT[2023] \tphase : -0.214844\t(data_i, data_q): (0.968750,-0.781250)\n\t2024: o_phase = -9'd54;\t //LUT[2024] \tphase : -0.210938\t(data_i, data_q): (0.968750,-0.750000)\n\t2025: o_phase = -9'd52;\t //LUT[2025] \tphase : -0.203125\t(data_i, data_q): (0.968750,-0.718750)\n\t2026: o_phase = -9'd50;\t //LUT[2026] \tphase : -0.195312\t(data_i, data_q): (0.968750,-0.687500)\n\t2027: o_phase = -9'd49;\t //LUT[2027] \tphase : -0.191406\t(data_i, data_q): (0.968750,-0.656250)\n\t2028: o_phase = -9'd47;\t //LUT[2028] \tphase : -0.183594\t(data_i, data_q): (0.968750,-0.625000)\n\t2029: o_phase = -9'd45;\t //LUT[2029] \tphase : -0.175781\t(data_i, data_q): (0.968750,-0.593750)\n\t2030: o_phase = -9'd43;\t //LUT[2030] \tphase : -0.167969\t(data_i, data_q): (0.968750,-0.562500)\n\t2031: o_phase = -9'd41;\t //LUT[2031] \tphase : -0.160156\t(data_i, data_q): (0.968750,-0.531250)\n\t2032: o_phase = -9'd39;\t //LUT[2032] \tphase : -0.152344\t(data_i, data_q): (0.968750,-0.500000)\n\t2033: o_phase = -9'd37;\t //LUT[2033] \tphase : -0.144531\t(data_i, data_q): (0.968750,-0.468750)\n\t2034: o_phase = -9'd35;\t //LUT[2034] \tphase : -0.136719\t(data_i, data_q): (0.968750,-0.437500)\n\t2035: o_phase = -9'd32;\t //LUT[2035] \tphase : -0.125000\t(data_i, data_q): (0.968750,-0.406250)\n\t2036: o_phase = -9'd30;\t //LUT[2036] \tphase : -0.117188\t(data_i, data_q): (0.968750,-0.375000)\n\t2037: o_phase = -9'd28;\t //LUT[2037] \tphase : -0.109375\t(data_i, data_q): (0.968750,-0.343750)\n\t2038: o_phase = -9'd25;\t //LUT[2038] \tphase : -0.097656\t(data_i, data_q): (0.968750,-0.312500)\n\t2039: o_phase = -9'd23;\t //LUT[2039] \tphase : -0.089844\t(data_i, data_q): (0.968750,-0.281250)\n\t2040: o_phase = -9'd21;\t //LUT[2040] \tphase : -0.082031\t(data_i, data_q): (0.968750,-0.250000)\n\t2041: o_phase = -9'd18;\t //LUT[2041] \tphase : -0.070312\t(data_i, data_q): (0.968750,-0.218750)\n\t2042: o_phase = -9'd16;\t //LUT[2042] \tphase : -0.062500\t(data_i, data_q): (0.968750,-0.187500)\n\t2043: o_phase = -9'd13;\t //LUT[2043] \tphase : -0.050781\t(data_i, data_q): (0.968750,-0.156250)\n\t2044: o_phase = -9'd10;\t //LUT[2044] \tphase : -0.039062\t(data_i, data_q): (0.968750,-0.125000)\n\t2045: o_phase = -9'd8;\t //LUT[2045] \tphase : -0.031250\t(data_i, data_q): (0.968750,-0.093750)\n\t2046: o_phase = -9'd5;\t //LUT[2046] \tphase : -0.019531\t(data_i, data_q): (0.968750,-0.062500)\n\t2047: o_phase = -9'd3;\t //LUT[2047] \tphase : -0.011719\t(data_i, data_q): (0.968750,-0.031250)\n\t2048: o_phase = -9'd256;\t //LUT[2048] \tphase : -1.000000\t(data_i, data_q): (-1.000000,0.000000)\n\t2049: o_phase = +9'd253;\t //LUT[2049] \tphase : 0.988281\t(data_i, data_q): (-1.000000,0.031250)\n\t2050: o_phase = +9'd251;\t //LUT[2050] \tphase : 0.980469\t(data_i, data_q): (-1.000000,0.062500)\n\t2051: o_phase = +9'd248;\t //LUT[2051] \tphase : 0.968750\t(data_i, data_q): (-1.000000,0.093750)\n\t2052: o_phase = +9'd246;\t //LUT[2052] \tphase : 0.960938\t(data_i, data_q): (-1.000000,0.125000)\n\t2053: o_phase = +9'd243;\t //LUT[2053] \tphase : 0.949219\t(data_i, data_q): (-1.000000,0.156250)\n\t2054: o_phase = +9'd241;\t //LUT[2054] \tphase : 0.941406\t(data_i, data_q): (-1.000000,0.187500)\n\t2055: o_phase = +9'd238;\t //LUT[2055] \tphase : 0.929688\t(data_i, data_q): (-1.000000,0.218750)\n\t2056: o_phase = +9'd236;\t //LUT[2056] \tphase : 0.921875\t(data_i, data_q): (-1.000000,0.250000)\n\t2057: o_phase = +9'd234;\t //LUT[2057] \tphase : 0.914062\t(data_i, data_q): (-1.000000,0.281250)\n\t2058: o_phase = +9'd231;\t //LUT[2058] \tphase : 0.902344\t(data_i, data_q): (-1.000000,0.312500)\n\t2059: o_phase = +9'd229;\t //LUT[2059] \tphase : 0.894531\t(data_i, data_q): (-1.000000,0.343750)\n\t2060: o_phase = +9'd227;\t //LUT[2060] \tphase : 0.886719\t(data_i, data_q): (-1.000000,0.375000)\n\t2061: o_phase = +9'd225;\t //LUT[2061] \tphase : 0.878906\t(data_i, data_q): (-1.000000,0.406250)\n\t2062: o_phase = +9'd222;\t //LUT[2062] \tphase : 0.867188\t(data_i, data_q): (-1.000000,0.437500)\n\t2063: o_phase = +9'd220;\t //LUT[2063] \tphase : 0.859375\t(data_i, data_q): (-1.000000,0.468750)\n\t2064: o_phase = +9'd218;\t //LUT[2064] \tphase : 0.851562\t(data_i, data_q): (-1.000000,0.500000)\n\t2065: o_phase = +9'd216;\t //LUT[2065] \tphase : 0.843750\t(data_i, data_q): (-1.000000,0.531250)\n\t2066: o_phase = +9'd214;\t //LUT[2066] \tphase : 0.835938\t(data_i, data_q): (-1.000000,0.562500)\n\t2067: o_phase = +9'd212;\t //LUT[2067] \tphase : 0.828125\t(data_i, data_q): (-1.000000,0.593750)\n\t2068: o_phase = +9'd210;\t //LUT[2068] \tphase : 0.820312\t(data_i, data_q): (-1.000000,0.625000)\n\t2069: o_phase = +9'd209;\t //LUT[2069] \tphase : 0.816406\t(data_i, data_q): (-1.000000,0.656250)\n\t2070: o_phase = +9'd207;\t //LUT[2070] \tphase : 0.808594\t(data_i, data_q): (-1.000000,0.687500)\n\t2071: o_phase = +9'd205;\t //LUT[2071] \tphase : 0.800781\t(data_i, data_q): (-1.000000,0.718750)\n\t2072: o_phase = +9'd204;\t //LUT[2072] \tphase : 0.796875\t(data_i, data_q): (-1.000000,0.750000)\n\t2073: o_phase = +9'd202;\t //LUT[2073] \tphase : 0.789062\t(data_i, data_q): (-1.000000,0.781250)\n\t2074: o_phase = +9'd200;\t //LUT[2074] \tphase : 0.781250\t(data_i, data_q): (-1.000000,0.812500)\n\t2075: o_phase = +9'd199;\t //LUT[2075] \tphase : 0.777344\t(data_i, data_q): (-1.000000,0.843750)\n\t2076: o_phase = +9'd197;\t //LUT[2076] \tphase : 0.769531\t(data_i, data_q): (-1.000000,0.875000)\n\t2077: o_phase = +9'd196;\t //LUT[2077] \tphase : 0.765625\t(data_i, data_q): (-1.000000,0.906250)\n\t2078: o_phase = +9'd195;\t //LUT[2078] \tphase : 0.761719\t(data_i, data_q): (-1.000000,0.937500)\n\t2079: o_phase = +9'd193;\t //LUT[2079] \tphase : 0.753906\t(data_i, data_q): (-1.000000,0.968750)\n\t2080: o_phase = -9'd192;\t //LUT[2080] \tphase : -0.750000\t(data_i, data_q): (-1.000000,-1.000000)\n\t2081: o_phase = -9'd193;\t //LUT[2081] \tphase : -0.753906\t(data_i, data_q): (-1.000000,-0.968750)\n\t2082: o_phase = -9'd195;\t //LUT[2082] \tphase : -0.761719\t(data_i, data_q): (-1.000000,-0.937500)\n\t2083: o_phase = -9'd196;\t //LUT[2083] \tphase : -0.765625\t(data_i, data_q): (-1.000000,-0.906250)\n\t2084: o_phase = -9'd197;\t //LUT[2084] \tphase : -0.769531\t(data_i, data_q): (-1.000000,-0.875000)\n\t2085: o_phase = -9'd199;\t //LUT[2085] \tphase : -0.777344\t(data_i, data_q): (-1.000000,-0.843750)\n\t2086: o_phase = -9'd200;\t //LUT[2086] \tphase : -0.781250\t(data_i, data_q): (-1.000000,-0.812500)\n\t2087: o_phase = -9'd202;\t //LUT[2087] \tphase : -0.789062\t(data_i, data_q): (-1.000000,-0.781250)\n\t2088: o_phase = -9'd204;\t //LUT[2088] \tphase : -0.796875\t(data_i, data_q): (-1.000000,-0.750000)\n\t2089: o_phase = -9'd205;\t //LUT[2089] \tphase : -0.800781\t(data_i, data_q): (-1.000000,-0.718750)\n\t2090: o_phase = -9'd207;\t //LUT[2090] \tphase : -0.808594\t(data_i, data_q): (-1.000000,-0.687500)\n\t2091: o_phase = -9'd209;\t //LUT[2091] \tphase : -0.816406\t(data_i, data_q): (-1.000000,-0.656250)\n\t2092: o_phase = -9'd210;\t //LUT[2092] \tphase : -0.820312\t(data_i, data_q): (-1.000000,-0.625000)\n\t2093: o_phase = -9'd212;\t //LUT[2093] \tphase : -0.828125\t(data_i, data_q): (-1.000000,-0.593750)\n\t2094: o_phase = -9'd214;\t //LUT[2094] \tphase : -0.835938\t(data_i, data_q): (-1.000000,-0.562500)\n\t2095: o_phase = -9'd216;\t //LUT[2095] \tphase : -0.843750\t(data_i, data_q): (-1.000000,-0.531250)\n\t2096: o_phase = -9'd218;\t //LUT[2096] \tphase : -0.851562\t(data_i, data_q): (-1.000000,-0.500000)\n\t2097: o_phase = -9'd220;\t //LUT[2097] \tphase : -0.859375\t(data_i, data_q): (-1.000000,-0.468750)\n\t2098: o_phase = -9'd222;\t //LUT[2098] \tphase : -0.867188\t(data_i, data_q): (-1.000000,-0.437500)\n\t2099: o_phase = -9'd225;\t //LUT[2099] \tphase : -0.878906\t(data_i, data_q): (-1.000000,-0.406250)\n\t2100: o_phase = -9'd227;\t //LUT[2100] \tphase : -0.886719\t(data_i, data_q): (-1.000000,-0.375000)\n\t2101: o_phase = -9'd229;\t //LUT[2101] \tphase : -0.894531\t(data_i, data_q): (-1.000000,-0.343750)\n\t2102: o_phase = -9'd231;\t //LUT[2102] \tphase : -0.902344\t(data_i, data_q): (-1.000000,-0.312500)\n\t2103: o_phase = -9'd234;\t //LUT[2103] \tphase : -0.914062\t(data_i, data_q): (-1.000000,-0.281250)\n\t2104: o_phase = -9'd236;\t //LUT[2104] \tphase : -0.921875\t(data_i, data_q): (-1.000000,-0.250000)\n\t2105: o_phase = -9'd238;\t //LUT[2105] \tphase : -0.929688\t(data_i, data_q): (-1.000000,-0.218750)\n\t2106: o_phase = -9'd241;\t //LUT[2106] \tphase : -0.941406\t(data_i, data_q): (-1.000000,-0.187500)\n\t2107: o_phase = -9'd243;\t //LUT[2107] \tphase : -0.949219\t(data_i, data_q): (-1.000000,-0.156250)\n\t2108: o_phase = -9'd246;\t //LUT[2108] \tphase : -0.960938\t(data_i, data_q): (-1.000000,-0.125000)\n\t2109: o_phase = -9'd248;\t //LUT[2109] \tphase : -0.968750\t(data_i, data_q): (-1.000000,-0.093750)\n\t2110: o_phase = -9'd251;\t //LUT[2110] \tphase : -0.980469\t(data_i, data_q): (-1.000000,-0.062500)\n\t2111: o_phase = -9'd253;\t //LUT[2111] \tphase : -0.988281\t(data_i, data_q): (-1.000000,-0.031250)\n\t2112: o_phase = -9'd256;\t //LUT[2112] \tphase : -1.000000\t(data_i, data_q): (-0.968750,0.000000)\n\t2113: o_phase = +9'd253;\t //LUT[2113] \tphase : 0.988281\t(data_i, data_q): (-0.968750,0.031250)\n\t2114: o_phase = +9'd251;\t //LUT[2114] \tphase : 0.980469\t(data_i, data_q): (-0.968750,0.062500)\n\t2115: o_phase = +9'd248;\t //LUT[2115] \tphase : 0.968750\t(data_i, data_q): (-0.968750,0.093750)\n\t2116: o_phase = +9'd246;\t //LUT[2116] \tphase : 0.960938\t(data_i, data_q): (-0.968750,0.125000)\n\t2117: o_phase = +9'd243;\t //LUT[2117] \tphase : 0.949219\t(data_i, data_q): (-0.968750,0.156250)\n\t2118: o_phase = +9'd240;\t //LUT[2118] \tphase : 0.937500\t(data_i, data_q): (-0.968750,0.187500)\n\t2119: o_phase = +9'd238;\t //LUT[2119] \tphase : 0.929688\t(data_i, data_q): (-0.968750,0.218750)\n\t2120: o_phase = +9'd235;\t //LUT[2120] \tphase : 0.917969\t(data_i, data_q): (-0.968750,0.250000)\n\t2121: o_phase = +9'd233;\t //LUT[2121] \tphase : 0.910156\t(data_i, data_q): (-0.968750,0.281250)\n\t2122: o_phase = +9'd231;\t //LUT[2122] \tphase : 0.902344\t(data_i, data_q): (-0.968750,0.312500)\n\t2123: o_phase = +9'd228;\t //LUT[2123] \tphase : 0.890625\t(data_i, data_q): (-0.968750,0.343750)\n\t2124: o_phase = +9'd226;\t //LUT[2124] \tphase : 0.882812\t(data_i, data_q): (-0.968750,0.375000)\n\t2125: o_phase = +9'd224;\t //LUT[2125] \tphase : 0.875000\t(data_i, data_q): (-0.968750,0.406250)\n\t2126: o_phase = +9'd221;\t //LUT[2126] \tphase : 0.863281\t(data_i, data_q): (-0.968750,0.437500)\n\t2127: o_phase = +9'd219;\t //LUT[2127] \tphase : 0.855469\t(data_i, data_q): (-0.968750,0.468750)\n\t2128: o_phase = +9'd217;\t //LUT[2128] \tphase : 0.847656\t(data_i, data_q): (-0.968750,0.500000)\n\t2129: o_phase = +9'd215;\t //LUT[2129] \tphase : 0.839844\t(data_i, data_q): (-0.968750,0.531250)\n\t2130: o_phase = +9'd213;\t //LUT[2130] \tphase : 0.832031\t(data_i, data_q): (-0.968750,0.562500)\n\t2131: o_phase = +9'd211;\t //LUT[2131] \tphase : 0.824219\t(data_i, data_q): (-0.968750,0.593750)\n\t2132: o_phase = +9'd209;\t //LUT[2132] \tphase : 0.816406\t(data_i, data_q): (-0.968750,0.625000)\n\t2133: o_phase = +9'd207;\t //LUT[2133] \tphase : 0.808594\t(data_i, data_q): (-0.968750,0.656250)\n\t2134: o_phase = +9'd206;\t //LUT[2134] \tphase : 0.804688\t(data_i, data_q): (-0.968750,0.687500)\n\t2135: o_phase = +9'd204;\t //LUT[2135] \tphase : 0.796875\t(data_i, data_q): (-0.968750,0.718750)\n\t2136: o_phase = +9'd202;\t //LUT[2136] \tphase : 0.789062\t(data_i, data_q): (-0.968750,0.750000)\n\t2137: o_phase = +9'd201;\t //LUT[2137] \tphase : 0.785156\t(data_i, data_q): (-0.968750,0.781250)\n\t2138: o_phase = +9'd199;\t //LUT[2138] \tphase : 0.777344\t(data_i, data_q): (-0.968750,0.812500)\n\t2139: o_phase = +9'd198;\t //LUT[2139] \tphase : 0.773438\t(data_i, data_q): (-0.968750,0.843750)\n\t2140: o_phase = +9'd196;\t //LUT[2140] \tphase : 0.765625\t(data_i, data_q): (-0.968750,0.875000)\n\t2141: o_phase = +9'd195;\t //LUT[2141] \tphase : 0.761719\t(data_i, data_q): (-0.968750,0.906250)\n\t2142: o_phase = +9'd193;\t //LUT[2142] \tphase : 0.753906\t(data_i, data_q): (-0.968750,0.937500)\n\t2143: o_phase = +9'd192;\t //LUT[2143] \tphase : 0.750000\t(data_i, data_q): (-0.968750,0.968750)\n\t2144: o_phase = -9'd191;\t //LUT[2144] \tphase : -0.746094\t(data_i, data_q): (-0.968750,-1.000000)\n\t2145: o_phase = -9'd192;\t //LUT[2145] \tphase : -0.750000\t(data_i, data_q): (-0.968750,-0.968750)\n\t2146: o_phase = -9'd193;\t //LUT[2146] \tphase : -0.753906\t(data_i, data_q): (-0.968750,-0.937500)\n\t2147: o_phase = -9'd195;\t //LUT[2147] \tphase : -0.761719\t(data_i, data_q): (-0.968750,-0.906250)\n\t2148: o_phase = -9'd196;\t //LUT[2148] \tphase : -0.765625\t(data_i, data_q): (-0.968750,-0.875000)\n\t2149: o_phase = -9'd198;\t //LUT[2149] \tphase : -0.773438\t(data_i, data_q): (-0.968750,-0.843750)\n\t2150: o_phase = -9'd199;\t //LUT[2150] \tphase : -0.777344\t(data_i, data_q): (-0.968750,-0.812500)\n\t2151: o_phase = -9'd201;\t //LUT[2151] \tphase : -0.785156\t(data_i, data_q): (-0.968750,-0.781250)\n\t2152: o_phase = -9'd202;\t //LUT[2152] \tphase : -0.789062\t(data_i, data_q): (-0.968750,-0.750000)\n\t2153: o_phase = -9'd204;\t //LUT[2153] \tphase : -0.796875\t(data_i, data_q): (-0.968750,-0.718750)\n\t2154: o_phase = -9'd206;\t //LUT[2154] \tphase : -0.804688\t(data_i, data_q): (-0.968750,-0.687500)\n\t2155: o_phase = -9'd207;\t //LUT[2155] \tphase : -0.808594\t(data_i, data_q): (-0.968750,-0.656250)\n\t2156: o_phase = -9'd209;\t //LUT[2156] \tphase : -0.816406\t(data_i, data_q): (-0.968750,-0.625000)\n\t2157: o_phase = -9'd211;\t //LUT[2157] \tphase : -0.824219\t(data_i, data_q): (-0.968750,-0.593750)\n\t2158: o_phase = -9'd213;\t //LUT[2158] \tphase : -0.832031\t(data_i, data_q): (-0.968750,-0.562500)\n\t2159: o_phase = -9'd215;\t //LUT[2159] \tphase : -0.839844\t(data_i, data_q): (-0.968750,-0.531250)\n\t2160: o_phase = -9'd217;\t //LUT[2160] \tphase : -0.847656\t(data_i, data_q): (-0.968750,-0.500000)\n\t2161: o_phase = -9'd219;\t //LUT[2161] \tphase : -0.855469\t(data_i, data_q): (-0.968750,-0.468750)\n\t2162: o_phase = -9'd221;\t //LUT[2162] \tphase : -0.863281\t(data_i, data_q): (-0.968750,-0.437500)\n\t2163: o_phase = -9'd224;\t //LUT[2163] \tphase : -0.875000\t(data_i, data_q): (-0.968750,-0.406250)\n\t2164: o_phase = -9'd226;\t //LUT[2164] \tphase : -0.882812\t(data_i, data_q): (-0.968750,-0.375000)\n\t2165: o_phase = -9'd228;\t //LUT[2165] \tphase : -0.890625\t(data_i, data_q): (-0.968750,-0.343750)\n\t2166: o_phase = -9'd231;\t //LUT[2166] \tphase : -0.902344\t(data_i, data_q): (-0.968750,-0.312500)\n\t2167: o_phase = -9'd233;\t //LUT[2167] \tphase : -0.910156\t(data_i, data_q): (-0.968750,-0.281250)\n\t2168: o_phase = -9'd235;\t //LUT[2168] \tphase : -0.917969\t(data_i, data_q): (-0.968750,-0.250000)\n\t2169: o_phase = -9'd238;\t //LUT[2169] \tphase : -0.929688\t(data_i, data_q): (-0.968750,-0.218750)\n\t2170: o_phase = -9'd240;\t //LUT[2170] \tphase : -0.937500\t(data_i, data_q): (-0.968750,-0.187500)\n\t2171: o_phase = -9'd243;\t //LUT[2171] \tphase : -0.949219\t(data_i, data_q): (-0.968750,-0.156250)\n\t2172: o_phase = -9'd246;\t //LUT[2172] \tphase : -0.960938\t(data_i, data_q): (-0.968750,-0.125000)\n\t2173: o_phase = -9'd248;\t //LUT[2173] \tphase : -0.968750\t(data_i, data_q): (-0.968750,-0.093750)\n\t2174: o_phase = -9'd251;\t //LUT[2174] \tphase : -0.980469\t(data_i, data_q): (-0.968750,-0.062500)\n\t2175: o_phase = -9'd253;\t //LUT[2175] \tphase : -0.988281\t(data_i, data_q): (-0.968750,-0.031250)\n\t2176: o_phase = -9'd256;\t //LUT[2176] \tphase : -1.000000\t(data_i, data_q): (-0.937500,0.000000)\n\t2177: o_phase = +9'd253;\t //LUT[2177] \tphase : 0.988281\t(data_i, data_q): (-0.937500,0.031250)\n\t2178: o_phase = +9'd251;\t //LUT[2178] \tphase : 0.980469\t(data_i, data_q): (-0.937500,0.062500)\n\t2179: o_phase = +9'd248;\t //LUT[2179] \tphase : 0.968750\t(data_i, data_q): (-0.937500,0.093750)\n\t2180: o_phase = +9'd245;\t //LUT[2180] \tphase : 0.957031\t(data_i, data_q): (-0.937500,0.125000)\n\t2181: o_phase = +9'd243;\t //LUT[2181] \tphase : 0.949219\t(data_i, data_q): (-0.937500,0.156250)\n\t2182: o_phase = +9'd240;\t //LUT[2182] \tphase : 0.937500\t(data_i, data_q): (-0.937500,0.187500)\n\t2183: o_phase = +9'd237;\t //LUT[2183] \tphase : 0.925781\t(data_i, data_q): (-0.937500,0.218750)\n\t2184: o_phase = +9'd235;\t //LUT[2184] \tphase : 0.917969\t(data_i, data_q): (-0.937500,0.250000)\n\t2185: o_phase = +9'd232;\t //LUT[2185] \tphase : 0.906250\t(data_i, data_q): (-0.937500,0.281250)\n\t2186: o_phase = +9'd230;\t //LUT[2186] \tphase : 0.898438\t(data_i, data_q): (-0.937500,0.312500)\n\t2187: o_phase = +9'd227;\t //LUT[2187] \tphase : 0.886719\t(data_i, data_q): (-0.937500,0.343750)\n\t2188: o_phase = +9'd225;\t //LUT[2188] \tphase : 0.878906\t(data_i, data_q): (-0.937500,0.375000)\n\t2189: o_phase = +9'd223;\t //LUT[2189] \tphase : 0.871094\t(data_i, data_q): (-0.937500,0.406250)\n\t2190: o_phase = +9'd220;\t //LUT[2190] \tphase : 0.859375\t(data_i, data_q): (-0.937500,0.437500)\n\t2191: o_phase = +9'd218;\t //LUT[2191] \tphase : 0.851562\t(data_i, data_q): (-0.937500,0.468750)\n\t2192: o_phase = +9'd216;\t //LUT[2192] \tphase : 0.843750\t(data_i, data_q): (-0.937500,0.500000)\n\t2193: o_phase = +9'd214;\t //LUT[2193] \tphase : 0.835938\t(data_i, data_q): (-0.937500,0.531250)\n\t2194: o_phase = +9'd212;\t //LUT[2194] \tphase : 0.828125\t(data_i, data_q): (-0.937500,0.562500)\n\t2195: o_phase = +9'd210;\t //LUT[2195] \tphase : 0.820312\t(data_i, data_q): (-0.937500,0.593750)\n\t2196: o_phase = +9'd208;\t //LUT[2196] \tphase : 0.812500\t(data_i, data_q): (-0.937500,0.625000)\n\t2197: o_phase = +9'd206;\t //LUT[2197] \tphase : 0.804688\t(data_i, data_q): (-0.937500,0.656250)\n\t2198: o_phase = +9'd204;\t //LUT[2198] \tphase : 0.796875\t(data_i, data_q): (-0.937500,0.687500)\n\t2199: o_phase = +9'd203;\t //LUT[2199] \tphase : 0.792969\t(data_i, data_q): (-0.937500,0.718750)\n\t2200: o_phase = +9'd201;\t //LUT[2200] \tphase : 0.785156\t(data_i, data_q): (-0.937500,0.750000)\n\t2201: o_phase = +9'd199;\t //LUT[2201] \tphase : 0.777344\t(data_i, data_q): (-0.937500,0.781250)\n\t2202: o_phase = +9'd198;\t //LUT[2202] \tphase : 0.773438\t(data_i, data_q): (-0.937500,0.812500)\n\t2203: o_phase = +9'd196;\t //LUT[2203] \tphase : 0.765625\t(data_i, data_q): (-0.937500,0.843750)\n\t2204: o_phase = +9'd195;\t //LUT[2204] \tphase : 0.761719\t(data_i, data_q): (-0.937500,0.875000)\n\t2205: o_phase = +9'd193;\t //LUT[2205] \tphase : 0.753906\t(data_i, data_q): (-0.937500,0.906250)\n\t2206: o_phase = +9'd192;\t //LUT[2206] \tphase : 0.750000\t(data_i, data_q): (-0.937500,0.937500)\n\t2207: o_phase = +9'd191;\t //LUT[2207] \tphase : 0.746094\t(data_i, data_q): (-0.937500,0.968750)\n\t2208: o_phase = -9'd189;\t //LUT[2208] \tphase : -0.738281\t(data_i, data_q): (-0.937500,-1.000000)\n\t2209: o_phase = -9'd191;\t //LUT[2209] \tphase : -0.746094\t(data_i, data_q): (-0.937500,-0.968750)\n\t2210: o_phase = -9'd192;\t //LUT[2210] \tphase : -0.750000\t(data_i, data_q): (-0.937500,-0.937500)\n\t2211: o_phase = -9'd193;\t //LUT[2211] \tphase : -0.753906\t(data_i, data_q): (-0.937500,-0.906250)\n\t2212: o_phase = -9'd195;\t //LUT[2212] \tphase : -0.761719\t(data_i, data_q): (-0.937500,-0.875000)\n\t2213: o_phase = -9'd196;\t //LUT[2213] \tphase : -0.765625\t(data_i, data_q): (-0.937500,-0.843750)\n\t2214: o_phase = -9'd198;\t //LUT[2214] \tphase : -0.773438\t(data_i, data_q): (-0.937500,-0.812500)\n\t2215: o_phase = -9'd199;\t //LUT[2215] \tphase : -0.777344\t(data_i, data_q): (-0.937500,-0.781250)\n\t2216: o_phase = -9'd201;\t //LUT[2216] \tphase : -0.785156\t(data_i, data_q): (-0.937500,-0.750000)\n\t2217: o_phase = -9'd203;\t //LUT[2217] \tphase : -0.792969\t(data_i, data_q): (-0.937500,-0.718750)\n\t2218: o_phase = -9'd204;\t //LUT[2218] \tphase : -0.796875\t(data_i, data_q): (-0.937500,-0.687500)\n\t2219: o_phase = -9'd206;\t //LUT[2219] \tphase : -0.804688\t(data_i, data_q): (-0.937500,-0.656250)\n\t2220: o_phase = -9'd208;\t //LUT[2220] \tphase : -0.812500\t(data_i, data_q): (-0.937500,-0.625000)\n\t2221: o_phase = -9'd210;\t //LUT[2221] \tphase : -0.820312\t(data_i, data_q): (-0.937500,-0.593750)\n\t2222: o_phase = -9'd212;\t //LUT[2222] \tphase : -0.828125\t(data_i, data_q): (-0.937500,-0.562500)\n\t2223: o_phase = -9'd214;\t //LUT[2223] \tphase : -0.835938\t(data_i, data_q): (-0.937500,-0.531250)\n\t2224: o_phase = -9'd216;\t //LUT[2224] \tphase : -0.843750\t(data_i, data_q): (-0.937500,-0.500000)\n\t2225: o_phase = -9'd218;\t //LUT[2225] \tphase : -0.851562\t(data_i, data_q): (-0.937500,-0.468750)\n\t2226: o_phase = -9'd220;\t //LUT[2226] \tphase : -0.859375\t(data_i, data_q): (-0.937500,-0.437500)\n\t2227: o_phase = -9'd223;\t //LUT[2227] \tphase : -0.871094\t(data_i, data_q): (-0.937500,-0.406250)\n\t2228: o_phase = -9'd225;\t //LUT[2228] \tphase : -0.878906\t(data_i, data_q): (-0.937500,-0.375000)\n\t2229: o_phase = -9'd227;\t //LUT[2229] \tphase : -0.886719\t(data_i, data_q): (-0.937500,-0.343750)\n\t2230: o_phase = -9'd230;\t //LUT[2230] \tphase : -0.898438\t(data_i, data_q): (-0.937500,-0.312500)\n\t2231: o_phase = -9'd232;\t //LUT[2231] \tphase : -0.906250\t(data_i, data_q): (-0.937500,-0.281250)\n\t2232: o_phase = -9'd235;\t //LUT[2232] \tphase : -0.917969\t(data_i, data_q): (-0.937500,-0.250000)\n\t2233: o_phase = -9'd237;\t //LUT[2233] \tphase : -0.925781\t(data_i, data_q): (-0.937500,-0.218750)\n\t2234: o_phase = -9'd240;\t //LUT[2234] \tphase : -0.937500\t(data_i, data_q): (-0.937500,-0.187500)\n\t2235: o_phase = -9'd243;\t //LUT[2235] \tphase : -0.949219\t(data_i, data_q): (-0.937500,-0.156250)\n\t2236: o_phase = -9'd245;\t //LUT[2236] \tphase : -0.957031\t(data_i, data_q): (-0.937500,-0.125000)\n\t2237: o_phase = -9'd248;\t //LUT[2237] \tphase : -0.968750\t(data_i, data_q): (-0.937500,-0.093750)\n\t2238: o_phase = -9'd251;\t //LUT[2238] \tphase : -0.980469\t(data_i, data_q): (-0.937500,-0.062500)\n\t2239: o_phase = -9'd253;\t //LUT[2239] \tphase : -0.988281\t(data_i, data_q): (-0.937500,-0.031250)\n\t2240: o_phase = -9'd256;\t //LUT[2240] \tphase : -1.000000\t(data_i, data_q): (-0.906250,0.000000)\n\t2241: o_phase = +9'd253;\t //LUT[2241] \tphase : 0.988281\t(data_i, data_q): (-0.906250,0.031250)\n\t2242: o_phase = +9'd250;\t //LUT[2242] \tphase : 0.976562\t(data_i, data_q): (-0.906250,0.062500)\n\t2243: o_phase = +9'd248;\t //LUT[2243] \tphase : 0.968750\t(data_i, data_q): (-0.906250,0.093750)\n\t2244: o_phase = +9'd245;\t //LUT[2244] \tphase : 0.957031\t(data_i, data_q): (-0.906250,0.125000)\n\t2245: o_phase = +9'd242;\t //LUT[2245] \tphase : 0.945312\t(data_i, data_q): (-0.906250,0.156250)\n\t2246: o_phase = +9'd239;\t //LUT[2246] \tphase : 0.933594\t(data_i, data_q): (-0.906250,0.187500)\n\t2247: o_phase = +9'd237;\t //LUT[2247] \tphase : 0.925781\t(data_i, data_q): (-0.906250,0.218750)\n\t2248: o_phase = +9'd234;\t //LUT[2248] \tphase : 0.914062\t(data_i, data_q): (-0.906250,0.250000)\n\t2249: o_phase = +9'd231;\t //LUT[2249] \tphase : 0.902344\t(data_i, data_q): (-0.906250,0.281250)\n\t2250: o_phase = +9'd229;\t //LUT[2250] \tphase : 0.894531\t(data_i, data_q): (-0.906250,0.312500)\n\t2251: o_phase = +9'd226;\t //LUT[2251] \tphase : 0.882812\t(data_i, data_q): (-0.906250,0.343750)\n\t2252: o_phase = +9'd224;\t //LUT[2252] \tphase : 0.875000\t(data_i, data_q): (-0.906250,0.375000)\n\t2253: o_phase = +9'd222;\t //LUT[2253] \tphase : 0.867188\t(data_i, data_q): (-0.906250,0.406250)\n\t2254: o_phase = +9'd219;\t //LUT[2254] \tphase : 0.855469\t(data_i, data_q): (-0.906250,0.437500)\n\t2255: o_phase = +9'd217;\t //LUT[2255] \tphase : 0.847656\t(data_i, data_q): (-0.906250,0.468750)\n\t2256: o_phase = +9'd215;\t //LUT[2256] \tphase : 0.839844\t(data_i, data_q): (-0.906250,0.500000)\n\t2257: o_phase = +9'd213;\t //LUT[2257] \tphase : 0.832031\t(data_i, data_q): (-0.906250,0.531250)\n\t2258: o_phase = +9'd211;\t //LUT[2258] \tphase : 0.824219\t(data_i, data_q): (-0.906250,0.562500)\n\t2259: o_phase = +9'd209;\t //LUT[2259] \tphase : 0.816406\t(data_i, data_q): (-0.906250,0.593750)\n\t2260: o_phase = +9'd207;\t //LUT[2260] \tphase : 0.808594\t(data_i, data_q): (-0.906250,0.625000)\n\t2261: o_phase = +9'd205;\t //LUT[2261] \tphase : 0.800781\t(data_i, data_q): (-0.906250,0.656250)\n\t2262: o_phase = +9'd203;\t //LUT[2262] \tphase : 0.792969\t(data_i, data_q): (-0.906250,0.687500)\n\t2263: o_phase = +9'd201;\t //LUT[2263] \tphase : 0.785156\t(data_i, data_q): (-0.906250,0.718750)\n\t2264: o_phase = +9'd200;\t //LUT[2264] \tphase : 0.781250\t(data_i, data_q): (-0.906250,0.750000)\n\t2265: o_phase = +9'd198;\t //LUT[2265] \tphase : 0.773438\t(data_i, data_q): (-0.906250,0.781250)\n\t2266: o_phase = +9'd196;\t //LUT[2266] \tphase : 0.765625\t(data_i, data_q): (-0.906250,0.812500)\n\t2267: o_phase = +9'd195;\t //LUT[2267] \tphase : 0.761719\t(data_i, data_q): (-0.906250,0.843750)\n\t2268: o_phase = +9'd193;\t //LUT[2268] \tphase : 0.753906\t(data_i, data_q): (-0.906250,0.875000)\n\t2269: o_phase = +9'd192;\t //LUT[2269] \tphase : 0.750000\t(data_i, data_q): (-0.906250,0.906250)\n\t2270: o_phase = +9'd191;\t //LUT[2270] \tphase : 0.746094\t(data_i, data_q): (-0.906250,0.937500)\n\t2271: o_phase = +9'd189;\t //LUT[2271] \tphase : 0.738281\t(data_i, data_q): (-0.906250,0.968750)\n\t2272: o_phase = -9'd188;\t //LUT[2272] \tphase : -0.734375\t(data_i, data_q): (-0.906250,-1.000000)\n\t2273: o_phase = -9'd189;\t //LUT[2273] \tphase : -0.738281\t(data_i, data_q): (-0.906250,-0.968750)\n\t2274: o_phase = -9'd191;\t //LUT[2274] \tphase : -0.746094\t(data_i, data_q): (-0.906250,-0.937500)\n\t2275: o_phase = -9'd192;\t //LUT[2275] \tphase : -0.750000\t(data_i, data_q): (-0.906250,-0.906250)\n\t2276: o_phase = -9'd193;\t //LUT[2276] \tphase : -0.753906\t(data_i, data_q): (-0.906250,-0.875000)\n\t2277: o_phase = -9'd195;\t //LUT[2277] \tphase : -0.761719\t(data_i, data_q): (-0.906250,-0.843750)\n\t2278: o_phase = -9'd196;\t //LUT[2278] \tphase : -0.765625\t(data_i, data_q): (-0.906250,-0.812500)\n\t2279: o_phase = -9'd198;\t //LUT[2279] \tphase : -0.773438\t(data_i, data_q): (-0.906250,-0.781250)\n\t2280: o_phase = -9'd200;\t //LUT[2280] \tphase : -0.781250\t(data_i, data_q): (-0.906250,-0.750000)\n\t2281: o_phase = -9'd201;\t //LUT[2281] \tphase : -0.785156\t(data_i, data_q): (-0.906250,-0.718750)\n\t2282: o_phase = -9'd203;\t //LUT[2282] \tphase : -0.792969\t(data_i, data_q): (-0.906250,-0.687500)\n\t2283: o_phase = -9'd205;\t //LUT[2283] \tphase : -0.800781\t(data_i, data_q): (-0.906250,-0.656250)\n\t2284: o_phase = -9'd207;\t //LUT[2284] \tphase : -0.808594\t(data_i, data_q): (-0.906250,-0.625000)\n\t2285: o_phase = -9'd209;\t //LUT[2285] \tphase : -0.816406\t(data_i, data_q): (-0.906250,-0.593750)\n\t2286: o_phase = -9'd211;\t //LUT[2286] \tphase : -0.824219\t(data_i, data_q): (-0.906250,-0.562500)\n\t2287: o_phase = -9'd213;\t //LUT[2287] \tphase : -0.832031\t(data_i, data_q): (-0.906250,-0.531250)\n\t2288: o_phase = -9'd215;\t //LUT[2288] \tphase : -0.839844\t(data_i, data_q): (-0.906250,-0.500000)\n\t2289: o_phase = -9'd217;\t //LUT[2289] \tphase : -0.847656\t(data_i, data_q): (-0.906250,-0.468750)\n\t2290: o_phase = -9'd219;\t //LUT[2290] \tphase : -0.855469\t(data_i, data_q): (-0.906250,-0.437500)\n\t2291: o_phase = -9'd222;\t //LUT[2291] \tphase : -0.867188\t(data_i, data_q): (-0.906250,-0.406250)\n\t2292: o_phase = -9'd224;\t //LUT[2292] \tphase : -0.875000\t(data_i, data_q): (-0.906250,-0.375000)\n\t2293: o_phase = -9'd226;\t //LUT[2293] \tphase : -0.882812\t(data_i, data_q): (-0.906250,-0.343750)\n\t2294: o_phase = -9'd229;\t //LUT[2294] \tphase : -0.894531\t(data_i, data_q): (-0.906250,-0.312500)\n\t2295: o_phase = -9'd231;\t //LUT[2295] \tphase : -0.902344\t(data_i, data_q): (-0.906250,-0.281250)\n\t2296: o_phase = -9'd234;\t //LUT[2296] \tphase : -0.914062\t(data_i, data_q): (-0.906250,-0.250000)\n\t2297: o_phase = -9'd237;\t //LUT[2297] \tphase : -0.925781\t(data_i, data_q): (-0.906250,-0.218750)\n\t2298: o_phase = -9'd239;\t //LUT[2298] \tphase : -0.933594\t(data_i, data_q): (-0.906250,-0.187500)\n\t2299: o_phase = -9'd242;\t //LUT[2299] \tphase : -0.945312\t(data_i, data_q): (-0.906250,-0.156250)\n\t2300: o_phase = -9'd245;\t //LUT[2300] \tphase : -0.957031\t(data_i, data_q): (-0.906250,-0.125000)\n\t2301: o_phase = -9'd248;\t //LUT[2301] \tphase : -0.968750\t(data_i, data_q): (-0.906250,-0.093750)\n\t2302: o_phase = -9'd250;\t //LUT[2302] \tphase : -0.976562\t(data_i, data_q): (-0.906250,-0.062500)\n\t2303: o_phase = -9'd253;\t //LUT[2303] \tphase : -0.988281\t(data_i, data_q): (-0.906250,-0.031250)\n\t2304: o_phase = -9'd256;\t //LUT[2304] \tphase : -1.000000\t(data_i, data_q): (-0.875000,0.000000)\n\t2305: o_phase = +9'd253;\t //LUT[2305] \tphase : 0.988281\t(data_i, data_q): (-0.875000,0.031250)\n\t2306: o_phase = +9'd250;\t //LUT[2306] \tphase : 0.976562\t(data_i, data_q): (-0.875000,0.062500)\n\t2307: o_phase = +9'd247;\t //LUT[2307] \tphase : 0.964844\t(data_i, data_q): (-0.875000,0.093750)\n\t2308: o_phase = +9'd244;\t //LUT[2308] \tphase : 0.953125\t(data_i, data_q): (-0.875000,0.125000)\n\t2309: o_phase = +9'd242;\t //LUT[2309] \tphase : 0.945312\t(data_i, data_q): (-0.875000,0.156250)\n\t2310: o_phase = +9'd239;\t //LUT[2310] \tphase : 0.933594\t(data_i, data_q): (-0.875000,0.187500)\n\t2311: o_phase = +9'd236;\t //LUT[2311] \tphase : 0.921875\t(data_i, data_q): (-0.875000,0.218750)\n\t2312: o_phase = +9'd233;\t //LUT[2312] \tphase : 0.910156\t(data_i, data_q): (-0.875000,0.250000)\n\t2313: o_phase = +9'd231;\t //LUT[2313] \tphase : 0.902344\t(data_i, data_q): (-0.875000,0.281250)\n\t2314: o_phase = +9'd228;\t //LUT[2314] \tphase : 0.890625\t(data_i, data_q): (-0.875000,0.312500)\n\t2315: o_phase = +9'd225;\t //LUT[2315] \tphase : 0.878906\t(data_i, data_q): (-0.875000,0.343750)\n\t2316: o_phase = +9'd223;\t //LUT[2316] \tphase : 0.871094\t(data_i, data_q): (-0.875000,0.375000)\n\t2317: o_phase = +9'd221;\t //LUT[2317] \tphase : 0.863281\t(data_i, data_q): (-0.875000,0.406250)\n\t2318: o_phase = +9'd218;\t //LUT[2318] \tphase : 0.851562\t(data_i, data_q): (-0.875000,0.437500)\n\t2319: o_phase = +9'd216;\t //LUT[2319] \tphase : 0.843750\t(data_i, data_q): (-0.875000,0.468750)\n\t2320: o_phase = +9'd214;\t //LUT[2320] \tphase : 0.835938\t(data_i, data_q): (-0.875000,0.500000)\n\t2321: o_phase = +9'd212;\t //LUT[2321] \tphase : 0.828125\t(data_i, data_q): (-0.875000,0.531250)\n\t2322: o_phase = +9'd209;\t //LUT[2322] \tphase : 0.816406\t(data_i, data_q): (-0.875000,0.562500)\n\t2323: o_phase = +9'd207;\t //LUT[2323] \tphase : 0.808594\t(data_i, data_q): (-0.875000,0.593750)\n\t2324: o_phase = +9'd205;\t //LUT[2324] \tphase : 0.800781\t(data_i, data_q): (-0.875000,0.625000)\n\t2325: o_phase = +9'd204;\t //LUT[2325] \tphase : 0.796875\t(data_i, data_q): (-0.875000,0.656250)\n\t2326: o_phase = +9'd202;\t //LUT[2326] \tphase : 0.789062\t(data_i, data_q): (-0.875000,0.687500)\n\t2327: o_phase = +9'd200;\t //LUT[2327] \tphase : 0.781250\t(data_i, data_q): (-0.875000,0.718750)\n\t2328: o_phase = +9'd198;\t //LUT[2328] \tphase : 0.773438\t(data_i, data_q): (-0.875000,0.750000)\n\t2329: o_phase = +9'd197;\t //LUT[2329] \tphase : 0.769531\t(data_i, data_q): (-0.875000,0.781250)\n\t2330: o_phase = +9'd195;\t //LUT[2330] \tphase : 0.761719\t(data_i, data_q): (-0.875000,0.812500)\n\t2331: o_phase = +9'd193;\t //LUT[2331] \tphase : 0.753906\t(data_i, data_q): (-0.875000,0.843750)\n\t2332: o_phase = +9'd192;\t //LUT[2332] \tphase : 0.750000\t(data_i, data_q): (-0.875000,0.875000)\n\t2333: o_phase = +9'd191;\t //LUT[2333] \tphase : 0.746094\t(data_i, data_q): (-0.875000,0.906250)\n\t2334: o_phase = +9'd189;\t //LUT[2334] \tphase : 0.738281\t(data_i, data_q): (-0.875000,0.937500)\n\t2335: o_phase = +9'd188;\t //LUT[2335] \tphase : 0.734375\t(data_i, data_q): (-0.875000,0.968750)\n\t2336: o_phase = -9'd187;\t //LUT[2336] \tphase : -0.730469\t(data_i, data_q): (-0.875000,-1.000000)\n\t2337: o_phase = -9'd188;\t //LUT[2337] \tphase : -0.734375\t(data_i, data_q): (-0.875000,-0.968750)\n\t2338: o_phase = -9'd189;\t //LUT[2338] \tphase : -0.738281\t(data_i, data_q): (-0.875000,-0.937500)\n\t2339: o_phase = -9'd191;\t //LUT[2339] \tphase : -0.746094\t(data_i, data_q): (-0.875000,-0.906250)\n\t2340: o_phase = -9'd192;\t //LUT[2340] \tphase : -0.750000\t(data_i, data_q): (-0.875000,-0.875000)\n\t2341: o_phase = -9'd193;\t //LUT[2341] \tphase : -0.753906\t(data_i, data_q): (-0.875000,-0.843750)\n\t2342: o_phase = -9'd195;\t //LUT[2342] \tphase : -0.761719\t(data_i, data_q): (-0.875000,-0.812500)\n\t2343: o_phase = -9'd197;\t //LUT[2343] \tphase : -0.769531\t(data_i, data_q): (-0.875000,-0.781250)\n\t2344: o_phase = -9'd198;\t //LUT[2344] \tphase : -0.773438\t(data_i, data_q): (-0.875000,-0.750000)\n\t2345: o_phase = -9'd200;\t //LUT[2345] \tphase : -0.781250\t(data_i, data_q): (-0.875000,-0.718750)\n\t2346: o_phase = -9'd202;\t //LUT[2346] \tphase : -0.789062\t(data_i, data_q): (-0.875000,-0.687500)\n\t2347: o_phase = -9'd204;\t //LUT[2347] \tphase : -0.796875\t(data_i, data_q): (-0.875000,-0.656250)\n\t2348: o_phase = -9'd205;\t //LUT[2348] \tphase : -0.800781\t(data_i, data_q): (-0.875000,-0.625000)\n\t2349: o_phase = -9'd207;\t //LUT[2349] \tphase : -0.808594\t(data_i, data_q): (-0.875000,-0.593750)\n\t2350: o_phase = -9'd209;\t //LUT[2350] \tphase : -0.816406\t(data_i, data_q): (-0.875000,-0.562500)\n\t2351: o_phase = -9'd212;\t //LUT[2351] \tphase : -0.828125\t(data_i, data_q): (-0.875000,-0.531250)\n\t2352: o_phase = -9'd214;\t //LUT[2352] \tphase : -0.835938\t(data_i, data_q): (-0.875000,-0.500000)\n\t2353: o_phase = -9'd216;\t //LUT[2353] \tphase : -0.843750\t(data_i, data_q): (-0.875000,-0.468750)\n\t2354: o_phase = -9'd218;\t //LUT[2354] \tphase : -0.851562\t(data_i, data_q): (-0.875000,-0.437500)\n\t2355: o_phase = -9'd221;\t //LUT[2355] \tphase : -0.863281\t(data_i, data_q): (-0.875000,-0.406250)\n\t2356: o_phase = -9'd223;\t //LUT[2356] \tphase : -0.871094\t(data_i, data_q): (-0.875000,-0.375000)\n\t2357: o_phase = -9'd225;\t //LUT[2357] \tphase : -0.878906\t(data_i, data_q): (-0.875000,-0.343750)\n\t2358: o_phase = -9'd228;\t //LUT[2358] \tphase : -0.890625\t(data_i, data_q): (-0.875000,-0.312500)\n\t2359: o_phase = -9'd231;\t //LUT[2359] \tphase : -0.902344\t(data_i, data_q): (-0.875000,-0.281250)\n\t2360: o_phase = -9'd233;\t //LUT[2360] \tphase : -0.910156\t(data_i, data_q): (-0.875000,-0.250000)\n\t2361: o_phase = -9'd236;\t //LUT[2361] \tphase : -0.921875\t(data_i, data_q): (-0.875000,-0.218750)\n\t2362: o_phase = -9'd239;\t //LUT[2362] \tphase : -0.933594\t(data_i, data_q): (-0.875000,-0.187500)\n\t2363: o_phase = -9'd242;\t //LUT[2363] \tphase : -0.945312\t(data_i, data_q): (-0.875000,-0.156250)\n\t2364: o_phase = -9'd244;\t //LUT[2364] \tphase : -0.953125\t(data_i, data_q): (-0.875000,-0.125000)\n\t2365: o_phase = -9'd247;\t //LUT[2365] \tphase : -0.964844\t(data_i, data_q): (-0.875000,-0.093750)\n\t2366: o_phase = -9'd250;\t //LUT[2366] \tphase : -0.976562\t(data_i, data_q): (-0.875000,-0.062500)\n\t2367: o_phase = -9'd253;\t //LUT[2367] \tphase : -0.988281\t(data_i, data_q): (-0.875000,-0.031250)\n\t2368: o_phase = -9'd256;\t //LUT[2368] \tphase : -1.000000\t(data_i, data_q): (-0.843750,0.000000)\n\t2369: o_phase = +9'd253;\t //LUT[2369] \tphase : 0.988281\t(data_i, data_q): (-0.843750,0.031250)\n\t2370: o_phase = +9'd250;\t //LUT[2370] \tphase : 0.976562\t(data_i, data_q): (-0.843750,0.062500)\n\t2371: o_phase = +9'd247;\t //LUT[2371] \tphase : 0.964844\t(data_i, data_q): (-0.843750,0.093750)\n\t2372: o_phase = +9'd244;\t //LUT[2372] \tphase : 0.953125\t(data_i, data_q): (-0.843750,0.125000)\n\t2373: o_phase = +9'd241;\t //LUT[2373] \tphase : 0.941406\t(data_i, data_q): (-0.843750,0.156250)\n\t2374: o_phase = +9'd238;\t //LUT[2374] \tphase : 0.929688\t(data_i, data_q): (-0.843750,0.187500)\n\t2375: o_phase = +9'd235;\t //LUT[2375] \tphase : 0.917969\t(data_i, data_q): (-0.843750,0.218750)\n\t2376: o_phase = +9'd233;\t //LUT[2376] \tphase : 0.910156\t(data_i, data_q): (-0.843750,0.250000)\n\t2377: o_phase = +9'd230;\t //LUT[2377] \tphase : 0.898438\t(data_i, data_q): (-0.843750,0.281250)\n\t2378: o_phase = +9'd227;\t //LUT[2378] \tphase : 0.886719\t(data_i, data_q): (-0.843750,0.312500)\n\t2379: o_phase = +9'd224;\t //LUT[2379] \tphase : 0.875000\t(data_i, data_q): (-0.843750,0.343750)\n\t2380: o_phase = +9'd222;\t //LUT[2380] \tphase : 0.867188\t(data_i, data_q): (-0.843750,0.375000)\n\t2381: o_phase = +9'd219;\t //LUT[2381] \tphase : 0.855469\t(data_i, data_q): (-0.843750,0.406250)\n\t2382: o_phase = +9'd217;\t //LUT[2382] \tphase : 0.847656\t(data_i, data_q): (-0.843750,0.437500)\n\t2383: o_phase = +9'd215;\t //LUT[2383] \tphase : 0.839844\t(data_i, data_q): (-0.843750,0.468750)\n\t2384: o_phase = +9'd212;\t //LUT[2384] \tphase : 0.828125\t(data_i, data_q): (-0.843750,0.500000)\n\t2385: o_phase = +9'd210;\t //LUT[2385] \tphase : 0.820312\t(data_i, data_q): (-0.843750,0.531250)\n\t2386: o_phase = +9'd208;\t //LUT[2386] \tphase : 0.812500\t(data_i, data_q): (-0.843750,0.562500)\n\t2387: o_phase = +9'd206;\t //LUT[2387] \tphase : 0.804688\t(data_i, data_q): (-0.843750,0.593750)\n\t2388: o_phase = +9'd204;\t //LUT[2388] \tphase : 0.796875\t(data_i, data_q): (-0.843750,0.625000)\n\t2389: o_phase = +9'd202;\t //LUT[2389] \tphase : 0.789062\t(data_i, data_q): (-0.843750,0.656250)\n\t2390: o_phase = +9'd200;\t //LUT[2390] \tphase : 0.781250\t(data_i, data_q): (-0.843750,0.687500)\n\t2391: o_phase = +9'd199;\t //LUT[2391] \tphase : 0.777344\t(data_i, data_q): (-0.843750,0.718750)\n\t2392: o_phase = +9'd197;\t //LUT[2392] \tphase : 0.769531\t(data_i, data_q): (-0.843750,0.750000)\n\t2393: o_phase = +9'd195;\t //LUT[2393] \tphase : 0.761719\t(data_i, data_q): (-0.843750,0.781250)\n\t2394: o_phase = +9'd194;\t //LUT[2394] \tphase : 0.757812\t(data_i, data_q): (-0.843750,0.812500)\n\t2395: o_phase = +9'd192;\t //LUT[2395] \tphase : 0.750000\t(data_i, data_q): (-0.843750,0.843750)\n\t2396: o_phase = +9'd191;\t //LUT[2396] \tphase : 0.746094\t(data_i, data_q): (-0.843750,0.875000)\n\t2397: o_phase = +9'd189;\t //LUT[2397] \tphase : 0.738281\t(data_i, data_q): (-0.843750,0.906250)\n\t2398: o_phase = +9'd188;\t //LUT[2398] \tphase : 0.734375\t(data_i, data_q): (-0.843750,0.937500)\n\t2399: o_phase = +9'd186;\t //LUT[2399] \tphase : 0.726562\t(data_i, data_q): (-0.843750,0.968750)\n\t2400: o_phase = -9'd185;\t //LUT[2400] \tphase : -0.722656\t(data_i, data_q): (-0.843750,-1.000000)\n\t2401: o_phase = -9'd186;\t //LUT[2401] \tphase : -0.726562\t(data_i, data_q): (-0.843750,-0.968750)\n\t2402: o_phase = -9'd188;\t //LUT[2402] \tphase : -0.734375\t(data_i, data_q): (-0.843750,-0.937500)\n\t2403: o_phase = -9'd189;\t //LUT[2403] \tphase : -0.738281\t(data_i, data_q): (-0.843750,-0.906250)\n\t2404: o_phase = -9'd191;\t //LUT[2404] \tphase : -0.746094\t(data_i, data_q): (-0.843750,-0.875000)\n\t2405: o_phase = -9'd192;\t //LUT[2405] \tphase : -0.750000\t(data_i, data_q): (-0.843750,-0.843750)\n\t2406: o_phase = -9'd194;\t //LUT[2406] \tphase : -0.757812\t(data_i, data_q): (-0.843750,-0.812500)\n\t2407: o_phase = -9'd195;\t //LUT[2407] \tphase : -0.761719\t(data_i, data_q): (-0.843750,-0.781250)\n\t2408: o_phase = -9'd197;\t //LUT[2408] \tphase : -0.769531\t(data_i, data_q): (-0.843750,-0.750000)\n\t2409: o_phase = -9'd199;\t //LUT[2409] \tphase : -0.777344\t(data_i, data_q): (-0.843750,-0.718750)\n\t2410: o_phase = -9'd200;\t //LUT[2410] \tphase : -0.781250\t(data_i, data_q): (-0.843750,-0.687500)\n\t2411: o_phase = -9'd202;\t //LUT[2411] \tphase : -0.789062\t(data_i, data_q): (-0.843750,-0.656250)\n\t2412: o_phase = -9'd204;\t //LUT[2412] \tphase : -0.796875\t(data_i, data_q): (-0.843750,-0.625000)\n\t2413: o_phase = -9'd206;\t //LUT[2413] \tphase : -0.804688\t(data_i, data_q): (-0.843750,-0.593750)\n\t2414: o_phase = -9'd208;\t //LUT[2414] \tphase : -0.812500\t(data_i, data_q): (-0.843750,-0.562500)\n\t2415: o_phase = -9'd210;\t //LUT[2415] \tphase : -0.820312\t(data_i, data_q): (-0.843750,-0.531250)\n\t2416: o_phase = -9'd212;\t //LUT[2416] \tphase : -0.828125\t(data_i, data_q): (-0.843750,-0.500000)\n\t2417: o_phase = -9'd215;\t //LUT[2417] \tphase : -0.839844\t(data_i, data_q): (-0.843750,-0.468750)\n\t2418: o_phase = -9'd217;\t //LUT[2418] \tphase : -0.847656\t(data_i, data_q): (-0.843750,-0.437500)\n\t2419: o_phase = -9'd219;\t //LUT[2419] \tphase : -0.855469\t(data_i, data_q): (-0.843750,-0.406250)\n\t2420: o_phase = -9'd222;\t //LUT[2420] \tphase : -0.867188\t(data_i, data_q): (-0.843750,-0.375000)\n\t2421: o_phase = -9'd224;\t //LUT[2421] \tphase : -0.875000\t(data_i, data_q): (-0.843750,-0.343750)\n\t2422: o_phase = -9'd227;\t //LUT[2422] \tphase : -0.886719\t(data_i, data_q): (-0.843750,-0.312500)\n\t2423: o_phase = -9'd230;\t //LUT[2423] \tphase : -0.898438\t(data_i, data_q): (-0.843750,-0.281250)\n\t2424: o_phase = -9'd233;\t //LUT[2424] \tphase : -0.910156\t(data_i, data_q): (-0.843750,-0.250000)\n\t2425: o_phase = -9'd235;\t //LUT[2425] \tphase : -0.917969\t(data_i, data_q): (-0.843750,-0.218750)\n\t2426: o_phase = -9'd238;\t //LUT[2426] \tphase : -0.929688\t(data_i, data_q): (-0.843750,-0.187500)\n\t2427: o_phase = -9'd241;\t //LUT[2427] \tphase : -0.941406\t(data_i, data_q): (-0.843750,-0.156250)\n\t2428: o_phase = -9'd244;\t //LUT[2428] \tphase : -0.953125\t(data_i, data_q): (-0.843750,-0.125000)\n\t2429: o_phase = -9'd247;\t //LUT[2429] \tphase : -0.964844\t(data_i, data_q): (-0.843750,-0.093750)\n\t2430: o_phase = -9'd250;\t //LUT[2430] \tphase : -0.976562\t(data_i, data_q): (-0.843750,-0.062500)\n\t2431: o_phase = -9'd253;\t //LUT[2431] \tphase : -0.988281\t(data_i, data_q): (-0.843750,-0.031250)\n\t2432: o_phase = -9'd256;\t //LUT[2432] \tphase : -1.000000\t(data_i, data_q): (-0.812500,0.000000)\n\t2433: o_phase = +9'd253;\t //LUT[2433] \tphase : 0.988281\t(data_i, data_q): (-0.812500,0.031250)\n\t2434: o_phase = +9'd250;\t //LUT[2434] \tphase : 0.976562\t(data_i, data_q): (-0.812500,0.062500)\n\t2435: o_phase = +9'd247;\t //LUT[2435] \tphase : 0.964844\t(data_i, data_q): (-0.812500,0.093750)\n\t2436: o_phase = +9'd244;\t //LUT[2436] \tphase : 0.953125\t(data_i, data_q): (-0.812500,0.125000)\n\t2437: o_phase = +9'd241;\t //LUT[2437] \tphase : 0.941406\t(data_i, data_q): (-0.812500,0.156250)\n\t2438: o_phase = +9'd238;\t //LUT[2438] \tphase : 0.929688\t(data_i, data_q): (-0.812500,0.187500)\n\t2439: o_phase = +9'd235;\t //LUT[2439] \tphase : 0.917969\t(data_i, data_q): (-0.812500,0.218750)\n\t2440: o_phase = +9'd232;\t //LUT[2440] \tphase : 0.906250\t(data_i, data_q): (-0.812500,0.250000)\n\t2441: o_phase = +9'd229;\t //LUT[2441] \tphase : 0.894531\t(data_i, data_q): (-0.812500,0.281250)\n\t2442: o_phase = +9'd226;\t //LUT[2442] \tphase : 0.882812\t(data_i, data_q): (-0.812500,0.312500)\n\t2443: o_phase = +9'd223;\t //LUT[2443] \tphase : 0.871094\t(data_i, data_q): (-0.812500,0.343750)\n\t2444: o_phase = +9'd221;\t //LUT[2444] \tphase : 0.863281\t(data_i, data_q): (-0.812500,0.375000)\n\t2445: o_phase = +9'd218;\t //LUT[2445] \tphase : 0.851562\t(data_i, data_q): (-0.812500,0.406250)\n\t2446: o_phase = +9'd216;\t //LUT[2446] \tphase : 0.843750\t(data_i, data_q): (-0.812500,0.437500)\n\t2447: o_phase = +9'd213;\t //LUT[2447] \tphase : 0.832031\t(data_i, data_q): (-0.812500,0.468750)\n\t2448: o_phase = +9'd211;\t //LUT[2448] \tphase : 0.824219\t(data_i, data_q): (-0.812500,0.500000)\n\t2449: o_phase = +9'd209;\t //LUT[2449] \tphase : 0.816406\t(data_i, data_q): (-0.812500,0.531250)\n\t2450: o_phase = +9'd207;\t //LUT[2450] \tphase : 0.808594\t(data_i, data_q): (-0.812500,0.562500)\n\t2451: o_phase = +9'd205;\t //LUT[2451] \tphase : 0.800781\t(data_i, data_q): (-0.812500,0.593750)\n\t2452: o_phase = +9'd203;\t //LUT[2452] \tphase : 0.792969\t(data_i, data_q): (-0.812500,0.625000)\n\t2453: o_phase = +9'd201;\t //LUT[2453] \tphase : 0.785156\t(data_i, data_q): (-0.812500,0.656250)\n\t2454: o_phase = +9'd199;\t //LUT[2454] \tphase : 0.777344\t(data_i, data_q): (-0.812500,0.687500)\n\t2455: o_phase = +9'd197;\t //LUT[2455] \tphase : 0.769531\t(data_i, data_q): (-0.812500,0.718750)\n\t2456: o_phase = +9'd195;\t //LUT[2456] \tphase : 0.761719\t(data_i, data_q): (-0.812500,0.750000)\n\t2457: o_phase = +9'd194;\t //LUT[2457] \tphase : 0.757812\t(data_i, data_q): (-0.812500,0.781250)\n\t2458: o_phase = +9'd192;\t //LUT[2458] \tphase : 0.750000\t(data_i, data_q): (-0.812500,0.812500)\n\t2459: o_phase = +9'd190;\t //LUT[2459] \tphase : 0.742188\t(data_i, data_q): (-0.812500,0.843750)\n\t2460: o_phase = +9'd189;\t //LUT[2460] \tphase : 0.738281\t(data_i, data_q): (-0.812500,0.875000)\n\t2461: o_phase = +9'd188;\t //LUT[2461] \tphase : 0.734375\t(data_i, data_q): (-0.812500,0.906250)\n\t2462: o_phase = +9'd186;\t //LUT[2462] \tphase : 0.726562\t(data_i, data_q): (-0.812500,0.937500)\n\t2463: o_phase = +9'd185;\t //LUT[2463] \tphase : 0.722656\t(data_i, data_q): (-0.812500,0.968750)\n\t2464: o_phase = -9'd184;\t //LUT[2464] \tphase : -0.718750\t(data_i, data_q): (-0.812500,-1.000000)\n\t2465: o_phase = -9'd185;\t //LUT[2465] \tphase : -0.722656\t(data_i, data_q): (-0.812500,-0.968750)\n\t2466: o_phase = -9'd186;\t //LUT[2466] \tphase : -0.726562\t(data_i, data_q): (-0.812500,-0.937500)\n\t2467: o_phase = -9'd188;\t //LUT[2467] \tphase : -0.734375\t(data_i, data_q): (-0.812500,-0.906250)\n\t2468: o_phase = -9'd189;\t //LUT[2468] \tphase : -0.738281\t(data_i, data_q): (-0.812500,-0.875000)\n\t2469: o_phase = -9'd190;\t //LUT[2469] \tphase : -0.742188\t(data_i, data_q): (-0.812500,-0.843750)\n\t2470: o_phase = -9'd192;\t //LUT[2470] \tphase : -0.750000\t(data_i, data_q): (-0.812500,-0.812500)\n\t2471: o_phase = -9'd194;\t //LUT[2471] \tphase : -0.757812\t(data_i, data_q): (-0.812500,-0.781250)\n\t2472: o_phase = -9'd195;\t //LUT[2472] \tphase : -0.761719\t(data_i, data_q): (-0.812500,-0.750000)\n\t2473: o_phase = -9'd197;\t //LUT[2473] \tphase : -0.769531\t(data_i, data_q): (-0.812500,-0.718750)\n\t2474: o_phase = -9'd199;\t //LUT[2474] \tphase : -0.777344\t(data_i, data_q): (-0.812500,-0.687500)\n\t2475: o_phase = -9'd201;\t //LUT[2475] \tphase : -0.785156\t(data_i, data_q): (-0.812500,-0.656250)\n\t2476: o_phase = -9'd203;\t //LUT[2476] \tphase : -0.792969\t(data_i, data_q): (-0.812500,-0.625000)\n\t2477: o_phase = -9'd205;\t //LUT[2477] \tphase : -0.800781\t(data_i, data_q): (-0.812500,-0.593750)\n\t2478: o_phase = -9'd207;\t //LUT[2478] \tphase : -0.808594\t(data_i, data_q): (-0.812500,-0.562500)\n\t2479: o_phase = -9'd209;\t //LUT[2479] \tphase : -0.816406\t(data_i, data_q): (-0.812500,-0.531250)\n\t2480: o_phase = -9'd211;\t //LUT[2480] \tphase : -0.824219\t(data_i, data_q): (-0.812500,-0.500000)\n\t2481: o_phase = -9'd213;\t //LUT[2481] \tphase : -0.832031\t(data_i, data_q): (-0.812500,-0.468750)\n\t2482: o_phase = -9'd216;\t //LUT[2482] \tphase : -0.843750\t(data_i, data_q): (-0.812500,-0.437500)\n\t2483: o_phase = -9'd218;\t //LUT[2483] \tphase : -0.851562\t(data_i, data_q): (-0.812500,-0.406250)\n\t2484: o_phase = -9'd221;\t //LUT[2484] \tphase : -0.863281\t(data_i, data_q): (-0.812500,-0.375000)\n\t2485: o_phase = -9'd223;\t //LUT[2485] \tphase : -0.871094\t(data_i, data_q): (-0.812500,-0.343750)\n\t2486: o_phase = -9'd226;\t //LUT[2486] \tphase : -0.882812\t(data_i, data_q): (-0.812500,-0.312500)\n\t2487: o_phase = -9'd229;\t //LUT[2487] \tphase : -0.894531\t(data_i, data_q): (-0.812500,-0.281250)\n\t2488: o_phase = -9'd232;\t //LUT[2488] \tphase : -0.906250\t(data_i, data_q): (-0.812500,-0.250000)\n\t2489: o_phase = -9'd235;\t //LUT[2489] \tphase : -0.917969\t(data_i, data_q): (-0.812500,-0.218750)\n\t2490: o_phase = -9'd238;\t //LUT[2490] \tphase : -0.929688\t(data_i, data_q): (-0.812500,-0.187500)\n\t2491: o_phase = -9'd241;\t //LUT[2491] \tphase : -0.941406\t(data_i, data_q): (-0.812500,-0.156250)\n\t2492: o_phase = -9'd244;\t //LUT[2492] \tphase : -0.953125\t(data_i, data_q): (-0.812500,-0.125000)\n\t2493: o_phase = -9'd247;\t //LUT[2493] \tphase : -0.964844\t(data_i, data_q): (-0.812500,-0.093750)\n\t2494: o_phase = -9'd250;\t //LUT[2494] \tphase : -0.976562\t(data_i, data_q): (-0.812500,-0.062500)\n\t2495: o_phase = -9'd253;\t //LUT[2495] \tphase : -0.988281\t(data_i, data_q): (-0.812500,-0.031250)\n\t2496: o_phase = -9'd256;\t //LUT[2496] \tphase : -1.000000\t(data_i, data_q): (-0.781250,0.000000)\n\t2497: o_phase = +9'd253;\t //LUT[2497] \tphase : 0.988281\t(data_i, data_q): (-0.781250,0.031250)\n\t2498: o_phase = +9'd249;\t //LUT[2498] \tphase : 0.972656\t(data_i, data_q): (-0.781250,0.062500)\n\t2499: o_phase = +9'd246;\t //LUT[2499] \tphase : 0.960938\t(data_i, data_q): (-0.781250,0.093750)\n\t2500: o_phase = +9'd243;\t //LUT[2500] \tphase : 0.949219\t(data_i, data_q): (-0.781250,0.125000)\n\t2501: o_phase = +9'd240;\t //LUT[2501] \tphase : 0.937500\t(data_i, data_q): (-0.781250,0.156250)\n\t2502: o_phase = +9'd237;\t //LUT[2502] \tphase : 0.925781\t(data_i, data_q): (-0.781250,0.187500)\n\t2503: o_phase = +9'd234;\t //LUT[2503] \tphase : 0.914062\t(data_i, data_q): (-0.781250,0.218750)\n\t2504: o_phase = +9'd231;\t //LUT[2504] \tphase : 0.902344\t(data_i, data_q): (-0.781250,0.250000)\n\t2505: o_phase = +9'd228;\t //LUT[2505] \tphase : 0.890625\t(data_i, data_q): (-0.781250,0.281250)\n\t2506: o_phase = +9'd225;\t //LUT[2506] \tphase : 0.878906\t(data_i, data_q): (-0.781250,0.312500)\n\t2507: o_phase = +9'd222;\t //LUT[2507] \tphase : 0.867188\t(data_i, data_q): (-0.781250,0.343750)\n\t2508: o_phase = +9'd220;\t //LUT[2508] \tphase : 0.859375\t(data_i, data_q): (-0.781250,0.375000)\n\t2509: o_phase = +9'd217;\t //LUT[2509] \tphase : 0.847656\t(data_i, data_q): (-0.781250,0.406250)\n\t2510: o_phase = +9'd214;\t //LUT[2510] \tphase : 0.835938\t(data_i, data_q): (-0.781250,0.437500)\n\t2511: o_phase = +9'd212;\t //LUT[2511] \tphase : 0.828125\t(data_i, data_q): (-0.781250,0.468750)\n\t2512: o_phase = +9'd210;\t //LUT[2512] \tphase : 0.820312\t(data_i, data_q): (-0.781250,0.500000)\n\t2513: o_phase = +9'd207;\t //LUT[2513] \tphase : 0.808594\t(data_i, data_q): (-0.781250,0.531250)\n\t2514: o_phase = +9'd205;\t //LUT[2514] \tphase : 0.800781\t(data_i, data_q): (-0.781250,0.562500)\n\t2515: o_phase = +9'd203;\t //LUT[2515] \tphase : 0.792969\t(data_i, data_q): (-0.781250,0.593750)\n\t2516: o_phase = +9'd201;\t //LUT[2516] \tphase : 0.785156\t(data_i, data_q): (-0.781250,0.625000)\n\t2517: o_phase = +9'd199;\t //LUT[2517] \tphase : 0.777344\t(data_i, data_q): (-0.781250,0.656250)\n\t2518: o_phase = +9'd197;\t //LUT[2518] \tphase : 0.769531\t(data_i, data_q): (-0.781250,0.687500)\n\t2519: o_phase = +9'd195;\t //LUT[2519] \tphase : 0.761719\t(data_i, data_q): (-0.781250,0.718750)\n\t2520: o_phase = +9'd194;\t //LUT[2520] \tphase : 0.757812\t(data_i, data_q): (-0.781250,0.750000)\n\t2521: o_phase = +9'd192;\t //LUT[2521] \tphase : 0.750000\t(data_i, data_q): (-0.781250,0.781250)\n\t2522: o_phase = +9'd190;\t //LUT[2522] \tphase : 0.742188\t(data_i, data_q): (-0.781250,0.812500)\n\t2523: o_phase = +9'd189;\t //LUT[2523] \tphase : 0.738281\t(data_i, data_q): (-0.781250,0.843750)\n\t2524: o_phase = +9'd187;\t //LUT[2524] \tphase : 0.730469\t(data_i, data_q): (-0.781250,0.875000)\n\t2525: o_phase = +9'd186;\t //LUT[2525] \tphase : 0.726562\t(data_i, data_q): (-0.781250,0.906250)\n\t2526: o_phase = +9'd185;\t //LUT[2526] \tphase : 0.722656\t(data_i, data_q): (-0.781250,0.937500)\n\t2527: o_phase = +9'd183;\t //LUT[2527] \tphase : 0.714844\t(data_i, data_q): (-0.781250,0.968750)\n\t2528: o_phase = -9'd182;\t //LUT[2528] \tphase : -0.710938\t(data_i, data_q): (-0.781250,-1.000000)\n\t2529: o_phase = -9'd183;\t //LUT[2529] \tphase : -0.714844\t(data_i, data_q): (-0.781250,-0.968750)\n\t2530: o_phase = -9'd185;\t //LUT[2530] \tphase : -0.722656\t(data_i, data_q): (-0.781250,-0.937500)\n\t2531: o_phase = -9'd186;\t //LUT[2531] \tphase : -0.726562\t(data_i, data_q): (-0.781250,-0.906250)\n\t2532: o_phase = -9'd187;\t //LUT[2532] \tphase : -0.730469\t(data_i, data_q): (-0.781250,-0.875000)\n\t2533: o_phase = -9'd189;\t //LUT[2533] \tphase : -0.738281\t(data_i, data_q): (-0.781250,-0.843750)\n\t2534: o_phase = -9'd190;\t //LUT[2534] \tphase : -0.742188\t(data_i, data_q): (-0.781250,-0.812500)\n\t2535: o_phase = -9'd192;\t //LUT[2535] \tphase : -0.750000\t(data_i, data_q): (-0.781250,-0.781250)\n\t2536: o_phase = -9'd194;\t //LUT[2536] \tphase : -0.757812\t(data_i, data_q): (-0.781250,-0.750000)\n\t2537: o_phase = -9'd195;\t //LUT[2537] \tphase : -0.761719\t(data_i, data_q): (-0.781250,-0.718750)\n\t2538: o_phase = -9'd197;\t //LUT[2538] \tphase : -0.769531\t(data_i, data_q): (-0.781250,-0.687500)\n\t2539: o_phase = -9'd199;\t //LUT[2539] \tphase : -0.777344\t(data_i, data_q): (-0.781250,-0.656250)\n\t2540: o_phase = -9'd201;\t //LUT[2540] \tphase : -0.785156\t(data_i, data_q): (-0.781250,-0.625000)\n\t2541: o_phase = -9'd203;\t //LUT[2541] \tphase : -0.792969\t(data_i, data_q): (-0.781250,-0.593750)\n\t2542: o_phase = -9'd205;\t //LUT[2542] \tphase : -0.800781\t(data_i, data_q): (-0.781250,-0.562500)\n\t2543: o_phase = -9'd207;\t //LUT[2543] \tphase : -0.808594\t(data_i, data_q): (-0.781250,-0.531250)\n\t2544: o_phase = -9'd210;\t //LUT[2544] \tphase : -0.820312\t(data_i, data_q): (-0.781250,-0.500000)\n\t2545: o_phase = -9'd212;\t //LUT[2545] \tphase : -0.828125\t(data_i, data_q): (-0.781250,-0.468750)\n\t2546: o_phase = -9'd214;\t //LUT[2546] \tphase : -0.835938\t(data_i, data_q): (-0.781250,-0.437500)\n\t2547: o_phase = -9'd217;\t //LUT[2547] \tphase : -0.847656\t(data_i, data_q): (-0.781250,-0.406250)\n\t2548: o_phase = -9'd220;\t //LUT[2548] \tphase : -0.859375\t(data_i, data_q): (-0.781250,-0.375000)\n\t2549: o_phase = -9'd222;\t //LUT[2549] \tphase : -0.867188\t(data_i, data_q): (-0.781250,-0.343750)\n\t2550: o_phase = -9'd225;\t //LUT[2550] \tphase : -0.878906\t(data_i, data_q): (-0.781250,-0.312500)\n\t2551: o_phase = -9'd228;\t //LUT[2551] \tphase : -0.890625\t(data_i, data_q): (-0.781250,-0.281250)\n\t2552: o_phase = -9'd231;\t //LUT[2552] \tphase : -0.902344\t(data_i, data_q): (-0.781250,-0.250000)\n\t2553: o_phase = -9'd234;\t //LUT[2553] \tphase : -0.914062\t(data_i, data_q): (-0.781250,-0.218750)\n\t2554: o_phase = -9'd237;\t //LUT[2554] \tphase : -0.925781\t(data_i, data_q): (-0.781250,-0.187500)\n\t2555: o_phase = -9'd240;\t //LUT[2555] \tphase : -0.937500\t(data_i, data_q): (-0.781250,-0.156250)\n\t2556: o_phase = -9'd243;\t //LUT[2556] \tphase : -0.949219\t(data_i, data_q): (-0.781250,-0.125000)\n\t2557: o_phase = -9'd246;\t //LUT[2557] \tphase : -0.960938\t(data_i, data_q): (-0.781250,-0.093750)\n\t2558: o_phase = -9'd249;\t //LUT[2558] \tphase : -0.972656\t(data_i, data_q): (-0.781250,-0.062500)\n\t2559: o_phase = -9'd253;\t //LUT[2559] \tphase : -0.988281\t(data_i, data_q): (-0.781250,-0.031250)\n\t2560: o_phase = -9'd256;\t //LUT[2560] \tphase : -1.000000\t(data_i, data_q): (-0.750000,0.000000)\n\t2561: o_phase = +9'd253;\t //LUT[2561] \tphase : 0.988281\t(data_i, data_q): (-0.750000,0.031250)\n\t2562: o_phase = +9'd249;\t //LUT[2562] \tphase : 0.972656\t(data_i, data_q): (-0.750000,0.062500)\n\t2563: o_phase = +9'd246;\t //LUT[2563] \tphase : 0.960938\t(data_i, data_q): (-0.750000,0.093750)\n\t2564: o_phase = +9'd243;\t //LUT[2564] \tphase : 0.949219\t(data_i, data_q): (-0.750000,0.125000)\n\t2565: o_phase = +9'd239;\t //LUT[2565] \tphase : 0.933594\t(data_i, data_q): (-0.750000,0.156250)\n\t2566: o_phase = +9'd236;\t //LUT[2566] \tphase : 0.921875\t(data_i, data_q): (-0.750000,0.187500)\n\t2567: o_phase = +9'd233;\t //LUT[2567] \tphase : 0.910156\t(data_i, data_q): (-0.750000,0.218750)\n\t2568: o_phase = +9'd230;\t //LUT[2568] \tphase : 0.898438\t(data_i, data_q): (-0.750000,0.250000)\n\t2569: o_phase = +9'd227;\t //LUT[2569] \tphase : 0.886719\t(data_i, data_q): (-0.750000,0.281250)\n\t2570: o_phase = +9'd224;\t //LUT[2570] \tphase : 0.875000\t(data_i, data_q): (-0.750000,0.312500)\n\t2571: o_phase = +9'd221;\t //LUT[2571] \tphase : 0.863281\t(data_i, data_q): (-0.750000,0.343750)\n\t2572: o_phase = +9'd218;\t //LUT[2572] \tphase : 0.851562\t(data_i, data_q): (-0.750000,0.375000)\n\t2573: o_phase = +9'd216;\t //LUT[2573] \tphase : 0.843750\t(data_i, data_q): (-0.750000,0.406250)\n\t2574: o_phase = +9'd213;\t //LUT[2574] \tphase : 0.832031\t(data_i, data_q): (-0.750000,0.437500)\n\t2575: o_phase = +9'd210;\t //LUT[2575] \tphase : 0.820312\t(data_i, data_q): (-0.750000,0.468750)\n\t2576: o_phase = +9'd208;\t //LUT[2576] \tphase : 0.812500\t(data_i, data_q): (-0.750000,0.500000)\n\t2577: o_phase = +9'd206;\t //LUT[2577] \tphase : 0.804688\t(data_i, data_q): (-0.750000,0.531250)\n\t2578: o_phase = +9'd204;\t //LUT[2578] \tphase : 0.796875\t(data_i, data_q): (-0.750000,0.562500)\n\t2579: o_phase = +9'd201;\t //LUT[2579] \tphase : 0.785156\t(data_i, data_q): (-0.750000,0.593750)\n\t2580: o_phase = +9'd199;\t //LUT[2580] \tphase : 0.777344\t(data_i, data_q): (-0.750000,0.625000)\n\t2581: o_phase = +9'd197;\t //LUT[2581] \tphase : 0.769531\t(data_i, data_q): (-0.750000,0.656250)\n\t2582: o_phase = +9'd196;\t //LUT[2582] \tphase : 0.765625\t(data_i, data_q): (-0.750000,0.687500)\n\t2583: o_phase = +9'd194;\t //LUT[2583] \tphase : 0.757812\t(data_i, data_q): (-0.750000,0.718750)\n\t2584: o_phase = +9'd192;\t //LUT[2584] \tphase : 0.750000\t(data_i, data_q): (-0.750000,0.750000)\n\t2585: o_phase = +9'd190;\t //LUT[2585] \tphase : 0.742188\t(data_i, data_q): (-0.750000,0.781250)\n\t2586: o_phase = +9'd189;\t //LUT[2586] \tphase : 0.738281\t(data_i, data_q): (-0.750000,0.812500)\n\t2587: o_phase = +9'd187;\t //LUT[2587] \tphase : 0.730469\t(data_i, data_q): (-0.750000,0.843750)\n\t2588: o_phase = +9'd186;\t //LUT[2588] \tphase : 0.726562\t(data_i, data_q): (-0.750000,0.875000)\n\t2589: o_phase = +9'd184;\t //LUT[2589] \tphase : 0.718750\t(data_i, data_q): (-0.750000,0.906250)\n\t2590: o_phase = +9'd183;\t //LUT[2590] \tphase : 0.714844\t(data_i, data_q): (-0.750000,0.937500)\n\t2591: o_phase = +9'd182;\t //LUT[2591] \tphase : 0.710938\t(data_i, data_q): (-0.750000,0.968750)\n\t2592: o_phase = -9'd180;\t //LUT[2592] \tphase : -0.703125\t(data_i, data_q): (-0.750000,-1.000000)\n\t2593: o_phase = -9'd182;\t //LUT[2593] \tphase : -0.710938\t(data_i, data_q): (-0.750000,-0.968750)\n\t2594: o_phase = -9'd183;\t //LUT[2594] \tphase : -0.714844\t(data_i, data_q): (-0.750000,-0.937500)\n\t2595: o_phase = -9'd184;\t //LUT[2595] \tphase : -0.718750\t(data_i, data_q): (-0.750000,-0.906250)\n\t2596: o_phase = -9'd186;\t //LUT[2596] \tphase : -0.726562\t(data_i, data_q): (-0.750000,-0.875000)\n\t2597: o_phase = -9'd187;\t //LUT[2597] \tphase : -0.730469\t(data_i, data_q): (-0.750000,-0.843750)\n\t2598: o_phase = -9'd189;\t //LUT[2598] \tphase : -0.738281\t(data_i, data_q): (-0.750000,-0.812500)\n\t2599: o_phase = -9'd190;\t //LUT[2599] \tphase : -0.742188\t(data_i, data_q): (-0.750000,-0.781250)\n\t2600: o_phase = -9'd192;\t //LUT[2600] \tphase : -0.750000\t(data_i, data_q): (-0.750000,-0.750000)\n\t2601: o_phase = -9'd194;\t //LUT[2601] \tphase : -0.757812\t(data_i, data_q): (-0.750000,-0.718750)\n\t2602: o_phase = -9'd196;\t //LUT[2602] \tphase : -0.765625\t(data_i, data_q): (-0.750000,-0.687500)\n\t2603: o_phase = -9'd197;\t //LUT[2603] \tphase : -0.769531\t(data_i, data_q): (-0.750000,-0.656250)\n\t2604: o_phase = -9'd199;\t //LUT[2604] \tphase : -0.777344\t(data_i, data_q): (-0.750000,-0.625000)\n\t2605: o_phase = -9'd201;\t //LUT[2605] \tphase : -0.785156\t(data_i, data_q): (-0.750000,-0.593750)\n\t2606: o_phase = -9'd204;\t //LUT[2606] \tphase : -0.796875\t(data_i, data_q): (-0.750000,-0.562500)\n\t2607: o_phase = -9'd206;\t //LUT[2607] \tphase : -0.804688\t(data_i, data_q): (-0.750000,-0.531250)\n\t2608: o_phase = -9'd208;\t //LUT[2608] \tphase : -0.812500\t(data_i, data_q): (-0.750000,-0.500000)\n\t2609: o_phase = -9'd210;\t //LUT[2609] \tphase : -0.820312\t(data_i, data_q): (-0.750000,-0.468750)\n\t2610: o_phase = -9'd213;\t //LUT[2610] \tphase : -0.832031\t(data_i, data_q): (-0.750000,-0.437500)\n\t2611: o_phase = -9'd216;\t //LUT[2611] \tphase : -0.843750\t(data_i, data_q): (-0.750000,-0.406250)\n\t2612: o_phase = -9'd218;\t //LUT[2612] \tphase : -0.851562\t(data_i, data_q): (-0.750000,-0.375000)\n\t2613: o_phase = -9'd221;\t //LUT[2613] \tphase : -0.863281\t(data_i, data_q): (-0.750000,-0.343750)\n\t2614: o_phase = -9'd224;\t //LUT[2614] \tphase : -0.875000\t(data_i, data_q): (-0.750000,-0.312500)\n\t2615: o_phase = -9'd227;\t //LUT[2615] \tphase : -0.886719\t(data_i, data_q): (-0.750000,-0.281250)\n\t2616: o_phase = -9'd230;\t //LUT[2616] \tphase : -0.898438\t(data_i, data_q): (-0.750000,-0.250000)\n\t2617: o_phase = -9'd233;\t //LUT[2617] \tphase : -0.910156\t(data_i, data_q): (-0.750000,-0.218750)\n\t2618: o_phase = -9'd236;\t //LUT[2618] \tphase : -0.921875\t(data_i, data_q): (-0.750000,-0.187500)\n\t2619: o_phase = -9'd239;\t //LUT[2619] \tphase : -0.933594\t(data_i, data_q): (-0.750000,-0.156250)\n\t2620: o_phase = -9'd243;\t //LUT[2620] \tphase : -0.949219\t(data_i, data_q): (-0.750000,-0.125000)\n\t2621: o_phase = -9'd246;\t //LUT[2621] \tphase : -0.960938\t(data_i, data_q): (-0.750000,-0.093750)\n\t2622: o_phase = -9'd249;\t //LUT[2622] \tphase : -0.972656\t(data_i, data_q): (-0.750000,-0.062500)\n\t2623: o_phase = -9'd253;\t //LUT[2623] \tphase : -0.988281\t(data_i, data_q): (-0.750000,-0.031250)\n\t2624: o_phase = -9'd256;\t //LUT[2624] \tphase : -1.000000\t(data_i, data_q): (-0.718750,0.000000)\n\t2625: o_phase = +9'd252;\t //LUT[2625] \tphase : 0.984375\t(data_i, data_q): (-0.718750,0.031250)\n\t2626: o_phase = +9'd249;\t //LUT[2626] \tphase : 0.972656\t(data_i, data_q): (-0.718750,0.062500)\n\t2627: o_phase = +9'd245;\t //LUT[2627] \tphase : 0.957031\t(data_i, data_q): (-0.718750,0.093750)\n\t2628: o_phase = +9'd242;\t //LUT[2628] \tphase : 0.945312\t(data_i, data_q): (-0.718750,0.125000)\n\t2629: o_phase = +9'd239;\t //LUT[2629] \tphase : 0.933594\t(data_i, data_q): (-0.718750,0.156250)\n\t2630: o_phase = +9'd235;\t //LUT[2630] \tphase : 0.917969\t(data_i, data_q): (-0.718750,0.187500)\n\t2631: o_phase = +9'd232;\t //LUT[2631] \tphase : 0.906250\t(data_i, data_q): (-0.718750,0.218750)\n\t2632: o_phase = +9'd229;\t //LUT[2632] \tphase : 0.894531\t(data_i, data_q): (-0.718750,0.250000)\n\t2633: o_phase = +9'd226;\t //LUT[2633] \tphase : 0.882812\t(data_i, data_q): (-0.718750,0.281250)\n\t2634: o_phase = +9'd223;\t //LUT[2634] \tphase : 0.871094\t(data_i, data_q): (-0.718750,0.312500)\n\t2635: o_phase = +9'd220;\t //LUT[2635] \tphase : 0.859375\t(data_i, data_q): (-0.718750,0.343750)\n\t2636: o_phase = +9'd217;\t //LUT[2636] \tphase : 0.847656\t(data_i, data_q): (-0.718750,0.375000)\n\t2637: o_phase = +9'd214;\t //LUT[2637] \tphase : 0.835938\t(data_i, data_q): (-0.718750,0.406250)\n\t2638: o_phase = +9'd211;\t //LUT[2638] \tphase : 0.824219\t(data_i, data_q): (-0.718750,0.437500)\n\t2639: o_phase = +9'd209;\t //LUT[2639] \tphase : 0.816406\t(data_i, data_q): (-0.718750,0.468750)\n\t2640: o_phase = +9'd206;\t //LUT[2640] \tphase : 0.804688\t(data_i, data_q): (-0.718750,0.500000)\n\t2641: o_phase = +9'd204;\t //LUT[2641] \tphase : 0.796875\t(data_i, data_q): (-0.718750,0.531250)\n\t2642: o_phase = +9'd202;\t //LUT[2642] \tphase : 0.789062\t(data_i, data_q): (-0.718750,0.562500)\n\t2643: o_phase = +9'd200;\t //LUT[2643] \tphase : 0.781250\t(data_i, data_q): (-0.718750,0.593750)\n\t2644: o_phase = +9'd198;\t //LUT[2644] \tphase : 0.773438\t(data_i, data_q): (-0.718750,0.625000)\n\t2645: o_phase = +9'd196;\t //LUT[2645] \tphase : 0.765625\t(data_i, data_q): (-0.718750,0.656250)\n\t2646: o_phase = +9'd194;\t //LUT[2646] \tphase : 0.757812\t(data_i, data_q): (-0.718750,0.687500)\n\t2647: o_phase = +9'd192;\t //LUT[2647] \tphase : 0.750000\t(data_i, data_q): (-0.718750,0.718750)\n\t2648: o_phase = +9'd190;\t //LUT[2648] \tphase : 0.742188\t(data_i, data_q): (-0.718750,0.750000)\n\t2649: o_phase = +9'd189;\t //LUT[2649] \tphase : 0.738281\t(data_i, data_q): (-0.718750,0.781250)\n\t2650: o_phase = +9'd187;\t //LUT[2650] \tphase : 0.730469\t(data_i, data_q): (-0.718750,0.812500)\n\t2651: o_phase = +9'd185;\t //LUT[2651] \tphase : 0.722656\t(data_i, data_q): (-0.718750,0.843750)\n\t2652: o_phase = +9'd184;\t //LUT[2652] \tphase : 0.718750\t(data_i, data_q): (-0.718750,0.875000)\n\t2653: o_phase = +9'd183;\t //LUT[2653] \tphase : 0.714844\t(data_i, data_q): (-0.718750,0.906250)\n\t2654: o_phase = +9'd181;\t //LUT[2654] \tphase : 0.707031\t(data_i, data_q): (-0.718750,0.937500)\n\t2655: o_phase = +9'd180;\t //LUT[2655] \tphase : 0.703125\t(data_i, data_q): (-0.718750,0.968750)\n\t2656: o_phase = -9'd179;\t //LUT[2656] \tphase : -0.699219\t(data_i, data_q): (-0.718750,-1.000000)\n\t2657: o_phase = -9'd180;\t //LUT[2657] \tphase : -0.703125\t(data_i, data_q): (-0.718750,-0.968750)\n\t2658: o_phase = -9'd181;\t //LUT[2658] \tphase : -0.707031\t(data_i, data_q): (-0.718750,-0.937500)\n\t2659: o_phase = -9'd183;\t //LUT[2659] \tphase : -0.714844\t(data_i, data_q): (-0.718750,-0.906250)\n\t2660: o_phase = -9'd184;\t //LUT[2660] \tphase : -0.718750\t(data_i, data_q): (-0.718750,-0.875000)\n\t2661: o_phase = -9'd185;\t //LUT[2661] \tphase : -0.722656\t(data_i, data_q): (-0.718750,-0.843750)\n\t2662: o_phase = -9'd187;\t //LUT[2662] \tphase : -0.730469\t(data_i, data_q): (-0.718750,-0.812500)\n\t2663: o_phase = -9'd189;\t //LUT[2663] \tphase : -0.738281\t(data_i, data_q): (-0.718750,-0.781250)\n\t2664: o_phase = -9'd190;\t //LUT[2664] \tphase : -0.742188\t(data_i, data_q): (-0.718750,-0.750000)\n\t2665: o_phase = -9'd192;\t //LUT[2665] \tphase : -0.750000\t(data_i, data_q): (-0.718750,-0.718750)\n\t2666: o_phase = -9'd194;\t //LUT[2666] \tphase : -0.757812\t(data_i, data_q): (-0.718750,-0.687500)\n\t2667: o_phase = -9'd196;\t //LUT[2667] \tphase : -0.765625\t(data_i, data_q): (-0.718750,-0.656250)\n\t2668: o_phase = -9'd198;\t //LUT[2668] \tphase : -0.773438\t(data_i, data_q): (-0.718750,-0.625000)\n\t2669: o_phase = -9'd200;\t //LUT[2669] \tphase : -0.781250\t(data_i, data_q): (-0.718750,-0.593750)\n\t2670: o_phase = -9'd202;\t //LUT[2670] \tphase : -0.789062\t(data_i, data_q): (-0.718750,-0.562500)\n\t2671: o_phase = -9'd204;\t //LUT[2671] \tphase : -0.796875\t(data_i, data_q): (-0.718750,-0.531250)\n\t2672: o_phase = -9'd206;\t //LUT[2672] \tphase : -0.804688\t(data_i, data_q): (-0.718750,-0.500000)\n\t2673: o_phase = -9'd209;\t //LUT[2673] \tphase : -0.816406\t(data_i, data_q): (-0.718750,-0.468750)\n\t2674: o_phase = -9'd211;\t //LUT[2674] \tphase : -0.824219\t(data_i, data_q): (-0.718750,-0.437500)\n\t2675: o_phase = -9'd214;\t //LUT[2675] \tphase : -0.835938\t(data_i, data_q): (-0.718750,-0.406250)\n\t2676: o_phase = -9'd217;\t //LUT[2676] \tphase : -0.847656\t(data_i, data_q): (-0.718750,-0.375000)\n\t2677: o_phase = -9'd220;\t //LUT[2677] \tphase : -0.859375\t(data_i, data_q): (-0.718750,-0.343750)\n\t2678: o_phase = -9'd223;\t //LUT[2678] \tphase : -0.871094\t(data_i, data_q): (-0.718750,-0.312500)\n\t2679: o_phase = -9'd226;\t //LUT[2679] \tphase : -0.882812\t(data_i, data_q): (-0.718750,-0.281250)\n\t2680: o_phase = -9'd229;\t //LUT[2680] \tphase : -0.894531\t(data_i, data_q): (-0.718750,-0.250000)\n\t2681: o_phase = -9'd232;\t //LUT[2681] \tphase : -0.906250\t(data_i, data_q): (-0.718750,-0.218750)\n\t2682: o_phase = -9'd235;\t //LUT[2682] \tphase : -0.917969\t(data_i, data_q): (-0.718750,-0.187500)\n\t2683: o_phase = -9'd239;\t //LUT[2683] \tphase : -0.933594\t(data_i, data_q): (-0.718750,-0.156250)\n\t2684: o_phase = -9'd242;\t //LUT[2684] \tphase : -0.945312\t(data_i, data_q): (-0.718750,-0.125000)\n\t2685: o_phase = -9'd245;\t //LUT[2685] \tphase : -0.957031\t(data_i, data_q): (-0.718750,-0.093750)\n\t2686: o_phase = -9'd249;\t //LUT[2686] \tphase : -0.972656\t(data_i, data_q): (-0.718750,-0.062500)\n\t2687: o_phase = -9'd252;\t //LUT[2687] \tphase : -0.984375\t(data_i, data_q): (-0.718750,-0.031250)\n\t2688: o_phase = -9'd256;\t //LUT[2688] \tphase : -1.000000\t(data_i, data_q): (-0.687500,0.000000)\n\t2689: o_phase = +9'd252;\t //LUT[2689] \tphase : 0.984375\t(data_i, data_q): (-0.687500,0.031250)\n\t2690: o_phase = +9'd249;\t //LUT[2690] \tphase : 0.972656\t(data_i, data_q): (-0.687500,0.062500)\n\t2691: o_phase = +9'd245;\t //LUT[2691] \tphase : 0.957031\t(data_i, data_q): (-0.687500,0.093750)\n\t2692: o_phase = +9'd241;\t //LUT[2692] \tphase : 0.941406\t(data_i, data_q): (-0.687500,0.125000)\n\t2693: o_phase = +9'd238;\t //LUT[2693] \tphase : 0.929688\t(data_i, data_q): (-0.687500,0.156250)\n\t2694: o_phase = +9'd234;\t //LUT[2694] \tphase : 0.914062\t(data_i, data_q): (-0.687500,0.187500)\n\t2695: o_phase = +9'd231;\t //LUT[2695] \tphase : 0.902344\t(data_i, data_q): (-0.687500,0.218750)\n\t2696: o_phase = +9'd228;\t //LUT[2696] \tphase : 0.890625\t(data_i, data_q): (-0.687500,0.250000)\n\t2697: o_phase = +9'd224;\t //LUT[2697] \tphase : 0.875000\t(data_i, data_q): (-0.687500,0.281250)\n\t2698: o_phase = +9'd221;\t //LUT[2698] \tphase : 0.863281\t(data_i, data_q): (-0.687500,0.312500)\n\t2699: o_phase = +9'd218;\t //LUT[2699] \tphase : 0.851562\t(data_i, data_q): (-0.687500,0.343750)\n\t2700: o_phase = +9'd215;\t //LUT[2700] \tphase : 0.839844\t(data_i, data_q): (-0.687500,0.375000)\n\t2701: o_phase = +9'd213;\t //LUT[2701] \tphase : 0.832031\t(data_i, data_q): (-0.687500,0.406250)\n\t2702: o_phase = +9'd210;\t //LUT[2702] \tphase : 0.820312\t(data_i, data_q): (-0.687500,0.437500)\n\t2703: o_phase = +9'd207;\t //LUT[2703] \tphase : 0.808594\t(data_i, data_q): (-0.687500,0.468750)\n\t2704: o_phase = +9'd205;\t //LUT[2704] \tphase : 0.800781\t(data_i, data_q): (-0.687500,0.500000)\n\t2705: o_phase = +9'd202;\t //LUT[2705] \tphase : 0.789062\t(data_i, data_q): (-0.687500,0.531250)\n\t2706: o_phase = +9'd200;\t //LUT[2706] \tphase : 0.781250\t(data_i, data_q): (-0.687500,0.562500)\n\t2707: o_phase = +9'd198;\t //LUT[2707] \tphase : 0.773438\t(data_i, data_q): (-0.687500,0.593750)\n\t2708: o_phase = +9'd196;\t //LUT[2708] \tphase : 0.765625\t(data_i, data_q): (-0.687500,0.625000)\n\t2709: o_phase = +9'd194;\t //LUT[2709] \tphase : 0.757812\t(data_i, data_q): (-0.687500,0.656250)\n\t2710: o_phase = +9'd192;\t //LUT[2710] \tphase : 0.750000\t(data_i, data_q): (-0.687500,0.687500)\n\t2711: o_phase = +9'd190;\t //LUT[2711] \tphase : 0.742188\t(data_i, data_q): (-0.687500,0.718750)\n\t2712: o_phase = +9'd188;\t //LUT[2712] \tphase : 0.734375\t(data_i, data_q): (-0.687500,0.750000)\n\t2713: o_phase = +9'd187;\t //LUT[2713] \tphase : 0.730469\t(data_i, data_q): (-0.687500,0.781250)\n\t2714: o_phase = +9'd185;\t //LUT[2714] \tphase : 0.722656\t(data_i, data_q): (-0.687500,0.812500)\n\t2715: o_phase = +9'd184;\t //LUT[2715] \tphase : 0.718750\t(data_i, data_q): (-0.687500,0.843750)\n\t2716: o_phase = +9'd182;\t //LUT[2716] \tphase : 0.710938\t(data_i, data_q): (-0.687500,0.875000)\n\t2717: o_phase = +9'd181;\t //LUT[2717] \tphase : 0.707031\t(data_i, data_q): (-0.687500,0.906250)\n\t2718: o_phase = +9'd180;\t //LUT[2718] \tphase : 0.703125\t(data_i, data_q): (-0.687500,0.937500)\n\t2719: o_phase = +9'd178;\t //LUT[2719] \tphase : 0.695312\t(data_i, data_q): (-0.687500,0.968750)\n\t2720: o_phase = -9'd177;\t //LUT[2720] \tphase : -0.691406\t(data_i, data_q): (-0.687500,-1.000000)\n\t2721: o_phase = -9'd178;\t //LUT[2721] \tphase : -0.695312\t(data_i, data_q): (-0.687500,-0.968750)\n\t2722: o_phase = -9'd180;\t //LUT[2722] \tphase : -0.703125\t(data_i, data_q): (-0.687500,-0.937500)\n\t2723: o_phase = -9'd181;\t //LUT[2723] \tphase : -0.707031\t(data_i, data_q): (-0.687500,-0.906250)\n\t2724: o_phase = -9'd182;\t //LUT[2724] \tphase : -0.710938\t(data_i, data_q): (-0.687500,-0.875000)\n\t2725: o_phase = -9'd184;\t //LUT[2725] \tphase : -0.718750\t(data_i, data_q): (-0.687500,-0.843750)\n\t2726: o_phase = -9'd185;\t //LUT[2726] \tphase : -0.722656\t(data_i, data_q): (-0.687500,-0.812500)\n\t2727: o_phase = -9'd187;\t //LUT[2727] \tphase : -0.730469\t(data_i, data_q): (-0.687500,-0.781250)\n\t2728: o_phase = -9'd188;\t //LUT[2728] \tphase : -0.734375\t(data_i, data_q): (-0.687500,-0.750000)\n\t2729: o_phase = -9'd190;\t //LUT[2729] \tphase : -0.742188\t(data_i, data_q): (-0.687500,-0.718750)\n\t2730: o_phase = -9'd192;\t //LUT[2730] \tphase : -0.750000\t(data_i, data_q): (-0.687500,-0.687500)\n\t2731: o_phase = -9'd194;\t //LUT[2731] \tphase : -0.757812\t(data_i, data_q): (-0.687500,-0.656250)\n\t2732: o_phase = -9'd196;\t //LUT[2732] \tphase : -0.765625\t(data_i, data_q): (-0.687500,-0.625000)\n\t2733: o_phase = -9'd198;\t //LUT[2733] \tphase : -0.773438\t(data_i, data_q): (-0.687500,-0.593750)\n\t2734: o_phase = -9'd200;\t //LUT[2734] \tphase : -0.781250\t(data_i, data_q): (-0.687500,-0.562500)\n\t2735: o_phase = -9'd202;\t //LUT[2735] \tphase : -0.789062\t(data_i, data_q): (-0.687500,-0.531250)\n\t2736: o_phase = -9'd205;\t //LUT[2736] \tphase : -0.800781\t(data_i, data_q): (-0.687500,-0.500000)\n\t2737: o_phase = -9'd207;\t //LUT[2737] \tphase : -0.808594\t(data_i, data_q): (-0.687500,-0.468750)\n\t2738: o_phase = -9'd210;\t //LUT[2738] \tphase : -0.820312\t(data_i, data_q): (-0.687500,-0.437500)\n\t2739: o_phase = -9'd213;\t //LUT[2739] \tphase : -0.832031\t(data_i, data_q): (-0.687500,-0.406250)\n\t2740: o_phase = -9'd215;\t //LUT[2740] \tphase : -0.839844\t(data_i, data_q): (-0.687500,-0.375000)\n\t2741: o_phase = -9'd218;\t //LUT[2741] \tphase : -0.851562\t(data_i, data_q): (-0.687500,-0.343750)\n\t2742: o_phase = -9'd221;\t //LUT[2742] \tphase : -0.863281\t(data_i, data_q): (-0.687500,-0.312500)\n\t2743: o_phase = -9'd224;\t //LUT[2743] \tphase : -0.875000\t(data_i, data_q): (-0.687500,-0.281250)\n\t2744: o_phase = -9'd228;\t //LUT[2744] \tphase : -0.890625\t(data_i, data_q): (-0.687500,-0.250000)\n\t2745: o_phase = -9'd231;\t //LUT[2745] \tphase : -0.902344\t(data_i, data_q): (-0.687500,-0.218750)\n\t2746: o_phase = -9'd234;\t //LUT[2746] \tphase : -0.914062\t(data_i, data_q): (-0.687500,-0.187500)\n\t2747: o_phase = -9'd238;\t //LUT[2747] \tphase : -0.929688\t(data_i, data_q): (-0.687500,-0.156250)\n\t2748: o_phase = -9'd241;\t //LUT[2748] \tphase : -0.941406\t(data_i, data_q): (-0.687500,-0.125000)\n\t2749: o_phase = -9'd245;\t //LUT[2749] \tphase : -0.957031\t(data_i, data_q): (-0.687500,-0.093750)\n\t2750: o_phase = -9'd249;\t //LUT[2750] \tphase : -0.972656\t(data_i, data_q): (-0.687500,-0.062500)\n\t2751: o_phase = -9'd252;\t //LUT[2751] \tphase : -0.984375\t(data_i, data_q): (-0.687500,-0.031250)\n\t2752: o_phase = -9'd256;\t //LUT[2752] \tphase : -1.000000\t(data_i, data_q): (-0.656250,0.000000)\n\t2753: o_phase = +9'd252;\t //LUT[2753] \tphase : 0.984375\t(data_i, data_q): (-0.656250,0.031250)\n\t2754: o_phase = +9'd248;\t //LUT[2754] \tphase : 0.968750\t(data_i, data_q): (-0.656250,0.062500)\n\t2755: o_phase = +9'd244;\t //LUT[2755] \tphase : 0.953125\t(data_i, data_q): (-0.656250,0.093750)\n\t2756: o_phase = +9'd241;\t //LUT[2756] \tphase : 0.941406\t(data_i, data_q): (-0.656250,0.125000)\n\t2757: o_phase = +9'd237;\t //LUT[2757] \tphase : 0.925781\t(data_i, data_q): (-0.656250,0.156250)\n\t2758: o_phase = +9'd233;\t //LUT[2758] \tphase : 0.910156\t(data_i, data_q): (-0.656250,0.187500)\n\t2759: o_phase = +9'd230;\t //LUT[2759] \tphase : 0.898438\t(data_i, data_q): (-0.656250,0.218750)\n\t2760: o_phase = +9'd226;\t //LUT[2760] \tphase : 0.882812\t(data_i, data_q): (-0.656250,0.250000)\n\t2761: o_phase = +9'd223;\t //LUT[2761] \tphase : 0.871094\t(data_i, data_q): (-0.656250,0.281250)\n\t2762: o_phase = +9'd220;\t //LUT[2762] \tphase : 0.859375\t(data_i, data_q): (-0.656250,0.312500)\n\t2763: o_phase = +9'd217;\t //LUT[2763] \tphase : 0.847656\t(data_i, data_q): (-0.656250,0.343750)\n\t2764: o_phase = +9'd214;\t //LUT[2764] \tphase : 0.835938\t(data_i, data_q): (-0.656250,0.375000)\n\t2765: o_phase = +9'd211;\t //LUT[2765] \tphase : 0.824219\t(data_i, data_q): (-0.656250,0.406250)\n\t2766: o_phase = +9'd208;\t //LUT[2766] \tphase : 0.812500\t(data_i, data_q): (-0.656250,0.437500)\n\t2767: o_phase = +9'd205;\t //LUT[2767] \tphase : 0.800781\t(data_i, data_q): (-0.656250,0.468750)\n\t2768: o_phase = +9'd203;\t //LUT[2768] \tphase : 0.792969\t(data_i, data_q): (-0.656250,0.500000)\n\t2769: o_phase = +9'd201;\t //LUT[2769] \tphase : 0.785156\t(data_i, data_q): (-0.656250,0.531250)\n\t2770: o_phase = +9'd198;\t //LUT[2770] \tphase : 0.773438\t(data_i, data_q): (-0.656250,0.562500)\n\t2771: o_phase = +9'd196;\t //LUT[2771] \tphase : 0.765625\t(data_i, data_q): (-0.656250,0.593750)\n\t2772: o_phase = +9'd194;\t //LUT[2772] \tphase : 0.757812\t(data_i, data_q): (-0.656250,0.625000)\n\t2773: o_phase = +9'd192;\t //LUT[2773] \tphase : 0.750000\t(data_i, data_q): (-0.656250,0.656250)\n\t2774: o_phase = +9'd190;\t //LUT[2774] \tphase : 0.742188\t(data_i, data_q): (-0.656250,0.687500)\n\t2775: o_phase = +9'd188;\t //LUT[2775] \tphase : 0.734375\t(data_i, data_q): (-0.656250,0.718750)\n\t2776: o_phase = +9'd187;\t //LUT[2776] \tphase : 0.730469\t(data_i, data_q): (-0.656250,0.750000)\n\t2777: o_phase = +9'd185;\t //LUT[2777] \tphase : 0.722656\t(data_i, data_q): (-0.656250,0.781250)\n\t2778: o_phase = +9'd183;\t //LUT[2778] \tphase : 0.714844\t(data_i, data_q): (-0.656250,0.812500)\n\t2779: o_phase = +9'd182;\t //LUT[2779] \tphase : 0.710938\t(data_i, data_q): (-0.656250,0.843750)\n\t2780: o_phase = +9'd180;\t //LUT[2780] \tphase : 0.703125\t(data_i, data_q): (-0.656250,0.875000)\n\t2781: o_phase = +9'd179;\t //LUT[2781] \tphase : 0.699219\t(data_i, data_q): (-0.656250,0.906250)\n\t2782: o_phase = +9'd178;\t //LUT[2782] \tphase : 0.695312\t(data_i, data_q): (-0.656250,0.937500)\n\t2783: o_phase = +9'd177;\t //LUT[2783] \tphase : 0.691406\t(data_i, data_q): (-0.656250,0.968750)\n\t2784: o_phase = -9'd175;\t //LUT[2784] \tphase : -0.683594\t(data_i, data_q): (-0.656250,-1.000000)\n\t2785: o_phase = -9'd177;\t //LUT[2785] \tphase : -0.691406\t(data_i, data_q): (-0.656250,-0.968750)\n\t2786: o_phase = -9'd178;\t //LUT[2786] \tphase : -0.695312\t(data_i, data_q): (-0.656250,-0.937500)\n\t2787: o_phase = -9'd179;\t //LUT[2787] \tphase : -0.699219\t(data_i, data_q): (-0.656250,-0.906250)\n\t2788: o_phase = -9'd180;\t //LUT[2788] \tphase : -0.703125\t(data_i, data_q): (-0.656250,-0.875000)\n\t2789: o_phase = -9'd182;\t //LUT[2789] \tphase : -0.710938\t(data_i, data_q): (-0.656250,-0.843750)\n\t2790: o_phase = -9'd183;\t //LUT[2790] \tphase : -0.714844\t(data_i, data_q): (-0.656250,-0.812500)\n\t2791: o_phase = -9'd185;\t //LUT[2791] \tphase : -0.722656\t(data_i, data_q): (-0.656250,-0.781250)\n\t2792: o_phase = -9'd187;\t //LUT[2792] \tphase : -0.730469\t(data_i, data_q): (-0.656250,-0.750000)\n\t2793: o_phase = -9'd188;\t //LUT[2793] \tphase : -0.734375\t(data_i, data_q): (-0.656250,-0.718750)\n\t2794: o_phase = -9'd190;\t //LUT[2794] \tphase : -0.742188\t(data_i, data_q): (-0.656250,-0.687500)\n\t2795: o_phase = -9'd192;\t //LUT[2795] \tphase : -0.750000\t(data_i, data_q): (-0.656250,-0.656250)\n\t2796: o_phase = -9'd194;\t //LUT[2796] \tphase : -0.757812\t(data_i, data_q): (-0.656250,-0.625000)\n\t2797: o_phase = -9'd196;\t //LUT[2797] \tphase : -0.765625\t(data_i, data_q): (-0.656250,-0.593750)\n\t2798: o_phase = -9'd198;\t //LUT[2798] \tphase : -0.773438\t(data_i, data_q): (-0.656250,-0.562500)\n\t2799: o_phase = -9'd201;\t //LUT[2799] \tphase : -0.785156\t(data_i, data_q): (-0.656250,-0.531250)\n\t2800: o_phase = -9'd203;\t //LUT[2800] \tphase : -0.792969\t(data_i, data_q): (-0.656250,-0.500000)\n\t2801: o_phase = -9'd205;\t //LUT[2801] \tphase : -0.800781\t(data_i, data_q): (-0.656250,-0.468750)\n\t2802: o_phase = -9'd208;\t //LUT[2802] \tphase : -0.812500\t(data_i, data_q): (-0.656250,-0.437500)\n\t2803: o_phase = -9'd211;\t //LUT[2803] \tphase : -0.824219\t(data_i, data_q): (-0.656250,-0.406250)\n\t2804: o_phase = -9'd214;\t //LUT[2804] \tphase : -0.835938\t(data_i, data_q): (-0.656250,-0.375000)\n\t2805: o_phase = -9'd217;\t //LUT[2805] \tphase : -0.847656\t(data_i, data_q): (-0.656250,-0.343750)\n\t2806: o_phase = -9'd220;\t //LUT[2806] \tphase : -0.859375\t(data_i, data_q): (-0.656250,-0.312500)\n\t2807: o_phase = -9'd223;\t //LUT[2807] \tphase : -0.871094\t(data_i, data_q): (-0.656250,-0.281250)\n\t2808: o_phase = -9'd226;\t //LUT[2808] \tphase : -0.882812\t(data_i, data_q): (-0.656250,-0.250000)\n\t2809: o_phase = -9'd230;\t //LUT[2809] \tphase : -0.898438\t(data_i, data_q): (-0.656250,-0.218750)\n\t2810: o_phase = -9'd233;\t //LUT[2810] \tphase : -0.910156\t(data_i, data_q): (-0.656250,-0.187500)\n\t2811: o_phase = -9'd237;\t //LUT[2811] \tphase : -0.925781\t(data_i, data_q): (-0.656250,-0.156250)\n\t2812: o_phase = -9'd241;\t //LUT[2812] \tphase : -0.941406\t(data_i, data_q): (-0.656250,-0.125000)\n\t2813: o_phase = -9'd244;\t //LUT[2813] \tphase : -0.953125\t(data_i, data_q): (-0.656250,-0.093750)\n\t2814: o_phase = -9'd248;\t //LUT[2814] \tphase : -0.968750\t(data_i, data_q): (-0.656250,-0.062500)\n\t2815: o_phase = -9'd252;\t //LUT[2815] \tphase : -0.984375\t(data_i, data_q): (-0.656250,-0.031250)\n\t2816: o_phase = -9'd256;\t //LUT[2816] \tphase : -1.000000\t(data_i, data_q): (-0.625000,0.000000)\n\t2817: o_phase = +9'd252;\t //LUT[2817] \tphase : 0.984375\t(data_i, data_q): (-0.625000,0.031250)\n\t2818: o_phase = +9'd248;\t //LUT[2818] \tphase : 0.968750\t(data_i, data_q): (-0.625000,0.062500)\n\t2819: o_phase = +9'd244;\t //LUT[2819] \tphase : 0.953125\t(data_i, data_q): (-0.625000,0.093750)\n\t2820: o_phase = +9'd240;\t //LUT[2820] \tphase : 0.937500\t(data_i, data_q): (-0.625000,0.125000)\n\t2821: o_phase = +9'd236;\t //LUT[2821] \tphase : 0.921875\t(data_i, data_q): (-0.625000,0.156250)\n\t2822: o_phase = +9'd232;\t //LUT[2822] \tphase : 0.906250\t(data_i, data_q): (-0.625000,0.187500)\n\t2823: o_phase = +9'd229;\t //LUT[2823] \tphase : 0.894531\t(data_i, data_q): (-0.625000,0.218750)\n\t2824: o_phase = +9'd225;\t //LUT[2824] \tphase : 0.878906\t(data_i, data_q): (-0.625000,0.250000)\n\t2825: o_phase = +9'd222;\t //LUT[2825] \tphase : 0.867188\t(data_i, data_q): (-0.625000,0.281250)\n\t2826: o_phase = +9'd218;\t //LUT[2826] \tphase : 0.851562\t(data_i, data_q): (-0.625000,0.312500)\n\t2827: o_phase = +9'd215;\t //LUT[2827] \tphase : 0.839844\t(data_i, data_q): (-0.625000,0.343750)\n\t2828: o_phase = +9'd212;\t //LUT[2828] \tphase : 0.828125\t(data_i, data_q): (-0.625000,0.375000)\n\t2829: o_phase = +9'd209;\t //LUT[2829] \tphase : 0.816406\t(data_i, data_q): (-0.625000,0.406250)\n\t2830: o_phase = +9'd206;\t //LUT[2830] \tphase : 0.804688\t(data_i, data_q): (-0.625000,0.437500)\n\t2831: o_phase = +9'd204;\t //LUT[2831] \tphase : 0.796875\t(data_i, data_q): (-0.625000,0.468750)\n\t2832: o_phase = +9'd201;\t //LUT[2832] \tphase : 0.785156\t(data_i, data_q): (-0.625000,0.500000)\n\t2833: o_phase = +9'd199;\t //LUT[2833] \tphase : 0.777344\t(data_i, data_q): (-0.625000,0.531250)\n\t2834: o_phase = +9'd196;\t //LUT[2834] \tphase : 0.765625\t(data_i, data_q): (-0.625000,0.562500)\n\t2835: o_phase = +9'd194;\t //LUT[2835] \tphase : 0.757812\t(data_i, data_q): (-0.625000,0.593750)\n\t2836: o_phase = +9'd192;\t //LUT[2836] \tphase : 0.750000\t(data_i, data_q): (-0.625000,0.625000)\n\t2837: o_phase = +9'd190;\t //LUT[2837] \tphase : 0.742188\t(data_i, data_q): (-0.625000,0.656250)\n\t2838: o_phase = +9'd188;\t //LUT[2838] \tphase : 0.734375\t(data_i, data_q): (-0.625000,0.687500)\n\t2839: o_phase = +9'd186;\t //LUT[2839] \tphase : 0.726562\t(data_i, data_q): (-0.625000,0.718750)\n\t2840: o_phase = +9'd185;\t //LUT[2840] \tphase : 0.722656\t(data_i, data_q): (-0.625000,0.750000)\n\t2841: o_phase = +9'd183;\t //LUT[2841] \tphase : 0.714844\t(data_i, data_q): (-0.625000,0.781250)\n\t2842: o_phase = +9'd181;\t //LUT[2842] \tphase : 0.707031\t(data_i, data_q): (-0.625000,0.812500)\n\t2843: o_phase = +9'd180;\t //LUT[2843] \tphase : 0.703125\t(data_i, data_q): (-0.625000,0.843750)\n\t2844: o_phase = +9'd179;\t //LUT[2844] \tphase : 0.699219\t(data_i, data_q): (-0.625000,0.875000)\n\t2845: o_phase = +9'd177;\t //LUT[2845] \tphase : 0.691406\t(data_i, data_q): (-0.625000,0.906250)\n\t2846: o_phase = +9'd176;\t //LUT[2846] \tphase : 0.687500\t(data_i, data_q): (-0.625000,0.937500)\n\t2847: o_phase = +9'd175;\t //LUT[2847] \tphase : 0.683594\t(data_i, data_q): (-0.625000,0.968750)\n\t2848: o_phase = -9'd174;\t //LUT[2848] \tphase : -0.679688\t(data_i, data_q): (-0.625000,-1.000000)\n\t2849: o_phase = -9'd175;\t //LUT[2849] \tphase : -0.683594\t(data_i, data_q): (-0.625000,-0.968750)\n\t2850: o_phase = -9'd176;\t //LUT[2850] \tphase : -0.687500\t(data_i, data_q): (-0.625000,-0.937500)\n\t2851: o_phase = -9'd177;\t //LUT[2851] \tphase : -0.691406\t(data_i, data_q): (-0.625000,-0.906250)\n\t2852: o_phase = -9'd179;\t //LUT[2852] \tphase : -0.699219\t(data_i, data_q): (-0.625000,-0.875000)\n\t2853: o_phase = -9'd180;\t //LUT[2853] \tphase : -0.703125\t(data_i, data_q): (-0.625000,-0.843750)\n\t2854: o_phase = -9'd181;\t //LUT[2854] \tphase : -0.707031\t(data_i, data_q): (-0.625000,-0.812500)\n\t2855: o_phase = -9'd183;\t //LUT[2855] \tphase : -0.714844\t(data_i, data_q): (-0.625000,-0.781250)\n\t2856: o_phase = -9'd185;\t //LUT[2856] \tphase : -0.722656\t(data_i, data_q): (-0.625000,-0.750000)\n\t2857: o_phase = -9'd186;\t //LUT[2857] \tphase : -0.726562\t(data_i, data_q): (-0.625000,-0.718750)\n\t2858: o_phase = -9'd188;\t //LUT[2858] \tphase : -0.734375\t(data_i, data_q): (-0.625000,-0.687500)\n\t2859: o_phase = -9'd190;\t //LUT[2859] \tphase : -0.742188\t(data_i, data_q): (-0.625000,-0.656250)\n\t2860: o_phase = -9'd192;\t //LUT[2860] \tphase : -0.750000\t(data_i, data_q): (-0.625000,-0.625000)\n\t2861: o_phase = -9'd194;\t //LUT[2861] \tphase : -0.757812\t(data_i, data_q): (-0.625000,-0.593750)\n\t2862: o_phase = -9'd196;\t //LUT[2862] \tphase : -0.765625\t(data_i, data_q): (-0.625000,-0.562500)\n\t2863: o_phase = -9'd199;\t //LUT[2863] \tphase : -0.777344\t(data_i, data_q): (-0.625000,-0.531250)\n\t2864: o_phase = -9'd201;\t //LUT[2864] \tphase : -0.785156\t(data_i, data_q): (-0.625000,-0.500000)\n\t2865: o_phase = -9'd204;\t //LUT[2865] \tphase : -0.796875\t(data_i, data_q): (-0.625000,-0.468750)\n\t2866: o_phase = -9'd206;\t //LUT[2866] \tphase : -0.804688\t(data_i, data_q): (-0.625000,-0.437500)\n\t2867: o_phase = -9'd209;\t //LUT[2867] \tphase : -0.816406\t(data_i, data_q): (-0.625000,-0.406250)\n\t2868: o_phase = -9'd212;\t //LUT[2868] \tphase : -0.828125\t(data_i, data_q): (-0.625000,-0.375000)\n\t2869: o_phase = -9'd215;\t //LUT[2869] \tphase : -0.839844\t(data_i, data_q): (-0.625000,-0.343750)\n\t2870: o_phase = -9'd218;\t //LUT[2870] \tphase : -0.851562\t(data_i, data_q): (-0.625000,-0.312500)\n\t2871: o_phase = -9'd222;\t //LUT[2871] \tphase : -0.867188\t(data_i, data_q): (-0.625000,-0.281250)\n\t2872: o_phase = -9'd225;\t //LUT[2872] \tphase : -0.878906\t(data_i, data_q): (-0.625000,-0.250000)\n\t2873: o_phase = -9'd229;\t //LUT[2873] \tphase : -0.894531\t(data_i, data_q): (-0.625000,-0.218750)\n\t2874: o_phase = -9'd232;\t //LUT[2874] \tphase : -0.906250\t(data_i, data_q): (-0.625000,-0.187500)\n\t2875: o_phase = -9'd236;\t //LUT[2875] \tphase : -0.921875\t(data_i, data_q): (-0.625000,-0.156250)\n\t2876: o_phase = -9'd240;\t //LUT[2876] \tphase : -0.937500\t(data_i, data_q): (-0.625000,-0.125000)\n\t2877: o_phase = -9'd244;\t //LUT[2877] \tphase : -0.953125\t(data_i, data_q): (-0.625000,-0.093750)\n\t2878: o_phase = -9'd248;\t //LUT[2878] \tphase : -0.968750\t(data_i, data_q): (-0.625000,-0.062500)\n\t2879: o_phase = -9'd252;\t //LUT[2879] \tphase : -0.984375\t(data_i, data_q): (-0.625000,-0.031250)\n\t2880: o_phase = -9'd256;\t //LUT[2880] \tphase : -1.000000\t(data_i, data_q): (-0.593750,0.000000)\n\t2881: o_phase = +9'd252;\t //LUT[2881] \tphase : 0.984375\t(data_i, data_q): (-0.593750,0.031250)\n\t2882: o_phase = +9'd247;\t //LUT[2882] \tphase : 0.964844\t(data_i, data_q): (-0.593750,0.062500)\n\t2883: o_phase = +9'd243;\t //LUT[2883] \tphase : 0.949219\t(data_i, data_q): (-0.593750,0.093750)\n\t2884: o_phase = +9'd239;\t //LUT[2884] \tphase : 0.933594\t(data_i, data_q): (-0.593750,0.125000)\n\t2885: o_phase = +9'd235;\t //LUT[2885] \tphase : 0.917969\t(data_i, data_q): (-0.593750,0.156250)\n\t2886: o_phase = +9'd231;\t //LUT[2886] \tphase : 0.902344\t(data_i, data_q): (-0.593750,0.187500)\n\t2887: o_phase = +9'd227;\t //LUT[2887] \tphase : 0.886719\t(data_i, data_q): (-0.593750,0.218750)\n\t2888: o_phase = +9'd224;\t //LUT[2888] \tphase : 0.875000\t(data_i, data_q): (-0.593750,0.250000)\n\t2889: o_phase = +9'd220;\t //LUT[2889] \tphase : 0.859375\t(data_i, data_q): (-0.593750,0.281250)\n\t2890: o_phase = +9'd217;\t //LUT[2890] \tphase : 0.847656\t(data_i, data_q): (-0.593750,0.312500)\n\t2891: o_phase = +9'd213;\t //LUT[2891] \tphase : 0.832031\t(data_i, data_q): (-0.593750,0.343750)\n\t2892: o_phase = +9'd210;\t //LUT[2892] \tphase : 0.820312\t(data_i, data_q): (-0.593750,0.375000)\n\t2893: o_phase = +9'd207;\t //LUT[2893] \tphase : 0.808594\t(data_i, data_q): (-0.593750,0.406250)\n\t2894: o_phase = +9'd204;\t //LUT[2894] \tphase : 0.796875\t(data_i, data_q): (-0.593750,0.437500)\n\t2895: o_phase = +9'd202;\t //LUT[2895] \tphase : 0.789062\t(data_i, data_q): (-0.593750,0.468750)\n\t2896: o_phase = +9'd199;\t //LUT[2896] \tphase : 0.777344\t(data_i, data_q): (-0.593750,0.500000)\n\t2897: o_phase = +9'd197;\t //LUT[2897] \tphase : 0.769531\t(data_i, data_q): (-0.593750,0.531250)\n\t2898: o_phase = +9'd194;\t //LUT[2898] \tphase : 0.757812\t(data_i, data_q): (-0.593750,0.562500)\n\t2899: o_phase = +9'd192;\t //LUT[2899] \tphase : 0.750000\t(data_i, data_q): (-0.593750,0.593750)\n\t2900: o_phase = +9'd190;\t //LUT[2900] \tphase : 0.742188\t(data_i, data_q): (-0.593750,0.625000)\n\t2901: o_phase = +9'd188;\t //LUT[2901] \tphase : 0.734375\t(data_i, data_q): (-0.593750,0.656250)\n\t2902: o_phase = +9'd186;\t //LUT[2902] \tphase : 0.726562\t(data_i, data_q): (-0.593750,0.687500)\n\t2903: o_phase = +9'd184;\t //LUT[2903] \tphase : 0.718750\t(data_i, data_q): (-0.593750,0.718750)\n\t2904: o_phase = +9'd183;\t //LUT[2904] \tphase : 0.714844\t(data_i, data_q): (-0.593750,0.750000)\n\t2905: o_phase = +9'd181;\t //LUT[2905] \tphase : 0.707031\t(data_i, data_q): (-0.593750,0.781250)\n\t2906: o_phase = +9'd179;\t //LUT[2906] \tphase : 0.699219\t(data_i, data_q): (-0.593750,0.812500)\n\t2907: o_phase = +9'd178;\t //LUT[2907] \tphase : 0.695312\t(data_i, data_q): (-0.593750,0.843750)\n\t2908: o_phase = +9'd177;\t //LUT[2908] \tphase : 0.691406\t(data_i, data_q): (-0.593750,0.875000)\n\t2909: o_phase = +9'd175;\t //LUT[2909] \tphase : 0.683594\t(data_i, data_q): (-0.593750,0.906250)\n\t2910: o_phase = +9'd174;\t //LUT[2910] \tphase : 0.679688\t(data_i, data_q): (-0.593750,0.937500)\n\t2911: o_phase = +9'd173;\t //LUT[2911] \tphase : 0.675781\t(data_i, data_q): (-0.593750,0.968750)\n\t2912: o_phase = -9'd172;\t //LUT[2912] \tphase : -0.671875\t(data_i, data_q): (-0.593750,-1.000000)\n\t2913: o_phase = -9'd173;\t //LUT[2913] \tphase : -0.675781\t(data_i, data_q): (-0.593750,-0.968750)\n\t2914: o_phase = -9'd174;\t //LUT[2914] \tphase : -0.679688\t(data_i, data_q): (-0.593750,-0.937500)\n\t2915: o_phase = -9'd175;\t //LUT[2915] \tphase : -0.683594\t(data_i, data_q): (-0.593750,-0.906250)\n\t2916: o_phase = -9'd177;\t //LUT[2916] \tphase : -0.691406\t(data_i, data_q): (-0.593750,-0.875000)\n\t2917: o_phase = -9'd178;\t //LUT[2917] \tphase : -0.695312\t(data_i, data_q): (-0.593750,-0.843750)\n\t2918: o_phase = -9'd179;\t //LUT[2918] \tphase : -0.699219\t(data_i, data_q): (-0.593750,-0.812500)\n\t2919: o_phase = -9'd181;\t //LUT[2919] \tphase : -0.707031\t(data_i, data_q): (-0.593750,-0.781250)\n\t2920: o_phase = -9'd183;\t //LUT[2920] \tphase : -0.714844\t(data_i, data_q): (-0.593750,-0.750000)\n\t2921: o_phase = -9'd184;\t //LUT[2921] \tphase : -0.718750\t(data_i, data_q): (-0.593750,-0.718750)\n\t2922: o_phase = -9'd186;\t //LUT[2922] \tphase : -0.726562\t(data_i, data_q): (-0.593750,-0.687500)\n\t2923: o_phase = -9'd188;\t //LUT[2923] \tphase : -0.734375\t(data_i, data_q): (-0.593750,-0.656250)\n\t2924: o_phase = -9'd190;\t //LUT[2924] \tphase : -0.742188\t(data_i, data_q): (-0.593750,-0.625000)\n\t2925: o_phase = -9'd192;\t //LUT[2925] \tphase : -0.750000\t(data_i, data_q): (-0.593750,-0.593750)\n\t2926: o_phase = -9'd194;\t //LUT[2926] \tphase : -0.757812\t(data_i, data_q): (-0.593750,-0.562500)\n\t2927: o_phase = -9'd197;\t //LUT[2927] \tphase : -0.769531\t(data_i, data_q): (-0.593750,-0.531250)\n\t2928: o_phase = -9'd199;\t //LUT[2928] \tphase : -0.777344\t(data_i, data_q): (-0.593750,-0.500000)\n\t2929: o_phase = -9'd202;\t //LUT[2929] \tphase : -0.789062\t(data_i, data_q): (-0.593750,-0.468750)\n\t2930: o_phase = -9'd204;\t //LUT[2930] \tphase : -0.796875\t(data_i, data_q): (-0.593750,-0.437500)\n\t2931: o_phase = -9'd207;\t //LUT[2931] \tphase : -0.808594\t(data_i, data_q): (-0.593750,-0.406250)\n\t2932: o_phase = -9'd210;\t //LUT[2932] \tphase : -0.820312\t(data_i, data_q): (-0.593750,-0.375000)\n\t2933: o_phase = -9'd213;\t //LUT[2933] \tphase : -0.832031\t(data_i, data_q): (-0.593750,-0.343750)\n\t2934: o_phase = -9'd217;\t //LUT[2934] \tphase : -0.847656\t(data_i, data_q): (-0.593750,-0.312500)\n\t2935: o_phase = -9'd220;\t //LUT[2935] \tphase : -0.859375\t(data_i, data_q): (-0.593750,-0.281250)\n\t2936: o_phase = -9'd224;\t //LUT[2936] \tphase : -0.875000\t(data_i, data_q): (-0.593750,-0.250000)\n\t2937: o_phase = -9'd227;\t //LUT[2937] \tphase : -0.886719\t(data_i, data_q): (-0.593750,-0.218750)\n\t2938: o_phase = -9'd231;\t //LUT[2938] \tphase : -0.902344\t(data_i, data_q): (-0.593750,-0.187500)\n\t2939: o_phase = -9'd235;\t //LUT[2939] \tphase : -0.917969\t(data_i, data_q): (-0.593750,-0.156250)\n\t2940: o_phase = -9'd239;\t //LUT[2940] \tphase : -0.933594\t(data_i, data_q): (-0.593750,-0.125000)\n\t2941: o_phase = -9'd243;\t //LUT[2941] \tphase : -0.949219\t(data_i, data_q): (-0.593750,-0.093750)\n\t2942: o_phase = -9'd247;\t //LUT[2942] \tphase : -0.964844\t(data_i, data_q): (-0.593750,-0.062500)\n\t2943: o_phase = -9'd252;\t //LUT[2943] \tphase : -0.984375\t(data_i, data_q): (-0.593750,-0.031250)\n\t2944: o_phase = -9'd256;\t //LUT[2944] \tphase : -1.000000\t(data_i, data_q): (-0.562500,0.000000)\n\t2945: o_phase = +9'd251;\t //LUT[2945] \tphase : 0.980469\t(data_i, data_q): (-0.562500,0.031250)\n\t2946: o_phase = +9'd247;\t //LUT[2946] \tphase : 0.964844\t(data_i, data_q): (-0.562500,0.062500)\n\t2947: o_phase = +9'd243;\t //LUT[2947] \tphase : 0.949219\t(data_i, data_q): (-0.562500,0.093750)\n\t2948: o_phase = +9'd238;\t //LUT[2948] \tphase : 0.929688\t(data_i, data_q): (-0.562500,0.125000)\n\t2949: o_phase = +9'd234;\t //LUT[2949] \tphase : 0.914062\t(data_i, data_q): (-0.562500,0.156250)\n\t2950: o_phase = +9'd230;\t //LUT[2950] \tphase : 0.898438\t(data_i, data_q): (-0.562500,0.187500)\n\t2951: o_phase = +9'd226;\t //LUT[2951] \tphase : 0.882812\t(data_i, data_q): (-0.562500,0.218750)\n\t2952: o_phase = +9'd222;\t //LUT[2952] \tphase : 0.867188\t(data_i, data_q): (-0.562500,0.250000)\n\t2953: o_phase = +9'd218;\t //LUT[2953] \tphase : 0.851562\t(data_i, data_q): (-0.562500,0.281250)\n\t2954: o_phase = +9'd215;\t //LUT[2954] \tphase : 0.839844\t(data_i, data_q): (-0.562500,0.312500)\n\t2955: o_phase = +9'd211;\t //LUT[2955] \tphase : 0.824219\t(data_i, data_q): (-0.562500,0.343750)\n\t2956: o_phase = +9'd208;\t //LUT[2956] \tphase : 0.812500\t(data_i, data_q): (-0.562500,0.375000)\n\t2957: o_phase = +9'd205;\t //LUT[2957] \tphase : 0.800781\t(data_i, data_q): (-0.562500,0.406250)\n\t2958: o_phase = +9'd202;\t //LUT[2958] \tphase : 0.789062\t(data_i, data_q): (-0.562500,0.437500)\n\t2959: o_phase = +9'd199;\t //LUT[2959] \tphase : 0.777344\t(data_i, data_q): (-0.562500,0.468750)\n\t2960: o_phase = +9'd197;\t //LUT[2960] \tphase : 0.769531\t(data_i, data_q): (-0.562500,0.500000)\n\t2961: o_phase = +9'd194;\t //LUT[2961] \tphase : 0.757812\t(data_i, data_q): (-0.562500,0.531250)\n\t2962: o_phase = +9'd192;\t //LUT[2962] \tphase : 0.750000\t(data_i, data_q): (-0.562500,0.562500)\n\t2963: o_phase = +9'd190;\t //LUT[2963] \tphase : 0.742188\t(data_i, data_q): (-0.562500,0.593750)\n\t2964: o_phase = +9'd188;\t //LUT[2964] \tphase : 0.734375\t(data_i, data_q): (-0.562500,0.625000)\n\t2965: o_phase = +9'd186;\t //LUT[2965] \tphase : 0.726562\t(data_i, data_q): (-0.562500,0.656250)\n\t2966: o_phase = +9'd184;\t //LUT[2966] \tphase : 0.718750\t(data_i, data_q): (-0.562500,0.687500)\n\t2967: o_phase = +9'd182;\t //LUT[2967] \tphase : 0.710938\t(data_i, data_q): (-0.562500,0.718750)\n\t2968: o_phase = +9'd180;\t //LUT[2968] \tphase : 0.703125\t(data_i, data_q): (-0.562500,0.750000)\n\t2969: o_phase = +9'd179;\t //LUT[2969] \tphase : 0.699219\t(data_i, data_q): (-0.562500,0.781250)\n\t2970: o_phase = +9'd177;\t //LUT[2970] \tphase : 0.691406\t(data_i, data_q): (-0.562500,0.812500)\n\t2971: o_phase = +9'd176;\t //LUT[2971] \tphase : 0.687500\t(data_i, data_q): (-0.562500,0.843750)\n\t2972: o_phase = +9'd175;\t //LUT[2972] \tphase : 0.683594\t(data_i, data_q): (-0.562500,0.875000)\n\t2973: o_phase = +9'd173;\t //LUT[2973] \tphase : 0.675781\t(data_i, data_q): (-0.562500,0.906250)\n\t2974: o_phase = +9'd172;\t //LUT[2974] \tphase : 0.671875\t(data_i, data_q): (-0.562500,0.937500)\n\t2975: o_phase = +9'd171;\t //LUT[2975] \tphase : 0.667969\t(data_i, data_q): (-0.562500,0.968750)\n\t2976: o_phase = -9'd170;\t //LUT[2976] \tphase : -0.664062\t(data_i, data_q): (-0.562500,-1.000000)\n\t2977: o_phase = -9'd171;\t //LUT[2977] \tphase : -0.667969\t(data_i, data_q): (-0.562500,-0.968750)\n\t2978: o_phase = -9'd172;\t //LUT[2978] \tphase : -0.671875\t(data_i, data_q): (-0.562500,-0.937500)\n\t2979: o_phase = -9'd173;\t //LUT[2979] \tphase : -0.675781\t(data_i, data_q): (-0.562500,-0.906250)\n\t2980: o_phase = -9'd175;\t //LUT[2980] \tphase : -0.683594\t(data_i, data_q): (-0.562500,-0.875000)\n\t2981: o_phase = -9'd176;\t //LUT[2981] \tphase : -0.687500\t(data_i, data_q): (-0.562500,-0.843750)\n\t2982: o_phase = -9'd177;\t //LUT[2982] \tphase : -0.691406\t(data_i, data_q): (-0.562500,-0.812500)\n\t2983: o_phase = -9'd179;\t //LUT[2983] \tphase : -0.699219\t(data_i, data_q): (-0.562500,-0.781250)\n\t2984: o_phase = -9'd180;\t //LUT[2984] \tphase : -0.703125\t(data_i, data_q): (-0.562500,-0.750000)\n\t2985: o_phase = -9'd182;\t //LUT[2985] \tphase : -0.710938\t(data_i, data_q): (-0.562500,-0.718750)\n\t2986: o_phase = -9'd184;\t //LUT[2986] \tphase : -0.718750\t(data_i, data_q): (-0.562500,-0.687500)\n\t2987: o_phase = -9'd186;\t //LUT[2987] \tphase : -0.726562\t(data_i, data_q): (-0.562500,-0.656250)\n\t2988: o_phase = -9'd188;\t //LUT[2988] \tphase : -0.734375\t(data_i, data_q): (-0.562500,-0.625000)\n\t2989: o_phase = -9'd190;\t //LUT[2989] \tphase : -0.742188\t(data_i, data_q): (-0.562500,-0.593750)\n\t2990: o_phase = -9'd192;\t //LUT[2990] \tphase : -0.750000\t(data_i, data_q): (-0.562500,-0.562500)\n\t2991: o_phase = -9'd194;\t //LUT[2991] \tphase : -0.757812\t(data_i, data_q): (-0.562500,-0.531250)\n\t2992: o_phase = -9'd197;\t //LUT[2992] \tphase : -0.769531\t(data_i, data_q): (-0.562500,-0.500000)\n\t2993: o_phase = -9'd199;\t //LUT[2993] \tphase : -0.777344\t(data_i, data_q): (-0.562500,-0.468750)\n\t2994: o_phase = -9'd202;\t //LUT[2994] \tphase : -0.789062\t(data_i, data_q): (-0.562500,-0.437500)\n\t2995: o_phase = -9'd205;\t //LUT[2995] \tphase : -0.800781\t(data_i, data_q): (-0.562500,-0.406250)\n\t2996: o_phase = -9'd208;\t //LUT[2996] \tphase : -0.812500\t(data_i, data_q): (-0.562500,-0.375000)\n\t2997: o_phase = -9'd211;\t //LUT[2997] \tphase : -0.824219\t(data_i, data_q): (-0.562500,-0.343750)\n\t2998: o_phase = -9'd215;\t //LUT[2998] \tphase : -0.839844\t(data_i, data_q): (-0.562500,-0.312500)\n\t2999: o_phase = -9'd218;\t //LUT[2999] \tphase : -0.851562\t(data_i, data_q): (-0.562500,-0.281250)\n\t3000: o_phase = -9'd222;\t //LUT[3000] \tphase : -0.867188\t(data_i, data_q): (-0.562500,-0.250000)\n\t3001: o_phase = -9'd226;\t //LUT[3001] \tphase : -0.882812\t(data_i, data_q): (-0.562500,-0.218750)\n\t3002: o_phase = -9'd230;\t //LUT[3002] \tphase : -0.898438\t(data_i, data_q): (-0.562500,-0.187500)\n\t3003: o_phase = -9'd234;\t //LUT[3003] \tphase : -0.914062\t(data_i, data_q): (-0.562500,-0.156250)\n\t3004: o_phase = -9'd238;\t //LUT[3004] \tphase : -0.929688\t(data_i, data_q): (-0.562500,-0.125000)\n\t3005: o_phase = -9'd243;\t //LUT[3005] \tphase : -0.949219\t(data_i, data_q): (-0.562500,-0.093750)\n\t3006: o_phase = -9'd247;\t //LUT[3006] \tphase : -0.964844\t(data_i, data_q): (-0.562500,-0.062500)\n\t3007: o_phase = -9'd251;\t //LUT[3007] \tphase : -0.980469\t(data_i, data_q): (-0.562500,-0.031250)\n\t3008: o_phase = -9'd256;\t //LUT[3008] \tphase : -1.000000\t(data_i, data_q): (-0.531250,0.000000)\n\t3009: o_phase = +9'd251;\t //LUT[3009] \tphase : 0.980469\t(data_i, data_q): (-0.531250,0.031250)\n\t3010: o_phase = +9'd246;\t //LUT[3010] \tphase : 0.960938\t(data_i, data_q): (-0.531250,0.062500)\n\t3011: o_phase = +9'd242;\t //LUT[3011] \tphase : 0.945312\t(data_i, data_q): (-0.531250,0.093750)\n\t3012: o_phase = +9'd237;\t //LUT[3012] \tphase : 0.925781\t(data_i, data_q): (-0.531250,0.125000)\n\t3013: o_phase = +9'd233;\t //LUT[3013] \tphase : 0.910156\t(data_i, data_q): (-0.531250,0.156250)\n\t3014: o_phase = +9'd228;\t //LUT[3014] \tphase : 0.890625\t(data_i, data_q): (-0.531250,0.187500)\n\t3015: o_phase = +9'd224;\t //LUT[3015] \tphase : 0.875000\t(data_i, data_q): (-0.531250,0.218750)\n\t3016: o_phase = +9'd220;\t //LUT[3016] \tphase : 0.859375\t(data_i, data_q): (-0.531250,0.250000)\n\t3017: o_phase = +9'd216;\t //LUT[3017] \tphase : 0.843750\t(data_i, data_q): (-0.531250,0.281250)\n\t3018: o_phase = +9'd213;\t //LUT[3018] \tphase : 0.832031\t(data_i, data_q): (-0.531250,0.312500)\n\t3019: o_phase = +9'd209;\t //LUT[3019] \tphase : 0.816406\t(data_i, data_q): (-0.531250,0.343750)\n\t3020: o_phase = +9'd206;\t //LUT[3020] \tphase : 0.804688\t(data_i, data_q): (-0.531250,0.375000)\n\t3021: o_phase = +9'd203;\t //LUT[3021] \tphase : 0.792969\t(data_i, data_q): (-0.531250,0.406250)\n\t3022: o_phase = +9'd200;\t //LUT[3022] \tphase : 0.781250\t(data_i, data_q): (-0.531250,0.437500)\n\t3023: o_phase = +9'd197;\t //LUT[3023] \tphase : 0.769531\t(data_i, data_q): (-0.531250,0.468750)\n\t3024: o_phase = +9'd194;\t //LUT[3024] \tphase : 0.757812\t(data_i, data_q): (-0.531250,0.500000)\n\t3025: o_phase = +9'd192;\t //LUT[3025] \tphase : 0.750000\t(data_i, data_q): (-0.531250,0.531250)\n\t3026: o_phase = +9'd190;\t //LUT[3026] \tphase : 0.742188\t(data_i, data_q): (-0.531250,0.562500)\n\t3027: o_phase = +9'd187;\t //LUT[3027] \tphase : 0.730469\t(data_i, data_q): (-0.531250,0.593750)\n\t3028: o_phase = +9'd185;\t //LUT[3028] \tphase : 0.722656\t(data_i, data_q): (-0.531250,0.625000)\n\t3029: o_phase = +9'd183;\t //LUT[3029] \tphase : 0.714844\t(data_i, data_q): (-0.531250,0.656250)\n\t3030: o_phase = +9'd182;\t //LUT[3030] \tphase : 0.710938\t(data_i, data_q): (-0.531250,0.687500)\n\t3031: o_phase = +9'd180;\t //LUT[3031] \tphase : 0.703125\t(data_i, data_q): (-0.531250,0.718750)\n\t3032: o_phase = +9'd178;\t //LUT[3032] \tphase : 0.695312\t(data_i, data_q): (-0.531250,0.750000)\n\t3033: o_phase = +9'd177;\t //LUT[3033] \tphase : 0.691406\t(data_i, data_q): (-0.531250,0.781250)\n\t3034: o_phase = +9'd175;\t //LUT[3034] \tphase : 0.683594\t(data_i, data_q): (-0.531250,0.812500)\n\t3035: o_phase = +9'd174;\t //LUT[3035] \tphase : 0.679688\t(data_i, data_q): (-0.531250,0.843750)\n\t3036: o_phase = +9'd172;\t //LUT[3036] \tphase : 0.671875\t(data_i, data_q): (-0.531250,0.875000)\n\t3037: o_phase = +9'd171;\t //LUT[3037] \tphase : 0.667969\t(data_i, data_q): (-0.531250,0.906250)\n\t3038: o_phase = +9'd170;\t //LUT[3038] \tphase : 0.664062\t(data_i, data_q): (-0.531250,0.937500)\n\t3039: o_phase = +9'd169;\t //LUT[3039] \tphase : 0.660156\t(data_i, data_q): (-0.531250,0.968750)\n\t3040: o_phase = -9'd168;\t //LUT[3040] \tphase : -0.656250\t(data_i, data_q): (-0.531250,-1.000000)\n\t3041: o_phase = -9'd169;\t //LUT[3041] \tphase : -0.660156\t(data_i, data_q): (-0.531250,-0.968750)\n\t3042: o_phase = -9'd170;\t //LUT[3042] \tphase : -0.664062\t(data_i, data_q): (-0.531250,-0.937500)\n\t3043: o_phase = -9'd171;\t //LUT[3043] \tphase : -0.667969\t(data_i, data_q): (-0.531250,-0.906250)\n\t3044: o_phase = -9'd172;\t //LUT[3044] \tphase : -0.671875\t(data_i, data_q): (-0.531250,-0.875000)\n\t3045: o_phase = -9'd174;\t //LUT[3045] \tphase : -0.679688\t(data_i, data_q): (-0.531250,-0.843750)\n\t3046: o_phase = -9'd175;\t //LUT[3046] \tphase : -0.683594\t(data_i, data_q): (-0.531250,-0.812500)\n\t3047: o_phase = -9'd177;\t //LUT[3047] \tphase : -0.691406\t(data_i, data_q): (-0.531250,-0.781250)\n\t3048: o_phase = -9'd178;\t //LUT[3048] \tphase : -0.695312\t(data_i, data_q): (-0.531250,-0.750000)\n\t3049: o_phase = -9'd180;\t //LUT[3049] \tphase : -0.703125\t(data_i, data_q): (-0.531250,-0.718750)\n\t3050: o_phase = -9'd182;\t //LUT[3050] \tphase : -0.710938\t(data_i, data_q): (-0.531250,-0.687500)\n\t3051: o_phase = -9'd183;\t //LUT[3051] \tphase : -0.714844\t(data_i, data_q): (-0.531250,-0.656250)\n\t3052: o_phase = -9'd185;\t //LUT[3052] \tphase : -0.722656\t(data_i, data_q): (-0.531250,-0.625000)\n\t3053: o_phase = -9'd187;\t //LUT[3053] \tphase : -0.730469\t(data_i, data_q): (-0.531250,-0.593750)\n\t3054: o_phase = -9'd190;\t //LUT[3054] \tphase : -0.742188\t(data_i, data_q): (-0.531250,-0.562500)\n\t3055: o_phase = -9'd192;\t //LUT[3055] \tphase : -0.750000\t(data_i, data_q): (-0.531250,-0.531250)\n\t3056: o_phase = -9'd194;\t //LUT[3056] \tphase : -0.757812\t(data_i, data_q): (-0.531250,-0.500000)\n\t3057: o_phase = -9'd197;\t //LUT[3057] \tphase : -0.769531\t(data_i, data_q): (-0.531250,-0.468750)\n\t3058: o_phase = -9'd200;\t //LUT[3058] \tphase : -0.781250\t(data_i, data_q): (-0.531250,-0.437500)\n\t3059: o_phase = -9'd203;\t //LUT[3059] \tphase : -0.792969\t(data_i, data_q): (-0.531250,-0.406250)\n\t3060: o_phase = -9'd206;\t //LUT[3060] \tphase : -0.804688\t(data_i, data_q): (-0.531250,-0.375000)\n\t3061: o_phase = -9'd209;\t //LUT[3061] \tphase : -0.816406\t(data_i, data_q): (-0.531250,-0.343750)\n\t3062: o_phase = -9'd213;\t //LUT[3062] \tphase : -0.832031\t(data_i, data_q): (-0.531250,-0.312500)\n\t3063: o_phase = -9'd216;\t //LUT[3063] \tphase : -0.843750\t(data_i, data_q): (-0.531250,-0.281250)\n\t3064: o_phase = -9'd220;\t //LUT[3064] \tphase : -0.859375\t(data_i, data_q): (-0.531250,-0.250000)\n\t3065: o_phase = -9'd224;\t //LUT[3065] \tphase : -0.875000\t(data_i, data_q): (-0.531250,-0.218750)\n\t3066: o_phase = -9'd228;\t //LUT[3066] \tphase : -0.890625\t(data_i, data_q): (-0.531250,-0.187500)\n\t3067: o_phase = -9'd233;\t //LUT[3067] \tphase : -0.910156\t(data_i, data_q): (-0.531250,-0.156250)\n\t3068: o_phase = -9'd237;\t //LUT[3068] \tphase : -0.925781\t(data_i, data_q): (-0.531250,-0.125000)\n\t3069: o_phase = -9'd242;\t //LUT[3069] \tphase : -0.945312\t(data_i, data_q): (-0.531250,-0.093750)\n\t3070: o_phase = -9'd246;\t //LUT[3070] \tphase : -0.960938\t(data_i, data_q): (-0.531250,-0.062500)\n\t3071: o_phase = -9'd251;\t //LUT[3071] \tphase : -0.980469\t(data_i, data_q): (-0.531250,-0.031250)\n\t3072: o_phase = -9'd256;\t //LUT[3072] \tphase : -1.000000\t(data_i, data_q): (-0.500000,0.000000)\n\t3073: o_phase = +9'd251;\t //LUT[3073] \tphase : 0.980469\t(data_i, data_q): (-0.500000,0.031250)\n\t3074: o_phase = +9'd246;\t //LUT[3074] \tphase : 0.960938\t(data_i, data_q): (-0.500000,0.062500)\n\t3075: o_phase = +9'd241;\t //LUT[3075] \tphase : 0.941406\t(data_i, data_q): (-0.500000,0.093750)\n\t3076: o_phase = +9'd236;\t //LUT[3076] \tphase : 0.921875\t(data_i, data_q): (-0.500000,0.125000)\n\t3077: o_phase = +9'd231;\t //LUT[3077] \tphase : 0.902344\t(data_i, data_q): (-0.500000,0.156250)\n\t3078: o_phase = +9'd227;\t //LUT[3078] \tphase : 0.886719\t(data_i, data_q): (-0.500000,0.187500)\n\t3079: o_phase = +9'd222;\t //LUT[3079] \tphase : 0.867188\t(data_i, data_q): (-0.500000,0.218750)\n\t3080: o_phase = +9'd218;\t //LUT[3080] \tphase : 0.851562\t(data_i, data_q): (-0.500000,0.250000)\n\t3081: o_phase = +9'd214;\t //LUT[3081] \tphase : 0.835938\t(data_i, data_q): (-0.500000,0.281250)\n\t3082: o_phase = +9'd210;\t //LUT[3082] \tphase : 0.820312\t(data_i, data_q): (-0.500000,0.312500)\n\t3083: o_phase = +9'd207;\t //LUT[3083] \tphase : 0.808594\t(data_i, data_q): (-0.500000,0.343750)\n\t3084: o_phase = +9'd204;\t //LUT[3084] \tphase : 0.796875\t(data_i, data_q): (-0.500000,0.375000)\n\t3085: o_phase = +9'd200;\t //LUT[3085] \tphase : 0.781250\t(data_i, data_q): (-0.500000,0.406250)\n\t3086: o_phase = +9'd197;\t //LUT[3086] \tphase : 0.769531\t(data_i, data_q): (-0.500000,0.437500)\n\t3087: o_phase = +9'd195;\t //LUT[3087] \tphase : 0.761719\t(data_i, data_q): (-0.500000,0.468750)\n\t3088: o_phase = +9'd192;\t //LUT[3088] \tphase : 0.750000\t(data_i, data_q): (-0.500000,0.500000)\n\t3089: o_phase = +9'd190;\t //LUT[3089] \tphase : 0.742188\t(data_i, data_q): (-0.500000,0.531250)\n\t3090: o_phase = +9'd187;\t //LUT[3090] \tphase : 0.730469\t(data_i, data_q): (-0.500000,0.562500)\n\t3091: o_phase = +9'd185;\t //LUT[3091] \tphase : 0.722656\t(data_i, data_q): (-0.500000,0.593750)\n\t3092: o_phase = +9'd183;\t //LUT[3092] \tphase : 0.714844\t(data_i, data_q): (-0.500000,0.625000)\n\t3093: o_phase = +9'd181;\t //LUT[3093] \tphase : 0.707031\t(data_i, data_q): (-0.500000,0.656250)\n\t3094: o_phase = +9'd179;\t //LUT[3094] \tphase : 0.699219\t(data_i, data_q): (-0.500000,0.687500)\n\t3095: o_phase = +9'd178;\t //LUT[3095] \tphase : 0.695312\t(data_i, data_q): (-0.500000,0.718750)\n\t3096: o_phase = +9'd176;\t //LUT[3096] \tphase : 0.687500\t(data_i, data_q): (-0.500000,0.750000)\n\t3097: o_phase = +9'd174;\t //LUT[3097] \tphase : 0.679688\t(data_i, data_q): (-0.500000,0.781250)\n\t3098: o_phase = +9'd173;\t //LUT[3098] \tphase : 0.675781\t(data_i, data_q): (-0.500000,0.812500)\n\t3099: o_phase = +9'd172;\t //LUT[3099] \tphase : 0.671875\t(data_i, data_q): (-0.500000,0.843750)\n\t3100: o_phase = +9'd170;\t //LUT[3100] \tphase : 0.664062\t(data_i, data_q): (-0.500000,0.875000)\n\t3101: o_phase = +9'd169;\t //LUT[3101] \tphase : 0.660156\t(data_i, data_q): (-0.500000,0.906250)\n\t3102: o_phase = +9'd168;\t //LUT[3102] \tphase : 0.656250\t(data_i, data_q): (-0.500000,0.937500)\n\t3103: o_phase = +9'd167;\t //LUT[3103] \tphase : 0.652344\t(data_i, data_q): (-0.500000,0.968750)\n\t3104: o_phase = -9'd166;\t //LUT[3104] \tphase : -0.648438\t(data_i, data_q): (-0.500000,-1.000000)\n\t3105: o_phase = -9'd167;\t //LUT[3105] \tphase : -0.652344\t(data_i, data_q): (-0.500000,-0.968750)\n\t3106: o_phase = -9'd168;\t //LUT[3106] \tphase : -0.656250\t(data_i, data_q): (-0.500000,-0.937500)\n\t3107: o_phase = -9'd169;\t //LUT[3107] \tphase : -0.660156\t(data_i, data_q): (-0.500000,-0.906250)\n\t3108: o_phase = -9'd170;\t //LUT[3108] \tphase : -0.664062\t(data_i, data_q): (-0.500000,-0.875000)\n\t3109: o_phase = -9'd172;\t //LUT[3109] \tphase : -0.671875\t(data_i, data_q): (-0.500000,-0.843750)\n\t3110: o_phase = -9'd173;\t //LUT[3110] \tphase : -0.675781\t(data_i, data_q): (-0.500000,-0.812500)\n\t3111: o_phase = -9'd174;\t //LUT[3111] \tphase : -0.679688\t(data_i, data_q): (-0.500000,-0.781250)\n\t3112: o_phase = -9'd176;\t //LUT[3112] \tphase : -0.687500\t(data_i, data_q): (-0.500000,-0.750000)\n\t3113: o_phase = -9'd178;\t //LUT[3113] \tphase : -0.695312\t(data_i, data_q): (-0.500000,-0.718750)\n\t3114: o_phase = -9'd179;\t //LUT[3114] \tphase : -0.699219\t(data_i, data_q): (-0.500000,-0.687500)\n\t3115: o_phase = -9'd181;\t //LUT[3115] \tphase : -0.707031\t(data_i, data_q): (-0.500000,-0.656250)\n\t3116: o_phase = -9'd183;\t //LUT[3116] \tphase : -0.714844\t(data_i, data_q): (-0.500000,-0.625000)\n\t3117: o_phase = -9'd185;\t //LUT[3117] \tphase : -0.722656\t(data_i, data_q): (-0.500000,-0.593750)\n\t3118: o_phase = -9'd187;\t //LUT[3118] \tphase : -0.730469\t(data_i, data_q): (-0.500000,-0.562500)\n\t3119: o_phase = -9'd190;\t //LUT[3119] \tphase : -0.742188\t(data_i, data_q): (-0.500000,-0.531250)\n\t3120: o_phase = -9'd192;\t //LUT[3120] \tphase : -0.750000\t(data_i, data_q): (-0.500000,-0.500000)\n\t3121: o_phase = -9'd195;\t //LUT[3121] \tphase : -0.761719\t(data_i, data_q): (-0.500000,-0.468750)\n\t3122: o_phase = -9'd197;\t //LUT[3122] \tphase : -0.769531\t(data_i, data_q): (-0.500000,-0.437500)\n\t3123: o_phase = -9'd200;\t //LUT[3123] \tphase : -0.781250\t(data_i, data_q): (-0.500000,-0.406250)\n\t3124: o_phase = -9'd204;\t //LUT[3124] \tphase : -0.796875\t(data_i, data_q): (-0.500000,-0.375000)\n\t3125: o_phase = -9'd207;\t //LUT[3125] \tphase : -0.808594\t(data_i, data_q): (-0.500000,-0.343750)\n\t3126: o_phase = -9'd210;\t //LUT[3126] \tphase : -0.820312\t(data_i, data_q): (-0.500000,-0.312500)\n\t3127: o_phase = -9'd214;\t //LUT[3127] \tphase : -0.835938\t(data_i, data_q): (-0.500000,-0.281250)\n\t3128: o_phase = -9'd218;\t //LUT[3128] \tphase : -0.851562\t(data_i, data_q): (-0.500000,-0.250000)\n\t3129: o_phase = -9'd222;\t //LUT[3129] \tphase : -0.867188\t(data_i, data_q): (-0.500000,-0.218750)\n\t3130: o_phase = -9'd227;\t //LUT[3130] \tphase : -0.886719\t(data_i, data_q): (-0.500000,-0.187500)\n\t3131: o_phase = -9'd231;\t //LUT[3131] \tphase : -0.902344\t(data_i, data_q): (-0.500000,-0.156250)\n\t3132: o_phase = -9'd236;\t //LUT[3132] \tphase : -0.921875\t(data_i, data_q): (-0.500000,-0.125000)\n\t3133: o_phase = -9'd241;\t //LUT[3133] \tphase : -0.941406\t(data_i, data_q): (-0.500000,-0.093750)\n\t3134: o_phase = -9'd246;\t //LUT[3134] \tphase : -0.960938\t(data_i, data_q): (-0.500000,-0.062500)\n\t3135: o_phase = -9'd251;\t //LUT[3135] \tphase : -0.980469\t(data_i, data_q): (-0.500000,-0.031250)\n\t3136: o_phase = -9'd256;\t //LUT[3136] \tphase : -1.000000\t(data_i, data_q): (-0.468750,0.000000)\n\t3137: o_phase = +9'd251;\t //LUT[3137] \tphase : 0.980469\t(data_i, data_q): (-0.468750,0.031250)\n\t3138: o_phase = +9'd245;\t //LUT[3138] \tphase : 0.957031\t(data_i, data_q): (-0.468750,0.062500)\n\t3139: o_phase = +9'd240;\t //LUT[3139] \tphase : 0.937500\t(data_i, data_q): (-0.468750,0.093750)\n\t3140: o_phase = +9'd235;\t //LUT[3140] \tphase : 0.917969\t(data_i, data_q): (-0.468750,0.125000)\n\t3141: o_phase = +9'd230;\t //LUT[3141] \tphase : 0.898438\t(data_i, data_q): (-0.468750,0.156250)\n\t3142: o_phase = +9'd225;\t //LUT[3142] \tphase : 0.878906\t(data_i, data_q): (-0.468750,0.187500)\n\t3143: o_phase = +9'd220;\t //LUT[3143] \tphase : 0.859375\t(data_i, data_q): (-0.468750,0.218750)\n\t3144: o_phase = +9'd216;\t //LUT[3144] \tphase : 0.843750\t(data_i, data_q): (-0.468750,0.250000)\n\t3145: o_phase = +9'd212;\t //LUT[3145] \tphase : 0.828125\t(data_i, data_q): (-0.468750,0.281250)\n\t3146: o_phase = +9'd208;\t //LUT[3146] \tphase : 0.812500\t(data_i, data_q): (-0.468750,0.312500)\n\t3147: o_phase = +9'd204;\t //LUT[3147] \tphase : 0.796875\t(data_i, data_q): (-0.468750,0.343750)\n\t3148: o_phase = +9'd201;\t //LUT[3148] \tphase : 0.785156\t(data_i, data_q): (-0.468750,0.375000)\n\t3149: o_phase = +9'd198;\t //LUT[3149] \tphase : 0.773438\t(data_i, data_q): (-0.468750,0.406250)\n\t3150: o_phase = +9'd195;\t //LUT[3150] \tphase : 0.761719\t(data_i, data_q): (-0.468750,0.437500)\n\t3151: o_phase = +9'd192;\t //LUT[3151] \tphase : 0.750000\t(data_i, data_q): (-0.468750,0.468750)\n\t3152: o_phase = +9'd189;\t //LUT[3152] \tphase : 0.738281\t(data_i, data_q): (-0.468750,0.500000)\n\t3153: o_phase = +9'd187;\t //LUT[3153] \tphase : 0.730469\t(data_i, data_q): (-0.468750,0.531250)\n\t3154: o_phase = +9'd185;\t //LUT[3154] \tphase : 0.722656\t(data_i, data_q): (-0.468750,0.562500)\n\t3155: o_phase = +9'd182;\t //LUT[3155] \tphase : 0.710938\t(data_i, data_q): (-0.468750,0.593750)\n\t3156: o_phase = +9'd180;\t //LUT[3156] \tphase : 0.703125\t(data_i, data_q): (-0.468750,0.625000)\n\t3157: o_phase = +9'd179;\t //LUT[3157] \tphase : 0.699219\t(data_i, data_q): (-0.468750,0.656250)\n\t3158: o_phase = +9'd177;\t //LUT[3158] \tphase : 0.691406\t(data_i, data_q): (-0.468750,0.687500)\n\t3159: o_phase = +9'd175;\t //LUT[3159] \tphase : 0.683594\t(data_i, data_q): (-0.468750,0.718750)\n\t3160: o_phase = +9'd174;\t //LUT[3160] \tphase : 0.679688\t(data_i, data_q): (-0.468750,0.750000)\n\t3161: o_phase = +9'd172;\t //LUT[3161] \tphase : 0.671875\t(data_i, data_q): (-0.468750,0.781250)\n\t3162: o_phase = +9'd171;\t //LUT[3162] \tphase : 0.667969\t(data_i, data_q): (-0.468750,0.812500)\n\t3163: o_phase = +9'd169;\t //LUT[3163] \tphase : 0.660156\t(data_i, data_q): (-0.468750,0.843750)\n\t3164: o_phase = +9'd168;\t //LUT[3164] \tphase : 0.656250\t(data_i, data_q): (-0.468750,0.875000)\n\t3165: o_phase = +9'd167;\t //LUT[3165] \tphase : 0.652344\t(data_i, data_q): (-0.468750,0.906250)\n\t3166: o_phase = +9'd166;\t //LUT[3166] \tphase : 0.648438\t(data_i, data_q): (-0.468750,0.937500)\n\t3167: o_phase = +9'd165;\t //LUT[3167] \tphase : 0.644531\t(data_i, data_q): (-0.468750,0.968750)\n\t3168: o_phase = -9'd164;\t //LUT[3168] \tphase : -0.640625\t(data_i, data_q): (-0.468750,-1.000000)\n\t3169: o_phase = -9'd165;\t //LUT[3169] \tphase : -0.644531\t(data_i, data_q): (-0.468750,-0.968750)\n\t3170: o_phase = -9'd166;\t //LUT[3170] \tphase : -0.648438\t(data_i, data_q): (-0.468750,-0.937500)\n\t3171: o_phase = -9'd167;\t //LUT[3171] \tphase : -0.652344\t(data_i, data_q): (-0.468750,-0.906250)\n\t3172: o_phase = -9'd168;\t //LUT[3172] \tphase : -0.656250\t(data_i, data_q): (-0.468750,-0.875000)\n\t3173: o_phase = -9'd169;\t //LUT[3173] \tphase : -0.660156\t(data_i, data_q): (-0.468750,-0.843750)\n\t3174: o_phase = -9'd171;\t //LUT[3174] \tphase : -0.667969\t(data_i, data_q): (-0.468750,-0.812500)\n\t3175: o_phase = -9'd172;\t //LUT[3175] \tphase : -0.671875\t(data_i, data_q): (-0.468750,-0.781250)\n\t3176: o_phase = -9'd174;\t //LUT[3176] \tphase : -0.679688\t(data_i, data_q): (-0.468750,-0.750000)\n\t3177: o_phase = -9'd175;\t //LUT[3177] \tphase : -0.683594\t(data_i, data_q): (-0.468750,-0.718750)\n\t3178: o_phase = -9'd177;\t //LUT[3178] \tphase : -0.691406\t(data_i, data_q): (-0.468750,-0.687500)\n\t3179: o_phase = -9'd179;\t //LUT[3179] \tphase : -0.699219\t(data_i, data_q): (-0.468750,-0.656250)\n\t3180: o_phase = -9'd180;\t //LUT[3180] \tphase : -0.703125\t(data_i, data_q): (-0.468750,-0.625000)\n\t3181: o_phase = -9'd182;\t //LUT[3181] \tphase : -0.710938\t(data_i, data_q): (-0.468750,-0.593750)\n\t3182: o_phase = -9'd185;\t //LUT[3182] \tphase : -0.722656\t(data_i, data_q): (-0.468750,-0.562500)\n\t3183: o_phase = -9'd187;\t //LUT[3183] \tphase : -0.730469\t(data_i, data_q): (-0.468750,-0.531250)\n\t3184: o_phase = -9'd189;\t //LUT[3184] \tphase : -0.738281\t(data_i, data_q): (-0.468750,-0.500000)\n\t3185: o_phase = -9'd192;\t //LUT[3185] \tphase : -0.750000\t(data_i, data_q): (-0.468750,-0.468750)\n\t3186: o_phase = -9'd195;\t //LUT[3186] \tphase : -0.761719\t(data_i, data_q): (-0.468750,-0.437500)\n\t3187: o_phase = -9'd198;\t //LUT[3187] \tphase : -0.773438\t(data_i, data_q): (-0.468750,-0.406250)\n\t3188: o_phase = -9'd201;\t //LUT[3188] \tphase : -0.785156\t(data_i, data_q): (-0.468750,-0.375000)\n\t3189: o_phase = -9'd204;\t //LUT[3189] \tphase : -0.796875\t(data_i, data_q): (-0.468750,-0.343750)\n\t3190: o_phase = -9'd208;\t //LUT[3190] \tphase : -0.812500\t(data_i, data_q): (-0.468750,-0.312500)\n\t3191: o_phase = -9'd212;\t //LUT[3191] \tphase : -0.828125\t(data_i, data_q): (-0.468750,-0.281250)\n\t3192: o_phase = -9'd216;\t //LUT[3192] \tphase : -0.843750\t(data_i, data_q): (-0.468750,-0.250000)\n\t3193: o_phase = -9'd220;\t //LUT[3193] \tphase : -0.859375\t(data_i, data_q): (-0.468750,-0.218750)\n\t3194: o_phase = -9'd225;\t //LUT[3194] \tphase : -0.878906\t(data_i, data_q): (-0.468750,-0.187500)\n\t3195: o_phase = -9'd230;\t //LUT[3195] \tphase : -0.898438\t(data_i, data_q): (-0.468750,-0.156250)\n\t3196: o_phase = -9'd235;\t //LUT[3196] \tphase : -0.917969\t(data_i, data_q): (-0.468750,-0.125000)\n\t3197: o_phase = -9'd240;\t //LUT[3197] \tphase : -0.937500\t(data_i, data_q): (-0.468750,-0.093750)\n\t3198: o_phase = -9'd245;\t //LUT[3198] \tphase : -0.957031\t(data_i, data_q): (-0.468750,-0.062500)\n\t3199: o_phase = -9'd251;\t //LUT[3199] \tphase : -0.980469\t(data_i, data_q): (-0.468750,-0.031250)\n\t3200: o_phase = -9'd256;\t //LUT[3200] \tphase : -1.000000\t(data_i, data_q): (-0.437500,0.000000)\n\t3201: o_phase = +9'd250;\t //LUT[3201] \tphase : 0.976562\t(data_i, data_q): (-0.437500,0.031250)\n\t3202: o_phase = +9'd244;\t //LUT[3202] \tphase : 0.953125\t(data_i, data_q): (-0.437500,0.062500)\n\t3203: o_phase = +9'd239;\t //LUT[3203] \tphase : 0.933594\t(data_i, data_q): (-0.437500,0.093750)\n\t3204: o_phase = +9'd233;\t //LUT[3204] \tphase : 0.910156\t(data_i, data_q): (-0.437500,0.125000)\n\t3205: o_phase = +9'd228;\t //LUT[3205] \tphase : 0.890625\t(data_i, data_q): (-0.437500,0.156250)\n\t3206: o_phase = +9'd223;\t //LUT[3206] \tphase : 0.871094\t(data_i, data_q): (-0.437500,0.187500)\n\t3207: o_phase = +9'd218;\t //LUT[3207] \tphase : 0.851562\t(data_i, data_q): (-0.437500,0.218750)\n\t3208: o_phase = +9'd214;\t //LUT[3208] \tphase : 0.835938\t(data_i, data_q): (-0.437500,0.250000)\n\t3209: o_phase = +9'd209;\t //LUT[3209] \tphase : 0.816406\t(data_i, data_q): (-0.437500,0.281250)\n\t3210: o_phase = +9'd205;\t //LUT[3210] \tphase : 0.800781\t(data_i, data_q): (-0.437500,0.312500)\n\t3211: o_phase = +9'd202;\t //LUT[3211] \tphase : 0.789062\t(data_i, data_q): (-0.437500,0.343750)\n\t3212: o_phase = +9'd198;\t //LUT[3212] \tphase : 0.773438\t(data_i, data_q): (-0.437500,0.375000)\n\t3213: o_phase = +9'd195;\t //LUT[3213] \tphase : 0.761719\t(data_i, data_q): (-0.437500,0.406250)\n\t3214: o_phase = +9'd192;\t //LUT[3214] \tphase : 0.750000\t(data_i, data_q): (-0.437500,0.437500)\n\t3215: o_phase = +9'd189;\t //LUT[3215] \tphase : 0.738281\t(data_i, data_q): (-0.437500,0.468750)\n\t3216: o_phase = +9'd187;\t //LUT[3216] \tphase : 0.730469\t(data_i, data_q): (-0.437500,0.500000)\n\t3217: o_phase = +9'd184;\t //LUT[3217] \tphase : 0.718750\t(data_i, data_q): (-0.437500,0.531250)\n\t3218: o_phase = +9'd182;\t //LUT[3218] \tphase : 0.710938\t(data_i, data_q): (-0.437500,0.562500)\n\t3219: o_phase = +9'd180;\t //LUT[3219] \tphase : 0.703125\t(data_i, data_q): (-0.437500,0.593750)\n\t3220: o_phase = +9'd178;\t //LUT[3220] \tphase : 0.695312\t(data_i, data_q): (-0.437500,0.625000)\n\t3221: o_phase = +9'd176;\t //LUT[3221] \tphase : 0.687500\t(data_i, data_q): (-0.437500,0.656250)\n\t3222: o_phase = +9'd174;\t //LUT[3222] \tphase : 0.679688\t(data_i, data_q): (-0.437500,0.687500)\n\t3223: o_phase = +9'd173;\t //LUT[3223] \tphase : 0.675781\t(data_i, data_q): (-0.437500,0.718750)\n\t3224: o_phase = +9'd171;\t //LUT[3224] \tphase : 0.667969\t(data_i, data_q): (-0.437500,0.750000)\n\t3225: o_phase = +9'd170;\t //LUT[3225] \tphase : 0.664062\t(data_i, data_q): (-0.437500,0.781250)\n\t3226: o_phase = +9'd168;\t //LUT[3226] \tphase : 0.656250\t(data_i, data_q): (-0.437500,0.812500)\n\t3227: o_phase = +9'd167;\t //LUT[3227] \tphase : 0.652344\t(data_i, data_q): (-0.437500,0.843750)\n\t3228: o_phase = +9'd166;\t //LUT[3228] \tphase : 0.648438\t(data_i, data_q): (-0.437500,0.875000)\n\t3229: o_phase = +9'd165;\t //LUT[3229] \tphase : 0.644531\t(data_i, data_q): (-0.437500,0.906250)\n\t3230: o_phase = +9'd164;\t //LUT[3230] \tphase : 0.640625\t(data_i, data_q): (-0.437500,0.937500)\n\t3231: o_phase = +9'd163;\t //LUT[3231] \tphase : 0.636719\t(data_i, data_q): (-0.437500,0.968750)\n\t3232: o_phase = -9'd162;\t //LUT[3232] \tphase : -0.632812\t(data_i, data_q): (-0.437500,-1.000000)\n\t3233: o_phase = -9'd163;\t //LUT[3233] \tphase : -0.636719\t(data_i, data_q): (-0.437500,-0.968750)\n\t3234: o_phase = -9'd164;\t //LUT[3234] \tphase : -0.640625\t(data_i, data_q): (-0.437500,-0.937500)\n\t3235: o_phase = -9'd165;\t //LUT[3235] \tphase : -0.644531\t(data_i, data_q): (-0.437500,-0.906250)\n\t3236: o_phase = -9'd166;\t //LUT[3236] \tphase : -0.648438\t(data_i, data_q): (-0.437500,-0.875000)\n\t3237: o_phase = -9'd167;\t //LUT[3237] \tphase : -0.652344\t(data_i, data_q): (-0.437500,-0.843750)\n\t3238: o_phase = -9'd168;\t //LUT[3238] \tphase : -0.656250\t(data_i, data_q): (-0.437500,-0.812500)\n\t3239: o_phase = -9'd170;\t //LUT[3239] \tphase : -0.664062\t(data_i, data_q): (-0.437500,-0.781250)\n\t3240: o_phase = -9'd171;\t //LUT[3240] \tphase : -0.667969\t(data_i, data_q): (-0.437500,-0.750000)\n\t3241: o_phase = -9'd173;\t //LUT[3241] \tphase : -0.675781\t(data_i, data_q): (-0.437500,-0.718750)\n\t3242: o_phase = -9'd174;\t //LUT[3242] \tphase : -0.679688\t(data_i, data_q): (-0.437500,-0.687500)\n\t3243: o_phase = -9'd176;\t //LUT[3243] \tphase : -0.687500\t(data_i, data_q): (-0.437500,-0.656250)\n\t3244: o_phase = -9'd178;\t //LUT[3244] \tphase : -0.695312\t(data_i, data_q): (-0.437500,-0.625000)\n\t3245: o_phase = -9'd180;\t //LUT[3245] \tphase : -0.703125\t(data_i, data_q): (-0.437500,-0.593750)\n\t3246: o_phase = -9'd182;\t //LUT[3246] \tphase : -0.710938\t(data_i, data_q): (-0.437500,-0.562500)\n\t3247: o_phase = -9'd184;\t //LUT[3247] \tphase : -0.718750\t(data_i, data_q): (-0.437500,-0.531250)\n\t3248: o_phase = -9'd187;\t //LUT[3248] \tphase : -0.730469\t(data_i, data_q): (-0.437500,-0.500000)\n\t3249: o_phase = -9'd189;\t //LUT[3249] \tphase : -0.738281\t(data_i, data_q): (-0.437500,-0.468750)\n\t3250: o_phase = -9'd192;\t //LUT[3250] \tphase : -0.750000\t(data_i, data_q): (-0.437500,-0.437500)\n\t3251: o_phase = -9'd195;\t //LUT[3251] \tphase : -0.761719\t(data_i, data_q): (-0.437500,-0.406250)\n\t3252: o_phase = -9'd198;\t //LUT[3252] \tphase : -0.773438\t(data_i, data_q): (-0.437500,-0.375000)\n\t3253: o_phase = -9'd202;\t //LUT[3253] \tphase : -0.789062\t(data_i, data_q): (-0.437500,-0.343750)\n\t3254: o_phase = -9'd205;\t //LUT[3254] \tphase : -0.800781\t(data_i, data_q): (-0.437500,-0.312500)\n\t3255: o_phase = -9'd209;\t //LUT[3255] \tphase : -0.816406\t(data_i, data_q): (-0.437500,-0.281250)\n\t3256: o_phase = -9'd214;\t //LUT[3256] \tphase : -0.835938\t(data_i, data_q): (-0.437500,-0.250000)\n\t3257: o_phase = -9'd218;\t //LUT[3257] \tphase : -0.851562\t(data_i, data_q): (-0.437500,-0.218750)\n\t3258: o_phase = -9'd223;\t //LUT[3258] \tphase : -0.871094\t(data_i, data_q): (-0.437500,-0.187500)\n\t3259: o_phase = -9'd228;\t //LUT[3259] \tphase : -0.890625\t(data_i, data_q): (-0.437500,-0.156250)\n\t3260: o_phase = -9'd233;\t //LUT[3260] \tphase : -0.910156\t(data_i, data_q): (-0.437500,-0.125000)\n\t3261: o_phase = -9'd239;\t //LUT[3261] \tphase : -0.933594\t(data_i, data_q): (-0.437500,-0.093750)\n\t3262: o_phase = -9'd244;\t //LUT[3262] \tphase : -0.953125\t(data_i, data_q): (-0.437500,-0.062500)\n\t3263: o_phase = -9'd250;\t //LUT[3263] \tphase : -0.976562\t(data_i, data_q): (-0.437500,-0.031250)\n\t3264: o_phase = -9'd256;\t //LUT[3264] \tphase : -1.000000\t(data_i, data_q): (-0.406250,0.000000)\n\t3265: o_phase = +9'd250;\t //LUT[3265] \tphase : 0.976562\t(data_i, data_q): (-0.406250,0.031250)\n\t3266: o_phase = +9'd244;\t //LUT[3266] \tphase : 0.953125\t(data_i, data_q): (-0.406250,0.062500)\n\t3267: o_phase = +9'd238;\t //LUT[3267] \tphase : 0.929688\t(data_i, data_q): (-0.406250,0.093750)\n\t3268: o_phase = +9'd232;\t //LUT[3268] \tphase : 0.906250\t(data_i, data_q): (-0.406250,0.125000)\n\t3269: o_phase = +9'd226;\t //LUT[3269] \tphase : 0.882812\t(data_i, data_q): (-0.406250,0.156250)\n\t3270: o_phase = +9'd221;\t //LUT[3270] \tphase : 0.863281\t(data_i, data_q): (-0.406250,0.187500)\n\t3271: o_phase = +9'd216;\t //LUT[3271] \tphase : 0.843750\t(data_i, data_q): (-0.406250,0.218750)\n\t3272: o_phase = +9'd211;\t //LUT[3272] \tphase : 0.824219\t(data_i, data_q): (-0.406250,0.250000)\n\t3273: o_phase = +9'd207;\t //LUT[3273] \tphase : 0.808594\t(data_i, data_q): (-0.406250,0.281250)\n\t3274: o_phase = +9'd203;\t //LUT[3274] \tphase : 0.792969\t(data_i, data_q): (-0.406250,0.312500)\n\t3275: o_phase = +9'd199;\t //LUT[3275] \tphase : 0.777344\t(data_i, data_q): (-0.406250,0.343750)\n\t3276: o_phase = +9'd195;\t //LUT[3276] \tphase : 0.761719\t(data_i, data_q): (-0.406250,0.375000)\n\t3277: o_phase = +9'd192;\t //LUT[3277] \tphase : 0.750000\t(data_i, data_q): (-0.406250,0.406250)\n\t3278: o_phase = +9'd189;\t //LUT[3278] \tphase : 0.738281\t(data_i, data_q): (-0.406250,0.437500)\n\t3279: o_phase = +9'd186;\t //LUT[3279] \tphase : 0.726562\t(data_i, data_q): (-0.406250,0.468750)\n\t3280: o_phase = +9'd184;\t //LUT[3280] \tphase : 0.718750\t(data_i, data_q): (-0.406250,0.500000)\n\t3281: o_phase = +9'd181;\t //LUT[3281] \tphase : 0.707031\t(data_i, data_q): (-0.406250,0.531250)\n\t3282: o_phase = +9'd179;\t //LUT[3282] \tphase : 0.699219\t(data_i, data_q): (-0.406250,0.562500)\n\t3283: o_phase = +9'd177;\t //LUT[3283] \tphase : 0.691406\t(data_i, data_q): (-0.406250,0.593750)\n\t3284: o_phase = +9'd175;\t //LUT[3284] \tphase : 0.683594\t(data_i, data_q): (-0.406250,0.625000)\n\t3285: o_phase = +9'd173;\t //LUT[3285] \tphase : 0.675781\t(data_i, data_q): (-0.406250,0.656250)\n\t3286: o_phase = +9'd171;\t //LUT[3286] \tphase : 0.667969\t(data_i, data_q): (-0.406250,0.687500)\n\t3287: o_phase = +9'd170;\t //LUT[3287] \tphase : 0.664062\t(data_i, data_q): (-0.406250,0.718750)\n\t3288: o_phase = +9'd168;\t //LUT[3288] \tphase : 0.656250\t(data_i, data_q): (-0.406250,0.750000)\n\t3289: o_phase = +9'd167;\t //LUT[3289] \tphase : 0.652344\t(data_i, data_q): (-0.406250,0.781250)\n\t3290: o_phase = +9'd166;\t //LUT[3290] \tphase : 0.648438\t(data_i, data_q): (-0.406250,0.812500)\n\t3291: o_phase = +9'd165;\t //LUT[3291] \tphase : 0.644531\t(data_i, data_q): (-0.406250,0.843750)\n\t3292: o_phase = +9'd163;\t //LUT[3292] \tphase : 0.636719\t(data_i, data_q): (-0.406250,0.875000)\n\t3293: o_phase = +9'd162;\t //LUT[3293] \tphase : 0.632812\t(data_i, data_q): (-0.406250,0.906250)\n\t3294: o_phase = +9'd161;\t //LUT[3294] \tphase : 0.628906\t(data_i, data_q): (-0.406250,0.937500)\n\t3295: o_phase = +9'd160;\t //LUT[3295] \tphase : 0.625000\t(data_i, data_q): (-0.406250,0.968750)\n\t3296: o_phase = -9'd159;\t //LUT[3296] \tphase : -0.621094\t(data_i, data_q): (-0.406250,-1.000000)\n\t3297: o_phase = -9'd160;\t //LUT[3297] \tphase : -0.625000\t(data_i, data_q): (-0.406250,-0.968750)\n\t3298: o_phase = -9'd161;\t //LUT[3298] \tphase : -0.628906\t(data_i, data_q): (-0.406250,-0.937500)\n\t3299: o_phase = -9'd162;\t //LUT[3299] \tphase : -0.632812\t(data_i, data_q): (-0.406250,-0.906250)\n\t3300: o_phase = -9'd163;\t //LUT[3300] \tphase : -0.636719\t(data_i, data_q): (-0.406250,-0.875000)\n\t3301: o_phase = -9'd165;\t //LUT[3301] \tphase : -0.644531\t(data_i, data_q): (-0.406250,-0.843750)\n\t3302: o_phase = -9'd166;\t //LUT[3302] \tphase : -0.648438\t(data_i, data_q): (-0.406250,-0.812500)\n\t3303: o_phase = -9'd167;\t //LUT[3303] \tphase : -0.652344\t(data_i, data_q): (-0.406250,-0.781250)\n\t3304: o_phase = -9'd168;\t //LUT[3304] \tphase : -0.656250\t(data_i, data_q): (-0.406250,-0.750000)\n\t3305: o_phase = -9'd170;\t //LUT[3305] \tphase : -0.664062\t(data_i, data_q): (-0.406250,-0.718750)\n\t3306: o_phase = -9'd171;\t //LUT[3306] \tphase : -0.667969\t(data_i, data_q): (-0.406250,-0.687500)\n\t3307: o_phase = -9'd173;\t //LUT[3307] \tphase : -0.675781\t(data_i, data_q): (-0.406250,-0.656250)\n\t3308: o_phase = -9'd175;\t //LUT[3308] \tphase : -0.683594\t(data_i, data_q): (-0.406250,-0.625000)\n\t3309: o_phase = -9'd177;\t //LUT[3309] \tphase : -0.691406\t(data_i, data_q): (-0.406250,-0.593750)\n\t3310: o_phase = -9'd179;\t //LUT[3310] \tphase : -0.699219\t(data_i, data_q): (-0.406250,-0.562500)\n\t3311: o_phase = -9'd181;\t //LUT[3311] \tphase : -0.707031\t(data_i, data_q): (-0.406250,-0.531250)\n\t3312: o_phase = -9'd184;\t //LUT[3312] \tphase : -0.718750\t(data_i, data_q): (-0.406250,-0.500000)\n\t3313: o_phase = -9'd186;\t //LUT[3313] \tphase : -0.726562\t(data_i, data_q): (-0.406250,-0.468750)\n\t3314: o_phase = -9'd189;\t //LUT[3314] \tphase : -0.738281\t(data_i, data_q): (-0.406250,-0.437500)\n\t3315: o_phase = -9'd192;\t //LUT[3315] \tphase : -0.750000\t(data_i, data_q): (-0.406250,-0.406250)\n\t3316: o_phase = -9'd195;\t //LUT[3316] \tphase : -0.761719\t(data_i, data_q): (-0.406250,-0.375000)\n\t3317: o_phase = -9'd199;\t //LUT[3317] \tphase : -0.777344\t(data_i, data_q): (-0.406250,-0.343750)\n\t3318: o_phase = -9'd203;\t //LUT[3318] \tphase : -0.792969\t(data_i, data_q): (-0.406250,-0.312500)\n\t3319: o_phase = -9'd207;\t //LUT[3319] \tphase : -0.808594\t(data_i, data_q): (-0.406250,-0.281250)\n\t3320: o_phase = -9'd211;\t //LUT[3320] \tphase : -0.824219\t(data_i, data_q): (-0.406250,-0.250000)\n\t3321: o_phase = -9'd216;\t //LUT[3321] \tphase : -0.843750\t(data_i, data_q): (-0.406250,-0.218750)\n\t3322: o_phase = -9'd221;\t //LUT[3322] \tphase : -0.863281\t(data_i, data_q): (-0.406250,-0.187500)\n\t3323: o_phase = -9'd226;\t //LUT[3323] \tphase : -0.882812\t(data_i, data_q): (-0.406250,-0.156250)\n\t3324: o_phase = -9'd232;\t //LUT[3324] \tphase : -0.906250\t(data_i, data_q): (-0.406250,-0.125000)\n\t3325: o_phase = -9'd238;\t //LUT[3325] \tphase : -0.929688\t(data_i, data_q): (-0.406250,-0.093750)\n\t3326: o_phase = -9'd244;\t //LUT[3326] \tphase : -0.953125\t(data_i, data_q): (-0.406250,-0.062500)\n\t3327: o_phase = -9'd250;\t //LUT[3327] \tphase : -0.976562\t(data_i, data_q): (-0.406250,-0.031250)\n\t3328: o_phase = -9'd256;\t //LUT[3328] \tphase : -1.000000\t(data_i, data_q): (-0.375000,0.000000)\n\t3329: o_phase = +9'd249;\t //LUT[3329] \tphase : 0.972656\t(data_i, data_q): (-0.375000,0.031250)\n\t3330: o_phase = +9'd243;\t //LUT[3330] \tphase : 0.949219\t(data_i, data_q): (-0.375000,0.062500)\n\t3331: o_phase = +9'd236;\t //LUT[3331] \tphase : 0.921875\t(data_i, data_q): (-0.375000,0.093750)\n\t3332: o_phase = +9'd230;\t //LUT[3332] \tphase : 0.898438\t(data_i, data_q): (-0.375000,0.125000)\n\t3333: o_phase = +9'd224;\t //LUT[3333] \tphase : 0.875000\t(data_i, data_q): (-0.375000,0.156250)\n\t3334: o_phase = +9'd218;\t //LUT[3334] \tphase : 0.851562\t(data_i, data_q): (-0.375000,0.187500)\n\t3335: o_phase = +9'd213;\t //LUT[3335] \tphase : 0.832031\t(data_i, data_q): (-0.375000,0.218750)\n\t3336: o_phase = +9'd208;\t //LUT[3336] \tphase : 0.812500\t(data_i, data_q): (-0.375000,0.250000)\n\t3337: o_phase = +9'd204;\t //LUT[3337] \tphase : 0.796875\t(data_i, data_q): (-0.375000,0.281250)\n\t3338: o_phase = +9'd199;\t //LUT[3338] \tphase : 0.777344\t(data_i, data_q): (-0.375000,0.312500)\n\t3339: o_phase = +9'd196;\t //LUT[3339] \tphase : 0.765625\t(data_i, data_q): (-0.375000,0.343750)\n\t3340: o_phase = +9'd192;\t //LUT[3340] \tphase : 0.750000\t(data_i, data_q): (-0.375000,0.375000)\n\t3341: o_phase = +9'd189;\t //LUT[3341] \tphase : 0.738281\t(data_i, data_q): (-0.375000,0.406250)\n\t3342: o_phase = +9'd186;\t //LUT[3342] \tphase : 0.726562\t(data_i, data_q): (-0.375000,0.437500)\n\t3343: o_phase = +9'd183;\t //LUT[3343] \tphase : 0.714844\t(data_i, data_q): (-0.375000,0.468750)\n\t3344: o_phase = +9'd180;\t //LUT[3344] \tphase : 0.703125\t(data_i, data_q): (-0.375000,0.500000)\n\t3345: o_phase = +9'd178;\t //LUT[3345] \tphase : 0.695312\t(data_i, data_q): (-0.375000,0.531250)\n\t3346: o_phase = +9'd176;\t //LUT[3346] \tphase : 0.687500\t(data_i, data_q): (-0.375000,0.562500)\n\t3347: o_phase = +9'd174;\t //LUT[3347] \tphase : 0.679688\t(data_i, data_q): (-0.375000,0.593750)\n\t3348: o_phase = +9'd172;\t //LUT[3348] \tphase : 0.671875\t(data_i, data_q): (-0.375000,0.625000)\n\t3349: o_phase = +9'd170;\t //LUT[3349] \tphase : 0.664062\t(data_i, data_q): (-0.375000,0.656250)\n\t3350: o_phase = +9'd169;\t //LUT[3350] \tphase : 0.660156\t(data_i, data_q): (-0.375000,0.687500)\n\t3351: o_phase = +9'd167;\t //LUT[3351] \tphase : 0.652344\t(data_i, data_q): (-0.375000,0.718750)\n\t3352: o_phase = +9'd166;\t //LUT[3352] \tphase : 0.648438\t(data_i, data_q): (-0.375000,0.750000)\n\t3353: o_phase = +9'd164;\t //LUT[3353] \tphase : 0.640625\t(data_i, data_q): (-0.375000,0.781250)\n\t3354: o_phase = +9'd163;\t //LUT[3354] \tphase : 0.636719\t(data_i, data_q): (-0.375000,0.812500)\n\t3355: o_phase = +9'd162;\t //LUT[3355] \tphase : 0.632812\t(data_i, data_q): (-0.375000,0.843750)\n\t3356: o_phase = +9'd161;\t //LUT[3356] \tphase : 0.628906\t(data_i, data_q): (-0.375000,0.875000)\n\t3357: o_phase = +9'd160;\t //LUT[3357] \tphase : 0.625000\t(data_i, data_q): (-0.375000,0.906250)\n\t3358: o_phase = +9'd159;\t //LUT[3358] \tphase : 0.621094\t(data_i, data_q): (-0.375000,0.937500)\n\t3359: o_phase = +9'd158;\t //LUT[3359] \tphase : 0.617188\t(data_i, data_q): (-0.375000,0.968750)\n\t3360: o_phase = -9'd157;\t //LUT[3360] \tphase : -0.613281\t(data_i, data_q): (-0.375000,-1.000000)\n\t3361: o_phase = -9'd158;\t //LUT[3361] \tphase : -0.617188\t(data_i, data_q): (-0.375000,-0.968750)\n\t3362: o_phase = -9'd159;\t //LUT[3362] \tphase : -0.621094\t(data_i, data_q): (-0.375000,-0.937500)\n\t3363: o_phase = -9'd160;\t //LUT[3363] \tphase : -0.625000\t(data_i, data_q): (-0.375000,-0.906250)\n\t3364: o_phase = -9'd161;\t //LUT[3364] \tphase : -0.628906\t(data_i, data_q): (-0.375000,-0.875000)\n\t3365: o_phase = -9'd162;\t //LUT[3365] \tphase : -0.632812\t(data_i, data_q): (-0.375000,-0.843750)\n\t3366: o_phase = -9'd163;\t //LUT[3366] \tphase : -0.636719\t(data_i, data_q): (-0.375000,-0.812500)\n\t3367: o_phase = -9'd164;\t //LUT[3367] \tphase : -0.640625\t(data_i, data_q): (-0.375000,-0.781250)\n\t3368: o_phase = -9'd166;\t //LUT[3368] \tphase : -0.648438\t(data_i, data_q): (-0.375000,-0.750000)\n\t3369: o_phase = -9'd167;\t //LUT[3369] \tphase : -0.652344\t(data_i, data_q): (-0.375000,-0.718750)\n\t3370: o_phase = -9'd169;\t //LUT[3370] \tphase : -0.660156\t(data_i, data_q): (-0.375000,-0.687500)\n\t3371: o_phase = -9'd170;\t //LUT[3371] \tphase : -0.664062\t(data_i, data_q): (-0.375000,-0.656250)\n\t3372: o_phase = -9'd172;\t //LUT[3372] \tphase : -0.671875\t(data_i, data_q): (-0.375000,-0.625000)\n\t3373: o_phase = -9'd174;\t //LUT[3373] \tphase : -0.679688\t(data_i, data_q): (-0.375000,-0.593750)\n\t3374: o_phase = -9'd176;\t //LUT[3374] \tphase : -0.687500\t(data_i, data_q): (-0.375000,-0.562500)\n\t3375: o_phase = -9'd178;\t //LUT[3375] \tphase : -0.695312\t(data_i, data_q): (-0.375000,-0.531250)\n\t3376: o_phase = -9'd180;\t //LUT[3376] \tphase : -0.703125\t(data_i, data_q): (-0.375000,-0.500000)\n\t3377: o_phase = -9'd183;\t //LUT[3377] \tphase : -0.714844\t(data_i, data_q): (-0.375000,-0.468750)\n\t3378: o_phase = -9'd186;\t //LUT[3378] \tphase : -0.726562\t(data_i, data_q): (-0.375000,-0.437500)\n\t3379: o_phase = -9'd189;\t //LUT[3379] \tphase : -0.738281\t(data_i, data_q): (-0.375000,-0.406250)\n\t3380: o_phase = -9'd192;\t //LUT[3380] \tphase : -0.750000\t(data_i, data_q): (-0.375000,-0.375000)\n\t3381: o_phase = -9'd196;\t //LUT[3381] \tphase : -0.765625\t(data_i, data_q): (-0.375000,-0.343750)\n\t3382: o_phase = -9'd199;\t //LUT[3382] \tphase : -0.777344\t(data_i, data_q): (-0.375000,-0.312500)\n\t3383: o_phase = -9'd204;\t //LUT[3383] \tphase : -0.796875\t(data_i, data_q): (-0.375000,-0.281250)\n\t3384: o_phase = -9'd208;\t //LUT[3384] \tphase : -0.812500\t(data_i, data_q): (-0.375000,-0.250000)\n\t3385: o_phase = -9'd213;\t //LUT[3385] \tphase : -0.832031\t(data_i, data_q): (-0.375000,-0.218750)\n\t3386: o_phase = -9'd218;\t //LUT[3386] \tphase : -0.851562\t(data_i, data_q): (-0.375000,-0.187500)\n\t3387: o_phase = -9'd224;\t //LUT[3387] \tphase : -0.875000\t(data_i, data_q): (-0.375000,-0.156250)\n\t3388: o_phase = -9'd230;\t //LUT[3388] \tphase : -0.898438\t(data_i, data_q): (-0.375000,-0.125000)\n\t3389: o_phase = -9'd236;\t //LUT[3389] \tphase : -0.921875\t(data_i, data_q): (-0.375000,-0.093750)\n\t3390: o_phase = -9'd243;\t //LUT[3390] \tphase : -0.949219\t(data_i, data_q): (-0.375000,-0.062500)\n\t3391: o_phase = -9'd249;\t //LUT[3391] \tphase : -0.972656\t(data_i, data_q): (-0.375000,-0.031250)\n\t3392: o_phase = -9'd256;\t //LUT[3392] \tphase : -1.000000\t(data_i, data_q): (-0.343750,0.000000)\n\t3393: o_phase = +9'd249;\t //LUT[3393] \tphase : 0.972656\t(data_i, data_q): (-0.343750,0.031250)\n\t3394: o_phase = +9'd241;\t //LUT[3394] \tphase : 0.941406\t(data_i, data_q): (-0.343750,0.062500)\n\t3395: o_phase = +9'd234;\t //LUT[3395] \tphase : 0.914062\t(data_i, data_q): (-0.343750,0.093750)\n\t3396: o_phase = +9'd228;\t //LUT[3396] \tphase : 0.890625\t(data_i, data_q): (-0.343750,0.125000)\n\t3397: o_phase = +9'd221;\t //LUT[3397] \tphase : 0.863281\t(data_i, data_q): (-0.343750,0.156250)\n\t3398: o_phase = +9'd215;\t //LUT[3398] \tphase : 0.839844\t(data_i, data_q): (-0.343750,0.187500)\n\t3399: o_phase = +9'd210;\t //LUT[3399] \tphase : 0.820312\t(data_i, data_q): (-0.343750,0.218750)\n\t3400: o_phase = +9'd205;\t //LUT[3400] \tphase : 0.800781\t(data_i, data_q): (-0.343750,0.250000)\n\t3401: o_phase = +9'd200;\t //LUT[3401] \tphase : 0.781250\t(data_i, data_q): (-0.343750,0.281250)\n\t3402: o_phase = +9'd196;\t //LUT[3402] \tphase : 0.765625\t(data_i, data_q): (-0.343750,0.312500)\n\t3403: o_phase = +9'd192;\t //LUT[3403] \tphase : 0.750000\t(data_i, data_q): (-0.343750,0.343750)\n\t3404: o_phase = +9'd188;\t //LUT[3404] \tphase : 0.734375\t(data_i, data_q): (-0.343750,0.375000)\n\t3405: o_phase = +9'd185;\t //LUT[3405] \tphase : 0.722656\t(data_i, data_q): (-0.343750,0.406250)\n\t3406: o_phase = +9'd182;\t //LUT[3406] \tphase : 0.710938\t(data_i, data_q): (-0.343750,0.437500)\n\t3407: o_phase = +9'd180;\t //LUT[3407] \tphase : 0.703125\t(data_i, data_q): (-0.343750,0.468750)\n\t3408: o_phase = +9'd177;\t //LUT[3408] \tphase : 0.691406\t(data_i, data_q): (-0.343750,0.500000)\n\t3409: o_phase = +9'd175;\t //LUT[3409] \tphase : 0.683594\t(data_i, data_q): (-0.343750,0.531250)\n\t3410: o_phase = +9'd173;\t //LUT[3410] \tphase : 0.675781\t(data_i, data_q): (-0.343750,0.562500)\n\t3411: o_phase = +9'd171;\t //LUT[3411] \tphase : 0.667969\t(data_i, data_q): (-0.343750,0.593750)\n\t3412: o_phase = +9'd169;\t //LUT[3412] \tphase : 0.660156\t(data_i, data_q): (-0.343750,0.625000)\n\t3413: o_phase = +9'd167;\t //LUT[3413] \tphase : 0.652344\t(data_i, data_q): (-0.343750,0.656250)\n\t3414: o_phase = +9'd166;\t //LUT[3414] \tphase : 0.648438\t(data_i, data_q): (-0.343750,0.687500)\n\t3415: o_phase = +9'd164;\t //LUT[3415] \tphase : 0.640625\t(data_i, data_q): (-0.343750,0.718750)\n\t3416: o_phase = +9'd163;\t //LUT[3416] \tphase : 0.636719\t(data_i, data_q): (-0.343750,0.750000)\n\t3417: o_phase = +9'd162;\t //LUT[3417] \tphase : 0.632812\t(data_i, data_q): (-0.343750,0.781250)\n\t3418: o_phase = +9'd161;\t //LUT[3418] \tphase : 0.628906\t(data_i, data_q): (-0.343750,0.812500)\n\t3419: o_phase = +9'd160;\t //LUT[3419] \tphase : 0.625000\t(data_i, data_q): (-0.343750,0.843750)\n\t3420: o_phase = +9'd159;\t //LUT[3420] \tphase : 0.621094\t(data_i, data_q): (-0.343750,0.875000)\n\t3421: o_phase = +9'd158;\t //LUT[3421] \tphase : 0.617188\t(data_i, data_q): (-0.343750,0.906250)\n\t3422: o_phase = +9'd157;\t //LUT[3422] \tphase : 0.613281\t(data_i, data_q): (-0.343750,0.937500)\n\t3423: o_phase = +9'd156;\t //LUT[3423] \tphase : 0.609375\t(data_i, data_q): (-0.343750,0.968750)\n\t3424: o_phase = -9'd155;\t //LUT[3424] \tphase : -0.605469\t(data_i, data_q): (-0.343750,-1.000000)\n\t3425: o_phase = -9'd156;\t //LUT[3425] \tphase : -0.609375\t(data_i, data_q): (-0.343750,-0.968750)\n\t3426: o_phase = -9'd157;\t //LUT[3426] \tphase : -0.613281\t(data_i, data_q): (-0.343750,-0.937500)\n\t3427: o_phase = -9'd158;\t //LUT[3427] \tphase : -0.617188\t(data_i, data_q): (-0.343750,-0.906250)\n\t3428: o_phase = -9'd159;\t //LUT[3428] \tphase : -0.621094\t(data_i, data_q): (-0.343750,-0.875000)\n\t3429: o_phase = -9'd160;\t //LUT[3429] \tphase : -0.625000\t(data_i, data_q): (-0.343750,-0.843750)\n\t3430: o_phase = -9'd161;\t //LUT[3430] \tphase : -0.628906\t(data_i, data_q): (-0.343750,-0.812500)\n\t3431: o_phase = -9'd162;\t //LUT[3431] \tphase : -0.632812\t(data_i, data_q): (-0.343750,-0.781250)\n\t3432: o_phase = -9'd163;\t //LUT[3432] \tphase : -0.636719\t(data_i, data_q): (-0.343750,-0.750000)\n\t3433: o_phase = -9'd164;\t //LUT[3433] \tphase : -0.640625\t(data_i, data_q): (-0.343750,-0.718750)\n\t3434: o_phase = -9'd166;\t //LUT[3434] \tphase : -0.648438\t(data_i, data_q): (-0.343750,-0.687500)\n\t3435: o_phase = -9'd167;\t //LUT[3435] \tphase : -0.652344\t(data_i, data_q): (-0.343750,-0.656250)\n\t3436: o_phase = -9'd169;\t //LUT[3436] \tphase : -0.660156\t(data_i, data_q): (-0.343750,-0.625000)\n\t3437: o_phase = -9'd171;\t //LUT[3437] \tphase : -0.667969\t(data_i, data_q): (-0.343750,-0.593750)\n\t3438: o_phase = -9'd173;\t //LUT[3438] \tphase : -0.675781\t(data_i, data_q): (-0.343750,-0.562500)\n\t3439: o_phase = -9'd175;\t //LUT[3439] \tphase : -0.683594\t(data_i, data_q): (-0.343750,-0.531250)\n\t3440: o_phase = -9'd177;\t //LUT[3440] \tphase : -0.691406\t(data_i, data_q): (-0.343750,-0.500000)\n\t3441: o_phase = -9'd180;\t //LUT[3441] \tphase : -0.703125\t(data_i, data_q): (-0.343750,-0.468750)\n\t3442: o_phase = -9'd182;\t //LUT[3442] \tphase : -0.710938\t(data_i, data_q): (-0.343750,-0.437500)\n\t3443: o_phase = -9'd185;\t //LUT[3443] \tphase : -0.722656\t(data_i, data_q): (-0.343750,-0.406250)\n\t3444: o_phase = -9'd188;\t //LUT[3444] \tphase : -0.734375\t(data_i, data_q): (-0.343750,-0.375000)\n\t3445: o_phase = -9'd192;\t //LUT[3445] \tphase : -0.750000\t(data_i, data_q): (-0.343750,-0.343750)\n\t3446: o_phase = -9'd196;\t //LUT[3446] \tphase : -0.765625\t(data_i, data_q): (-0.343750,-0.312500)\n\t3447: o_phase = -9'd200;\t //LUT[3447] \tphase : -0.781250\t(data_i, data_q): (-0.343750,-0.281250)\n\t3448: o_phase = -9'd205;\t //LUT[3448] \tphase : -0.800781\t(data_i, data_q): (-0.343750,-0.250000)\n\t3449: o_phase = -9'd210;\t //LUT[3449] \tphase : -0.820312\t(data_i, data_q): (-0.343750,-0.218750)\n\t3450: o_phase = -9'd215;\t //LUT[3450] \tphase : -0.839844\t(data_i, data_q): (-0.343750,-0.187500)\n\t3451: o_phase = -9'd221;\t //LUT[3451] \tphase : -0.863281\t(data_i, data_q): (-0.343750,-0.156250)\n\t3452: o_phase = -9'd228;\t //LUT[3452] \tphase : -0.890625\t(data_i, data_q): (-0.343750,-0.125000)\n\t3453: o_phase = -9'd234;\t //LUT[3453] \tphase : -0.914062\t(data_i, data_q): (-0.343750,-0.093750)\n\t3454: o_phase = -9'd241;\t //LUT[3454] \tphase : -0.941406\t(data_i, data_q): (-0.343750,-0.062500)\n\t3455: o_phase = -9'd249;\t //LUT[3455] \tphase : -0.972656\t(data_i, data_q): (-0.343750,-0.031250)\n\t3456: o_phase = -9'd256;\t //LUT[3456] \tphase : -1.000000\t(data_i, data_q): (-0.312500,0.000000)\n\t3457: o_phase = +9'd248;\t //LUT[3457] \tphase : 0.968750\t(data_i, data_q): (-0.312500,0.031250)\n\t3458: o_phase = +9'd240;\t //LUT[3458] \tphase : 0.937500\t(data_i, data_q): (-0.312500,0.062500)\n\t3459: o_phase = +9'd232;\t //LUT[3459] \tphase : 0.906250\t(data_i, data_q): (-0.312500,0.093750)\n\t3460: o_phase = +9'd225;\t //LUT[3460] \tphase : 0.878906\t(data_i, data_q): (-0.312500,0.125000)\n\t3461: o_phase = +9'd218;\t //LUT[3461] \tphase : 0.851562\t(data_i, data_q): (-0.312500,0.156250)\n\t3462: o_phase = +9'd212;\t //LUT[3462] \tphase : 0.828125\t(data_i, data_q): (-0.312500,0.187500)\n\t3463: o_phase = +9'd206;\t //LUT[3463] \tphase : 0.804688\t(data_i, data_q): (-0.312500,0.218750)\n\t3464: o_phase = +9'd201;\t //LUT[3464] \tphase : 0.785156\t(data_i, data_q): (-0.312500,0.250000)\n\t3465: o_phase = +9'd196;\t //LUT[3465] \tphase : 0.765625\t(data_i, data_q): (-0.312500,0.281250)\n\t3466: o_phase = +9'd192;\t //LUT[3466] \tphase : 0.750000\t(data_i, data_q): (-0.312500,0.312500)\n\t3467: o_phase = +9'd188;\t //LUT[3467] \tphase : 0.734375\t(data_i, data_q): (-0.312500,0.343750)\n\t3468: o_phase = +9'd185;\t //LUT[3468] \tphase : 0.722656\t(data_i, data_q): (-0.312500,0.375000)\n\t3469: o_phase = +9'd181;\t //LUT[3469] \tphase : 0.707031\t(data_i, data_q): (-0.312500,0.406250)\n\t3470: o_phase = +9'd179;\t //LUT[3470] \tphase : 0.699219\t(data_i, data_q): (-0.312500,0.437500)\n\t3471: o_phase = +9'd176;\t //LUT[3471] \tphase : 0.687500\t(data_i, data_q): (-0.312500,0.468750)\n\t3472: o_phase = +9'd174;\t //LUT[3472] \tphase : 0.679688\t(data_i, data_q): (-0.312500,0.500000)\n\t3473: o_phase = +9'd171;\t //LUT[3473] \tphase : 0.667969\t(data_i, data_q): (-0.312500,0.531250)\n\t3474: o_phase = +9'd169;\t //LUT[3474] \tphase : 0.660156\t(data_i, data_q): (-0.312500,0.562500)\n\t3475: o_phase = +9'd167;\t //LUT[3475] \tphase : 0.652344\t(data_i, data_q): (-0.312500,0.593750)\n\t3476: o_phase = +9'd166;\t //LUT[3476] \tphase : 0.648438\t(data_i, data_q): (-0.312500,0.625000)\n\t3477: o_phase = +9'd164;\t //LUT[3477] \tphase : 0.640625\t(data_i, data_q): (-0.312500,0.656250)\n\t3478: o_phase = +9'd163;\t //LUT[3478] \tphase : 0.636719\t(data_i, data_q): (-0.312500,0.687500)\n\t3479: o_phase = +9'd161;\t //LUT[3479] \tphase : 0.628906\t(data_i, data_q): (-0.312500,0.718750)\n\t3480: o_phase = +9'd160;\t //LUT[3480] \tphase : 0.625000\t(data_i, data_q): (-0.312500,0.750000)\n\t3481: o_phase = +9'd159;\t //LUT[3481] \tphase : 0.621094\t(data_i, data_q): (-0.312500,0.781250)\n\t3482: o_phase = +9'd158;\t //LUT[3482] \tphase : 0.617188\t(data_i, data_q): (-0.312500,0.812500)\n\t3483: o_phase = +9'd157;\t //LUT[3483] \tphase : 0.613281\t(data_i, data_q): (-0.312500,0.843750)\n\t3484: o_phase = +9'd156;\t //LUT[3484] \tphase : 0.609375\t(data_i, data_q): (-0.312500,0.875000)\n\t3485: o_phase = +9'd155;\t //LUT[3485] \tphase : 0.605469\t(data_i, data_q): (-0.312500,0.906250)\n\t3486: o_phase = +9'd154;\t //LUT[3486] \tphase : 0.601562\t(data_i, data_q): (-0.312500,0.937500)\n\t3487: o_phase = +9'd153;\t //LUT[3487] \tphase : 0.597656\t(data_i, data_q): (-0.312500,0.968750)\n\t3488: o_phase = -9'd153;\t //LUT[3488] \tphase : -0.597656\t(data_i, data_q): (-0.312500,-1.000000)\n\t3489: o_phase = -9'd153;\t //LUT[3489] \tphase : -0.597656\t(data_i, data_q): (-0.312500,-0.968750)\n\t3490: o_phase = -9'd154;\t //LUT[3490] \tphase : -0.601562\t(data_i, data_q): (-0.312500,-0.937500)\n\t3491: o_phase = -9'd155;\t //LUT[3491] \tphase : -0.605469\t(data_i, data_q): (-0.312500,-0.906250)\n\t3492: o_phase = -9'd156;\t //LUT[3492] \tphase : -0.609375\t(data_i, data_q): (-0.312500,-0.875000)\n\t3493: o_phase = -9'd157;\t //LUT[3493] \tphase : -0.613281\t(data_i, data_q): (-0.312500,-0.843750)\n\t3494: o_phase = -9'd158;\t //LUT[3494] \tphase : -0.617188\t(data_i, data_q): (-0.312500,-0.812500)\n\t3495: o_phase = -9'd159;\t //LUT[3495] \tphase : -0.621094\t(data_i, data_q): (-0.312500,-0.781250)\n\t3496: o_phase = -9'd160;\t //LUT[3496] \tphase : -0.625000\t(data_i, data_q): (-0.312500,-0.750000)\n\t3497: o_phase = -9'd161;\t //LUT[3497] \tphase : -0.628906\t(data_i, data_q): (-0.312500,-0.718750)\n\t3498: o_phase = -9'd163;\t //LUT[3498] \tphase : -0.636719\t(data_i, data_q): (-0.312500,-0.687500)\n\t3499: o_phase = -9'd164;\t //LUT[3499] \tphase : -0.640625\t(data_i, data_q): (-0.312500,-0.656250)\n\t3500: o_phase = -9'd166;\t //LUT[3500] \tphase : -0.648438\t(data_i, data_q): (-0.312500,-0.625000)\n\t3501: o_phase = -9'd167;\t //LUT[3501] \tphase : -0.652344\t(data_i, data_q): (-0.312500,-0.593750)\n\t3502: o_phase = -9'd169;\t //LUT[3502] \tphase : -0.660156\t(data_i, data_q): (-0.312500,-0.562500)\n\t3503: o_phase = -9'd171;\t //LUT[3503] \tphase : -0.667969\t(data_i, data_q): (-0.312500,-0.531250)\n\t3504: o_phase = -9'd174;\t //LUT[3504] \tphase : -0.679688\t(data_i, data_q): (-0.312500,-0.500000)\n\t3505: o_phase = -9'd176;\t //LUT[3505] \tphase : -0.687500\t(data_i, data_q): (-0.312500,-0.468750)\n\t3506: o_phase = -9'd179;\t //LUT[3506] \tphase : -0.699219\t(data_i, data_q): (-0.312500,-0.437500)\n\t3507: o_phase = -9'd181;\t //LUT[3507] \tphase : -0.707031\t(data_i, data_q): (-0.312500,-0.406250)\n\t3508: o_phase = -9'd185;\t //LUT[3508] \tphase : -0.722656\t(data_i, data_q): (-0.312500,-0.375000)\n\t3509: o_phase = -9'd188;\t //LUT[3509] \tphase : -0.734375\t(data_i, data_q): (-0.312500,-0.343750)\n\t3510: o_phase = -9'd192;\t //LUT[3510] \tphase : -0.750000\t(data_i, data_q): (-0.312500,-0.312500)\n\t3511: o_phase = -9'd196;\t //LUT[3511] \tphase : -0.765625\t(data_i, data_q): (-0.312500,-0.281250)\n\t3512: o_phase = -9'd201;\t //LUT[3512] \tphase : -0.785156\t(data_i, data_q): (-0.312500,-0.250000)\n\t3513: o_phase = -9'd206;\t //LUT[3513] \tphase : -0.804688\t(data_i, data_q): (-0.312500,-0.218750)\n\t3514: o_phase = -9'd212;\t //LUT[3514] \tphase : -0.828125\t(data_i, data_q): (-0.312500,-0.187500)\n\t3515: o_phase = -9'd218;\t //LUT[3515] \tphase : -0.851562\t(data_i, data_q): (-0.312500,-0.156250)\n\t3516: o_phase = -9'd225;\t //LUT[3516] \tphase : -0.878906\t(data_i, data_q): (-0.312500,-0.125000)\n\t3517: o_phase = -9'd232;\t //LUT[3517] \tphase : -0.906250\t(data_i, data_q): (-0.312500,-0.093750)\n\t3518: o_phase = -9'd240;\t //LUT[3518] \tphase : -0.937500\t(data_i, data_q): (-0.312500,-0.062500)\n\t3519: o_phase = -9'd248;\t //LUT[3519] \tphase : -0.968750\t(data_i, data_q): (-0.312500,-0.031250)\n\t3520: o_phase = -9'd256;\t //LUT[3520] \tphase : -1.000000\t(data_i, data_q): (-0.281250,0.000000)\n\t3521: o_phase = +9'd247;\t //LUT[3521] \tphase : 0.964844\t(data_i, data_q): (-0.281250,0.031250)\n\t3522: o_phase = +9'd238;\t //LUT[3522] \tphase : 0.929688\t(data_i, data_q): (-0.281250,0.062500)\n\t3523: o_phase = +9'd230;\t //LUT[3523] \tphase : 0.898438\t(data_i, data_q): (-0.281250,0.093750)\n\t3524: o_phase = +9'd222;\t //LUT[3524] \tphase : 0.867188\t(data_i, data_q): (-0.281250,0.125000)\n\t3525: o_phase = +9'd215;\t //LUT[3525] \tphase : 0.839844\t(data_i, data_q): (-0.281250,0.156250)\n\t3526: o_phase = +9'd208;\t //LUT[3526] \tphase : 0.812500\t(data_i, data_q): (-0.281250,0.187500)\n\t3527: o_phase = +9'd202;\t //LUT[3527] \tphase : 0.789062\t(data_i, data_q): (-0.281250,0.218750)\n\t3528: o_phase = +9'd197;\t //LUT[3528] \tphase : 0.769531\t(data_i, data_q): (-0.281250,0.250000)\n\t3529: o_phase = +9'd192;\t //LUT[3529] \tphase : 0.750000\t(data_i, data_q): (-0.281250,0.281250)\n\t3530: o_phase = +9'd188;\t //LUT[3530] \tphase : 0.734375\t(data_i, data_q): (-0.281250,0.312500)\n\t3531: o_phase = +9'd184;\t //LUT[3531] \tphase : 0.718750\t(data_i, data_q): (-0.281250,0.343750)\n\t3532: o_phase = +9'd180;\t //LUT[3532] \tphase : 0.703125\t(data_i, data_q): (-0.281250,0.375000)\n\t3533: o_phase = +9'd177;\t //LUT[3533] \tphase : 0.691406\t(data_i, data_q): (-0.281250,0.406250)\n\t3534: o_phase = +9'd175;\t //LUT[3534] \tphase : 0.683594\t(data_i, data_q): (-0.281250,0.437500)\n\t3535: o_phase = +9'd172;\t //LUT[3535] \tphase : 0.671875\t(data_i, data_q): (-0.281250,0.468750)\n\t3536: o_phase = +9'd170;\t //LUT[3536] \tphase : 0.664062\t(data_i, data_q): (-0.281250,0.500000)\n\t3537: o_phase = +9'd168;\t //LUT[3537] \tphase : 0.656250\t(data_i, data_q): (-0.281250,0.531250)\n\t3538: o_phase = +9'd166;\t //LUT[3538] \tphase : 0.648438\t(data_i, data_q): (-0.281250,0.562500)\n\t3539: o_phase = +9'd164;\t //LUT[3539] \tphase : 0.640625\t(data_i, data_q): (-0.281250,0.593750)\n\t3540: o_phase = +9'd162;\t //LUT[3540] \tphase : 0.632812\t(data_i, data_q): (-0.281250,0.625000)\n\t3541: o_phase = +9'd161;\t //LUT[3541] \tphase : 0.628906\t(data_i, data_q): (-0.281250,0.656250)\n\t3542: o_phase = +9'd160;\t //LUT[3542] \tphase : 0.625000\t(data_i, data_q): (-0.281250,0.687500)\n\t3543: o_phase = +9'd158;\t //LUT[3543] \tphase : 0.617188\t(data_i, data_q): (-0.281250,0.718750)\n\t3544: o_phase = +9'd157;\t //LUT[3544] \tphase : 0.613281\t(data_i, data_q): (-0.281250,0.750000)\n\t3545: o_phase = +9'd156;\t //LUT[3545] \tphase : 0.609375\t(data_i, data_q): (-0.281250,0.781250)\n\t3546: o_phase = +9'd155;\t //LUT[3546] \tphase : 0.605469\t(data_i, data_q): (-0.281250,0.812500)\n\t3547: o_phase = +9'd154;\t //LUT[3547] \tphase : 0.601562\t(data_i, data_q): (-0.281250,0.843750)\n\t3548: o_phase = +9'd153;\t //LUT[3548] \tphase : 0.597656\t(data_i, data_q): (-0.281250,0.875000)\n\t3549: o_phase = +9'd153;\t //LUT[3549] \tphase : 0.597656\t(data_i, data_q): (-0.281250,0.906250)\n\t3550: o_phase = +9'd152;\t //LUT[3550] \tphase : 0.593750\t(data_i, data_q): (-0.281250,0.937500)\n\t3551: o_phase = +9'd151;\t //LUT[3551] \tphase : 0.589844\t(data_i, data_q): (-0.281250,0.968750)\n\t3552: o_phase = -9'd150;\t //LUT[3552] \tphase : -0.585938\t(data_i, data_q): (-0.281250,-1.000000)\n\t3553: o_phase = -9'd151;\t //LUT[3553] \tphase : -0.589844\t(data_i, data_q): (-0.281250,-0.968750)\n\t3554: o_phase = -9'd152;\t //LUT[3554] \tphase : -0.593750\t(data_i, data_q): (-0.281250,-0.937500)\n\t3555: o_phase = -9'd153;\t //LUT[3555] \tphase : -0.597656\t(data_i, data_q): (-0.281250,-0.906250)\n\t3556: o_phase = -9'd153;\t //LUT[3556] \tphase : -0.597656\t(data_i, data_q): (-0.281250,-0.875000)\n\t3557: o_phase = -9'd154;\t //LUT[3557] \tphase : -0.601562\t(data_i, data_q): (-0.281250,-0.843750)\n\t3558: o_phase = -9'd155;\t //LUT[3558] \tphase : -0.605469\t(data_i, data_q): (-0.281250,-0.812500)\n\t3559: o_phase = -9'd156;\t //LUT[3559] \tphase : -0.609375\t(data_i, data_q): (-0.281250,-0.781250)\n\t3560: o_phase = -9'd157;\t //LUT[3560] \tphase : -0.613281\t(data_i, data_q): (-0.281250,-0.750000)\n\t3561: o_phase = -9'd158;\t //LUT[3561] \tphase : -0.617188\t(data_i, data_q): (-0.281250,-0.718750)\n\t3562: o_phase = -9'd160;\t //LUT[3562] \tphase : -0.625000\t(data_i, data_q): (-0.281250,-0.687500)\n\t3563: o_phase = -9'd161;\t //LUT[3563] \tphase : -0.628906\t(data_i, data_q): (-0.281250,-0.656250)\n\t3564: o_phase = -9'd162;\t //LUT[3564] \tphase : -0.632812\t(data_i, data_q): (-0.281250,-0.625000)\n\t3565: o_phase = -9'd164;\t //LUT[3565] \tphase : -0.640625\t(data_i, data_q): (-0.281250,-0.593750)\n\t3566: o_phase = -9'd166;\t //LUT[3566] \tphase : -0.648438\t(data_i, data_q): (-0.281250,-0.562500)\n\t3567: o_phase = -9'd168;\t //LUT[3567] \tphase : -0.656250\t(data_i, data_q): (-0.281250,-0.531250)\n\t3568: o_phase = -9'd170;\t //LUT[3568] \tphase : -0.664062\t(data_i, data_q): (-0.281250,-0.500000)\n\t3569: o_phase = -9'd172;\t //LUT[3569] \tphase : -0.671875\t(data_i, data_q): (-0.281250,-0.468750)\n\t3570: o_phase = -9'd175;\t //LUT[3570] \tphase : -0.683594\t(data_i, data_q): (-0.281250,-0.437500)\n\t3571: o_phase = -9'd177;\t //LUT[3571] \tphase : -0.691406\t(data_i, data_q): (-0.281250,-0.406250)\n\t3572: o_phase = -9'd180;\t //LUT[3572] \tphase : -0.703125\t(data_i, data_q): (-0.281250,-0.375000)\n\t3573: o_phase = -9'd184;\t //LUT[3573] \tphase : -0.718750\t(data_i, data_q): (-0.281250,-0.343750)\n\t3574: o_phase = -9'd188;\t //LUT[3574] \tphase : -0.734375\t(data_i, data_q): (-0.281250,-0.312500)\n\t3575: o_phase = -9'd192;\t //LUT[3575] \tphase : -0.750000\t(data_i, data_q): (-0.281250,-0.281250)\n\t3576: o_phase = -9'd197;\t //LUT[3576] \tphase : -0.769531\t(data_i, data_q): (-0.281250,-0.250000)\n\t3577: o_phase = -9'd202;\t //LUT[3577] \tphase : -0.789062\t(data_i, data_q): (-0.281250,-0.218750)\n\t3578: o_phase = -9'd208;\t //LUT[3578] \tphase : -0.812500\t(data_i, data_q): (-0.281250,-0.187500)\n\t3579: o_phase = -9'd215;\t //LUT[3579] \tphase : -0.839844\t(data_i, data_q): (-0.281250,-0.156250)\n\t3580: o_phase = -9'd222;\t //LUT[3580] \tphase : -0.867188\t(data_i, data_q): (-0.281250,-0.125000)\n\t3581: o_phase = -9'd230;\t //LUT[3581] \tphase : -0.898438\t(data_i, data_q): (-0.281250,-0.093750)\n\t3582: o_phase = -9'd238;\t //LUT[3582] \tphase : -0.929688\t(data_i, data_q): (-0.281250,-0.062500)\n\t3583: o_phase = -9'd247;\t //LUT[3583] \tphase : -0.964844\t(data_i, data_q): (-0.281250,-0.031250)\n\t3584: o_phase = -9'd256;\t //LUT[3584] \tphase : -1.000000\t(data_i, data_q): (-0.250000,0.000000)\n\t3585: o_phase = +9'd246;\t //LUT[3585] \tphase : 0.960938\t(data_i, data_q): (-0.250000,0.031250)\n\t3586: o_phase = +9'd236;\t //LUT[3586] \tphase : 0.921875\t(data_i, data_q): (-0.250000,0.062500)\n\t3587: o_phase = +9'd227;\t //LUT[3587] \tphase : 0.886719\t(data_i, data_q): (-0.250000,0.093750)\n\t3588: o_phase = +9'd218;\t //LUT[3588] \tphase : 0.851562\t(data_i, data_q): (-0.250000,0.125000)\n\t3589: o_phase = +9'd210;\t //LUT[3589] \tphase : 0.820312\t(data_i, data_q): (-0.250000,0.156250)\n\t3590: o_phase = +9'd204;\t //LUT[3590] \tphase : 0.796875\t(data_i, data_q): (-0.250000,0.187500)\n\t3591: o_phase = +9'd197;\t //LUT[3591] \tphase : 0.769531\t(data_i, data_q): (-0.250000,0.218750)\n\t3592: o_phase = +9'd192;\t //LUT[3592] \tphase : 0.750000\t(data_i, data_q): (-0.250000,0.250000)\n\t3593: o_phase = +9'd187;\t //LUT[3593] \tphase : 0.730469\t(data_i, data_q): (-0.250000,0.281250)\n\t3594: o_phase = +9'd183;\t //LUT[3594] \tphase : 0.714844\t(data_i, data_q): (-0.250000,0.312500)\n\t3595: o_phase = +9'd179;\t //LUT[3595] \tphase : 0.699219\t(data_i, data_q): (-0.250000,0.343750)\n\t3596: o_phase = +9'd176;\t //LUT[3596] \tphase : 0.687500\t(data_i, data_q): (-0.250000,0.375000)\n\t3597: o_phase = +9'd173;\t //LUT[3597] \tphase : 0.675781\t(data_i, data_q): (-0.250000,0.406250)\n\t3598: o_phase = +9'd170;\t //LUT[3598] \tphase : 0.664062\t(data_i, data_q): (-0.250000,0.437500)\n\t3599: o_phase = +9'd168;\t //LUT[3599] \tphase : 0.656250\t(data_i, data_q): (-0.250000,0.468750)\n\t3600: o_phase = +9'd166;\t //LUT[3600] \tphase : 0.648438\t(data_i, data_q): (-0.250000,0.500000)\n\t3601: o_phase = +9'd164;\t //LUT[3601] \tphase : 0.640625\t(data_i, data_q): (-0.250000,0.531250)\n\t3602: o_phase = +9'd162;\t //LUT[3602] \tphase : 0.632812\t(data_i, data_q): (-0.250000,0.562500)\n\t3603: o_phase = +9'd160;\t //LUT[3603] \tphase : 0.625000\t(data_i, data_q): (-0.250000,0.593750)\n\t3604: o_phase = +9'd159;\t //LUT[3604] \tphase : 0.621094\t(data_i, data_q): (-0.250000,0.625000)\n\t3605: o_phase = +9'd158;\t //LUT[3605] \tphase : 0.617188\t(data_i, data_q): (-0.250000,0.656250)\n\t3606: o_phase = +9'd156;\t //LUT[3606] \tphase : 0.609375\t(data_i, data_q): (-0.250000,0.687500)\n\t3607: o_phase = +9'd155;\t //LUT[3607] \tphase : 0.605469\t(data_i, data_q): (-0.250000,0.718750)\n\t3608: o_phase = +9'd154;\t //LUT[3608] \tphase : 0.601562\t(data_i, data_q): (-0.250000,0.750000)\n\t3609: o_phase = +9'd153;\t //LUT[3609] \tphase : 0.597656\t(data_i, data_q): (-0.250000,0.781250)\n\t3610: o_phase = +9'd152;\t //LUT[3610] \tphase : 0.593750\t(data_i, data_q): (-0.250000,0.812500)\n\t3611: o_phase = +9'd151;\t //LUT[3611] \tphase : 0.589844\t(data_i, data_q): (-0.250000,0.843750)\n\t3612: o_phase = +9'd151;\t //LUT[3612] \tphase : 0.589844\t(data_i, data_q): (-0.250000,0.875000)\n\t3613: o_phase = +9'd150;\t //LUT[3613] \tphase : 0.585938\t(data_i, data_q): (-0.250000,0.906250)\n\t3614: o_phase = +9'd149;\t //LUT[3614] \tphase : 0.582031\t(data_i, data_q): (-0.250000,0.937500)\n\t3615: o_phase = +9'd149;\t //LUT[3615] \tphase : 0.582031\t(data_i, data_q): (-0.250000,0.968750)\n\t3616: o_phase = -9'd148;\t //LUT[3616] \tphase : -0.578125\t(data_i, data_q): (-0.250000,-1.000000)\n\t3617: o_phase = -9'd149;\t //LUT[3617] \tphase : -0.582031\t(data_i, data_q): (-0.250000,-0.968750)\n\t3618: o_phase = -9'd149;\t //LUT[3618] \tphase : -0.582031\t(data_i, data_q): (-0.250000,-0.937500)\n\t3619: o_phase = -9'd150;\t //LUT[3619] \tphase : -0.585938\t(data_i, data_q): (-0.250000,-0.906250)\n\t3620: o_phase = -9'd151;\t //LUT[3620] \tphase : -0.589844\t(data_i, data_q): (-0.250000,-0.875000)\n\t3621: o_phase = -9'd151;\t //LUT[3621] \tphase : -0.589844\t(data_i, data_q): (-0.250000,-0.843750)\n\t3622: o_phase = -9'd152;\t //LUT[3622] \tphase : -0.593750\t(data_i, data_q): (-0.250000,-0.812500)\n\t3623: o_phase = -9'd153;\t //LUT[3623] \tphase : -0.597656\t(data_i, data_q): (-0.250000,-0.781250)\n\t3624: o_phase = -9'd154;\t //LUT[3624] \tphase : -0.601562\t(data_i, data_q): (-0.250000,-0.750000)\n\t3625: o_phase = -9'd155;\t //LUT[3625] \tphase : -0.605469\t(data_i, data_q): (-0.250000,-0.718750)\n\t3626: o_phase = -9'd156;\t //LUT[3626] \tphase : -0.609375\t(data_i, data_q): (-0.250000,-0.687500)\n\t3627: o_phase = -9'd158;\t //LUT[3627] \tphase : -0.617188\t(data_i, data_q): (-0.250000,-0.656250)\n\t3628: o_phase = -9'd159;\t //LUT[3628] \tphase : -0.621094\t(data_i, data_q): (-0.250000,-0.625000)\n\t3629: o_phase = -9'd160;\t //LUT[3629] \tphase : -0.625000\t(data_i, data_q): (-0.250000,-0.593750)\n\t3630: o_phase = -9'd162;\t //LUT[3630] \tphase : -0.632812\t(data_i, data_q): (-0.250000,-0.562500)\n\t3631: o_phase = -9'd164;\t //LUT[3631] \tphase : -0.640625\t(data_i, data_q): (-0.250000,-0.531250)\n\t3632: o_phase = -9'd166;\t //LUT[3632] \tphase : -0.648438\t(data_i, data_q): (-0.250000,-0.500000)\n\t3633: o_phase = -9'd168;\t //LUT[3633] \tphase : -0.656250\t(data_i, data_q): (-0.250000,-0.468750)\n\t3634: o_phase = -9'd170;\t //LUT[3634] \tphase : -0.664062\t(data_i, data_q): (-0.250000,-0.437500)\n\t3635: o_phase = -9'd173;\t //LUT[3635] \tphase : -0.675781\t(data_i, data_q): (-0.250000,-0.406250)\n\t3636: o_phase = -9'd176;\t //LUT[3636] \tphase : -0.687500\t(data_i, data_q): (-0.250000,-0.375000)\n\t3637: o_phase = -9'd179;\t //LUT[3637] \tphase : -0.699219\t(data_i, data_q): (-0.250000,-0.343750)\n\t3638: o_phase = -9'd183;\t //LUT[3638] \tphase : -0.714844\t(data_i, data_q): (-0.250000,-0.312500)\n\t3639: o_phase = -9'd187;\t //LUT[3639] \tphase : -0.730469\t(data_i, data_q): (-0.250000,-0.281250)\n\t3640: o_phase = -9'd192;\t //LUT[3640] \tphase : -0.750000\t(data_i, data_q): (-0.250000,-0.250000)\n\t3641: o_phase = -9'd197;\t //LUT[3641] \tphase : -0.769531\t(data_i, data_q): (-0.250000,-0.218750)\n\t3642: o_phase = -9'd204;\t //LUT[3642] \tphase : -0.796875\t(data_i, data_q): (-0.250000,-0.187500)\n\t3643: o_phase = -9'd210;\t //LUT[3643] \tphase : -0.820312\t(data_i, data_q): (-0.250000,-0.156250)\n\t3644: o_phase = -9'd218;\t //LUT[3644] \tphase : -0.851562\t(data_i, data_q): (-0.250000,-0.125000)\n\t3645: o_phase = -9'd227;\t //LUT[3645] \tphase : -0.886719\t(data_i, data_q): (-0.250000,-0.093750)\n\t3646: o_phase = -9'd236;\t //LUT[3646] \tphase : -0.921875\t(data_i, data_q): (-0.250000,-0.062500)\n\t3647: o_phase = -9'd246;\t //LUT[3647] \tphase : -0.960938\t(data_i, data_q): (-0.250000,-0.031250)\n\t3648: o_phase = -9'd256;\t //LUT[3648] \tphase : -1.000000\t(data_i, data_q): (-0.218750,0.000000)\n\t3649: o_phase = +9'd244;\t //LUT[3649] \tphase : 0.953125\t(data_i, data_q): (-0.218750,0.031250)\n\t3650: o_phase = +9'd233;\t //LUT[3650] \tphase : 0.910156\t(data_i, data_q): (-0.218750,0.062500)\n\t3651: o_phase = +9'd223;\t //LUT[3651] \tphase : 0.871094\t(data_i, data_q): (-0.218750,0.093750)\n\t3652: o_phase = +9'd214;\t //LUT[3652] \tphase : 0.835938\t(data_i, data_q): (-0.218750,0.125000)\n\t3653: o_phase = +9'd205;\t //LUT[3653] \tphase : 0.800781\t(data_i, data_q): (-0.218750,0.156250)\n\t3654: o_phase = +9'd198;\t //LUT[3654] \tphase : 0.773438\t(data_i, data_q): (-0.218750,0.187500)\n\t3655: o_phase = +9'd192;\t //LUT[3655] \tphase : 0.750000\t(data_i, data_q): (-0.218750,0.218750)\n\t3656: o_phase = +9'd187;\t //LUT[3656] \tphase : 0.730469\t(data_i, data_q): (-0.218750,0.250000)\n\t3657: o_phase = +9'd182;\t //LUT[3657] \tphase : 0.710938\t(data_i, data_q): (-0.218750,0.281250)\n\t3658: o_phase = +9'd178;\t //LUT[3658] \tphase : 0.695312\t(data_i, data_q): (-0.218750,0.312500)\n\t3659: o_phase = +9'd174;\t //LUT[3659] \tphase : 0.679688\t(data_i, data_q): (-0.218750,0.343750)\n\t3660: o_phase = +9'd171;\t //LUT[3660] \tphase : 0.667969\t(data_i, data_q): (-0.218750,0.375000)\n\t3661: o_phase = +9'd168;\t //LUT[3661] \tphase : 0.656250\t(data_i, data_q): (-0.218750,0.406250)\n\t3662: o_phase = +9'd166;\t //LUT[3662] \tphase : 0.648438\t(data_i, data_q): (-0.218750,0.437500)\n\t3663: o_phase = +9'd164;\t //LUT[3663] \tphase : 0.640625\t(data_i, data_q): (-0.218750,0.468750)\n\t3664: o_phase = +9'd162;\t //LUT[3664] \tphase : 0.632812\t(data_i, data_q): (-0.218750,0.500000)\n\t3665: o_phase = +9'd160;\t //LUT[3665] \tphase : 0.625000\t(data_i, data_q): (-0.218750,0.531250)\n\t3666: o_phase = +9'd158;\t //LUT[3666] \tphase : 0.617188\t(data_i, data_q): (-0.218750,0.562500)\n\t3667: o_phase = +9'd157;\t //LUT[3667] \tphase : 0.613281\t(data_i, data_q): (-0.218750,0.593750)\n\t3668: o_phase = +9'd155;\t //LUT[3668] \tphase : 0.605469\t(data_i, data_q): (-0.218750,0.625000)\n\t3669: o_phase = +9'd154;\t //LUT[3669] \tphase : 0.601562\t(data_i, data_q): (-0.218750,0.656250)\n\t3670: o_phase = +9'd153;\t //LUT[3670] \tphase : 0.597656\t(data_i, data_q): (-0.218750,0.687500)\n\t3671: o_phase = +9'd152;\t //LUT[3671] \tphase : 0.593750\t(data_i, data_q): (-0.218750,0.718750)\n\t3672: o_phase = +9'd151;\t //LUT[3672] \tphase : 0.589844\t(data_i, data_q): (-0.218750,0.750000)\n\t3673: o_phase = +9'd150;\t //LUT[3673] \tphase : 0.585938\t(data_i, data_q): (-0.218750,0.781250)\n\t3674: o_phase = +9'd149;\t //LUT[3674] \tphase : 0.582031\t(data_i, data_q): (-0.218750,0.812500)\n\t3675: o_phase = +9'd149;\t //LUT[3675] \tphase : 0.582031\t(data_i, data_q): (-0.218750,0.843750)\n\t3676: o_phase = +9'd148;\t //LUT[3676] \tphase : 0.578125\t(data_i, data_q): (-0.218750,0.875000)\n\t3677: o_phase = +9'd147;\t //LUT[3677] \tphase : 0.574219\t(data_i, data_q): (-0.218750,0.906250)\n\t3678: o_phase = +9'd147;\t //LUT[3678] \tphase : 0.574219\t(data_i, data_q): (-0.218750,0.937500)\n\t3679: o_phase = +9'd146;\t //LUT[3679] \tphase : 0.570312\t(data_i, data_q): (-0.218750,0.968750)\n\t3680: o_phase = -9'd146;\t //LUT[3680] \tphase : -0.570312\t(data_i, data_q): (-0.218750,-1.000000)\n\t3681: o_phase = -9'd146;\t //LUT[3681] \tphase : -0.570312\t(data_i, data_q): (-0.218750,-0.968750)\n\t3682: o_phase = -9'd147;\t //LUT[3682] \tphase : -0.574219\t(data_i, data_q): (-0.218750,-0.937500)\n\t3683: o_phase = -9'd147;\t //LUT[3683] \tphase : -0.574219\t(data_i, data_q): (-0.218750,-0.906250)\n\t3684: o_phase = -9'd148;\t //LUT[3684] \tphase : -0.578125\t(data_i, data_q): (-0.218750,-0.875000)\n\t3685: o_phase = -9'd149;\t //LUT[3685] \tphase : -0.582031\t(data_i, data_q): (-0.218750,-0.843750)\n\t3686: o_phase = -9'd149;\t //LUT[3686] \tphase : -0.582031\t(data_i, data_q): (-0.218750,-0.812500)\n\t3687: o_phase = -9'd150;\t //LUT[3687] \tphase : -0.585938\t(data_i, data_q): (-0.218750,-0.781250)\n\t3688: o_phase = -9'd151;\t //LUT[3688] \tphase : -0.589844\t(data_i, data_q): (-0.218750,-0.750000)\n\t3689: o_phase = -9'd152;\t //LUT[3689] \tphase : -0.593750\t(data_i, data_q): (-0.218750,-0.718750)\n\t3690: o_phase = -9'd153;\t //LUT[3690] \tphase : -0.597656\t(data_i, data_q): (-0.218750,-0.687500)\n\t3691: o_phase = -9'd154;\t //LUT[3691] \tphase : -0.601562\t(data_i, data_q): (-0.218750,-0.656250)\n\t3692: o_phase = -9'd155;\t //LUT[3692] \tphase : -0.605469\t(data_i, data_q): (-0.218750,-0.625000)\n\t3693: o_phase = -9'd157;\t //LUT[3693] \tphase : -0.613281\t(data_i, data_q): (-0.218750,-0.593750)\n\t3694: o_phase = -9'd158;\t //LUT[3694] \tphase : -0.617188\t(data_i, data_q): (-0.218750,-0.562500)\n\t3695: o_phase = -9'd160;\t //LUT[3695] \tphase : -0.625000\t(data_i, data_q): (-0.218750,-0.531250)\n\t3696: o_phase = -9'd162;\t //LUT[3696] \tphase : -0.632812\t(data_i, data_q): (-0.218750,-0.500000)\n\t3697: o_phase = -9'd164;\t //LUT[3697] \tphase : -0.640625\t(data_i, data_q): (-0.218750,-0.468750)\n\t3698: o_phase = -9'd166;\t //LUT[3698] \tphase : -0.648438\t(data_i, data_q): (-0.218750,-0.437500)\n\t3699: o_phase = -9'd168;\t //LUT[3699] \tphase : -0.656250\t(data_i, data_q): (-0.218750,-0.406250)\n\t3700: o_phase = -9'd171;\t //LUT[3700] \tphase : -0.667969\t(data_i, data_q): (-0.218750,-0.375000)\n\t3701: o_phase = -9'd174;\t //LUT[3701] \tphase : -0.679688\t(data_i, data_q): (-0.218750,-0.343750)\n\t3702: o_phase = -9'd178;\t //LUT[3702] \tphase : -0.695312\t(data_i, data_q): (-0.218750,-0.312500)\n\t3703: o_phase = -9'd182;\t //LUT[3703] \tphase : -0.710938\t(data_i, data_q): (-0.218750,-0.281250)\n\t3704: o_phase = -9'd187;\t //LUT[3704] \tphase : -0.730469\t(data_i, data_q): (-0.218750,-0.250000)\n\t3705: o_phase = -9'd192;\t //LUT[3705] \tphase : -0.750000\t(data_i, data_q): (-0.218750,-0.218750)\n\t3706: o_phase = -9'd198;\t //LUT[3706] \tphase : -0.773438\t(data_i, data_q): (-0.218750,-0.187500)\n\t3707: o_phase = -9'd205;\t //LUT[3707] \tphase : -0.800781\t(data_i, data_q): (-0.218750,-0.156250)\n\t3708: o_phase = -9'd214;\t //LUT[3708] \tphase : -0.835938\t(data_i, data_q): (-0.218750,-0.125000)\n\t3709: o_phase = -9'd223;\t //LUT[3709] \tphase : -0.871094\t(data_i, data_q): (-0.218750,-0.093750)\n\t3710: o_phase = -9'd233;\t //LUT[3710] \tphase : -0.910156\t(data_i, data_q): (-0.218750,-0.062500)\n\t3711: o_phase = -9'd244;\t //LUT[3711] \tphase : -0.953125\t(data_i, data_q): (-0.218750,-0.031250)\n\t3712: o_phase = -9'd256;\t //LUT[3712] \tphase : -1.000000\t(data_i, data_q): (-0.187500,0.000000)\n\t3713: o_phase = +9'd243;\t //LUT[3713] \tphase : 0.949219\t(data_i, data_q): (-0.187500,0.031250)\n\t3714: o_phase = +9'd230;\t //LUT[3714] \tphase : 0.898438\t(data_i, data_q): (-0.187500,0.062500)\n\t3715: o_phase = +9'd218;\t //LUT[3715] \tphase : 0.851562\t(data_i, data_q): (-0.187500,0.093750)\n\t3716: o_phase = +9'd208;\t //LUT[3716] \tphase : 0.812500\t(data_i, data_q): (-0.187500,0.125000)\n\t3717: o_phase = +9'd199;\t //LUT[3717] \tphase : 0.777344\t(data_i, data_q): (-0.187500,0.156250)\n\t3718: o_phase = +9'd192;\t //LUT[3718] \tphase : 0.750000\t(data_i, data_q): (-0.187500,0.187500)\n\t3719: o_phase = +9'd186;\t //LUT[3719] \tphase : 0.726562\t(data_i, data_q): (-0.187500,0.218750)\n\t3720: o_phase = +9'd180;\t //LUT[3720] \tphase : 0.703125\t(data_i, data_q): (-0.187500,0.250000)\n\t3721: o_phase = +9'd176;\t //LUT[3721] \tphase : 0.687500\t(data_i, data_q): (-0.187500,0.281250)\n\t3722: o_phase = +9'd172;\t //LUT[3722] \tphase : 0.671875\t(data_i, data_q): (-0.187500,0.312500)\n\t3723: o_phase = +9'd169;\t //LUT[3723] \tphase : 0.660156\t(data_i, data_q): (-0.187500,0.343750)\n\t3724: o_phase = +9'd166;\t //LUT[3724] \tphase : 0.648438\t(data_i, data_q): (-0.187500,0.375000)\n\t3725: o_phase = +9'd163;\t //LUT[3725] \tphase : 0.636719\t(data_i, data_q): (-0.187500,0.406250)\n\t3726: o_phase = +9'd161;\t //LUT[3726] \tphase : 0.628906\t(data_i, data_q): (-0.187500,0.437500)\n\t3727: o_phase = +9'd159;\t //LUT[3727] \tphase : 0.621094\t(data_i, data_q): (-0.187500,0.468750)\n\t3728: o_phase = +9'd157;\t //LUT[3728] \tphase : 0.613281\t(data_i, data_q): (-0.187500,0.500000)\n\t3729: o_phase = +9'd156;\t //LUT[3729] \tphase : 0.609375\t(data_i, data_q): (-0.187500,0.531250)\n\t3730: o_phase = +9'd154;\t //LUT[3730] \tphase : 0.601562\t(data_i, data_q): (-0.187500,0.562500)\n\t3731: o_phase = +9'd153;\t //LUT[3731] \tphase : 0.597656\t(data_i, data_q): (-0.187500,0.593750)\n\t3732: o_phase = +9'd152;\t //LUT[3732] \tphase : 0.593750\t(data_i, data_q): (-0.187500,0.625000)\n\t3733: o_phase = +9'd151;\t //LUT[3733] \tphase : 0.589844\t(data_i, data_q): (-0.187500,0.656250)\n\t3734: o_phase = +9'd150;\t //LUT[3734] \tphase : 0.585938\t(data_i, data_q): (-0.187500,0.687500)\n\t3735: o_phase = +9'd149;\t //LUT[3735] \tphase : 0.582031\t(data_i, data_q): (-0.187500,0.718750)\n\t3736: o_phase = +9'd148;\t //LUT[3736] \tphase : 0.578125\t(data_i, data_q): (-0.187500,0.750000)\n\t3737: o_phase = +9'd147;\t //LUT[3737] \tphase : 0.574219\t(data_i, data_q): (-0.187500,0.781250)\n\t3738: o_phase = +9'd146;\t //LUT[3738] \tphase : 0.570312\t(data_i, data_q): (-0.187500,0.812500)\n\t3739: o_phase = +9'd146;\t //LUT[3739] \tphase : 0.570312\t(data_i, data_q): (-0.187500,0.843750)\n\t3740: o_phase = +9'd145;\t //LUT[3740] \tphase : 0.566406\t(data_i, data_q): (-0.187500,0.875000)\n\t3741: o_phase = +9'd145;\t //LUT[3741] \tphase : 0.566406\t(data_i, data_q): (-0.187500,0.906250)\n\t3742: o_phase = +9'd144;\t //LUT[3742] \tphase : 0.562500\t(data_i, data_q): (-0.187500,0.937500)\n\t3743: o_phase = +9'd144;\t //LUT[3743] \tphase : 0.562500\t(data_i, data_q): (-0.187500,0.968750)\n\t3744: o_phase = -9'd143;\t //LUT[3744] \tphase : -0.558594\t(data_i, data_q): (-0.187500,-1.000000)\n\t3745: o_phase = -9'd144;\t //LUT[3745] \tphase : -0.562500\t(data_i, data_q): (-0.187500,-0.968750)\n\t3746: o_phase = -9'd144;\t //LUT[3746] \tphase : -0.562500\t(data_i, data_q): (-0.187500,-0.937500)\n\t3747: o_phase = -9'd145;\t //LUT[3747] \tphase : -0.566406\t(data_i, data_q): (-0.187500,-0.906250)\n\t3748: o_phase = -9'd145;\t //LUT[3748] \tphase : -0.566406\t(data_i, data_q): (-0.187500,-0.875000)\n\t3749: o_phase = -9'd146;\t //LUT[3749] \tphase : -0.570312\t(data_i, data_q): (-0.187500,-0.843750)\n\t3750: o_phase = -9'd146;\t //LUT[3750] \tphase : -0.570312\t(data_i, data_q): (-0.187500,-0.812500)\n\t3751: o_phase = -9'd147;\t //LUT[3751] \tphase : -0.574219\t(data_i, data_q): (-0.187500,-0.781250)\n\t3752: o_phase = -9'd148;\t //LUT[3752] \tphase : -0.578125\t(data_i, data_q): (-0.187500,-0.750000)\n\t3753: o_phase = -9'd149;\t //LUT[3753] \tphase : -0.582031\t(data_i, data_q): (-0.187500,-0.718750)\n\t3754: o_phase = -9'd150;\t //LUT[3754] \tphase : -0.585938\t(data_i, data_q): (-0.187500,-0.687500)\n\t3755: o_phase = -9'd151;\t //LUT[3755] \tphase : -0.589844\t(data_i, data_q): (-0.187500,-0.656250)\n\t3756: o_phase = -9'd152;\t //LUT[3756] \tphase : -0.593750\t(data_i, data_q): (-0.187500,-0.625000)\n\t3757: o_phase = -9'd153;\t //LUT[3757] \tphase : -0.597656\t(data_i, data_q): (-0.187500,-0.593750)\n\t3758: o_phase = -9'd154;\t //LUT[3758] \tphase : -0.601562\t(data_i, data_q): (-0.187500,-0.562500)\n\t3759: o_phase = -9'd156;\t //LUT[3759] \tphase : -0.609375\t(data_i, data_q): (-0.187500,-0.531250)\n\t3760: o_phase = -9'd157;\t //LUT[3760] \tphase : -0.613281\t(data_i, data_q): (-0.187500,-0.500000)\n\t3761: o_phase = -9'd159;\t //LUT[3761] \tphase : -0.621094\t(data_i, data_q): (-0.187500,-0.468750)\n\t3762: o_phase = -9'd161;\t //LUT[3762] \tphase : -0.628906\t(data_i, data_q): (-0.187500,-0.437500)\n\t3763: o_phase = -9'd163;\t //LUT[3763] \tphase : -0.636719\t(data_i, data_q): (-0.187500,-0.406250)\n\t3764: o_phase = -9'd166;\t //LUT[3764] \tphase : -0.648438\t(data_i, data_q): (-0.187500,-0.375000)\n\t3765: o_phase = -9'd169;\t //LUT[3765] \tphase : -0.660156\t(data_i, data_q): (-0.187500,-0.343750)\n\t3766: o_phase = -9'd172;\t //LUT[3766] \tphase : -0.671875\t(data_i, data_q): (-0.187500,-0.312500)\n\t3767: o_phase = -9'd176;\t //LUT[3767] \tphase : -0.687500\t(data_i, data_q): (-0.187500,-0.281250)\n\t3768: o_phase = -9'd180;\t //LUT[3768] \tphase : -0.703125\t(data_i, data_q): (-0.187500,-0.250000)\n\t3769: o_phase = -9'd186;\t //LUT[3769] \tphase : -0.726562\t(data_i, data_q): (-0.187500,-0.218750)\n\t3770: o_phase = -9'd192;\t //LUT[3770] \tphase : -0.750000\t(data_i, data_q): (-0.187500,-0.187500)\n\t3771: o_phase = -9'd199;\t //LUT[3771] \tphase : -0.777344\t(data_i, data_q): (-0.187500,-0.156250)\n\t3772: o_phase = -9'd208;\t //LUT[3772] \tphase : -0.812500\t(data_i, data_q): (-0.187500,-0.125000)\n\t3773: o_phase = -9'd218;\t //LUT[3773] \tphase : -0.851562\t(data_i, data_q): (-0.187500,-0.093750)\n\t3774: o_phase = -9'd230;\t //LUT[3774] \tphase : -0.898438\t(data_i, data_q): (-0.187500,-0.062500)\n\t3775: o_phase = -9'd243;\t //LUT[3775] \tphase : -0.949219\t(data_i, data_q): (-0.187500,-0.031250)\n\t3776: o_phase = -9'd256;\t //LUT[3776] \tphase : -1.000000\t(data_i, data_q): (-0.156250,0.000000)\n\t3777: o_phase = +9'd240;\t //LUT[3777] \tphase : 0.937500\t(data_i, data_q): (-0.156250,0.031250)\n\t3778: o_phase = +9'd225;\t //LUT[3778] \tphase : 0.878906\t(data_i, data_q): (-0.156250,0.062500)\n\t3779: o_phase = +9'd212;\t //LUT[3779] \tphase : 0.828125\t(data_i, data_q): (-0.156250,0.093750)\n\t3780: o_phase = +9'd201;\t //LUT[3780] \tphase : 0.785156\t(data_i, data_q): (-0.156250,0.125000)\n\t3781: o_phase = +9'd192;\t //LUT[3781] \tphase : 0.750000\t(data_i, data_q): (-0.156250,0.156250)\n\t3782: o_phase = +9'd185;\t //LUT[3782] \tphase : 0.722656\t(data_i, data_q): (-0.156250,0.187500)\n\t3783: o_phase = +9'd179;\t //LUT[3783] \tphase : 0.699219\t(data_i, data_q): (-0.156250,0.218750)\n\t3784: o_phase = +9'd174;\t //LUT[3784] \tphase : 0.679688\t(data_i, data_q): (-0.156250,0.250000)\n\t3785: o_phase = +9'd169;\t //LUT[3785] \tphase : 0.660156\t(data_i, data_q): (-0.156250,0.281250)\n\t3786: o_phase = +9'd166;\t //LUT[3786] \tphase : 0.648438\t(data_i, data_q): (-0.156250,0.312500)\n\t3787: o_phase = +9'd163;\t //LUT[3787] \tphase : 0.636719\t(data_i, data_q): (-0.156250,0.343750)\n\t3788: o_phase = +9'd160;\t //LUT[3788] \tphase : 0.625000\t(data_i, data_q): (-0.156250,0.375000)\n\t3789: o_phase = +9'd158;\t //LUT[3789] \tphase : 0.617188\t(data_i, data_q): (-0.156250,0.406250)\n\t3790: o_phase = +9'd156;\t //LUT[3790] \tphase : 0.609375\t(data_i, data_q): (-0.156250,0.437500)\n\t3791: o_phase = +9'd154;\t //LUT[3791] \tphase : 0.601562\t(data_i, data_q): (-0.156250,0.468750)\n\t3792: o_phase = +9'd153;\t //LUT[3792] \tphase : 0.597656\t(data_i, data_q): (-0.156250,0.500000)\n\t3793: o_phase = +9'd151;\t //LUT[3793] \tphase : 0.589844\t(data_i, data_q): (-0.156250,0.531250)\n\t3794: o_phase = +9'd150;\t //LUT[3794] \tphase : 0.585938\t(data_i, data_q): (-0.156250,0.562500)\n\t3795: o_phase = +9'd149;\t //LUT[3795] \tphase : 0.582031\t(data_i, data_q): (-0.156250,0.593750)\n\t3796: o_phase = +9'd148;\t //LUT[3796] \tphase : 0.578125\t(data_i, data_q): (-0.156250,0.625000)\n\t3797: o_phase = +9'd147;\t //LUT[3797] \tphase : 0.574219\t(data_i, data_q): (-0.156250,0.656250)\n\t3798: o_phase = +9'd146;\t //LUT[3798] \tphase : 0.570312\t(data_i, data_q): (-0.156250,0.687500)\n\t3799: o_phase = +9'd145;\t //LUT[3799] \tphase : 0.566406\t(data_i, data_q): (-0.156250,0.718750)\n\t3800: o_phase = +9'd145;\t //LUT[3800] \tphase : 0.566406\t(data_i, data_q): (-0.156250,0.750000)\n\t3801: o_phase = +9'd144;\t //LUT[3801] \tphase : 0.562500\t(data_i, data_q): (-0.156250,0.781250)\n\t3802: o_phase = +9'd143;\t //LUT[3802] \tphase : 0.558594\t(data_i, data_q): (-0.156250,0.812500)\n\t3803: o_phase = +9'd143;\t //LUT[3803] \tphase : 0.558594\t(data_i, data_q): (-0.156250,0.843750)\n\t3804: o_phase = +9'd142;\t //LUT[3804] \tphase : 0.554688\t(data_i, data_q): (-0.156250,0.875000)\n\t3805: o_phase = +9'd142;\t //LUT[3805] \tphase : 0.554688\t(data_i, data_q): (-0.156250,0.906250)\n\t3806: o_phase = +9'd141;\t //LUT[3806] \tphase : 0.550781\t(data_i, data_q): (-0.156250,0.937500)\n\t3807: o_phase = +9'd141;\t //LUT[3807] \tphase : 0.550781\t(data_i, data_q): (-0.156250,0.968750)\n\t3808: o_phase = -9'd141;\t //LUT[3808] \tphase : -0.550781\t(data_i, data_q): (-0.156250,-1.000000)\n\t3809: o_phase = -9'd141;\t //LUT[3809] \tphase : -0.550781\t(data_i, data_q): (-0.156250,-0.968750)\n\t3810: o_phase = -9'd141;\t //LUT[3810] \tphase : -0.550781\t(data_i, data_q): (-0.156250,-0.937500)\n\t3811: o_phase = -9'd142;\t //LUT[3811] \tphase : -0.554688\t(data_i, data_q): (-0.156250,-0.906250)\n\t3812: o_phase = -9'd142;\t //LUT[3812] \tphase : -0.554688\t(data_i, data_q): (-0.156250,-0.875000)\n\t3813: o_phase = -9'd143;\t //LUT[3813] \tphase : -0.558594\t(data_i, data_q): (-0.156250,-0.843750)\n\t3814: o_phase = -9'd143;\t //LUT[3814] \tphase : -0.558594\t(data_i, data_q): (-0.156250,-0.812500)\n\t3815: o_phase = -9'd144;\t //LUT[3815] \tphase : -0.562500\t(data_i, data_q): (-0.156250,-0.781250)\n\t3816: o_phase = -9'd145;\t //LUT[3816] \tphase : -0.566406\t(data_i, data_q): (-0.156250,-0.750000)\n\t3817: o_phase = -9'd145;\t //LUT[3817] \tphase : -0.566406\t(data_i, data_q): (-0.156250,-0.718750)\n\t3818: o_phase = -9'd146;\t //LUT[3818] \tphase : -0.570312\t(data_i, data_q): (-0.156250,-0.687500)\n\t3819: o_phase = -9'd147;\t //LUT[3819] \tphase : -0.574219\t(data_i, data_q): (-0.156250,-0.656250)\n\t3820: o_phase = -9'd148;\t //LUT[3820] \tphase : -0.578125\t(data_i, data_q): (-0.156250,-0.625000)\n\t3821: o_phase = -9'd149;\t //LUT[3821] \tphase : -0.582031\t(data_i, data_q): (-0.156250,-0.593750)\n\t3822: o_phase = -9'd150;\t //LUT[3822] \tphase : -0.585938\t(data_i, data_q): (-0.156250,-0.562500)\n\t3823: o_phase = -9'd151;\t //LUT[3823] \tphase : -0.589844\t(data_i, data_q): (-0.156250,-0.531250)\n\t3824: o_phase = -9'd153;\t //LUT[3824] \tphase : -0.597656\t(data_i, data_q): (-0.156250,-0.500000)\n\t3825: o_phase = -9'd154;\t //LUT[3825] \tphase : -0.601562\t(data_i, data_q): (-0.156250,-0.468750)\n\t3826: o_phase = -9'd156;\t //LUT[3826] \tphase : -0.609375\t(data_i, data_q): (-0.156250,-0.437500)\n\t3827: o_phase = -9'd158;\t //LUT[3827] \tphase : -0.617188\t(data_i, data_q): (-0.156250,-0.406250)\n\t3828: o_phase = -9'd160;\t //LUT[3828] \tphase : -0.625000\t(data_i, data_q): (-0.156250,-0.375000)\n\t3829: o_phase = -9'd163;\t //LUT[3829] \tphase : -0.636719\t(data_i, data_q): (-0.156250,-0.343750)\n\t3830: o_phase = -9'd166;\t //LUT[3830] \tphase : -0.648438\t(data_i, data_q): (-0.156250,-0.312500)\n\t3831: o_phase = -9'd169;\t //LUT[3831] \tphase : -0.660156\t(data_i, data_q): (-0.156250,-0.281250)\n\t3832: o_phase = -9'd174;\t //LUT[3832] \tphase : -0.679688\t(data_i, data_q): (-0.156250,-0.250000)\n\t3833: o_phase = -9'd179;\t //LUT[3833] \tphase : -0.699219\t(data_i, data_q): (-0.156250,-0.218750)\n\t3834: o_phase = -9'd185;\t //LUT[3834] \tphase : -0.722656\t(data_i, data_q): (-0.156250,-0.187500)\n\t3835: o_phase = -9'd192;\t //LUT[3835] \tphase : -0.750000\t(data_i, data_q): (-0.156250,-0.156250)\n\t3836: o_phase = -9'd201;\t //LUT[3836] \tphase : -0.785156\t(data_i, data_q): (-0.156250,-0.125000)\n\t3837: o_phase = -9'd212;\t //LUT[3837] \tphase : -0.828125\t(data_i, data_q): (-0.156250,-0.093750)\n\t3838: o_phase = -9'd225;\t //LUT[3838] \tphase : -0.878906\t(data_i, data_q): (-0.156250,-0.062500)\n\t3839: o_phase = -9'd240;\t //LUT[3839] \tphase : -0.937500\t(data_i, data_q): (-0.156250,-0.031250)\n\t3840: o_phase = -9'd256;\t //LUT[3840] \tphase : -1.000000\t(data_i, data_q): (-0.125000,0.000000)\n\t3841: o_phase = +9'd236;\t //LUT[3841] \tphase : 0.921875\t(data_i, data_q): (-0.125000,0.031250)\n\t3842: o_phase = +9'd218;\t //LUT[3842] \tphase : 0.851562\t(data_i, data_q): (-0.125000,0.062500)\n\t3843: o_phase = +9'd204;\t //LUT[3843] \tphase : 0.796875\t(data_i, data_q): (-0.125000,0.093750)\n\t3844: o_phase = +9'd192;\t //LUT[3844] \tphase : 0.750000\t(data_i, data_q): (-0.125000,0.125000)\n\t3845: o_phase = +9'd183;\t //LUT[3845] \tphase : 0.714844\t(data_i, data_q): (-0.125000,0.156250)\n\t3846: o_phase = +9'd176;\t //LUT[3846] \tphase : 0.687500\t(data_i, data_q): (-0.125000,0.187500)\n\t3847: o_phase = +9'd170;\t //LUT[3847] \tphase : 0.664062\t(data_i, data_q): (-0.125000,0.218750)\n\t3848: o_phase = +9'd166;\t //LUT[3848] \tphase : 0.648438\t(data_i, data_q): (-0.125000,0.250000)\n\t3849: o_phase = +9'd162;\t //LUT[3849] \tphase : 0.632812\t(data_i, data_q): (-0.125000,0.281250)\n\t3850: o_phase = +9'd159;\t //LUT[3850] \tphase : 0.621094\t(data_i, data_q): (-0.125000,0.312500)\n\t3851: o_phase = +9'd156;\t //LUT[3851] \tphase : 0.609375\t(data_i, data_q): (-0.125000,0.343750)\n\t3852: o_phase = +9'd154;\t //LUT[3852] \tphase : 0.601562\t(data_i, data_q): (-0.125000,0.375000)\n\t3853: o_phase = +9'd152;\t //LUT[3853] \tphase : 0.593750\t(data_i, data_q): (-0.125000,0.406250)\n\t3854: o_phase = +9'd151;\t //LUT[3854] \tphase : 0.589844\t(data_i, data_q): (-0.125000,0.437500)\n\t3855: o_phase = +9'd149;\t //LUT[3855] \tphase : 0.582031\t(data_i, data_q): (-0.125000,0.468750)\n\t3856: o_phase = +9'd148;\t //LUT[3856] \tphase : 0.578125\t(data_i, data_q): (-0.125000,0.500000)\n\t3857: o_phase = +9'd147;\t //LUT[3857] \tphase : 0.574219\t(data_i, data_q): (-0.125000,0.531250)\n\t3858: o_phase = +9'd146;\t //LUT[3858] \tphase : 0.570312\t(data_i, data_q): (-0.125000,0.562500)\n\t3859: o_phase = +9'd145;\t //LUT[3859] \tphase : 0.566406\t(data_i, data_q): (-0.125000,0.593750)\n\t3860: o_phase = +9'd144;\t //LUT[3860] \tphase : 0.562500\t(data_i, data_q): (-0.125000,0.625000)\n\t3861: o_phase = +9'd143;\t //LUT[3861] \tphase : 0.558594\t(data_i, data_q): (-0.125000,0.656250)\n\t3862: o_phase = +9'd143;\t //LUT[3862] \tphase : 0.558594\t(data_i, data_q): (-0.125000,0.687500)\n\t3863: o_phase = +9'd142;\t //LUT[3863] \tphase : 0.554688\t(data_i, data_q): (-0.125000,0.718750)\n\t3864: o_phase = +9'd141;\t //LUT[3864] \tphase : 0.550781\t(data_i, data_q): (-0.125000,0.750000)\n\t3865: o_phase = +9'd141;\t //LUT[3865] \tphase : 0.550781\t(data_i, data_q): (-0.125000,0.781250)\n\t3866: o_phase = +9'd140;\t //LUT[3866] \tphase : 0.546875\t(data_i, data_q): (-0.125000,0.812500)\n\t3867: o_phase = +9'd140;\t //LUT[3867] \tphase : 0.546875\t(data_i, data_q): (-0.125000,0.843750)\n\t3868: o_phase = +9'd140;\t //LUT[3868] \tphase : 0.546875\t(data_i, data_q): (-0.125000,0.875000)\n\t3869: o_phase = +9'd139;\t //LUT[3869] \tphase : 0.542969\t(data_i, data_q): (-0.125000,0.906250)\n\t3870: o_phase = +9'd139;\t //LUT[3870] \tphase : 0.542969\t(data_i, data_q): (-0.125000,0.937500)\n\t3871: o_phase = +9'd138;\t //LUT[3871] \tphase : 0.539062\t(data_i, data_q): (-0.125000,0.968750)\n\t3872: o_phase = -9'd138;\t //LUT[3872] \tphase : -0.539062\t(data_i, data_q): (-0.125000,-1.000000)\n\t3873: o_phase = -9'd138;\t //LUT[3873] \tphase : -0.539062\t(data_i, data_q): (-0.125000,-0.968750)\n\t3874: o_phase = -9'd139;\t //LUT[3874] \tphase : -0.542969\t(data_i, data_q): (-0.125000,-0.937500)\n\t3875: o_phase = -9'd139;\t //LUT[3875] \tphase : -0.542969\t(data_i, data_q): (-0.125000,-0.906250)\n\t3876: o_phase = -9'd140;\t //LUT[3876] \tphase : -0.546875\t(data_i, data_q): (-0.125000,-0.875000)\n\t3877: o_phase = -9'd140;\t //LUT[3877] \tphase : -0.546875\t(data_i, data_q): (-0.125000,-0.843750)\n\t3878: o_phase = -9'd140;\t //LUT[3878] \tphase : -0.546875\t(data_i, data_q): (-0.125000,-0.812500)\n\t3879: o_phase = -9'd141;\t //LUT[3879] \tphase : -0.550781\t(data_i, data_q): (-0.125000,-0.781250)\n\t3880: o_phase = -9'd141;\t //LUT[3880] \tphase : -0.550781\t(data_i, data_q): (-0.125000,-0.750000)\n\t3881: o_phase = -9'd142;\t //LUT[3881] \tphase : -0.554688\t(data_i, data_q): (-0.125000,-0.718750)\n\t3882: o_phase = -9'd143;\t //LUT[3882] \tphase : -0.558594\t(data_i, data_q): (-0.125000,-0.687500)\n\t3883: o_phase = -9'd143;\t //LUT[3883] \tphase : -0.558594\t(data_i, data_q): (-0.125000,-0.656250)\n\t3884: o_phase = -9'd144;\t //LUT[3884] \tphase : -0.562500\t(data_i, data_q): (-0.125000,-0.625000)\n\t3885: o_phase = -9'd145;\t //LUT[3885] \tphase : -0.566406\t(data_i, data_q): (-0.125000,-0.593750)\n\t3886: o_phase = -9'd146;\t //LUT[3886] \tphase : -0.570312\t(data_i, data_q): (-0.125000,-0.562500)\n\t3887: o_phase = -9'd147;\t //LUT[3887] \tphase : -0.574219\t(data_i, data_q): (-0.125000,-0.531250)\n\t3888: o_phase = -9'd148;\t //LUT[3888] \tphase : -0.578125\t(data_i, data_q): (-0.125000,-0.500000)\n\t3889: o_phase = -9'd149;\t //LUT[3889] \tphase : -0.582031\t(data_i, data_q): (-0.125000,-0.468750)\n\t3890: o_phase = -9'd151;\t //LUT[3890] \tphase : -0.589844\t(data_i, data_q): (-0.125000,-0.437500)\n\t3891: o_phase = -9'd152;\t //LUT[3891] \tphase : -0.593750\t(data_i, data_q): (-0.125000,-0.406250)\n\t3892: o_phase = -9'd154;\t //LUT[3892] \tphase : -0.601562\t(data_i, data_q): (-0.125000,-0.375000)\n\t3893: o_phase = -9'd156;\t //LUT[3893] \tphase : -0.609375\t(data_i, data_q): (-0.125000,-0.343750)\n\t3894: o_phase = -9'd159;\t //LUT[3894] \tphase : -0.621094\t(data_i, data_q): (-0.125000,-0.312500)\n\t3895: o_phase = -9'd162;\t //LUT[3895] \tphase : -0.632812\t(data_i, data_q): (-0.125000,-0.281250)\n\t3896: o_phase = -9'd166;\t //LUT[3896] \tphase : -0.648438\t(data_i, data_q): (-0.125000,-0.250000)\n\t3897: o_phase = -9'd170;\t //LUT[3897] \tphase : -0.664062\t(data_i, data_q): (-0.125000,-0.218750)\n\t3898: o_phase = -9'd176;\t //LUT[3898] \tphase : -0.687500\t(data_i, data_q): (-0.125000,-0.187500)\n\t3899: o_phase = -9'd183;\t //LUT[3899] \tphase : -0.714844\t(data_i, data_q): (-0.125000,-0.156250)\n\t3900: o_phase = -9'd192;\t //LUT[3900] \tphase : -0.750000\t(data_i, data_q): (-0.125000,-0.125000)\n\t3901: o_phase = -9'd204;\t //LUT[3901] \tphase : -0.796875\t(data_i, data_q): (-0.125000,-0.093750)\n\t3902: o_phase = -9'd218;\t //LUT[3902] \tphase : -0.851562\t(data_i, data_q): (-0.125000,-0.062500)\n\t3903: o_phase = -9'd236;\t //LUT[3903] \tphase : -0.921875\t(data_i, data_q): (-0.125000,-0.031250)\n\t3904: o_phase = -9'd256;\t //LUT[3904] \tphase : -1.000000\t(data_i, data_q): (-0.093750,0.000000)\n\t3905: o_phase = +9'd230;\t //LUT[3905] \tphase : 0.898438\t(data_i, data_q): (-0.093750,0.031250)\n\t3906: o_phase = +9'd208;\t //LUT[3906] \tphase : 0.812500\t(data_i, data_q): (-0.093750,0.062500)\n\t3907: o_phase = +9'd192;\t //LUT[3907] \tphase : 0.750000\t(data_i, data_q): (-0.093750,0.093750)\n\t3908: o_phase = +9'd180;\t //LUT[3908] \tphase : 0.703125\t(data_i, data_q): (-0.093750,0.125000)\n\t3909: o_phase = +9'd172;\t //LUT[3909] \tphase : 0.671875\t(data_i, data_q): (-0.093750,0.156250)\n\t3910: o_phase = +9'd166;\t //LUT[3910] \tphase : 0.648438\t(data_i, data_q): (-0.093750,0.187500)\n\t3911: o_phase = +9'd161;\t //LUT[3911] \tphase : 0.628906\t(data_i, data_q): (-0.093750,0.218750)\n\t3912: o_phase = +9'd157;\t //LUT[3912] \tphase : 0.613281\t(data_i, data_q): (-0.093750,0.250000)\n\t3913: o_phase = +9'd154;\t //LUT[3913] \tphase : 0.601562\t(data_i, data_q): (-0.093750,0.281250)\n\t3914: o_phase = +9'd152;\t //LUT[3914] \tphase : 0.593750\t(data_i, data_q): (-0.093750,0.312500)\n\t3915: o_phase = +9'd150;\t //LUT[3915] \tphase : 0.585938\t(data_i, data_q): (-0.093750,0.343750)\n\t3916: o_phase = +9'd148;\t //LUT[3916] \tphase : 0.578125\t(data_i, data_q): (-0.093750,0.375000)\n\t3917: o_phase = +9'd146;\t //LUT[3917] \tphase : 0.570312\t(data_i, data_q): (-0.093750,0.406250)\n\t3918: o_phase = +9'd145;\t //LUT[3918] \tphase : 0.566406\t(data_i, data_q): (-0.093750,0.437500)\n\t3919: o_phase = +9'd144;\t //LUT[3919] \tphase : 0.562500\t(data_i, data_q): (-0.093750,0.468750)\n\t3920: o_phase = +9'd143;\t //LUT[3920] \tphase : 0.558594\t(data_i, data_q): (-0.093750,0.500000)\n\t3921: o_phase = +9'd142;\t //LUT[3921] \tphase : 0.554688\t(data_i, data_q): (-0.093750,0.531250)\n\t3922: o_phase = +9'd141;\t //LUT[3922] \tphase : 0.550781\t(data_i, data_q): (-0.093750,0.562500)\n\t3923: o_phase = +9'd141;\t //LUT[3923] \tphase : 0.550781\t(data_i, data_q): (-0.093750,0.593750)\n\t3924: o_phase = +9'd140;\t //LUT[3924] \tphase : 0.546875\t(data_i, data_q): (-0.093750,0.625000)\n\t3925: o_phase = +9'd140;\t //LUT[3925] \tphase : 0.546875\t(data_i, data_q): (-0.093750,0.656250)\n\t3926: o_phase = +9'd139;\t //LUT[3926] \tphase : 0.542969\t(data_i, data_q): (-0.093750,0.687500)\n\t3927: o_phase = +9'd139;\t //LUT[3927] \tphase : 0.542969\t(data_i, data_q): (-0.093750,0.718750)\n\t3928: o_phase = +9'd138;\t //LUT[3928] \tphase : 0.539062\t(data_i, data_q): (-0.093750,0.750000)\n\t3929: o_phase = +9'd138;\t //LUT[3929] \tphase : 0.539062\t(data_i, data_q): (-0.093750,0.781250)\n\t3930: o_phase = +9'd137;\t //LUT[3930] \tphase : 0.535156\t(data_i, data_q): (-0.093750,0.812500)\n\t3931: o_phase = +9'd137;\t //LUT[3931] \tphase : 0.535156\t(data_i, data_q): (-0.093750,0.843750)\n\t3932: o_phase = +9'd137;\t //LUT[3932] \tphase : 0.535156\t(data_i, data_q): (-0.093750,0.875000)\n\t3933: o_phase = +9'd136;\t //LUT[3933] \tphase : 0.531250\t(data_i, data_q): (-0.093750,0.906250)\n\t3934: o_phase = +9'd136;\t //LUT[3934] \tphase : 0.531250\t(data_i, data_q): (-0.093750,0.937500)\n\t3935: o_phase = +9'd136;\t //LUT[3935] \tphase : 0.531250\t(data_i, data_q): (-0.093750,0.968750)\n\t3936: o_phase = -9'd136;\t //LUT[3936] \tphase : -0.531250\t(data_i, data_q): (-0.093750,-1.000000)\n\t3937: o_phase = -9'd136;\t //LUT[3937] \tphase : -0.531250\t(data_i, data_q): (-0.093750,-0.968750)\n\t3938: o_phase = -9'd136;\t //LUT[3938] \tphase : -0.531250\t(data_i, data_q): (-0.093750,-0.937500)\n\t3939: o_phase = -9'd136;\t //LUT[3939] \tphase : -0.531250\t(data_i, data_q): (-0.093750,-0.906250)\n\t3940: o_phase = -9'd137;\t //LUT[3940] \tphase : -0.535156\t(data_i, data_q): (-0.093750,-0.875000)\n\t3941: o_phase = -9'd137;\t //LUT[3941] \tphase : -0.535156\t(data_i, data_q): (-0.093750,-0.843750)\n\t3942: o_phase = -9'd137;\t //LUT[3942] \tphase : -0.535156\t(data_i, data_q): (-0.093750,-0.812500)\n\t3943: o_phase = -9'd138;\t //LUT[3943] \tphase : -0.539062\t(data_i, data_q): (-0.093750,-0.781250)\n\t3944: o_phase = -9'd138;\t //LUT[3944] \tphase : -0.539062\t(data_i, data_q): (-0.093750,-0.750000)\n\t3945: o_phase = -9'd139;\t //LUT[3945] \tphase : -0.542969\t(data_i, data_q): (-0.093750,-0.718750)\n\t3946: o_phase = -9'd139;\t //LUT[3946] \tphase : -0.542969\t(data_i, data_q): (-0.093750,-0.687500)\n\t3947: o_phase = -9'd140;\t //LUT[3947] \tphase : -0.546875\t(data_i, data_q): (-0.093750,-0.656250)\n\t3948: o_phase = -9'd140;\t //LUT[3948] \tphase : -0.546875\t(data_i, data_q): (-0.093750,-0.625000)\n\t3949: o_phase = -9'd141;\t //LUT[3949] \tphase : -0.550781\t(data_i, data_q): (-0.093750,-0.593750)\n\t3950: o_phase = -9'd141;\t //LUT[3950] \tphase : -0.550781\t(data_i, data_q): (-0.093750,-0.562500)\n\t3951: o_phase = -9'd142;\t //LUT[3951] \tphase : -0.554688\t(data_i, data_q): (-0.093750,-0.531250)\n\t3952: o_phase = -9'd143;\t //LUT[3952] \tphase : -0.558594\t(data_i, data_q): (-0.093750,-0.500000)\n\t3953: o_phase = -9'd144;\t //LUT[3953] \tphase : -0.562500\t(data_i, data_q): (-0.093750,-0.468750)\n\t3954: o_phase = -9'd145;\t //LUT[3954] \tphase : -0.566406\t(data_i, data_q): (-0.093750,-0.437500)\n\t3955: o_phase = -9'd146;\t //LUT[3955] \tphase : -0.570312\t(data_i, data_q): (-0.093750,-0.406250)\n\t3956: o_phase = -9'd148;\t //LUT[3956] \tphase : -0.578125\t(data_i, data_q): (-0.093750,-0.375000)\n\t3957: o_phase = -9'd150;\t //LUT[3957] \tphase : -0.585938\t(data_i, data_q): (-0.093750,-0.343750)\n\t3958: o_phase = -9'd152;\t //LUT[3958] \tphase : -0.593750\t(data_i, data_q): (-0.093750,-0.312500)\n\t3959: o_phase = -9'd154;\t //LUT[3959] \tphase : -0.601562\t(data_i, data_q): (-0.093750,-0.281250)\n\t3960: o_phase = -9'd157;\t //LUT[3960] \tphase : -0.613281\t(data_i, data_q): (-0.093750,-0.250000)\n\t3961: o_phase = -9'd161;\t //LUT[3961] \tphase : -0.628906\t(data_i, data_q): (-0.093750,-0.218750)\n\t3962: o_phase = -9'd166;\t //LUT[3962] \tphase : -0.648438\t(data_i, data_q): (-0.093750,-0.187500)\n\t3963: o_phase = -9'd172;\t //LUT[3963] \tphase : -0.671875\t(data_i, data_q): (-0.093750,-0.156250)\n\t3964: o_phase = -9'd180;\t //LUT[3964] \tphase : -0.703125\t(data_i, data_q): (-0.093750,-0.125000)\n\t3965: o_phase = -9'd192;\t //LUT[3965] \tphase : -0.750000\t(data_i, data_q): (-0.093750,-0.093750)\n\t3966: o_phase = -9'd208;\t //LUT[3966] \tphase : -0.812500\t(data_i, data_q): (-0.093750,-0.062500)\n\t3967: o_phase = -9'd230;\t //LUT[3967] \tphase : -0.898438\t(data_i, data_q): (-0.093750,-0.031250)\n\t3968: o_phase = -9'd256;\t //LUT[3968] \tphase : -1.000000\t(data_i, data_q): (-0.062500,0.000000)\n\t3969: o_phase = +9'd218;\t //LUT[3969] \tphase : 0.851562\t(data_i, data_q): (-0.062500,0.031250)\n\t3970: o_phase = +9'd192;\t //LUT[3970] \tphase : 0.750000\t(data_i, data_q): (-0.062500,0.062500)\n\t3971: o_phase = +9'd176;\t //LUT[3971] \tphase : 0.687500\t(data_i, data_q): (-0.062500,0.093750)\n\t3972: o_phase = +9'd166;\t //LUT[3972] \tphase : 0.648438\t(data_i, data_q): (-0.062500,0.125000)\n\t3973: o_phase = +9'd159;\t //LUT[3973] \tphase : 0.621094\t(data_i, data_q): (-0.062500,0.156250)\n\t3974: o_phase = +9'd154;\t //LUT[3974] \tphase : 0.601562\t(data_i, data_q): (-0.062500,0.187500)\n\t3975: o_phase = +9'd151;\t //LUT[3975] \tphase : 0.589844\t(data_i, data_q): (-0.062500,0.218750)\n\t3976: o_phase = +9'd148;\t //LUT[3976] \tphase : 0.578125\t(data_i, data_q): (-0.062500,0.250000)\n\t3977: o_phase = +9'd146;\t //LUT[3977] \tphase : 0.570312\t(data_i, data_q): (-0.062500,0.281250)\n\t3978: o_phase = +9'd144;\t //LUT[3978] \tphase : 0.562500\t(data_i, data_q): (-0.062500,0.312500)\n\t3979: o_phase = +9'd143;\t //LUT[3979] \tphase : 0.558594\t(data_i, data_q): (-0.062500,0.343750)\n\t3980: o_phase = +9'd141;\t //LUT[3980] \tphase : 0.550781\t(data_i, data_q): (-0.062500,0.375000)\n\t3981: o_phase = +9'd140;\t //LUT[3981] \tphase : 0.546875\t(data_i, data_q): (-0.062500,0.406250)\n\t3982: o_phase = +9'd140;\t //LUT[3982] \tphase : 0.546875\t(data_i, data_q): (-0.062500,0.437500)\n\t3983: o_phase = +9'd139;\t //LUT[3983] \tphase : 0.542969\t(data_i, data_q): (-0.062500,0.468750)\n\t3984: o_phase = +9'd138;\t //LUT[3984] \tphase : 0.539062\t(data_i, data_q): (-0.062500,0.500000)\n\t3985: o_phase = +9'd138;\t //LUT[3985] \tphase : 0.539062\t(data_i, data_q): (-0.062500,0.531250)\n\t3986: o_phase = +9'd137;\t //LUT[3986] \tphase : 0.535156\t(data_i, data_q): (-0.062500,0.562500)\n\t3987: o_phase = +9'd137;\t //LUT[3987] \tphase : 0.535156\t(data_i, data_q): (-0.062500,0.593750)\n\t3988: o_phase = +9'd136;\t //LUT[3988] \tphase : 0.531250\t(data_i, data_q): (-0.062500,0.625000)\n\t3989: o_phase = +9'd136;\t //LUT[3989] \tphase : 0.531250\t(data_i, data_q): (-0.062500,0.656250)\n\t3990: o_phase = +9'd135;\t //LUT[3990] \tphase : 0.527344\t(data_i, data_q): (-0.062500,0.687500)\n\t3991: o_phase = +9'd135;\t //LUT[3991] \tphase : 0.527344\t(data_i, data_q): (-0.062500,0.718750)\n\t3992: o_phase = +9'd135;\t //LUT[3992] \tphase : 0.527344\t(data_i, data_q): (-0.062500,0.750000)\n\t3993: o_phase = +9'd135;\t //LUT[3993] \tphase : 0.527344\t(data_i, data_q): (-0.062500,0.781250)\n\t3994: o_phase = +9'd134;\t //LUT[3994] \tphase : 0.523438\t(data_i, data_q): (-0.062500,0.812500)\n\t3995: o_phase = +9'd134;\t //LUT[3995] \tphase : 0.523438\t(data_i, data_q): (-0.062500,0.843750)\n\t3996: o_phase = +9'd134;\t //LUT[3996] \tphase : 0.523438\t(data_i, data_q): (-0.062500,0.875000)\n\t3997: o_phase = +9'd134;\t //LUT[3997] \tphase : 0.523438\t(data_i, data_q): (-0.062500,0.906250)\n\t3998: o_phase = +9'd133;\t //LUT[3998] \tphase : 0.519531\t(data_i, data_q): (-0.062500,0.937500)\n\t3999: o_phase = +9'd133;\t //LUT[3999] \tphase : 0.519531\t(data_i, data_q): (-0.062500,0.968750)\n\t4000: o_phase = -9'd133;\t //LUT[4000] \tphase : -0.519531\t(data_i, data_q): (-0.062500,-1.000000)\n\t4001: o_phase = -9'd133;\t //LUT[4001] \tphase : -0.519531\t(data_i, data_q): (-0.062500,-0.968750)\n\t4002: o_phase = -9'd133;\t //LUT[4002] \tphase : -0.519531\t(data_i, data_q): (-0.062500,-0.937500)\n\t4003: o_phase = -9'd134;\t //LUT[4003] \tphase : -0.523438\t(data_i, data_q): (-0.062500,-0.906250)\n\t4004: o_phase = -9'd134;\t //LUT[4004] \tphase : -0.523438\t(data_i, data_q): (-0.062500,-0.875000)\n\t4005: o_phase = -9'd134;\t //LUT[4005] \tphase : -0.523438\t(data_i, data_q): (-0.062500,-0.843750)\n\t4006: o_phase = -9'd134;\t //LUT[4006] \tphase : -0.523438\t(data_i, data_q): (-0.062500,-0.812500)\n\t4007: o_phase = -9'd135;\t //LUT[4007] \tphase : -0.527344\t(data_i, data_q): (-0.062500,-0.781250)\n\t4008: o_phase = -9'd135;\t //LUT[4008] \tphase : -0.527344\t(data_i, data_q): (-0.062500,-0.750000)\n\t4009: o_phase = -9'd135;\t //LUT[4009] \tphase : -0.527344\t(data_i, data_q): (-0.062500,-0.718750)\n\t4010: o_phase = -9'd135;\t //LUT[4010] \tphase : -0.527344\t(data_i, data_q): (-0.062500,-0.687500)\n\t4011: o_phase = -9'd136;\t //LUT[4011] \tphase : -0.531250\t(data_i, data_q): (-0.062500,-0.656250)\n\t4012: o_phase = -9'd136;\t //LUT[4012] \tphase : -0.531250\t(data_i, data_q): (-0.062500,-0.625000)\n\t4013: o_phase = -9'd137;\t //LUT[4013] \tphase : -0.535156\t(data_i, data_q): (-0.062500,-0.593750)\n\t4014: o_phase = -9'd137;\t //LUT[4014] \tphase : -0.535156\t(data_i, data_q): (-0.062500,-0.562500)\n\t4015: o_phase = -9'd138;\t //LUT[4015] \tphase : -0.539062\t(data_i, data_q): (-0.062500,-0.531250)\n\t4016: o_phase = -9'd138;\t //LUT[4016] \tphase : -0.539062\t(data_i, data_q): (-0.062500,-0.500000)\n\t4017: o_phase = -9'd139;\t //LUT[4017] \tphase : -0.542969\t(data_i, data_q): (-0.062500,-0.468750)\n\t4018: o_phase = -9'd140;\t //LUT[4018] \tphase : -0.546875\t(data_i, data_q): (-0.062500,-0.437500)\n\t4019: o_phase = -9'd140;\t //LUT[4019] \tphase : -0.546875\t(data_i, data_q): (-0.062500,-0.406250)\n\t4020: o_phase = -9'd141;\t //LUT[4020] \tphase : -0.550781\t(data_i, data_q): (-0.062500,-0.375000)\n\t4021: o_phase = -9'd143;\t //LUT[4021] \tphase : -0.558594\t(data_i, data_q): (-0.062500,-0.343750)\n\t4022: o_phase = -9'd144;\t //LUT[4022] \tphase : -0.562500\t(data_i, data_q): (-0.062500,-0.312500)\n\t4023: o_phase = -9'd146;\t //LUT[4023] \tphase : -0.570312\t(data_i, data_q): (-0.062500,-0.281250)\n\t4024: o_phase = -9'd148;\t //LUT[4024] \tphase : -0.578125\t(data_i, data_q): (-0.062500,-0.250000)\n\t4025: o_phase = -9'd151;\t //LUT[4025] \tphase : -0.589844\t(data_i, data_q): (-0.062500,-0.218750)\n\t4026: o_phase = -9'd154;\t //LUT[4026] \tphase : -0.601562\t(data_i, data_q): (-0.062500,-0.187500)\n\t4027: o_phase = -9'd159;\t //LUT[4027] \tphase : -0.621094\t(data_i, data_q): (-0.062500,-0.156250)\n\t4028: o_phase = -9'd166;\t //LUT[4028] \tphase : -0.648438\t(data_i, data_q): (-0.062500,-0.125000)\n\t4029: o_phase = -9'd176;\t //LUT[4029] \tphase : -0.687500\t(data_i, data_q): (-0.062500,-0.093750)\n\t4030: o_phase = -9'd192;\t //LUT[4030] \tphase : -0.750000\t(data_i, data_q): (-0.062500,-0.062500)\n\t4031: o_phase = -9'd218;\t //LUT[4031] \tphase : -0.851562\t(data_i, data_q): (-0.062500,-0.031250)\n\t4032: o_phase = -9'd256;\t //LUT[4032] \tphase : -1.000000\t(data_i, data_q): (-0.031250,0.000000)\n\t4033: o_phase = +9'd192;\t //LUT[4033] \tphase : 0.750000\t(data_i, data_q): (-0.031250,0.031250)\n\t4034: o_phase = +9'd166;\t //LUT[4034] \tphase : 0.648438\t(data_i, data_q): (-0.031250,0.062500)\n\t4035: o_phase = +9'd154;\t //LUT[4035] \tphase : 0.601562\t(data_i, data_q): (-0.031250,0.093750)\n\t4036: o_phase = +9'd148;\t //LUT[4036] \tphase : 0.578125\t(data_i, data_q): (-0.031250,0.125000)\n\t4037: o_phase = +9'd144;\t //LUT[4037] \tphase : 0.562500\t(data_i, data_q): (-0.031250,0.156250)\n\t4038: o_phase = +9'd141;\t //LUT[4038] \tphase : 0.550781\t(data_i, data_q): (-0.031250,0.187500)\n\t4039: o_phase = +9'd140;\t //LUT[4039] \tphase : 0.546875\t(data_i, data_q): (-0.031250,0.218750)\n\t4040: o_phase = +9'd138;\t //LUT[4040] \tphase : 0.539062\t(data_i, data_q): (-0.031250,0.250000)\n\t4041: o_phase = +9'd137;\t //LUT[4041] \tphase : 0.535156\t(data_i, data_q): (-0.031250,0.281250)\n\t4042: o_phase = +9'd136;\t //LUT[4042] \tphase : 0.531250\t(data_i, data_q): (-0.031250,0.312500)\n\t4043: o_phase = +9'd135;\t //LUT[4043] \tphase : 0.527344\t(data_i, data_q): (-0.031250,0.343750)\n\t4044: o_phase = +9'd135;\t //LUT[4044] \tphase : 0.527344\t(data_i, data_q): (-0.031250,0.375000)\n\t4045: o_phase = +9'd134;\t //LUT[4045] \tphase : 0.523438\t(data_i, data_q): (-0.031250,0.406250)\n\t4046: o_phase = +9'd134;\t //LUT[4046] \tphase : 0.523438\t(data_i, data_q): (-0.031250,0.437500)\n\t4047: o_phase = +9'd133;\t //LUT[4047] \tphase : 0.519531\t(data_i, data_q): (-0.031250,0.468750)\n\t4048: o_phase = +9'd133;\t //LUT[4048] \tphase : 0.519531\t(data_i, data_q): (-0.031250,0.500000)\n\t4049: o_phase = +9'd133;\t //LUT[4049] \tphase : 0.519531\t(data_i, data_q): (-0.031250,0.531250)\n\t4050: o_phase = +9'd133;\t //LUT[4050] \tphase : 0.519531\t(data_i, data_q): (-0.031250,0.562500)\n\t4051: o_phase = +9'd132;\t //LUT[4051] \tphase : 0.515625\t(data_i, data_q): (-0.031250,0.593750)\n\t4052: o_phase = +9'd132;\t //LUT[4052] \tphase : 0.515625\t(data_i, data_q): (-0.031250,0.625000)\n\t4053: o_phase = +9'd132;\t //LUT[4053] \tphase : 0.515625\t(data_i, data_q): (-0.031250,0.656250)\n\t4054: o_phase = +9'd132;\t //LUT[4054] \tphase : 0.515625\t(data_i, data_q): (-0.031250,0.687500)\n\t4055: o_phase = +9'd132;\t //LUT[4055] \tphase : 0.515625\t(data_i, data_q): (-0.031250,0.718750)\n\t4056: o_phase = +9'd131;\t //LUT[4056] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.750000)\n\t4057: o_phase = +9'd131;\t //LUT[4057] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.781250)\n\t4058: o_phase = +9'd131;\t //LUT[4058] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.812500)\n\t4059: o_phase = +9'd131;\t //LUT[4059] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.843750)\n\t4060: o_phase = +9'd131;\t //LUT[4060] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.875000)\n\t4061: o_phase = +9'd131;\t //LUT[4061] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.906250)\n\t4062: o_phase = +9'd131;\t //LUT[4062] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.937500)\n\t4063: o_phase = +9'd131;\t //LUT[4063] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.968750)\n\t4064: o_phase = -9'd131;\t //LUT[4064] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-1.000000)\n\t4065: o_phase = -9'd131;\t //LUT[4065] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.968750)\n\t4066: o_phase = -9'd131;\t //LUT[4066] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.937500)\n\t4067: o_phase = -9'd131;\t //LUT[4067] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.906250)\n\t4068: o_phase = -9'd131;\t //LUT[4068] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.875000)\n\t4069: o_phase = -9'd131;\t //LUT[4069] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.843750)\n\t4070: o_phase = -9'd131;\t //LUT[4070] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.812500)\n\t4071: o_phase = -9'd131;\t //LUT[4071] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.781250)\n\t4072: o_phase = -9'd131;\t //LUT[4072] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.750000)\n\t4073: o_phase = -9'd132;\t //LUT[4073] \tphase : -0.515625\t(data_i, data_q): (-0.031250,-0.718750)\n\t4074: o_phase = -9'd132;\t //LUT[4074] \tphase : -0.515625\t(data_i, data_q): (-0.031250,-0.687500)\n\t4075: o_phase = -9'd132;\t //LUT[4075] \tphase : -0.515625\t(data_i, data_q): (-0.031250,-0.656250)\n\t4076: o_phase = -9'd132;\t //LUT[4076] \tphase : -0.515625\t(data_i, data_q): (-0.031250,-0.625000)\n\t4077: o_phase = -9'd132;\t //LUT[4077] \tphase : -0.515625\t(data_i, data_q): (-0.031250,-0.593750)\n\t4078: o_phase = -9'd133;\t //LUT[4078] \tphase : -0.519531\t(data_i, data_q): (-0.031250,-0.562500)\n\t4079: o_phase = -9'd133;\t //LUT[4079] \tphase : -0.519531\t(data_i, data_q): (-0.031250,-0.531250)\n\t4080: o_phase = -9'd133;\t //LUT[4080] \tphase : -0.519531\t(data_i, data_q): (-0.031250,-0.500000)\n\t4081: o_phase = -9'd133;\t //LUT[4081] \tphase : -0.519531\t(data_i, data_q): (-0.031250,-0.468750)\n\t4082: o_phase = -9'd134;\t //LUT[4082] \tphase : -0.523438\t(data_i, data_q): (-0.031250,-0.437500)\n\t4083: o_phase = -9'd134;\t //LUT[4083] \tphase : -0.523438\t(data_i, data_q): (-0.031250,-0.406250)\n\t4084: o_phase = -9'd135;\t //LUT[4084] \tphase : -0.527344\t(data_i, data_q): (-0.031250,-0.375000)\n\t4085: o_phase = -9'd135;\t //LUT[4085] \tphase : -0.527344\t(data_i, data_q): (-0.031250,-0.343750)\n\t4086: o_phase = -9'd136;\t //LUT[4086] \tphase : -0.531250\t(data_i, data_q): (-0.031250,-0.312500)\n\t4087: o_phase = -9'd137;\t //LUT[4087] \tphase : -0.535156\t(data_i, data_q): (-0.031250,-0.281250)\n\t4088: o_phase = -9'd138;\t //LUT[4088] \tphase : -0.539062\t(data_i, data_q): (-0.031250,-0.250000)\n\t4089: o_phase = -9'd140;\t //LUT[4089] \tphase : -0.546875\t(data_i, data_q): (-0.031250,-0.218750)\n\t4090: o_phase = -9'd141;\t //LUT[4090] \tphase : -0.550781\t(data_i, data_q): (-0.031250,-0.187500)\n\t4091: o_phase = -9'd144;\t //LUT[4091] \tphase : -0.562500\t(data_i, data_q): (-0.031250,-0.156250)\n\t4092: o_phase = -9'd148;\t //LUT[4092] \tphase : -0.578125\t(data_i, data_q): (-0.031250,-0.125000)\n\t4093: o_phase = -9'd154;\t //LUT[4093] \tphase : -0.601562\t(data_i, data_q): (-0.031250,-0.093750)\n\t4094: o_phase = -9'd166;\t //LUT[4094] \tphase : -0.648438\t(data_i, data_q): (-0.031250,-0.062500)\n\t4095: o_phase = -9'd192; \t //LUT[4095] \tphase : -0.750000\t(data_i, data_q): (-0.031250,-0.031250)\n\tendcase\nend\n\nendmodule"}, "patch": {"rtl/phase_lut.sv": ""}, "harness": {"docker-compose.yml": "services:\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : /bin/sh -c \"pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s\"", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/phase_lut.sv\nTOPLEVEL        = phase_lut\nMODULE          = test_phase_lut\nPYTHONPATH      = /src\nHASH            = 19-modify-rtl---phase-lut", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n            \nasync def reset_dut(reset_n, duration_ns=10):\n    reset_n.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")   \n\ndef normalize_angle(angle):\n    \"\"\"Normalize angle to be within the range of -180 to 180 degrees.\"\"\"\n    return (angle + 180) % 360 - 180", "src/test_phase_lut.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ClockCycles, Timer\nimport harness_library as hrs_lb\nimport random\nimport math\nimport cmath\n\n@cocotb.test()\nasync def test_convolution_0(dut):\n    \n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    debug = 0\n    # Retrieve the parameters from the DUT    \n    NBW_IN = int(dut.NBW_IN.value)\n\n    max_data = (2 ** NBW_IN)/2 - 1\n    min_data = -((2 ** NBW_IN)/2 -1)\n\n    runs = 100\n    \n    exp_phase = 0\n    exp_phase_delayed = 0\n\n    # Initialize DUT\n    await hrs_lb.dut_init(dut) \n    await hrs_lb.reset_dut(dut.rst_async_n)\n\n    # Check for interface Changes\n    assert hasattr(dut,'clk'), f\"Clock signal not found in DUT\"\n    assert hasattr(dut,'rst_async_n'), f\"Reset signal not found in DUT\"\n    assert hasattr(dut,'NBI_IN'), f\"Parameter NBI_IN not found in DUT\"\n    assert hasattr(dut,'NBI_PHASE'), f\"Parameter NBI_PHASE not found in DUT\"\n\n    await RisingEdge(dut.clk)\n\n    for i in range(runs):\n        i_data_i = random.randint(min_data, max_data)\n        i_data_q = random.randint(min_data, max_data)\n\n        dut.i_data_i.value = i_data_i\n        dut.i_data_q.value = i_data_q\n\n        exp_phase_delayed = exp_phase\n        exp_phase = (math.atan2(i_data_q, i_data_i)*180/math.pi)\n        exp_phase = hrs_lb.normalize_angle(exp_phase)*256/180\n\n        await RisingEdge(dut.clk)\n        #await Timer(1, units=\"ns\")\n\n        dut_phase = dut.o_phase.value.to_signed()\n\n        if debug == 1:\n          cocotb.log.info(f\"[INPUTS] i_data_i = {i_data_i}, i_data_q = {i_data_q}\")\n          cocotb.log.info(f\"[DUT] o_phase = {dut_phase}\")\n          cocotb.log.info(f\"[EXP] o_phase = {exp_phase_delayed}\")\n\n        abs_diff = abs(dut_phase - exp_phase_delayed)\n        if debug == 1:\n           cocotb.log.info(f\"[DIFF] o_phase = {abs_diff}\")\n\n        assert abs_diff < 1, f\"Phase mismatch. Expected {exp_phase_delayed} but got {dut_phase}\"\n\n    #for item in dir(dut.gen_lut_phase_rot[0].uu_phase_rotation.i_data_re):\n    #  print(f\"- {item}\")      \n  ", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Parametrize test for different random data sizes\n@pytest.mark.parametrize(\"test\", range(100))\ndef test_data(test):\n    # Run the simulation with specified parameters\n    runner()"}}
{"id": "cvdp_agentic_lagoon_dragon_diamond_4339", "categories": ["cid004", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "The **detect_sequence** module must be updated with the following changes to its interface and internal behavior.\n\n#### Interface Modifications\n\n- **Remove** the input signal `i_static_threshold` and its associated parameter.\n- **Add** a new **parameter** `NBW_TH_UNLOCK`, default value: `3`.\n- **Add** a new **input signal** `i_static_unlock_threshold` with width `NBW_TH_UNLOCK`.\n- **Add** a new **1-bit output signal** `o_locked`.\n\n#### Functional Description\n\n- A new **finite state machine (FSM)** must be implemented with two operational states:\n  - `ST_DETECT_SEQUENCE`: handles initial detection monitoring.\n  - `ST_DETECT_PROC`: maintains a locked state and monitors detection quality.\n\n- The FSM begins in the `ST_DETECT_SEQUENCE` state. While in this state, the module continuously evaluates incoming data for detection events. The signal responsible for defining the operation mode of the `correlate` module must be held low in this state, and the output `o_locked` must also remain low. A transition to the `ST_DETECT_PROC` state occurs only when both the output `o_proc_detected` is high and a signal returned from the `adder_2d_layer` module is high. This signal confirms that the detected values meet the criteria of being less than three valid modules.\n\n- In the `ST_DETECT_PROC` state, the system assumes that detection has been achieved. A cycle counter begins tracking the number of processing cycles. If detection fails during a cycle (i.e., the detection output is low), a secondary counter increments to record consecutive failed sequences. The FSM transitions back to the `ST_DETECT_SEQUENCE` state when three conditions are met simultaneously: (1) the processing cycle counter reaches its maximum count, (2) no detection is reported, and (3) the failure counter reaches the value defined by the input `i_static_unlock_threshold`.\n\n- While in `ST_DETECT_PROC`, if detection continues successfully, the FSM remains in this state, and the failure counter is reset. In this condition, the output `o_locked` is asserted high, and the mode selector for operation remains in its active configuration.\n\n- The FSM uses an internal cycle counter to monitor the progress of a detection processing window. This counter increments on each valid cycle while the FSM is in the `ST_DETECT_PROC` state. When it reaches the predefined number of cycles that constitute a full processing window, the FSM evaluates detection outcomes and determines whether to maintain or exit the locked state.\n\n- The output signal `o_locked` is asserted during the `ST_DETECT_PROC` state only when detection is actively being confirmed within the current processing window.\n\n- Two counters are used by the FSM: one to count regular processing cycles and another to count undetected sequences. The regular processing cycle counter tracks the number of cycles processed during a locked window, and the undetected counter increments only when no detection occurs at the end of a window. Both counters must have a bit-width large enough to count up to the total number of 32-bit words defined in the external specification.\n\n- The required counter size must accommodate a total number of words as specified in the `words_counting.md` document.\n\n- All counters and state logic must respond to an asynchronous active-low reset (`rst_async_n`), which clears internal state and resets both counters.\n\n- A condition influencing state transitions is provided by the `cross_correlation` module, which must be connected internally but requires no changes to that module's interface.\n\n#### Cross Correlation Module Updates\n\n- The **cross_correlation** module must be updated to include the following new interface signals:\n  - An asynchronous active-low reset input (`rst_async_n`) received from the top-level.\n  - A new input signal `i_mode`, which is provided by the FSM from the top-level module.\n  - A new 1-bit output signal `o_aware_mode`, indicating internal awareness status.\n\n- The `rst_async_n` and `i_mode` signals must be propagated internally to the **adder_2d_layers** submodule.\n- Additionally, the `i_mode` signal must be connected to the **correlate** submodule.\n\nThese updates ensure consistent control and synchronization across internal components, and align the interface of the `cross_correlation` module with new detection and locking logic defined at the top level.\n\n#### Adder 2D Layers Module Update\n\n- The **adder_2d_layers** module must be modified to incorporate logic that monitors the value of the operation mode input.\n- A new synchronous output flag must be raised when the mode input corresponds to a valid mode value.\n- Valid mode values are defined externally and must be interpreted according to the list provided in the `valid_modes.md` document.\n- This flag must be updated synchronously with the system clock and used to inform the FSM in the `detect_sequence` module that the current operation mode is valid.\n\n#### Correlate Module Update\n\n- The **correlate** module must be updated to support operation based on a new 2-bit input signal `i_mode`.\n- When `i_mode` is set to `0`, the module should perform its original behavior without modification.\n- When `i_mode` is set to `1`, all index computations must apply subtraction between relevant inputs.\n- When `i_mode` is set to `2`, all index computations must apply addition between relevant inputs.\n- When `i_mode` is set to `3`, the output indices must be forced to zero, effectively disabling dynamic computation.\n", "context": {"docs/spec_conj.md": "# Conjugate Sequence Specification (`conj_proc_h` and `conj_proc_v`)\n\n## Purpose\n\nThis document describes how to derive the conjugate reference sequences used in the `detect_sequence` module, specifically:\n\n- Real part of the horizontal conjugate sequence  \n- Imag part of the horizontal conjugate sequence  \n- Real part of the vertical conjugate sequence  \n- Imag part of the vertical conjugate sequence\n\nThese sequences are used for cross-correlation against known pilot symbols in complex form. Each sample is represented by its real (`I`) and imaginary (`Q`) parts, both normalized to `+1` or `-1`.\n\n---\n\n## Generation Process\n\n1. **Start from the ideal complex pilot sequence** (row-wise and column-wise).\n2. **Apply complex conjugation**, inverting the imaginary part:\nconj(x + j\u00b7y) = x - j\u00b7y\n4. **Normalize** each value to sign-only:\n- If real/imag \u2265 0 \u2192 `+1`\n- If real/imag <  0 \u2192 `-1`\n4. **Encode** these into two parallel vectors per sequence:\n- One for real parts\n- One for imag parts\n5. These bits are stored as logic vectors of width 23.\n\n---\n\n## Symbol Mapping\n\nEach position in the sequence represents a normalized complex symbol `(Re, Im)`:\n\n| Symbol Value | Encoded as |\n|--------------|------------|\n| `(+1, +1)`   | Real = 0, Imag = 0 |\n| `(+1, -1)`   | Real = 0, Imag = 1 |\n| `(-1, +1)`   | Real = 1, Imag = 0 |\n| `(-1, -1)`   | Real = 1, Imag = 1 |\n\n---\n\n## Table: Sequence Interpretation\n\nEach row below corresponds to one of the 23 complex samples in the sequence. The real and imag parts are shown as `+1` or `-1`.\n\n### `conj_proc_h` \u2014 Horizontal Conjugate Sequence\n\n| Index | Real Part                    | Imag Part                    |\n|-------|------------------------------|------------------------------|\n| 0     | +1                           | -1                           |\n| 1     | -1                           | -1                           |\n| 2     | +1                           | +1                           |\n| 3     | -1                           | -1                           |\n| 4     | +1                           | +1                           |\n| 5     | +1                           | -1                           |\n| 6     | -1                           | -1                           |\n| 7     | -1                           | +1                           |\n| 8     | +1                           | -1                           |\n| 9     | +1                           | +1                           |\n| 10    | +1                           | -1                           |\n| 11    | -1                           | -1                           |\n| 12    | +1                           | -1                           |\n| 13    | -1                           | +1                           |\n| 14    | +1                           | -1                           |\n| 15    | +1                           | +1                           |\n| 16    | -1                           | -1                           |\n| 17    | +1                           | +1                           |\n| 18    | +1                           | -1                           |\n| 19    | -1                           | +1                           |\n| 20    | -1                           | +1                           |\n| 21    | +1                           | +1                           |\n| 22    | +1                           | +1                           |\n\n### `conj_proc_v` \u2014 Vertical Conjugate Sequence\n\n| Index | Real Part                    | Imag Part                    |\n|-------|------------------------------|------------------------------|\n| 0     | -1                           | +1                           |\n| 1     | -1                           | -1                           |\n| 2     | +1                           | +1                           |\n| 3     | -1                           | +1                           |\n| 4     | +1                           | -1                           |\n| 5     | -1                           | -1                           |\n| 6     | -1                           | +1                           |\n| 7     | +1                           | -1                           |\n| 8     | -1                           | -1                           |\n| 9     | +1                           | +1                           |\n| 10    | +1                           | -1                           |\n| 11    | -1                           | +1                           |\n| 12    | +1                           | +1                           |\n| 13    | -1                           | -1                           |\n| 14    | +1                           | -1                           |\n| 15    | +1                           | +1                           |\n| 16    | +1                           | -1                           |\n| 17    | +1                           | +1                           |\n| 18    | -1                           | -1                           |\n| 19    | -1                           | +1                           |\n| 20    | +1                           | -1                           |\n| 21    | +1                           | +1                           |\n| 22    | -1                           | +1                           |", "docs/spec_cross_correlation.md": "# Cross Correlation Top-Level Module (`cross_correlation.sv`)\n\n## Overview\nThe `cross_correlation` module performs energy-based correlation of complex sequences composed of **I (in-phase)** and **Q (quadrature)** components. This top-level module integrates two main functional blocks:\n\n- A **correlation stage**, handled by the existing `correlate` module.\n- A **reduction and energy computation stage**, implemented in the existing `adder_2d_layers` module.\n\nThe goal is to produce a scalar energy output derived from the correlation between input data and a conjugate reference sequence, while supporting dynamic operation modes and mode-awareness feedback.\n\n---\n\n## Required Modules\n\n### `cross_correlation`\nThis top-level module instantiates:\n\n- The `correlate` module to compute intermediate correlation terms.\n- The `adder_2d_layers` module to perform summation and energy computation.\n\nThis module exposes configuration parameters and connects all control and data paths. All internal parameters required by submodules (e.g., widths, number of symbols, levels of the tree, register configurations) are configured through the top-level module.\n\n#### Parameters\n| Parameter         | Description                                  | Default Value | Constraints                                              |\n|-------------------|----------------------------------------------|---------------|----------------------------------------------------------|\n| `NS_DATA_IN`      | Number of input data samples                 | `2`           | \u2265 2                                                      |\n| `NBW_DATA_IN`     | Bit width of each input data sample          | `5`           | \u2265 3                                                      |\n| `NBI_DATA_IN`     | Number of integer bits in the input data     | `1`           | \u2264 `NBW_DATA_IN - 2`                                      |\n| `NBW_ENERGY`      | Bit width of the final energy output         | `5`           | Between 3 and `NBW_DATA_IN`, inclusive                   |\n\n#### Interface\n\n| Signal             | Direction | Width                              | Description                                               |\n|--------------------|-----------|------------------------------------|-----------------------------------------------------------|\n| `clk`              | Input     | 1 bit                              | System clock                                              |\n| `rst_async_n`      | Input     | 1 bit                              | Asynchronous active-low reset                             |\n| `i_enable`         | Input     | 1 bit                              | Enable signal for pipeline stages                         |\n| `i_mode`           | Input     | 2 bits                             | Operation mode selector                                   |\n| `i_data_i`         | Input     | `NBW_DATA_IN * NS_DATA_IN`         | Input data (I component)                                  |\n| `i_data_q`         | Input     | `NBW_DATA_IN * NS_DATA_IN`         | Input data (Q component)                                  |\n| `i_conj_seq_i`     | Input     | `NS_DATA_IN`                       | Conjugate sequence for I                                  |\n| `i_conj_seq_q`     | Input     | `NS_DATA_IN`                       | Conjugate sequence for Q                                  |\n| `o_energy`         | Output    | `NBW_ENERGY`                       | Computed energy value from cross correlation              |\n| `o_aware_mode`     | Output    | 1 bit                              | Indicates if mode is recognized as valid by adder layer   |\n\n#### Signal Propagation\n- The signal `i_mode` is connected to both the `correlate` and `adder_2d_layers` submodules.\n- The signal `rst_async_n` is connected to the `adder_2d_layers` module.\n- The output `o_aware_mode` is driven by the `adder_2d_layers` module and forwarded through this top-level interface.\n\n---\n\n### `adder_2d_layers`\nThis module sits between `cross_correlation` and `adder_tree_2d`. Its responsibilities include:\n\n1. Instantiating two `adder_tree_2d` modules (for I and Q correlation results) to perform 2D summation of the outputs from `correlate`.\n2. Registering the outputs of both adder trees when `i_enable` is asserted.\n3. Computing the energy using the squared values of I and Q outputs, and truncating the result according to the `NBW_ENERGY` parameter.\n4. Monitoring the `i_mode` signal and comparing it to valid modes (defined externally in `valid_modes.md`). If `i_mode` matches a valid mode, the `o_aware_mode` flag is raised synchronously with the clock.\n\n#### Parameters\n\n| Parameter             | Default Value | Description                                                                |\n|-----------------------|---------------|----------------------------------------------------------------------------|\n| `NBW_IN`              | 8             | Bit width of each correlation input sample                                 |\n| `NS_IN`               | 80            | Number of input samples to the adder tree                                  |\n| `N_LEVELS`            | 7             | Number of levels in the adder tree                                         |\n| `REGS`                | 8'b100010_0   | Pipeline register mask per level                                           |\n| `NBW_ADDER_TREE_OUT`  | 8             | Output bit width of the adder tree                                         |\n| `NBW_ENERGY`          | 5             | Output bit width for energy (after truncation)                             |\n\n#### Interface\n\n| Signal           | Direction | Width                                 | Description                                               |\n|------------------|-----------|---------------------------------------|-----------------------------------------------------------|\n| `clk`            | Input     | 1 bit                                 | System clock                                              |\n| `rst_async_n`    | Input     | 1 bit                                 | Asynchronous active-low reset                             |\n| `i_enable`       | Input     | 1 bit                                 | Enable signal to control output registration              |\n| `i_mode`         | Input     | 2 bits                                | Operation mode selector                                   |\n| `i_data_i`       | Input     | `NBW_IN * NS_IN`                      | Input correlation data (I component)                      |\n| `i_data_q`       | Input     | `NBW_IN * NS_IN`                      | Input correlation data (Q component)                      |\n| `o_data_i`       | Output    | `NBW_IN + N_LEVELS`                   | Accumulated correlation result for I                      |\n| `o_data_q`       | Output    | `NBW_IN + N_LEVELS`                   | Accumulated correlation result for Q                      |\n| `o_energy`       | Output    | `NBW_ENERGY`                          | Truncated energy result from the squared I and Q results  |\n| `o_aware_mode`   | Output    | 1 bit                                 | High when current mode is valid                           |\n\n---\n\n### `correlate`\nThe `correlate` module has been updated to support a new 2-bit input signal `i_mode`. Its behavior is determined by this mode:\n\n- `i_mode == 2'b00`: operates as originally specified.\n- `i_mode == 2'b01`: always subtracts incoming data for correlation index computation.\n- `i_mode == 2'b10`: always adds incoming data for correlation index computation.\n- `i_mode == 2'b11`: outputs all-zero indices, effectively disabling correlation.\n\nThis logic allows dynamic reconfiguration of correlation behavior based on system-level FSM control.\n\n---\n\n## Notes\n\n- The `adder_2d_layers` module includes sequential (pipelining) and combinational (energy calculation) logic as specified.\n- Mode-awareness and reset propagation must be handled through the existing interfaces.\n- All configuration must be managed through top-level parameters to ensure consistency across submodules.", "docs/spec_detect_sequence.md": "# Sequence Detection Module (`detect_sequence.sv`)\n\n## Parameters\n\n| Parameter           | Description                                               | Default | Constraints                                                             |\n|---------------------|-----------------------------------------------------------|---------|-------------------------------------------------------------------------|\n| `NS`                | Number of pilot symbols                                   | 64      | Minimum 32, maximum 64, must be a multiple of 2                         |\n| `NBW_PILOT_POS`     | Bit width to address position within `NS`                 | 6       | Must be equal to `ceil(log2(NS))`                                       |\n| `NBW_DATA_SYMB`     | Bit width of each I/Q data sample                         | 8       | Minimum 3                                                               |\n| `NBI_DATA_SYMB`     | Number of integer bits within each sample                 | 2       | Must be `NBW_DATA_SYMB - 2`                                             |\n| `NBW_TH_UNLOCK`     | Bit width of unlock threshold input                       | 3       | Determines range for FSM unlock threshold                               |\n| `NBW_ENERGY`        | Bit width of energy output from correlation               | 10      | Should match cross correlation output width                             |\n| `NS_FAW`            | Number of samples used in FAW correlation                 | 23      | Fixed value                                                             |\n| `NS_FAW_OVERLAP`    | Overlap used in FAW correlation                           | 22      | Must be equal to `NS_FAW - 1`                                           |\n\n---\n\n## Interfaces\n\n### Inputs\n\n| Signal                     | Width                                    | Description                                        |\n|----------------------------|------------------------------------------|----------------------------------------------------|\n| `clk`                      | 1                                        | System clock                                       |\n| `rst_async_n`              | 1                                        | Asynchronous active-low reset                      |\n| `i_valid`                  | 1                                        | Valid signal to indicate valid input window        |\n| `i_enable`                 | 1                                        | Global enable for detection                        |\n| `i_proc_pol`               | 1                                        | Sequence polarity selector (horizontal/vertical)   |\n| `i_proc_pos`               | `NBW_PILOT_POS`                          | Processing start position                          |\n| `i_static_unlock_threshold`| `NBW_TH_UNLOCK`                          | Threshold for sequence unlock in FSM               |\n| `i_data_i`                 | `NBW_DATA_SYMB * (NS + NS_FAW_OVERLAP)`  | Flattened I input samples for full window          |\n| `i_data_q`                 | `NBW_DATA_SYMB * (NS + NS_FAW_OVERLAP)`  | Flattened Q input samples for full window          |\n\n### Outputs\n\n| Signal            | Width  | Description                                |\n|-------------------|--------|--------------------------------------------|\n| `o_proc_detected` | 1      | Detection flag output (1 = sequence found) |\n| `o_locked`        | 1      | Lock status output (1 = tracking active)   |\n\n---\n\n## Logic Description\n\n### Conjugate Sequence Setup\n\nTwo predefined sequences must be stored to represent conjugate reference signals in the complex plane. These sequences correspond to expected pilot patterns in both horizontal and vertical orientations. The values should be constructed by computing the complex conjugate of the ideal signal, converting it to fixed-point representation, and then encoding the real and imaginary parts as bitstreams.\n\nThe module must allow dynamic selection between these two sequences based on a polarity signal. The selected conjugate must be assigned combinationally using the registered version of `i_proc_pol`.\n\nFor more information, refer docs/spec_conj.md\n\n### Enable Pipeline\n\nA global `enable` signal must be formed by combining `i_valid` and `i_enable`. This signal must be propagated through a pipeline of flip-flops. The number of stages in the pipeline must match the internal latency of the `cross_correlation` module.\n\n- The **first stage** of the pipeline is used to drive the `i_enable` input of `cross_correlation`.\n- The **last stage** must be used to validate the final detection output (`o_proc_detected`).\n- When reset is active, all pipeline stages must be cleared to zero.\n\n### Input Data Buffering\n\nOn the rising edge of the clock, when the global enable is active **before** the pipeline, a window of `NS_FAW` samples must be extracted from both `i_data_i` and `i_data_q` starting at position `i_proc_pos`. These samples must be stored in internal registers.\n\n### FSM-Based Detection Logic\n\nA finite state machine (FSM) controls the operation of the module and manages detection locking. It contains two states:\n\n- `ST_DETECT_SEQUENCE`: Initial scanning mode. In this state:\n  - The `cross_correlation` mode is forced to 0.\n  - `o_locked` output is low.\n  - If detection (`o_proc_detected`) is asserted and the mode is valid (`o_aware_mode`), the FSM transitions to `ST_DETECT_PROC`.\n\n- `ST_DETECT_PROC`: Tracking mode. In this state:\n  - The module monitors correlation energy for continued detection.\n  - A cycle counter counts up to the detection window size.\n  - A separate counter increments if detection fails at the end of a window.\n  - If detection fails and the undetected counter reaches the configured threshold (`i_static_unlock_threshold`), the FSM transitions back to `ST_DETECT_SEQUENCE`.\n\nThe `o_locked` output is high when in the `ST_DETECT_PROC` state and detection is being successfully confirmed.\n\n### Counters\n\n- **Sequence Count**: Tracks the number of cycles in a detection processing window.\n- **Undetected Count**: Tracks how many consecutive processing windows failed to detect the sequence.\n\nBoth counters must reset when FSM transitions states or when `rst_async_n` is low. The bit-width of these counters must be sufficient to count up to 58 processing windows (based on the reference document `words_counting.md`).\n\n### Cross-Correlation Output Processing\n\nThe output energy from the `cross_correlation` module must be compared against an internal threshold. The decision logic varies based on FSM state:\n\n- In `ST_DETECT_SEQUENCE`, detection output is only used to trigger FSM state change.\n- In `ST_DETECT_PROC`, detection success resets the undetected counter and maintains lock. Failure increments the counter.\n\nThe result is registered and forwarded to `o_proc_detected`.", "docs/valid_modes.md": "Valid modes are the numbers:\n- 0\n- 1\n- 2", "docs/words_counting.md": "11111110101000001100010110100001010010000100010010001000110111010011001010010011011110011111100111001011010110011100001001111011101010000010010011010100011110010010100000111011010010111101111110010001000010000101010100001111010100001011110000011111110101101100011000010010110011111100001010010110010101111011010010111111101101000010100101100000011000001011100000111000110011100011010011001110010010100100110111001011010010001110011111000000010111010100101101011101011010110010111011111000011101101010001001110011001111010001100101111101000001100110101100011001001010100011111110010100101011111101111011000110111100110011111111111011100011101000101000110001111110001111011111100000110110110111001011011110011001111011000100101100110011101011111001110110101110011100101000110001010011001001001111010101000001100111010110110010001111001110110011111010011110111101000011010101001101101111000001001100010111101101010110001011011100101011100101100101110111010111110001110001100010111001010011000110010001011101001010010100111000010000101010000011001010010110011011000110011010001100100111100110001110001110101111110001010010010100111100011001011001011000011000011010001011001111100011000111100010010101100100100011001011100010011101010001100101000010011101110110111000011001100110000111101110001011110111000000000011111100110111100110101100010001000100000000110010010010101110000011001001010111010100001101010101110100111000100101010000101001100110101101010001011000011100111111000111010000110001010001010001011111001100100001100011010000110101000001101111111100101100100001101011111011100011110000011100100110000011001100111111101001001110101000000111000111001011001100001001001100001100010011110111010100111100000101000011111111110001111101100110100000010010110000110100100110011011011000101011001111011000101001111000110000000010101110011111010000000110111110", "rtl/adder_2d_layers.sv": "module adder_2d_layers #(\n    parameter NBW_IN   = 'd8        ,\n    parameter NS_IN    = 'd80       ,\n    parameter N_LEVELS = 'd7        ,\n    parameter REGS     = 8'b100010_0,\n    parameter NBW_ADDER_TREE_OUT = 8,\n    parameter NBW_ENERGY = 5\n) (\n    input  logic                                clk    ,\n    input  logic                               i_enable,\n    input  logic [           NBW_IN*NS_IN-1:0] i_data_i,\n    input  logic [           NBW_IN*NS_IN-1:0] i_data_q,\n    output logic [(NBW_IN+N_LEVELS)-1:0] o_data_i,\n    output logic [(NBW_IN+N_LEVELS)-1:0] o_data_q,\n    output logic [NBW_IN-1:0] o_energy    \n);\n\nlogic signed [NBW_ADDER_TREE_OUT-1:0] correlation_i_dff;\nlogic signed [NBW_ADDER_TREE_OUT-1:0] correlation_q_dff;\n\nwire signed [2*NBW_ADDER_TREE_OUT-1:0] energy_i;\nwire signed [2*NBW_ADDER_TREE_OUT-1:0] energy_q;\nwire signed [2*NBW_ADDER_TREE_OUT:0] energy;\n\n/*Sum all corelation_i components */\nadder_tree_2d #(\n    .NBW_IN  (NBW_IN  ),\n    .NS_IN   (NS_IN   ),\n    .N_LEVELS(N_LEVELS),\n    .REGS    (REGS    ) \n) uu_sum_corr_i (\n        .clk   (clk            ),\n        .i_data(i_data_i       ),\n        .o_data(o_data_i       )\n);\n\n/*Sum all corelation_q components */\nadder_tree_2d #(\n    .NBW_IN  (NBW_IN  ),\n    .NS_IN   (NS_IN   ),\n    .N_LEVELS(N_LEVELS),\n    .REGS    (REGS    ) \n) uu_sum_corr_q (\n        .clk   (clk            ),\n        .i_data(i_data_q       ),\n        .o_data(o_data_q       )\n);\n\nalways_ff @(posedge clk) begin : proc_correlation_dff\n  if(i_enable) begin\n      correlation_i_dff <= o_data_i;\n      correlation_q_dff <= o_data_q;\n   end \nend\n\nassign energy_i  = correlation_i_dff*correlation_i_dff;\nassign energy_q  = correlation_q_dff*correlation_q_dff;\nassign energy    = $unsigned(energy_i) + $unsigned(energy_q);\nassign o_energy  = energy[2*NBW_ADDER_TREE_OUT-:NBW_ENERGY];\n\n\nendmodule", "rtl/adder_tree_2d.sv": "module adder_tree_2d #(\n    parameter NBW_IN   = 'd8        ,\n    parameter NS_IN    = 'd80       ,\n    parameter N_LEVELS = 'd7        ,\n    parameter REGS     = 8'b100010_0\n) (\n    input  logic                                clk               ,\n    input  logic        [NBW_IN*NS_IN-1:0]      i_data,\n    output logic signed [(NBW_IN+N_LEVELS)-1:0] o_data\n);\n    logic signed [NBW_IN-1:0] i_data_2d [NS_IN-1:0];\n\n    always_comb begin\n      for(int k = 0; k < NS_IN; k++) begin\n         i_data_2d[k] = $signed(i_data[(k+1)*NBW_IN-1-:NBW_IN]);\n      end\n    end\n\n    function automatic integer func_nadd (input integer level);\n        integer i;\n        integer nadd;\n        begin\n            nadd = $signed(NS_IN);\n            for (i=0; i<level; i=i+1) begin\n                nadd = (nadd+1)/2;\n            end\n            func_nadd = nadd;\n        end\n    endfunction\n\n    genvar i,j;\n    generate\n        for (i=0; i<=N_LEVELS; i=i+1) begin : levels\n\n            for (j=0; j<func_nadd(i); j=j+1 ) begin : nodes\n\n                reg signed [i+NBW_IN-1:0] result;\n\n                if (i == 0) begin : gen_initial\n\n                    if (REGS[i]) begin: gen_init_reg\n                        always_ff @ (posedge clk) begin : in_split_reg\n                            begin\n                                result <= $signed(i_data_2d[j]);\n                            end\n                        end\n                    end else begin : gen_comb\n                        always_comb begin : in_split_comb\n                            result = $signed(i_data_2d[j]);\n                        end\n                    end\n\n                end else if (2*j+1 == func_nadd(i-1)) begin : gen_others\n\n                    if (REGS[i]) begin : gen_reg\n                        always_ff @ (posedge clk) begin : odd_reg\n                            begin\n                                result <= levels[i-1].nodes[2*j+0].result;\n                            end\n                        end\n                    end else begin : gen_comb\n                        always_comb begin : odd \n                            result = levels[i-1].nodes[2*j+0].result;\n                        end\n\n                    end\n\n                end else begin : gen_final\n\n                    if (REGS[i]) begin : gen_end_ff\n                        always_ff @(posedge clk) begin : add_reg\n                            begin\n                                result <= levels[i-1].nodes[2*j+0].result +\n                                    levels[i-1].nodes[2*j+1].result;\n                            end\n                        end\n                    end else begin : gen_end_comb\n                        always_comb begin : add \n                            result = levels[i-1].nodes[2*j+0].result +\n                                levels[i-1].nodes[2*j+1].result;\n                        end\n                    end\n\n                end\n            end\n        end\n    endgenerate\n\n    assign o_data = levels[N_LEVELS].nodes[0].result;\n\nendmodule", "rtl/correlate.sv": "module correlate #(\n   parameter  NS_DATA_IN        = 'd11,\n   parameter  NBW_DATA_IN = 'd08,\n   parameter  NBW_ADDER_TREE_IN = 3\n)\n(\n input  logic [NBW_DATA_IN*NS_DATA_IN-1 : 0]  i_data_i    ,\n input  logic [NBW_DATA_IN*NS_DATA_IN-1 : 0]  i_data_q    ,\n input  logic        [       NS_DATA_IN-1 : 0]  i_conj_seq_i,\n input  logic        [       NS_DATA_IN-1 : 0]  i_conj_seq_q,   \n output logic [NBW_ADDER_TREE_IN*NS_DATA_IN-1:0]o_sum_i,\n output logic [NBW_ADDER_TREE_IN*NS_DATA_IN-1:0]o_sum_q\n\n);\n\nwire signed  [      NBW_DATA_IN:0] add[NS_DATA_IN];\nwire signed  [      NBW_DATA_IN:0] sub[NS_DATA_IN];\n\nlogic signed [NBW_ADDER_TREE_IN-1:0] sum_i[NS_DATA_IN];\nlogic signed [NBW_ADDER_TREE_IN-1:0] sum_q[NS_DATA_IN];\n\nlogic signed [NBW_DATA_IN-1:0]  i_data_i_2d [NS_DATA_IN-1:0]; \nlogic signed [NBW_DATA_IN-1:0]  i_data_q_2d [NS_DATA_IN-1:0]; \n\nwire [NS_DATA_IN-1:0] signal_seq_i;\nwire [NS_DATA_IN-1:0] signal_seq_q;\n\nalways_comb begin\n    for (int i=0; i<NS_DATA_IN; i++) begin\n        i_data_i_2d[i] = $signed(i_data_i[(i+1)*NBW_DATA_IN-1-:NBW_DATA_IN]);\n        i_data_q_2d[i] = $signed(i_data_q[(i+1)*NBW_DATA_IN-1-:NBW_DATA_IN]);\n    end\nend\n\ngenerate\n    for(genvar i = 0 ; i < NS_DATA_IN; i++) begin\n        \n        /*determinate the signal of the FAW symbs*/\n        assign signal_seq_i[i] = i_conj_seq_i[i];\n        assign signal_seq_q[i] = i_conj_seq_q[i];\n\n\n        assign add[i] = i_data_i_2d[i] + i_data_q_2d[i];\n        assign sub[i] = i_data_i_2d[i] - i_data_q_2d[i];\n    \n        always_comb begin\n            case({signal_seq_i[i],signal_seq_q[i]})\n                2'b00: begin\n                            sum_i[i]  = sub[i];\n                            sum_q[i]  = add[i];\n                       end\n\n                2'b01: begin\n                            sum_i[i]  =  add[i];\n                            sum_q[i]  = -sub[i];\n                       end    \n\n                2'b10: begin\n                            sum_i[i]  = -add[i];\n                            sum_q[i]  =  sub[i];\n                       end    \n\n                2'b11: begin\n                            sum_i[i]  = -sub[i];\n                            sum_q[i]  = -add[i];\n                       end    \n            endcase \n        end\n    end    \nendgenerate\n\nalways_comb begin\n    for (int i=0; i<NS_DATA_IN; ++i) begin\n        o_sum_i[(i+1)*NBW_ADDER_TREE_IN-1-:NBW_ADDER_TREE_IN] = sum_i[i];\n        o_sum_q[(i+1)*NBW_ADDER_TREE_IN-1-:NBW_ADDER_TREE_IN] = sum_q[i];\n    end\nend\nendmodule", "rtl/cross_correlation.sv": "module cross_correlation #(\n   parameter  NS_DATA_IN  = 'd11,\n   parameter  NBW_DATA_IN = 'd08,\n   parameter  NBI_DATA_IN = 'd02,   \n   parameter  NBW_ENERGY  = 'd08\n)\n( \n input  logic                                clk         ,\n input  logic                                i_enable    , \n input  logic [NBW_DATA_IN*NS_DATA_IN-1 : 0] i_data_i    ,\n input  logic [NBW_DATA_IN*NS_DATA_IN-1 : 0] i_data_q    ,\n input  logic [NS_DATA_IN-1:0]               i_conj_seq_i,\n input  logic [NS_DATA_IN-1:0]               i_conj_seq_q,\n output logic [NBW_ENERGY-1:0]               o_energy  \n);\nlocalparam N_ADDER_LEVELS= $clog2(NS_DATA_IN);\nlocalparam N_REG_LEVELS  = 8'b00000000;\n\nlocalparam NBW_ADDER_TREE_IN  = NBW_DATA_IN + 2;\nlocalparam NBI_ADDER_TREE_IN  = NBI_DATA_IN + 2;\n\nlocalparam NBW_ADDER_TREE_OUT = NBW_ADDER_TREE_IN  + N_ADDER_LEVELS;\nlocalparam NBI_ADDER_TREE_OUT = NBI_ADDER_TREE_IN  + N_ADDER_LEVELS;\nlocalparam NBF_ADDER_TREE_OUT = NBW_ADDER_TREE_OUT - NBI_ADDER_TREE_OUT;\n\nlogic [NBW_ADDER_TREE_IN*NS_DATA_IN-1:0] sum_i_1d;\nlogic [NBW_ADDER_TREE_IN*NS_DATA_IN-1:0] sum_q_1d;\n\n/*Correlation result for i and q data component*/\nwire signed [NBW_ADDER_TREE_OUT-1:0] correlation_i;\nwire signed [NBW_ADDER_TREE_OUT-1:0] correlation_q;\n\ncorrelate #(\n    .NS_DATA_IN       (NS_DATA_IN       ),\n    .NBW_DATA_IN      (NBW_DATA_IN      ),\n    .NBW_ADDER_TREE_IN(NBW_ADDER_TREE_IN)\n) uu_correlate(\n    .i_data_i    (i_data_i    ),\n    .i_data_q    (i_data_q    ),\n    .i_conj_seq_i(i_conj_seq_i),\n    .i_conj_seq_q(i_conj_seq_q),   \n    .o_sum_i     (sum_i_1d    ),\n    .o_sum_q     (sum_q_1d    )\n);\n\nadder_2d_layers  #(\n    .NBW_IN            (NBW_ADDER_TREE_IN ),\n    .NS_IN             (NS_DATA_IN        ),\n    .N_LEVELS          (N_ADDER_LEVELS    ),\n    .REGS              (N_REG_LEVELS      ),\n    .NBW_ADDER_TREE_OUT(NBW_ADDER_TREE_OUT),\n    .NBW_ENERGY        (NBW_ENERGY        )\n) uu_adder_2d_layers (\n        .clk     (clk            ),\n        .i_enable(i_enable       ),\n        .i_data_i(sum_i_1d       ),\n        .i_data_q(sum_q_1d       ),\n        .o_data_i(correlation_i  ),\n        .o_data_q(correlation_q  ),\n        .o_energy(o_energy)            \n);\n\nendmodule", "rtl/detect_sequence.sv": "module detect_sequence #(\n    parameter    NS              =  'd64      ,\n    parameter    NBW_PILOT_POS   =  'd06      ,\n    parameter    NBW_DATA_IN     =  'd08      ,\n    parameter    NBI_DATA_IN     =  'd02      ,\n    parameter    NBW_TH_PROC     =  'd10      ,\n    parameter    NBW_ENERGY      =  'd10      ,\n    parameter    NS_PROC         =  'd23      ,\n    parameter    NS_PROC_OVERLAP =  NS_PROC - 1\n)\n(\n    input  logic                                        clk               ,\n    input  logic                                        rst_async_n       ,\n    input  logic                                        i_valid           ,\n    input  logic                                        i_enable          ,\n    input  logic                                        i_proc_pol        ,\n    input  logic [NBW_PILOT_POS-1:0]                    i_proc_pos        ,\n    input  logic [NBW_TH_PROC-1:0]                      i_static_threshold,\n    input  logic [NBW_DATA_IN*(NS+NS_PROC_OVERLAP)-1:0] i_data_i          ,\n    input  logic [NBW_DATA_IN*(NS+NS_PROC_OVERLAP)-1:0] i_data_q          ,\n    output logic                                        o_proc_detected    \n);\nlocalparam   PROC_CORR_ADDER_LEVELS   = $clog2(NS_PROC);\nlocalparam   PROC_CORR_REG_LEVELS     = 8'b00000000;\nlocalparam   PIPE_DEPTH              = 3;\n\nlogic [NS_PROC-1:0] conj_proc_h[2];\nlogic [NS_PROC-1:0] conj_proc_v[2];\n\nassign conj_proc_h[1] = 23'b11011001100011010001110;\nassign conj_proc_v[1] = 23'b10000101011110000101011;\n\nassign conj_proc_h[0] = 23'b10101010111011101000000;\nassign conj_proc_v[0] = 23'b11010110101100100001110;\n\nlogic signed [NBW_DATA_IN-1:0]  i_data_i_2d[(NS+NS_PROC_OVERLAP)];\nlogic signed [NBW_DATA_IN-1:0]  i_data_q_2d[(NS+NS_PROC_OVERLAP)];\n\nalways_comb begin\n    for (int i=0; i<(NS+NS_PROC_OVERLAP); i++) begin\n        i_data_i_2d[i] = $signed(i_data_i[(i+1)*NBW_DATA_IN-1-:NBW_DATA_IN]);\n        i_data_q_2d[i] = $signed(i_data_q[(i+1)*NBW_DATA_IN-1-:NBW_DATA_IN]);\n    end\nend\n\nlogic  [PIPE_DEPTH-1:0] proc_enable_dff;\n\nlogic  proc_detected_dff;\n\nlogic  proc_pol_dff;\n\nlogic signed [NBW_DATA_IN-1:0] proc_buffer_i_dff[NS_PROC];\nlogic signed [NBW_DATA_IN-1:0] proc_buffer_q_dff[NS_PROC];\nlogic signed [NBW_DATA_IN*NS_PROC-1:0] proc_buffer_i_dff_1d;\nlogic signed [NBW_DATA_IN*NS_PROC-1:0] proc_buffer_q_dff_1d;\nlogic                     proc_enable;      \nlogic [NBW_ENERGY  -1 :0] proc_calc_energy; \nlogic [       NS_PROC-1:0] conj_proc_seq[2];\n\nassign proc_enable  = i_valid & i_enable;\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : proc_proc_enable_dff\n  if(~rst_async_n) \n    proc_enable_dff <= {PIPE_DEPTH{1'b0}};\n  else begin\n    proc_enable_dff[0] <= proc_enable;\n    for(int i = 1 ; i < PIPE_DEPTH ; i++)\n      proc_enable_dff[i] <= proc_enable_dff[i-1];\n  end\nend\n\nalways_ff @(posedge clk) begin\n    if(proc_enable) begin\n      for(int i = 0; i < NS_PROC; i++) begin\n        proc_buffer_i_dff[i] <=  i_data_i_2d[i_proc_pos + i];\n        proc_buffer_q_dff[i] <=  i_data_q_2d[i_proc_pos + i];\n      end\n    end\nend\n\nalways_ff @(posedge clk or negedge rst_async_n) begin\n    if(~rst_async_n)\n        proc_pol_dff <= 1'b0;\n    else      \n      if(proc_enable)\n        proc_pol_dff <=  i_proc_pol;\nend\n\nalways_comb begin\n  if(proc_pol_dff) begin\n    conj_proc_seq[0] = conj_proc_v[0];\n    conj_proc_seq[1] = conj_proc_v[1];\n  end\n  else begin\n    conj_proc_seq[0] = conj_proc_h[0];\n    conj_proc_seq[1] = conj_proc_h[1];    \n  end\nend\n\nalways_comb begin\n  for (int i=0; i<NS_PROC; ++i) begin\n    proc_buffer_i_dff_1d[(i+1)*NBW_DATA_IN-1-:NBW_DATA_IN] = proc_buffer_i_dff[i];\n    proc_buffer_q_dff_1d[(i+1)*NBW_DATA_IN-1-:NBW_DATA_IN] = proc_buffer_q_dff[i];\n  end\nend\n\ncross_correlation #(\n        .NS_DATA_IN  (NS_PROC     ),\n        .NBW_DATA_IN (NBW_DATA_IN ),\n        .NBI_DATA_IN (NBI_DATA_IN ),\n        .NBW_ENERGY  (NBW_ENERGY  )\n  ) uu_cross_correlation(\n     .clk         (clk                 ),\n     .i_enable    (proc_enable_dff[0]  ),\n     .i_data_i    (proc_buffer_i_dff_1d),\n     .i_data_q    (proc_buffer_q_dff_1d),\n     .i_conj_seq_i(conj_proc_seq[0]    ),\n     .i_conj_seq_q(conj_proc_seq[1]    ),\n     .o_energy    (proc_calc_energy    )\n);\n\nassign proc_detected  =   (proc_calc_energy >= i_static_threshold ) && proc_enable_dff[2]; \n\nalways_ff @(posedge clk or negedge rst_async_n) begin : proc_proc_detected_dff\n  if(~rst_async_n) \n     proc_detected_dff <= 1'b0;\n  else\n     proc_detected_dff <=  proc_detected;\nend\n\nassign o_proc_detected = proc_detected_dff;\n\nendmodule"}, "patch": {"rtl/adder_2d_layers.sv": "", "rtl/correlate.sv": "", "rtl/cross_correlation.sv": "", "rtl/detect_sequence.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : /bin/sh -c \"pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s\"", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/detect_sequence.sv /code/rtl/cross_correlation.sv /code/rtl/adder_tree_2d.sv /code/rtl/adder_2d_layers.sv /code/rtl/correlate.sv\nTOPLEVEL        = detect_sequence\nMODULE          = test_detect_sequence\nPYTHONPATH      = /src\nHASH            = 31-modify-rtl-detect-sequence", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nimport math\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# Reset the DUT (design under test)\nasync def reset_dut(reset_n, duration_ns=10):\n    reset_n.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")   \n\ndef check_instances(dut):\n    assert hasattr(dut, 'uu_cross_correlation'), \"Module cross_correlation does not exist\"\n    assert hasattr(dut.uu_cross_correlation, 'uu_adder_2d_layers'), \"Module adder_2d_layers does not exist\"\n    assert hasattr(dut.uu_cross_correlation, 'uu_correlate'), \"Module correlate does not exist\"\n    assert hasattr(dut.uu_cross_correlation.uu_adder_2d_layers, 'uu_sum_corr_i'), \"Module uu_sum_corr_i does not exist\"\n    assert hasattr(dut.uu_cross_correlation.uu_adder_2d_layers, 'uu_sum_corr_q'), \"Module uu_sum_corr_q does not exist\"    \n\ndef check_inteface_changes(dut):\n    assert hasattr(dut, 'NBW_TH_UNLOCK'), f\"Parameter NBW_TH_UNLOCK does not exist\"\n    assert not hasattr(dut, 'NBW_TH_PROC'), f\"Parameter NBW_TH_PROC exist\"\n    assert hasattr(dut, 'i_static_unlock_threshold'), f\"Input i_static_unlock_threshold does not exist\"\n    assert not hasattr(dut, 'i_static_threshold'), f\"Input i_static_threshold exist\"\n    assert hasattr(dut, 'o_locked'), f\"Output o_locked does not exist\"\n    assert hasattr(dut.uu_cross_correlation, 'i_mode'), f\"Input i_mode does not exist\"\n    assert hasattr(dut.uu_cross_correlation, 'o_aware_mode'), f\"Output o_aware_mode does not exist\"\n    assert hasattr(dut.uu_cross_correlation, 'rst_async_n'), f\"Output rst_async_n does not exist\"\n    assert hasattr(dut.uu_cross_correlation.uu_correlate, 'i_mode'), f\"Input i_mode does not exist\"\n    assert hasattr(dut.uu_cross_correlation.uu_adder_2d_layers, 'i_mode'), f'Input i_mode does not exist'\n    assert hasattr(dut.uu_cross_correlation.uu_adder_2d_layers, 'o_aware_mode'), f'Output o_aware_mode does not exist'\n    assert hasattr(dut.uu_cross_correlation.uu_adder_2d_layers, 'rst_async_n'), f'Output rst_async_n does not exist'\n\n\nclass FSM:\n    ST_DETECT_TS = 0\n    ST_DETECT_FAW = 1\n\n    def __init__(self, n_ts_cycles=58):\n        self.mode_nx = 0\n        self.mode = 0\n        self.N_TS_CYCLES = n_ts_cycles\n        self.N_FAW_CYCLES = self.N_TS_CYCLES * 49\n\n        self.i_static_unlock_threshold = None\n\n        self.curr_state = self.ST_DETECT_TS\n        self.nxt_state = self.ST_DETECT_TS\n\n        self.ts_count_dff = 0\n        self.nxt_ts_count = 0\n\n        self.ts_undetected_count_dff = 0\n        self.nxt_ts_undetected_count = 0\n\n        self.o_locked = 0\n        self.o_locked_delayed = 0\n\n    def set_unlock_threshold(self, threshold):\n        self.i_static_unlock_threshold = threshold\n\n    def proc_ts_count_dff(self, rst_async_n: bool):\n        if not rst_async_n:\n            self.ts_count_dff = 0\n        else:\n            self.ts_count_dff = self.nxt_ts_count\n\n    def proc_nxt_ts_count(self, curr_state: int, i_valid: bool):\n        if curr_state == self.ST_DETECT_TS:\n            self.nxt_ts_count = 0\n        else:\n            if i_valid:\n                if self.ts_count_dff == self.N_TS_CYCLES - 1:\n                    self.nxt_ts_count = 0\n                else:\n                    self.nxt_ts_count = self.ts_count_dff + 1\n            else:\n                self.nxt_ts_count = self.ts_count_dff\n\n    def proc_state_dff(self, rst_async_n: bool):\n        if not rst_async_n:\n            self.curr_state = self.ST_DETECT_TS\n        else:\n            self.curr_state = self.nxt_state\n\n    def proc_next_state(self, o_proc_detected, i_static_unlock_threshold, i_valid, i_aware_mode):\n        self.i_static_unlock_threshold = i_static_unlock_threshold\n\n        self.proc_state_dff(True)\n        self.proc_ts_count_dff(True)\n        self.proc_nxt_ts_count(self.curr_state, i_valid)\n        self.proc_ts_undetected_count_dff(True)\n        self.proc_nxt_ts_undetected_count(self.curr_state, o_proc_detected)\n       \n        self.o_locked_delayed = self.o_locked\n        self.mode = self.mode_nx\n        if self.curr_state == self.ST_DETECT_TS:\n            self.mode_nx = 0\n            self.o_locked = self.o_locked_delayed\n            if o_proc_detected and i_aware_mode == 1:\n                self.nxt_state = self.ST_DETECT_FAW\n            else:\n                self.nxt_state = self.ST_DETECT_TS\n\n        elif self.curr_state == self.ST_DETECT_FAW:\n            if (self.ts_count_dff == self.N_TS_CYCLES - 1 and\n                not o_proc_detected and\n                self.ts_undetected_count_dff == self.i_static_unlock_threshold):\n                self.nxt_state = self.ST_DETECT_TS\n                self.mode_nx = 0\n                self.o_locked = self.o_locked_delayed\n            elif o_proc_detected:\n                self.o_locked = 1\n                self.nxt_state = self.ST_DETECT_FAW\n                self.mode_nx = 0\n            else:\n                self.o_locked = self.o_locked_delayed\n                self.nxt_state = self.ST_DETECT_TS\n                self.mode_nx = self.ts_undetected_count_dff\n        else:\n            self.nxt_state = self.ST_DETECT_TS\n\n    def proc_ts_undetected_count_dff(self, rst_async_n: bool):\n        if not rst_async_n:\n            self.ts_undetected_count_dff = 0\n        else:\n            self.ts_undetected_count_dff = self.nxt_ts_undetected_count\n\n    def proc_nxt_ts_undetected_count(self, curr_state: int, o_proc_detected: bool):\n        if curr_state == self.ST_DETECT_TS:\n            self.nxt_ts_undetected_count = 0\n        else:\n            if self.ts_count_dff == self.N_TS_CYCLES - 1:\n                if o_proc_detected:\n                    self.nxt_ts_undetected_count = 0\n                else:\n                    self.nxt_ts_undetected_count = self.ts_undetected_count_dff + 1\n            else:\n                self.nxt_ts_undetected_count = self.ts_undetected_count_dff\n\n\n\nclass detect_sequence:\n    def __init__(self, ns = 64, nbw_pilot_pos = 6, nbw_data_symb = 8, nbw_energy = 10, ns_proc = 23, ns_proc_overlap = 22):\n        self.ns = ns\n        self.nbw_pilot_pos = nbw_pilot_pos\n        self.nbw_data_symb = nbw_data_symb\n        self.nbw_energy = nbw_energy\n        self.ns_proc_overlap = ns_proc_overlap\n        self.ns_proc = ns_proc\n        self.pipe_depth = 4\n        self.proc_enable_dff = self.pipe_depth * [0]\n        self.proc_buffer_i_dff = self.ns_proc * [0]\n        self.proc_buffer_q_dff = self.ns_proc * [0]\n        self.i_data_i_2d_delayed = (self.ns + self.ns_proc_overlap) * [0]\n        self.i_data_q_2d_delayed = (self.ns + self.ns_proc_overlap) * [0]\n        self.i_proc_pos_delayed = 0\n        self.proc_buffer_i_dff_delayed_2 = self.ns_proc * [0]\n        self.proc_buffer_q_dff_delayed_2 = self.ns_proc * [0]                \n        self.proc_detected = 0\n        self.proc_detected_dff = 0\n        self.proc_pol_dff = 0\n        self.proc_pol_dff_delayed = 0\n        self.conj_proc_h_1 = 0b11011001100011010001110\n        self.conj_proc_v_1 = 0b10000101011110000101011\n        self.conj_proc_h_0 = 0b10101010111011101000000\n        self.conj_proc_v_0 = 0b11010110101100100001110        \n        self.conj_proc_0 = 0 \n        self.conj_proc_1 = 0\n\n        N_ADDER_LEVELS = math.ceil(math.log2(self.ns_proc))\n        NBW_ADDER_TREE_IN = self.nbw_data_symb + 2\n        NBW_ADDER_TREE_OUT = NBW_ADDER_TREE_IN + N_ADDER_LEVELS\n\n        self.proc_processor = FawSymbolProcessor(\n            ns_data_in=self.ns_proc,\n            nbw_adder_tree_out=NBW_ADDER_TREE_OUT,\n            nbw_energy=nbw_energy\n        )\n\n        self.fsm = FSM()\n\n    def insert_data_and_process(self, i_valid, i_enable, i_proc_pol, i_proc_pos, i_data_i_2d, i_data_q_2d):\n        self.proc_enable = i_valid & i_enable\n        for i in reversed(range(self.pipe_depth-1)):\n            self.proc_enable_dff[i+1] = self.proc_enable_dff[i]\n        self.proc_enable_dff[0] = self.proc_enable\n\n        self.proc_buffer_i_dff_delayed = self.proc_buffer_i_dff\n        self.proc_buffer_q_dff_delayed = self.proc_buffer_q_dff\n        self.proc_pol_dff_delayed = self.proc_pol_dff\n\n        for i in range(self.ns_proc):\n            self.proc_buffer_i_dff[i] = self.i_data_i_2d_delayed[self.i_proc_pos_delayed+i]\n            self.proc_buffer_q_dff[i] = self.i_data_q_2d_delayed[self.i_proc_pos_delayed+i]\n        if self.proc_enable:\n            self.proc_pol_dff = i_proc_pol\n            self.i_proc_pos_delayed = i_proc_pos\n            self.i_data_i_2d_delayed = i_data_i_2d\n            self.i_data_q_2d_delayed = i_data_q_2d\n\n\n        if self.proc_pol_dff_delayed:\n            self.conj_proc_0 = self.conj_proc_v_0\n            self.conj_proc_1 = self.conj_proc_v_1\n        else:\n            self.conj_proc_0 = self.conj_proc_h_0\n            self.conj_proc_1 = self.conj_proc_h_1  \n\n        sum_i, sum_q = self.proc_processor.process(\n            i_enable=self.proc_enable_dff[1],\n            i_conj_seq_i_int=self.conj_proc_0,\n            i_conj_seq_q_int=self.conj_proc_1,\n            i_data_i_2d=self.proc_buffer_i_dff_delayed,\n            i_data_q_2d=self.proc_buffer_q_dff_delayed,\n            i_mode=self.fsm.mode\n        )\n\n        self.proc_detected_dff = self.proc_detected\n        if self.proc_processor.o_energy_delayed >= 0:\n            self.proc_detected = 1  & self.proc_enable_dff[3]\n        else:\n            self.proc_detected = 0             \n\n        self.fsm.proc_next_state(self.proc_detected_dff, i_static_unlock_threshold=3, i_valid=i_valid, i_aware_mode=self.proc_processor.aware_mode)\n\nclass FawSymbolProcessor:\n    def __init__(self, ns_data_in, nbw_adder_tree_out, nbw_energy):\n        self.ns_data_in = ns_data_in\n        self.nbw_adder_tree_out = nbw_adder_tree_out\n        self.nbw_energy = nbw_energy\n        self.energy_i_delayed = 0 \n        self.energy_q_delayed = 0 \n        self.energy_delayed   = 0 \n        self.o_energy_delayed = 0\n        self.energy_i = 0 \n        self.energy_q = 0 \n        self.energy   = 0 \n        self.o_energy = 0\n        self.model_sum_all_i = 0\n        self.model_sum_all_q = 0\n        self.aware_mode = 0\n        self.aware_mode_delayed = 0\n\n    def _int_to_bit_list(self, value):\n        return [(value >> i) & 1 for i in range(self.ns_data_in)]\n    \n    def process(self, i_enable, i_conj_seq_i_int, i_conj_seq_q_int, i_data_i_2d, i_data_q_2d, i_mode=0):\n        i_enable_0 = i_enable & 1\n        #i_enable_1 = (i_enable >> 1) & 1\n\n        i_conj_seq_i = self._int_to_bit_list(i_conj_seq_i_int)\n        i_conj_seq_q = self._int_to_bit_list(i_conj_seq_q_int)\n\n        assert len(i_data_i_2d) == self.ns_data_in\n        assert len(i_data_q_2d) == self.ns_data_in\n        sum_i = []\n        sum_q = []\n\n        for i in range(self.ns_data_in):\n            signal_seq_i = i_conj_seq_i[i]\n            signal_seq_q = i_conj_seq_q[i]\n\n            add = i_data_i_2d[i] + i_data_q_2d[i]\n            sub = i_data_i_2d[i] - i_data_q_2d[i]\n\n            if i_mode == 0:\n                selector = (signal_seq_i << 1) | signal_seq_q\n                if selector == 0b00:\n                    sum_i.append(sub)\n                    sum_q.append(add)\n                elif selector == 0b01:\n                    sum_i.append(add)\n                    sum_q.append(-sub)\n                elif selector == 0b10:\n                    sum_i.append(-add)\n                    sum_q.append(sub)\n                elif selector == 0b11:\n                    sum_i.append(-sub)\n                    sum_q.append(-add)\n                else:\n                    raise ValueError(f\"Invalid selector: {selector}\")\n            elif i_mode == 1:\n                sum_i.append(sub)\n                sum_q.append(sub)\n            elif i_mode == 2:\n                sum_i.append(add)\n                sum_q.append(add)\n            elif i_mode == 3:\n                sum_i.append(0)\n                sum_q.append(0)\n\n        self.model_sum_all_i = sum(sum_i)        \n        self.model_sum_all_q = sum(sum_q)        \n\n        self.energy_i_delayed = self.energy_i\n        self.energy_q_delayed = self.energy_q\n        self.energy_delayed   = self.energy\n        self.o_energy_delayed = self.o_energy  \n\n        self.aware_mode_delayed = self.aware_mode\n        self.aware_mode = 1 if i_mode <= 2 else 0\n        \n\n        if i_enable_0:\n            self.energy_i = self.model_sum_all_i*self.model_sum_all_i\n            self.energy_q = self.model_sum_all_q*self.model_sum_all_q\n            self.energy   = self.energy_i + self.energy_q\n            self.o_energy = (self.energy >> int((2*self.nbw_adder_tree_out+1-self.nbw_energy))) & (2**self.nbw_energy-1)\n            #print(f\"self.nbw_adder_tree_out:{self.nbw_adder_tree_out}, self.energy:{self.energy}\")\n                \n        return sum_i, sum_q\n", "src/test_detect_sequence.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport harness_library as hrs_lb\nimport random\nimport math\nimport cmath\n\n@cocotb.test()\nasync def test_detect_sequence(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Debug mode\n    debug = 0\n\n    # Retrieve parameters from the DUT\n    NS_PROC = int(dut.NS_PROC.value)\n    NS_PROC_OVERLAP = NS_PROC - 1\n    NS  = int(dut.NS.value)\n    NS_DATA_IN = NS + NS_PROC_OVERLAP\n    NBW_PILOT_POS = int(dut.NBW_PILOT_POS.value)\n    NBW_DATA_IN = int(dut.NBW_DATA_IN.value)\n    NBI_DATA_IN = int(dut.NBI_DATA_IN.value)\n    NBW_ENERGY  = int(dut.NBW_ENERGY.value)\n\n    if debug:\n        cocotb.log.warning(f\"NS_PROC: {NS_PROC}, NS_PROC_OVERLAP: {NS_PROC_OVERLAP}, NS_DATA_IN: {NS_DATA_IN}, NBW_PILOT_POS: {NBW_PILOT_POS}, NBW_DATA_IN: {NBW_DATA_IN}, NBI_DATA_IN: {NBI_DATA_IN}, NBW_ENERGY: {NBW_ENERGY}\")\n\n    model = hrs_lb.detect_sequence(ns=NS, nbw_pilot_pos=NBW_PILOT_POS, nbw_data_symb=NBW_DATA_IN, nbw_energy=NBW_ENERGY, ns_proc=NS_PROC, ns_proc_overlap=NS_PROC_OVERLAP)\n\n    await hrs_lb.dut_init(dut)\n    await hrs_lb.reset_dut(dut.rst_async_n)\n    await RisingEdge(dut.clk)\n\n    data_min = int(-2**NBW_DATA_IN / 2)\n    data_max = int((2**NBW_DATA_IN / 2) - 1)\n    \n    num_random_iterations = 100\n    min_active_duration = 60\n    active_start = random.randint(0, num_random_iterations - min_active_duration)\n\n    dut.uu_cross_correlation.uu_adder_2d_layers.energy_i.value = 0\n    dut.uu_cross_correlation.uu_adder_2d_layers.energy_q.value = 0\n    for i in range(NS_PROC):\n        dut.proc_buffer_i_dff[i].value = 0\n        dut.proc_buffer_q_dff[i].value = 0\n\n    visited_states = set()\n\n    hrs_lb.check_instances(dut)\n    hrs_lb.check_inteface_changes(dut)\n    \n    for cycle in range(num_random_iterations):\n        if active_start <= cycle < active_start + min_active_duration:\n            i_enable = 1\n            i_valid = 1\n        else:\n            i_enable = random.randint(0, 1)\n            i_valid = random.randint(0, 1)\n    \n        dut.i_enable.value = i_enable\n        dut.i_valid.value = i_valid\n\n        i_proc_pol  = random.randint(0,1)\n        i_proc_pos  = random.randint(0,2**NBW_PILOT_POS - 1)\n        dut.i_enable.value    = i_enable\n        dut.i_valid.value     = i_valid\n        dut.i_proc_pol.value  = i_proc_pol\n        dut.i_proc_pos.value  = i_proc_pos\n\n        i_data_i_list = [random.randint(data_min, data_max) for _ in range(NS_DATA_IN)]\n        i_data_q_list = [random.randint(data_min, data_max) for _ in range(NS_DATA_IN)]\n\n        i_data_i_value = 0\n        i_data_q_value = 0\n        for idx in range(NS_DATA_IN):\n            i_data_i_value |= (i_data_i_list[idx] & ((1 << NBW_DATA_IN) - 1)) << (NBW_DATA_IN * idx)\n            i_data_q_value |= (i_data_q_list[idx] & ((1 << NBW_DATA_IN) - 1)) << (NBW_DATA_IN * idx)\n\n        dut.i_data_i.value = i_data_i_value\n        dut.i_data_q.value = i_data_q_value\n\n        model.insert_data_and_process(i_valid, i_enable, i_proc_pol, i_proc_pos, i_data_i_list, i_data_q_list)\n\n        if debug:\n            cocotb.log.info(f\"[INPUTS] i_data_i: {i_data_i_list}\")\n            cocotb.log.info(f\"[INPUTS] i_data_q: {i_data_q_list}\")\n            cocotb.log.info(f\"[INPUTS] i_valid : {i_valid}\")\n            cocotb.log.info(f\"[INPUTS] i_enable : {i_enable}\")\n            cocotb.log.info(f\"[INPUTS] i_proc_pol: {i_proc_pol}\")\n            cocotb.log.info(f\"[INPUTS] i_proc_pos: {i_proc_pos}\")\n            cocotb.log.info(f\"[DEBUG] start sample: {i_data_i_list[i_proc_pos]}\")\n\n        await RisingEdge(dut.clk)\n\n        if debug:\n            cocotb.log.info(f\"[DUT] buffer i: {dut.proc_buffer_i_dff.value[0].to_signed()}\")\n            cocotb.log.info(f\"[MOD] buffer i: {model.proc_buffer_i_dff_delayed[0]}\")\n            cocotb.log.info(f\"[DUT] energy: {dut.proc_calc_energy.value.to_signed()}\")\n            cocotb.log.info(f\"[MOD] energy: {model.proc_processor.o_energy_delayed}\")\n\n        assert dut.proc_buffer_i_dff.value[0].to_signed() == model.proc_buffer_i_dff_delayed[0]\n        assert dut.proc_pol_dff.value.to_unsigned() == model.proc_pol_dff_delayed\n        assert dut.conj_proc_seq.value[0].to_unsigned() == model.conj_proc_0\n        assert dut.conj_proc_seq.value[1].to_unsigned() == model.conj_proc_1\n        assert dut.proc_calc_energy.value.to_signed() == model.proc_processor.o_energy_delayed\n\n        if debug:\n            cocotb.log.info(f\"dut: {dut.o_proc_detected.value.to_unsigned()} , model: {model.proc_detected_dff}\")\n            cocotb.log.info(f\"[DETECTED] dut: {dut.proc_enable_dff.value[2]} , model: {model.proc_enable_dff[3]}\")\n\n        assert dut.o_proc_detected.value.to_unsigned() == model.proc_detected_dff\n\n        if debug:\n            cocotb.log.info(f\"[INPUTS] i_valid : {i_valid}\")\n            cocotb.log.info(f\"[DUT] energy: {dut.proc_calc_energy.value.to_signed()}\")\n            cocotb.log.info(f\"[MOD] energy: {model.proc_processor.o_energy_delayed}\")        \n            cocotb.log.info(f\"[MOD] state = {model.fsm.curr_state}, ts_count = {model.fsm.ts_count_dff}, undetected ts = {model.fsm.ts_undetected_count_dff}\")\n            cocotb.log.info(f\"[DUT] state = {dut.curr_state.value.to_unsigned()}, ts_count = {dut.ts_count_dff.value.to_unsigned()}, undetected ts = {dut.ts_undetected_count_dff.value.to_unsigned()}\")\n\n        assert dut.curr_state.value.to_unsigned() == model.fsm.curr_state, f\"[FSM MISMATCH] State: DUT={dut.curr_state.value.to_unsigned()} vs MODEL={model.fsm.curr_state}\"\n        assert dut.ts_count_dff.value.to_unsigned() == model.fsm.ts_count_dff, f\"[FSM MISMATCH] ts_count: DUT={dut.ts_count_dff.value.to_unsigned()} vs MODEL={model.fsm.ts_count_dff}\"\n        assert dut.ts_undetected_count_dff.value.to_unsigned() == model.fsm.ts_undetected_count_dff, f\"[FSM MISMATCH] undetected ts: DUT={dut.ts_undetected_count_dff.value.to_unsigned()} vs MODEL={model.fsm.ts_undetected_count_dff}\"\n\n        if debug:\n            cocotb.log.info(f\"Aware mode: DUT={dut.w_aware_mode.value.to_unsigned()} vs MODEL={model.proc_processor.aware_mode}\")\n\n        assert dut.w_aware_mode.value.to_unsigned() == model.proc_processor.aware_mode, f\"[FSM MISMATCH] Aware mode: DUT={dut.w_aware_mode.value.to_unsigned()} vs MODEL={model.proc_processor.aware_mode}\"\n\n        assert dut.o_locked.value.to_unsigned() == model.fsm.o_locked_delayed, f\"[FSM MISMATCH] Locked: DUT={dut.o_locked.value.to_unsigned()} vs MODEL={model.fsm.o_locked_delayed}\"\n\n        if debug:\n         cocotb.log.info(f\"Locked: DUT={dut.o_locked.value.to_unsigned()} vs MODEL={model.fsm.o_locked_delayed}\")\n        visited_states.add(int(dut.curr_state.value.to_unsigned()))\n\n        if debug:\n          cocotb.log.info(f\"Visited states: {visited_states}\")\n\n    assert 0 in visited_states, \"FSM did not enter state 0\"\n    assert 1 in visited_states, \"FSM did not enter state 1\"\n\n    cocotb.log.info(f\"All tests passed finished.\")", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nimport math\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef runner(NBW_DATA_IN: int, NS_DATA_IN: int, NBI_DATA_IN: int, NBW_ENERGY: int, NBW_PILOT_POS: int):\n    parameters = {\n        \"NBW_DATA_IN\":    NBW_DATA_IN,\n        \"NS\":             NS_DATA_IN,\n        \"NBI_DATA_IN\":    NBI_DATA_IN,\n        \"NBW_ENERGY\":     NBW_ENERGY,\n        \"NBW_PILOT_POS\":  NBW_PILOT_POS,\n        \"NS_PROC\":        23,\n        \"NS_PROC_OVERLAP\":22\n    }\n\n    # Debug information\n    print(f\"[DEBUG] Running simulation with:\")\n    for k, v in parameters.items():\n        print(f\"  {k} = {v}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameters,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\n# Generate valid parameter combinations\ndef generate_param_combinations():\n    combinations = []\n\n    for ns in range(32 , 65, 2):  # NS: 32 to 64, step 2\n        nbw_pilot_pos = int(math.ceil(math.log2(ns)))\n\n        for nbw in range(3, 9):  # NBW_DATA_IN: at least 3\n            nbi = nbw - 2  # NBI = NBW - 2\n            if nbi < 1:\n                continue\n\n            nbw_th_faw = nbw + 2\n            nbw_energy = nbw_th_faw\n\n            combinations.append((nbw, ns, nbi, nbw_energy, nbw_pilot_pos))\n\n    return combinations\n\n\n# Generate and limit number of tests\nN_TESTS = 5\nvalid_param_combinations = generate_param_combinations()\nlimited_param_combinations = valid_param_combinations[:N_TESTS]  # Change [:3] to run more/less\n\n\n# Parametrize using valid (NBW_DATA_IN, NS_DATA_IN, NBI_DATA_IN, NBW_ENERGY, ...) tuples\n@pytest.mark.parametrize(\"NBW_DATA_IN, NS_DATA_IN, NBI_DATA_IN, NBW_ENERGY, NBW_PILOT_POS\", limited_param_combinations)\n@pytest.mark.parametrize(\"test\", range(10))\ndef test_data(NBW_DATA_IN, NS_DATA_IN, NBI_DATA_IN, NBW_ENERGY, NBW_PILOT_POS, test):\n    runner(\n        NBW_DATA_IN=NBW_DATA_IN,\n        NS_DATA_IN=NS_DATA_IN,\n        NBI_DATA_IN=NBI_DATA_IN,\n        NBW_ENERGY=NBW_ENERGY,\n        NBW_PILOT_POS=NBW_PILOT_POS\n    )"}}
{"id": "cvdp_agentic_thunder_diamond_horizon_0119", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a **prbs_gen_check** module that generates or checks  pseudo-random bit sequence (PRBS) data,\n\nThe **prbs_gen_check** module is available at `/rtl/prbs_gen_check.sv` and its' specification in the `/docs` directory. Can you implement the **`scrambler_descrambler.sv`** in the `/rtl` folder? Details of the `scrambler_descrambler` module is as given below\n\n### Purpose\nThe **`scrambler_descrambler`** module should perform a simple data scrambling or descrambling function using a pseudo-random bit sequence (PRBS). It should instantiate the `prbs_gen_check` module to generate the random sequence used for XOR-based scrambling/descrambling. Scrambling involves XORing data with a pseudo-random bit sequence to randomize its pattern. Descrambling uses the same pseudo-random sequence to restore the original data from the scrambled stream.\n\n- It should support a parameterizable data bus width (`WIDTH`).  \n- It should rely on a specific polynomial length (`POLY_LENGTH`) and tap (`POLY_TAP`) for the underlying PRBS generation.  \n- Following features should be added:\n   - Add the input bypass_scrambling. When asserted the input data should be sent unmodified to data_out with a latency of 1 clock cycle.\n   - Add parameter CHECK_MODE. When 0, operate normally as a scrambler or a descrambler. When 1, check if the incoming data is a PRBS pattern or not.\n   - Add output bit_count. This will be used to check the throughput of the module and should be equal to the total valid data bits sent out from this module.\n- Latency considerations: This module should have the following latencies for the cases given:\n   - bypass_scrambling asserted: 1 clk latency\n   - bypass_scrambling deasserted and CHECK_MODE=0 (perform scrambling or descrambling): 1 clk latency.\n   - bypass_scrambling deasserted and CHECK_MODE=1 (perform data_in checking for PRBS): 2 clk latency.\n\n## Interface Definition\n\n\n| **Parameter**   | **Type** | **Default** | **Description**                                                 |\n|-----------------|----------|-------------|-----------------------------------------------------------------|\n| `POLY_LENGTH`   | int      | 31          | Length of the LFSR in the PRBS generator/checker.               |\n| `POLY_TAP`      | int      | 3           | Tap position(s) in the LFSR polynomial for feedback.            |\n| `WIDTH`         | int      | 16          | Data width (in bits) for `data_in` and `data_out`.              |\n| `CHECK_MODE`    | bit      | 0           | 0 => Generator mode (scrambler), 1 => Checker mode (PRBS check).|\n\n| **Port Name**         | **I/O** | **Width**           | **Description**                                                                                 |\n|-----------------------|---------|---------------------|-------------------------------------------------------------------------------------------------|\n| `clk`                 | Input   | 1                   | Primary clock input. Rising edge triggered.                                                     |\n| `rst`                 | Input   | 1                   | Active-high synchronous reset.                                                                  |\n| `bypass_scrambling`   | Input   | 1                   | 1 => pass data directly from `data_in` to `data_out`. 0 => normal scrambler/descrambler path.   |\n| `data_in`             | Input   | `WIDTH` bits        | Data word input for scrambling, descrambling, or checking.                                      |\n| `valid_in`            | Input   | 1                   | Indicates `data_in` is valid on the current cycle. Active-high.                                 |\n| `data_out`            | Output  | `WIDTH` bits        | Scrambled/descrambled (or pass-through) data.                                                   |\n| `valid_out`           | Output  | 1                   | Indicates `data_out` is valid on the current cycle. Active-high.                                |\n| `bit_count`           | Output  | 32 bits             | Total number of valid bits processed (increments by `WIDTH` every time `valid_in`=1).           |\n", "context": {"docs/prbs_specification.md": "# RTL Specification\n\n## 1. Overview\n\n### 1.1 Purpose\nThe **`prbs_gen_check`** module operates in two modes:\n- **Generation Mode**: Outputs a pseudo-random bit sequence (PRBS).\n- **Checker Mode**: Checks incoming data against an internal PRBS reference and flags mismatches.\n\n### 1.2 Scope\n- Supports a configurable data path width (`WIDTH`).\n- Uses a linear feedback shift register (LFSR) defined by polynomial length (`POLY_LENGTH`) and tap location (`POLY_TAP`).\n- Synchronous design with an active-high reset.\n\n---\n\n## 2. Functional Description\n\n### 2.1 Generation Mode (`CHECK_MODE=0`)\n1. On reset, the internal PRBS register (`prbs_reg`) is initialized (commonly to all 1\u2019s).  \n2. Each clock cycle, the LFSR shifts based on its feedback polynomial, producing the next pseudo-random word on `data_out`.\n\n### 2.2 Checker Mode (`CHECK_MODE=1`)\n1. On reset, `prbs_reg` is similarly initialized.  \n2. Each clock cycle, the module generates the \u201cexpected\u201d PRBS bit(s). It then compares each bit of the incoming data (`data_in`) to the internal PRBS reference.  \n3. The output `data_out` is set to `1` on any bit that mismatches, and `0` otherwise.\n\n### 2.3 Reset Behavior\n- `rst` is synchronous, active high.\n- On reset, `prbs_reg` is re-initialized, and the output may be driven to all 1\u2019s until the reset is released.\n\n---\n\n## 3. Interface Definition\n\n| **Port Name** | **I/O** | **Width**   | **Description**                                                                                  |\n|---------------|---------|-------------|--------------------------------------------------------------------------------------------------|\n| `clk`         | In      | 1           | Synchronous clock input.                                                                         |\n| `rst`         | In      | 1           | Synchronous reset, active high.                                                                  |\n| `data_in`     | In      | `WIDTH`     | In checker mode: Data to compare with the PRBS reference. In generator mode: tied to 0.          |\n| `data_out`    | Out     | `WIDTH`     | In generator mode: PRBS output. In checker mode: Bitwise error flags (`1` = mismatch).           |\n\n### 3.1 Parameters\n\n| **Parameter**   | **Type** | **Default** | **Description**                                                                             |\n|-----------------|----------|-------------|---------------------------------------------------------------------------------------------|\n| `CHECK_MODE`    | int      | `0`         | - `0`: Generation Mode <br/> - `1`: Checker Mode                                            |\n| `POLY_LENGTH`   | int      | `31`        | Number of shift register stages in the LFSR.                                                |\n| `POLY_TAP`      | int      | `3`         | Defines which bit(s) is XORed with the final stage for feedback.                            |\n| `WIDTH`         | int      | `16`        | Data path width.                                                                            |\n\n\n---\n\n## 4. Internal Architecture\n\n### 4.1 LFSR\n- A shift register (LFSR) generates the pseudo-random sequence.\n- Feedback is formed by XORing selected bits (defined by `POLY_TAP` and the MSB).\n\n### 4.2 Register Update\n- On each rising clock edge:\n  - If `rst` is asserted, the LFSR is re-initialized.\n  - Otherwise, it shifts in the new feedback bit each cycle.\n\n### 4.3 Output Behavior\n- **Generator Mode**: `data_out` is the new PRBS word each cycle.  \n- **Checker Mode**: `data_out` is the bitwise difference between the incoming data and the expected PRBS sequence.", "rtl/prbs_gen_check.sv": "/**************************************************************************\nFILENAME:    prbs_gen_check.sv\nDESCRIPTION: This module generates or checks a PRBS pattern.\n**************************************************************************/\n\nmodule prbs_gen_check #(\n   parameter CHECK_MODE  = 0,              // 0: uses LFSR structure to generate a PRBS pattern, 1: the incoming data is loaded into prbs registers and compared with locally generated PRBS pattern.\n   parameter POLY_LENGTH = 31,             // length of the polynomial.(number of shift register stages)\n   parameter POLY_TAP    = 3,              // Intermedite stage that is xored with the last stage to generate the next prbs bit.\n   parameter WIDTH       = 16              // Bus size of data_in and data_out.\n   )(\n   input                         clk     , // clock input\n   input                         rst     , // synchronous reset, active high\n   input         [WIDTH-1:0]     data_in , // input data to be checked(checker mode), tied to 0 (generator mode)\n   output logic  [WIDTH-1:0]     data_out  // generated prbs pattern (generator mode), error found (checker mode).\n);\n\nlogic [1:POLY_LENGTH] prbs [WIDTH:0];\nlogic [WIDTH-1:0]     prbs_xor_a;\nlogic [WIDTH-1:0]     prbs_xor_b;\nlogic [WIDTH:1]       prbs_msb;\nlogic [1:POLY_LENGTH] prbs_reg = {(POLY_LENGTH){1'b1}};\n\nassign prbs[0]   = prbs_reg;\n\ngenvar i;\ngenerate for(i=0; i<WIDTH; i=i+1) begin\n   assign prbs_xor_a[i] = prbs[i][POLY_TAP] ^ prbs[i][POLY_LENGTH];\n   assign prbs_xor_b[i] = prbs_xor_a[i] ^ data_in[i];\n   assign prbs_msb[i+1] = (CHECK_MODE==0) ? prbs_xor_a[i] : data_in[i];\n   assign prbs[i+1]     = {prbs_msb[i+1],prbs[i][1:POLY_LENGTH-1]};\nend\nendgenerate\n\nalways_ff @ (posedge clk) begin\n   if(rst) begin\n      prbs_reg <= {POLY_LENGTH{1'b1}};\n      data_out <= {WIDTH{1'b1}};\n   end else begin\n      prbs_reg <= prbs[WIDTH];\n      data_out <= prbs_xor_b;   \n   end\nend\n  \nendmodule"}, "patch": {"rtl/scrambler_descrambler.sv": ""}, "harness": {"docker-compose.yml": "services:\n  \n direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command: pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/prbs_gen_check.sv /code/rtl/scrambler_descrambler.sv\nTOPLEVEL        = scrambler_descrambler\nMODULE          = test_scrambler_descrambler\nPYTHONPATH      = /src\nHASH            = 1-component-integration-scramblerdescrambler", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner(WIDTH: int=4,CHECK_MODE: int=0,POLY_LENGTH:int=31,POLY_TAP: int=3):\n    \n    parameter = {\"WIDTH\":WIDTH, \"CHECK_MODE\":CHECK_MODE, \"POLY_LENGTH\":POLY_LENGTH, \"POLY_TAP\":POLY_TAP}\n    # Debug information\n    print(f\"[DEBUG] Running simulation with WIDTH={WIDTH}, CHECK_MODE={CHECK_MODE}, POLY_LENGTH={POLY_LENGTH}, POLY_TAP={POLY_TAP}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Parametrize test for different WIDTH,CHECK_MODE,POLY_LENGTH,POLY_TAP\n@pytest.mark.parametrize(\"WIDTH\", [4,5,8,12])\n@pytest.mark.parametrize(\"CHECK_MODE\", [0,1])\n@pytest.mark.parametrize(\"POLY_LENGTH\", [7,23,31])\n@pytest.mark.parametrize(\"POLY_TAP\", [1,3,5])\n\ndef test_sort(WIDTH,CHECK_MODE,POLY_LENGTH,POLY_TAP):\n    # Run the simulation with specified parameters\n    test_runner(WIDTH=WIDTH,CHECK_MODE=CHECK_MODE,POLY_LENGTH=POLY_LENGTH,POLY_TAP=POLY_TAP)\n", "src/test_scrambler_descrambler.py": "###############################################################################\n# test_scrambler_descrambler.py\n###############################################################################\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, ClockCycles\n\nimport random\nimport os\n\nasync def reset_dut(dut, cycles=2):\n    \"\"\"Helper routine to reset the DUT for a specified number of clock cycles.\"\"\"\n    dut.rst.value = 1\n    dut.data_in.value = 0\n    dut.valid_in.value = 0\n    dut.bypass_scrambling.value = 0\n    await RisingEdge(dut.clk)\n    for _ in range(cycles):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n# Helper function to generate expected PRBS sequence\ndef generate_prbs(seed, poly_length, poly_tap, width, num_cycles):\n    prbs_reg = [int(x) for x in f'{seed:0{poly_length}b}']\n    prbs_out = []\n\n    for _ in range(num_cycles):\n        prbs_xor_a = []\n        prbs = [prbs_reg]  # Initialize prbs[0] with the current PRBS register\n\n        # Loop through each bit of the output width\n        for i in range(width):\n            # Perform XOR operation between specified tap and last stage of PRBS\n            xor_a = prbs[i][poly_tap - 1] ^ prbs[i][poly_length - 1]\n            prbs_xor_a.append(xor_a)\n\n            # Shift the LFSR and insert the new XOR result to generate next state\n            prbs_next = [xor_a] + prbs[i][0:poly_length - 1]\n            prbs.append(prbs_next)\n\n        # Collect the XOR result as the output for this cycle\n        prbs_out.append(int(''.join(map(str, prbs_xor_a[::-1])), 2))\n\n        # Update the PRBS register with the last stage (prbs[width])\n        prbs_reg = prbs[width]\n\n    return prbs_out\n\n@cocotb.test()\nasync def test_scrambler_descrambler_sequential(dut):\n    \"\"\"\n    Perform a single-run test of the scrambler_descrambler module in two phases:\n      1) Scrambler Phase:\n         - Reset the module\n         - Feed incremental data (0, 1, 2, ...)\n         - Capture the scrambled output\n      2) Descrambler Phase:\n         - Reset the same module again (re-initializing the PRBS)\n         - Feed the previously captured scrambled data\n         - The output should match the original incremental data exactly\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    dut.rst.value = 0\n    dut.data_in.value = 0\n    dut.valid_in.value = 0\n    dut.bypass_scrambling.value = 0\n    check_mode = dut.CHECK_MODE.value\n    await RisingEdge(dut.clk)\n    \n    if(check_mode == 0):\n        # Start the clock\n\n        ######################################################################\n        # PHASE 1: SCRAMBLER\n        ######################################################################\n        # 1) Reset the DUT so the PRBS starts from its known seed\n        await reset_dut(dut,cycles=2)\n\n        # 2) Feed incremental data\n        NUM_WORDS = int(dut.WIDTH.value)\n        scrambled_data = []\n        for i in range(2**NUM_WORDS):\n            dut.data_in.value = i\n            dut.valid_in.value = 1\n            await RisingEdge(dut.clk)\n\n            # Capture the scrambled output\n            out_val = int(dut.data_out.value)\n            scrambled_data.append(out_val)\n\n        # Stop driving valid\n        dut.valid_in.value = 0\n\n        # Let a few cycles pass\n        for _ in range(5):\n            await RisingEdge(dut.clk)\n\n        ######################################################################\n        # PHASE 2: DESCRAMBLER\n        ######################################################################\n        # 1) Reset again so the PRBS restarts from the *same* seed\n        dut.rst.value = 1\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        dut.rst.value = 0\n        await RisingEdge(dut.clk)\n\n        # 2) Feed the scrambled data\n        descrambled_data = []\n        valid_out = []\n        for i in range((2**NUM_WORDS)-1):\n            dut.data_in.value = scrambled_data[i+1]\n            dut.valid_in.value = 1\n            await RisingEdge(dut.clk)\n\n            # Capture the descrambled output\n            out_val = int(dut.data_out.value)\n            if(dut.valid_out.value.to_unsigned()):\n                descrambled_data.append(out_val)\n            valid_out.append(dut.valid_out.value)\n\n        # Stop driving valid\n        dut.valid_in.value = 0\n        for _ in range(5):\n            await RisingEdge(dut.clk)\n\n        ######################################################################\n        # FINAL CHECK\n        ######################################################################\n        # Compare the descrambled data with the original incremental data\n        mismatches = 0\n        for i, data in enumerate(descrambled_data):\n            if(i!= 0):\n                if ((data != i)):\n                    mismatches += 1\n                    cocotb.log.error(f\"Mismatch at index {i}: expected {i-1}, got {data}\")\n\n        assert mismatches == 0, f\"Found {mismatches} mismatches!\"\n        cocotb.log.info(\"TEST PASSED: Descrambled data matches original incremental data.\")\n\n    else:\n        \n        await reset_dut(dut,cycles=2)\n        # Test Parameters\n        check_mode  = int(dut.CHECK_MODE.value)   # Select mode: generator or checker\n        poly_length = int(dut.POLY_LENGTH.value)  # Length of the polynomial\n        poly_tap    = int(dut.POLY_TAP.value)     # Tap position in the polynomial\n        width       = int(dut.WIDTH.value)        # Width of the PRBS output\n        num_cycles  = 10                          # Number of cycles to run the test\n\n        # Seed value for PRBS generation (all bits set to 1 initially)\n        seed = int('1' * poly_length, 2)\n        # Reset the DUT (Device Under Test)\n        dut.rst.value = 1\n        dut.bypass_scrambling.value = 0\n        dut.data_in.value = 0  # Initialize data_in to 0\n        await ClockCycles(dut.clk, 5)  # Wait for 5 clock cycles\n\n        # Release the reset and enable PRBS checking\n        dut.rst.value = 0  # Release reset\n        dut.valid_in.value = 1\n\n        # Generate expected PRBS sequence to feed into data_in\n        prbs_sequence = generate_prbs(seed, poly_length, poly_tap, width, num_cycles+1)\n\n        cocotb.log.info(f\"prbs_sequence: {prbs_sequence}\")\n        # Initialize error flag\n        error_flag = 0\n\n        # Wait for a rising edge of the clock to ensure reset is low\n        # await RisingEdge(dut.clk)\n        # Apply PRBS data_in\n        dut.data_in.value = prbs_sequence[0]\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk)\n        dut.data_in.value = prbs_sequence[1]\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk)\n\n        # Send the PRBS sequence to the DUT via data_in\n        for cycle in range(2,num_cycles):\n            # Apply PRBS data_in\n            dut.data_in.value = prbs_sequence[cycle]\n\n            # Wait for a clock cycle\n            await RisingEdge(dut.clk)\n\n            # Read the error flag from data_out (assuming data_out is the error indicator)\n            error_flag = dut.data_out.value.to_unsigned()\n\n            if(cycle>0):\n            # Check that error_flag is 0 (no error)\n                assert error_flag == 0, f\"No error expected, but error detected at cycle {cycle}, data out: {error_flag}\"\n                assert dut.valid_out.value.to_unsigned() == 1, f\"Valid not asserted\"\n\n        # Introduce an error in the data_in\n        dut.data_in.value = prbs_sequence[num_cycles] ^ 0x1  # Flip one bit to introduce error\n\n        # Wait for a few clock cycles\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        \n        # Read the error flag after introducing the error\n        error_flag = dut.data_out.value.to_unsigned()\n\n        # Check that error_flag is 1 (error detected)\n        assert error_flag >0, f\"Error expected, but no error detected\"\n        assert dut.valid_out.value.to_unsigned() == 1, f\"Valid not asserted\"\n\n@cocotb.test()\nasync def test_bypass_mode(dut):\n    \"\"\"\n    Test that bypass_scrambling=1 passes input data directly to output,\n    without PRBS alteration.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await RisingEdge(dut.clk)\n\n    await reset_dut(dut, cycles=3)\n    dut.bypass_scrambling.value = 1  # Enable bypass\n\n    test_size = 20\n    width = int(getattr(dut, \"WIDTH\", 16).value)\n\n    random_data = [random.randint(0, (1 << width) - 1) for _ in range(test_size)]\n    observed_data = []\n\n    for val in random_data:\n        dut.data_in.value = val\n        dut.valid_in.value = 1\n        await RisingEdge(dut.clk)\n        if(dut.valid_out.value.to_unsigned()):\n            out_val = int(dut.data_out.value)\n            observed_data.append(out_val)\n\n    # Stop driving valid\n    dut.valid_in.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    # Verify output == input\n    mismatches = 0\n     # Check if observed_data is empty and raise an error if so\n    if not observed_data:\n        raise cocotb.log.error(\"No output data was observed!\")\n    else:\n        for idx, (inp, obs) in enumerate(zip(random_data, observed_data)):\n            if inp != obs:\n                mismatches += 1\n                cocotb.log.error(f\"Bypass mismatch idx={idx}: sent=0x{inp:X}, got=0x{obs:X}\")\n\n    assert mismatches == 0, f\"Bypass mode: Found {mismatches} mismatch(es)!\"\n    cocotb.log.info(\"TEST PASSED: Bypass mode correctly forwards input to output.\")\n\n\n@cocotb.test()\nasync def test_bit_count(dut):\n    \"\"\"\n    Test the DUT's bit counter. We'll do two runs of valid data and\n    ensure bit_count increments by (num_words * WIDTH) each time.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await RisingEdge(dut.clk)\n    await reset_dut(dut, cycles=3)\n\n    width = int(getattr(dut, \"WIDTH\", 16).value)\n\n    # 1) First run\n    num_words_1 = 10\n    num_words_2 = 15\n    poly_length = int(dut.POLY_LENGTH.value)  # Length of the polynomial\n    poly_tap    = int(dut.POLY_TAP.value)     # Tap position in the polynomial\n    width       = int(dut.WIDTH.value)        # Width of the PRBS output\n    check_mode = dut.CHECK_MODE.value\n    # Seed value for PRBS generation (all bits set to 1 initially)\n    seed = int('1' * poly_length, 2)\n    if(check_mode == 0):\n        for i in range(num_words_1):\n            dut.data_in.value = i\n            dut.valid_in.value = 1\n            await RisingEdge(dut.clk)\n    \n        # Flush\n        dut.valid_in.value = 0\n        for _ in range(2):\n            await RisingEdge(dut.clk)\n    \n        # Check the counter\n        expected_bits_1 = num_words_1 * width\n            \n        actual_bits_1 = int(dut.bit_count.value)\n        cocotb.log.info(f\"[BitCount] After first run: bit_count={actual_bits_1}, expected={expected_bits_1}\")\n        assert actual_bits_1 == expected_bits_1, \"Bit count mismatch after first run!\"\n    \n        # 2) Second run\n        for i in range(num_words_2):\n            dut.data_in.value = i\n            dut.valid_in.value = 1\n            await RisingEdge(dut.clk)\n    \n        # Flush\n        dut.valid_in.value = 0\n        for _ in range(2):\n            await RisingEdge(dut.clk)\n    \n        # Check the counter\n        expected_bits_2 = (num_words_1 + num_words_2) * width\n        actual_bits_2 = int(dut.bit_count.value)\n        cocotb.log.info(f\"[BitCount] After second run: bit_count={actual_bits_2}, expected={expected_bits_2}\")\n        assert actual_bits_2 == expected_bits_2, \"Bit count mismatch after second run!\"\n    \n        cocotb.log.info(\"TEST PASSED: bit_count increments exactly as expected.\")\n    else :\n        # Reset the DUT (Device Under Test)\n        dut.rst.value = 1\n        dut.bypass_scrambling.value = 0\n        dut.data_in.value = 0  # Initialize data_in to 0\n        await ClockCycles(dut.clk, 5)  # Wait for 5 clock cycles\n\n        # Release the reset and enable PRBS checking\n        dut.rst.value = 0  # Release reset\n        dut.valid_in.value = 1\n        # Generate expected PRBS sequence to feed into data_in\n        prbs_sequence = generate_prbs(seed, poly_length, poly_tap, width, num_words_1+num_words_2)\n        for i in range(num_words_1+num_words_2):\n            dut.data_in.value = prbs_sequence[i]\n            dut.valid_in.value = 1\n            await RisingEdge(dut.clk)\n            if(i==num_words_1):\n                actual_bits_1 = int(dut.bit_count.value)\n        dut.valid_in.value = 0\n        await RisingEdge(dut.clk)\n        actual_bits_2 = int(dut.bit_count.value)\n        \n        # Check the counter\n        expected_bits_1 = num_words_1 * width\n        cocotb.log.info(f\"[BitCount] After first run: bit_count={actual_bits_1}, expected={expected_bits_1}\")\n        assert actual_bits_1 == expected_bits_1, \"Bit count mismatch after first run!\"\n    \n        # Check the counter\n        expected_bits_2 = (num_words_1 + num_words_2) * width\n        cocotb.log.info(f\"[BitCount] After second run: bit_count={actual_bits_2}, expected={expected_bits_2}\")\n        assert actual_bits_2 == expected_bits_2, \"Bit count mismatch after second run!\"\n    \n        cocotb.log.info(\"TEST PASSED: bit_count increments exactly as expected.\")\n"}}
{"id": "cvdp_agentic_comet_cloud_tiger_9313", "categories": ["cid003", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Design RTL module `rc5_enc_16bit` in `rtl` directory for a RC5 symmetric block-cipher encryption process based on the following specification and functionality. The design must support encryption of 16-bit plaintext input. The RTL design may assume one round of operation for encryption. The number of S-box variables and their values to be incorporated for encryption can be chosen accordingly. Following interface details have to be used for RTL design of RC5 encryption.\n\n## Interface details\n\n### Inputs:\n- **clock (1-bit)**: A single-bit input clock that drives the Finite State Machine executing the encryption algorithm at the positive edge. The clock typically has a 50:50 duty cycle.\n- **reset (1-bit)**: A control signal that resets the internal states of the encryption system. The reset can be configured as synchronous active low signal.\n- **enc_start (1-bit)**: After this signal becomes HIGH, the encryption process begins\n- **p (16-bit,[15:0])** : The 16-bit plaintext input of RC5 encryption \n\n### Output:\n- **c (16-bit,[15:0])** : The 16-bit ciphertext output of RC5 encryption \n- **enc_done (1-bit)**: A HIGH in this output signal indicates the end of RC5 encryption and stable output at `c`, the ciphertext output\n\n## Functionality\n\n### RC5 Encryption algorithm\n\n- The RC5 algorithm is a symmetric block cipher known for its simplicity and effectiveness in converting plaintext to ciphertext and vice versa. \n- It offers flexible options for adjusting block size, key size, and the number of encryption rounds. \n- The RC5 algorithm employs operations such as modulo addition, left rotation, modulo subtraction, right rotation, and XOR in its encryption and decryption processes.\n\nIn order to understand the RC5 block cipher encryption, the following parameters are needed:\n1. Plaintext (P)\n2. Plaintext as w-bit registers (A & B)\n2. Data width (2w)\n3. S-box key array (S)\n4. Rounds of operation (r)\n5. Ciphertext (C)\n\nThe RC5 encryption algorithm works as follows:\n\nA = A + S[0];\\\nB = B + S[1];\\\nfor i = 1 to r do\\\n&nbsp;&nbsp;&nbsp;&nbsp;A = ((A XOR B) <<< B) + S[2&times;i];\\\n&nbsp;&nbsp;&nbsp;&nbsp;B = ((B XOR A) <<< A) + S[(2&times;i)+1];\\\nC = {A,B}\n\nHere, <<< : Left rotation; + : Modulo 2<sup>w</sup> addition; A : MSB w-bits of plaintext P;\\\nB : LSB w-bits of plaintext P; S[0],S[1],S[2],....... : S-box keys ; {} : Concatenation\n\nAt the beginning of encryption, the MSB w-bits of plaintext are assumed as A, and the LSB w-bits of plaintext as B. Every step of this algorithm has to be carried out sequentially as the subsequent steps utilize the result of previous computations. Even though the encryption can be carried out on any data width, the recommended plaintext widths are 16,32 or 64. The number of S-box keys for the encryption is 2*(r+1), where 'r' represents the number of rounds. As the number of rounds increases, the algorithm requires more number of S-box keys. In general, S-box keys are assumed by the user during the encryption process which need to be shared for executing the decryption.\n\n## Considerations\n\n- The RTL design specifically should encrypt 16-bit data using four 8-bit S-box constants to meet operational needs. \n- Encryption has to be performed by a Finite State Machine (FSM) that completes one round of the RC5 algorithm in four clock cycles. The FSM progresses through four states: initial addition, computation of the most significant 8-bits (MSB), computation of the least significant 8-bits (LSB), and finally, output of the ciphertext. The system has to operate on 2w bits, where w is 8, fitting the 16-bit encryption scheme.\n- The encryption process requires 2(r+1) S-box entries, where r represents the number of rounds. Since the RTL module for RC5 encryption has to operate with a single round, it can incorporate four 8-bit S-box entries. These S-box entries, based on design assumptions, are to be set as follows:\n  - Implement Cellular Automata for PRNG: Develop a Cellular Automata-based PRNG specifically designed to generate four 8-bit random values. These values will be used as S-box keys in the RC5 encryption process.\n  - Ensure that the Cellular Automata configuration is capable of generating maximal length sequences. This is crucial for maintaining high entropy in the key stream and enhancing the cryptographic strength of the RC5 cipher.\n  - Implement a combination of Rule 90 and Rule 150 in your Cellular Automata design. These rules are selected for their properties in producing complex, pseudorandom patterns, suitable for cryptographic applications.\n   - Rule 90: A simple XOR of each cell with its two immediate neighbors (i.e., left and right cells).\n   - Rule 150: Involves XORing each cell with its left and right neighbors and itself, resulting in a more complex pattern.\n - The CA based PRNG has to be constructed with a combination of rules R90-R90-R150-R90-R150-R90-R150-R90 with 8-bit seed of 8'hFF\n - This CA should be capable of generating (2<sup>8</sup> - 1) pseudorandom sequences.\n- The encryption shall employ arithmetic and logical operations such as modulo 256 addition, left rotation, and XOR. These operations have to be executed sequentially, as each step of the algorithm depends on the output from the previous step to generate the 16-bit ciphertext.\n\n## Working example \n\n### RC5 Encryption\n\nLet us consider the following parameters:\n\nP = 16'hFFFF ; w = 8 ; r = 1 ; S[0] = 8'h20;S[1] = 8'h10;S[2] = 8'hFF;S[3] = 8'hFF;\n\nSolution:\n\nA = 8'hFF; B = 8'hFF\n\nA = (8'hFF + 8'h20) mod 256 = 1F\\\nB = (8'hFF + 8'h10) mod 256 = 0F\n\n(Loop computation)\\\n&nbsp;&nbsp;&nbsp;&nbsp;A = (((8'h1F XOR 8'h0F) <<< 8'h0F) + 8'hFF) mod 256 = (8'h08 + 8'hFF) mod 256 = 8'h07\\\n&nbsp;&nbsp;&nbsp;&nbsp;B = (((8'h0F XOR 8'h07) <<< 8'h07) + 8'hFF) mod 256 = (8'h04 + 8'hFF) mod 256 = 8'h03\n\nThe ciphertext output is C = 16'h0703\n\nThe `rtl` directory has four different CA implementations namely `CA_1.sv`, `CA_2.sv`, `CA_3.sv`,  and `CA_4.sv` and choose the appropriate CA design for S-box generation.\n", "context": {"rtl/CA_1.sv": "module CA_1(\n\tinput wire clock,\t\t//Clock input\n\tinput wire reset,\t\t//Reset input\n\tinput wire [7:0] CA_seed, \t//8-bit Cellular Automata (CA) seed\n\toutput reg [7:0] CA_out); \t//8-bit CA output\n\t\n\twire q1,q2,q3,q4,q5,q6,q7,q8;\n\t\n\t//Rule combination considered for 8-bit CA is R90-R90-R150-R90-R150-R90-R150-R90\n\t\n\t//Internal XORing based on rules 90 and 150 combination\n\tassign q1 = CA_out[6]; \t\t\t\t//R90\n\tassign q2 = CA_out[7] ^ CA_out[5]; \t\t//R90\n\tassign q3 = CA_out[6] ^ CA_out[5] ^ CA_out[4]; \t//R150\n\tassign q4 = CA_out[5] ^ CA_out[3]; \t\t//R90\n\tassign q5 = CA_out[4] ^ CA_out[3] ^ CA_out[2]; \t//R150\n\tassign q6 = CA_out[3] ^ CA_out[1]; \t\t//R90\n\tassign q7 = CA_out[2] ^ CA_out[1] ^ CA_out[0]; \t//R150\n\tassign q8 = CA_out[1]; \t\t\t\t//R90\n\n\talways_ff @(posedge clock)\n\tbegin\n\t\tif (reset)    //If reset is HIGH, 8-bit CA seed will be initialised at CA output\n\t\t\tCA_out <= CA_seed;\n\t\telse\n\t\t\tCA_out <= {q1,q2,q3,q4,q5,q6,q7,q8};   //Shift register based on the CA rules\n\tend\nendmodule", "rtl/CA_2.sv": "module CA_2(\n\tinput wire clock,\t\t//Clock input\n\tinput wire reset,\t\t//Reset input\n\tinput wire [7:0] CA_seed, \t//8-bit Cellular Automata (CA) seed\n\toutput reg [7:0] CA_out); \t//8-bit CA output\n\t\n\twire q1,q2,q3,q4,q5,q6,q7,q8;\n\t\n\t//Rule combination considered for 8-bit CA is R150-R90-R150-R90-R150-R90-R150-R150\n\t\n\t//Internal XORing based on rules 90 and 150 combination\n\tassign q1 = CA_out[7] ^ CA_out[6]; \t\t//R150\n\tassign q2 = CA_out[7] ^ CA_out[5]; \t\t//R90\n\tassign q3 = CA_out[6] ^ CA_out[5] ^ CA_out[4]; \t//R150\n\tassign q4 = CA_out[5] ^ CA_out[3]; \t\t//R90\n\tassign q5 = CA_out[4] ^ CA_out[3] ^ CA_out[2]; \t//R150\n\tassign q6 = CA_out[3] ^ CA_out[1]; \t\t//R90\n\tassign q7 = CA_out[2] ^ CA_out[1] ^ CA_out[0]; \t//R150\n\tassign q8 = CA_out[1] ^ CA_out[0];; \t//R150\n\n\talways_ff @(posedge clock)\n\tbegin\n\t\tif (reset)    //If reset is HIGH, 8-bit CA seed will be initialised at CA output\n\t\t\tCA_out <= CA_seed;\n\t\telse\n\t\t\tCA_out <= {q1,q2,q3,q4,q5,q6,q7,q8};   //Shift register based on the CA rules\n\tend\nendmodule", "rtl/CA_3.sv": "module CA_3(\n\tinput wire clock,\t\t//Clock input\n\tinput wire reset,\t\t//Reset input\n\tinput wire [7:0] CA_seed, \t//8-bit Cellular Automata (CA) seed\n\toutput reg [7:0] CA_out); \t//8-bit CA output\n\t\n\twire q1,q2,q3,q4,q5,q6,q7,q8;\n\t\n\t//Rule combination considered for 8-bit CA is R150-R150-R90-R150-R90-R150-R90-R150\n\t\n\t//Internal XORing based on rules 90 and 150 combination\n  assign q1 = CA_out[7] ^ CA_out[6]; \t\t\t\t        //R150\n  assign q2 = CA_out[7] ^ CA_out[6] ^ CA_out[5]; \t\t//R150\n  assign q3 = CA_out[6] ^ CA_out[4]; \t              //R90\n  assign q4 = CA_out[5] ^ CA_out[4] ^ CA_out[3]; \t\t//R150\n  assign q5 = CA_out[4] ^ CA_out[2];               \t//R90\n  assign q6 = CA_out[3] ^ CA_out[2] ^ CA_out[1]; \t\t//R150\n  assign q7 = CA_out[2] ^ CA_out[0]; \t              //R90\n  assign q8 = CA_out[1] ^ CA_out[0]; \t\t\t\t        //R150\n\n\talways_ff @(posedge clock)\n\tbegin\n\t\tif (reset)    //If reset is HIGH, 8-bit CA seed will be initialised at CA output\n\t\t\tCA_out <= CA_seed;\n\t\telse\n\t\t\tCA_out <= {q1,q2,q3,q4,q5,q6,q7,q8};   //Shift register based on the CA rules\n\tend\nendmodule", "rtl/CA_4.sv": "module CA_4(\n\tinput wire clock,\t\t//Clock input\n\tinput wire reset,\t\t//Reset input\n\tinput wire [7:0] CA_seed, \t//8-bit Cellular Automata (CA) seed\n\toutput reg [7:0] CA_out); \t//8-bit CA output\n\t\n\twire q1,q2,q3,q4,q5,q6,q7,q8;\n\t\n\t//Rule combination considered for 8-bit CA is R90-R90-R90-R150-R90-R150-R90-R150\n\t\n\t//Internal XORing based on rules 90 and 150 combination\n  assign q1 = CA_out[6]; \t\t\t\t                    //R90\n  assign q2 = CA_out[7] ^ CA_out[5]; \t\t            //R90\n  assign q3 = CA_out[6] ^ CA_out[4]; \t              //R90\n  assign q4 = CA_out[5] ^ CA_out[4] ^ CA_out[3]; \t\t//R150\n  assign q5 = CA_out[4] ^ CA_out[2];               \t//R90\n  assign q6 = CA_out[3] ^ CA_out[2] ^ CA_out[1]; \t\t//R150\n  assign q7 = CA_out[2] ^ CA_out[0]; \t              //R90\n  assign q8 = CA_out[1] ^ CA_out[0]; \t\t\t\t        //R150\n\n\talways_ff @(posedge clock)\n\tbegin\n\t\tif (reset)    //If reset is HIGH, 8-bit CA seed will be initialised at CA output\n\t\t\tCA_out <= CA_seed;\n\t\telse\n\t\t\tCA_out <= {q1,q2,q3,q4,q5,q6,q7,q8};   //Shift register based on the CA rules\n\tend\nendmodule"}, "patch": {"rtl/rc5_enc_16bit.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n", "docker-compose.yml": "services:\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v -s\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/rc5_enc_16bit.sv\nTOPLEVEL        = rc5_enc_16bit\nMODULE          = test_rc5_enc_16bit\nPYTHONPATH      = /src\nHASH            = 1-rc5-encryption", "src/test_rc5_enc_16bit.py": "import cocotb\nfrom cocotb.triggers import RisingEdge\nfrom cocotb.clock import Clock\n\n# Function to calculate the expected output based on the given RC5 encryption algorithm\ndef expected_rc5_enc_16bit(plaintext):\n    s = [0xAB, 0x29, 0x6E, 0xC1]  # S-box values\n    p_tmp = plaintext\n\n    # Step 1: Initial addition stage\n    p_tmp_msb = (p_tmp >> 8) & 0xFF\n    p_tmp_lsb = p_tmp & 0xFF\n\n    p_tmp_msb = (p_tmp_msb + s[0]) % 0x100\n    p_tmp_lsb = (p_tmp_lsb + s[1]) % 0x100\n\n    # Step 2: Computation of MSB 8-bits\n    tmp_msb = p_tmp_msb ^ p_tmp_lsb\n    rotated_msb = ((tmp_msb << (p_tmp_lsb % 8)) | (tmp_msb >> (8 - (p_tmp_lsb % 8)))) & 0xFF\n    p_tmp_msb = (rotated_msb + s[2]) % 0x100\n\n    # Step 3: Computation of LSB 8-bits\n    tmp_lsb = p_tmp_lsb ^ p_tmp_msb\n    rotated_lsb = ((tmp_lsb << (p_tmp_msb % 8)) | (tmp_lsb >> (8 - (p_tmp_msb % 8)))) & 0xFF\n    p_tmp_lsb = (rotated_lsb + s[3]) % 0x100\n\n    # Combine MSB and LSB to form the 16-bit ciphertext\n    ciphertext = (p_tmp_msb << 8) | p_tmp_lsb\n    return ciphertext\n\n@cocotb.test()\nasync def test_rc5_enc_16bit(dut):\n    \"\"\"Test the rc5_enc_16bit encryption module\"\"\"\n\n    # Generate clock\n    cocotb.start_soon(Clock(dut.clock, 10, units=\"ns\").start())\n\n    # Define a few test plaintext values\n    test_values = [0x1234, 0xABCD, 0x0000, 0xFFFF, 0xA5A5, 0x2222, 0x3333, 0x4444, 0x5555, 0xFFFF]\n    \n    \n\n    for plaintext in test_values:\n        # Reset the design\n        dut.reset.value = 0\n        dut.enc_start.value = 0\n        dut.p.value = plaintext  # Assign the plaintext value while reset is active\n        await RisingEdge(dut.clock)\n\n        # Release reset\n        dut.reset.value = 1\n        await RisingEdge(dut.clock)\n\n        # Start encryption\n        dut.enc_start.value = 1\n\n        # Wait for the encryption to complete\n        while dut.enc_done.value == 0:\n            await RisingEdge(dut.clock)\n\n        # Check the output with the expected result\n        encrypted = dut.c.value.integer\n        expected_encrypted = expected_rc5_enc_16bit(plaintext)\n\n        dut._log.info(f\"Plaintext: 0x{plaintext}, Ciphertext: 0x{encrypted}, Expected: 0x{expected_encrypted}\")\n       \n        # Compare the actual output with the expected result\n        assert encrypted == expected_encrypted, f\"Expected 0x{expected_encrypted}, but got 0x{encrypted}\"\n\n        # Reset the start signal for the next operation\n        dut.enc_start.value = 0\n        await RisingEdge(dut.clock)  # Ensure the enc_start is de-asserted before the next test\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_rc5_enc_16bit_run():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n    )\n"}}
{"id": "cvdp_agentic_falcon_willow_dragon_8753", "categories": ["cid004", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a **APBGlobalHistoryRegister** module located at `rtl/APBGlobalHistoryRegister.v`. This module currently lacks access control and can operate without any restriction. I want to enhance the system to be **secure**, such that the global history shift register only functions after a proper unlock sequence has been successfully completed.\n\n---\n\n### **Modification Goals**\n\nCreate a new module, named \"security_module\" in file \"security_module.v\" that acts as a **security gatekeeper**. This module must implement a finite state machine that enforces an **unlock sequence** before enabling the global history shift register. The unlock sequence consists of two steps:\n1. First, the hexadecimal value `0xAB` must be written to internal address `0`.\n2. Next, the value `0xCD` must be written to internal address `1`.\n\nOnly when both steps are performed in sequence should the system be considered **secure**. Any deviation (incorrect value or incorrect order) should cause the state machine to reset, requiring the entire sequence to be redone. The secure module is resettable and must return to the locked state upon system reset.\n\nOnce the unlock is complete, the secure module should assert a signal that enables the global history shift register. Until then, the global history shift register must remain inactive. Modify the \"APBGlobalHistoryRegister\" such that it will enable when the module is secure.\n\n---\n\n### **Top-Level Integration and module modification**\n\nCreate a new top-level module named \"APBGlobalHistoryRegister_secure_top.v\" that integrates both the security module and the global history shift register. Ensure correct data flow and signal connection between them. The security module interface should use the existing 8-bit apb interface but with a different clock named \"i_capture_pulse\". \nBelow are the IOs.\n\n```verilog \nmodule APBGlobalHistoryRegister_secure_top  #(                  \n    parameter p_unlock_code_0 = 8'hAB,            \n    parameter p_unlock_code_1 = 8'hCD            \n) (\n    input  wire         pclk,  \n    input  wire         presetn,  \n    // APB signals\n    input  wire [9:0]   paddr,  \n    input  wire         pselx,  \n    input  wire         penable,  \n    input  wire         pwrite, \n    input  wire [7:0]   pwdata, \n    input  wire         history_shift_valid,  \n    input  wire         clk_gate_en,  \n    \n    input wire          i_capture_pulse,    \n\n    output reg          pready, \n    output reg  [7:0]   prdata, \n    output reg          pslverr,  \n    output reg          history_full, \n    output reg          history_empty,  \n    output reg          error_flag, \n    output reg          interrupt_full, \n    output reg          interrupt_error       \n);\n```\n\n---\n\n### **Clocks and Reset**\n\nThe secure module operates on a clock derived from a **capture pulse** signal, while the global history shift register runs on its own **pclk clock**. These clocks are asynchronous. The reset signal is shared across both modules. \n\n---\n\n### **Expected Deliverable**\n\nA complete design containing:\n1. The **modified global history shift register** that responds to a secure-enable condition.\n2. A new **security module** enforcing the unlock logic.\n3. A **top-level module** instantiating and integrating both components, managing control flow and asynchronous clocks.\n\nThe system must ensure that the global history shift register never functions unless the unlock sequence is properly followed.\n", "context": {"rtl/APBGlobalHistoryRegister.v": "module APBGlobalHistoryRegister (\n    // APB clock & reset\n    input  wire         pclk,  //APB clock input used for all synchronous operations.\n    input  wire         presetn,  // Asynchronous reset for system initialization.\n\n    // APB signals\n    input  wire [9:0]   paddr,  //Address bus for accessing internal CSR registers.\n    input  wire         pselx,  //APB select signal, indicates CSR/memory selection.\n    input  wire         penable,  //APB enable signal, marks transaction progression.\n    input  wire         pwrite, //Write-enable signal. High for writes, low for reads.\n    input  wire [7:0]   pwdata, // Write data bus for sending data to CSR registers or memory.\n    input  wire         history_shift_valid,  \n    input  wire         clk_gate_en,  \n    output reg          pready, // Ready signal, driven high to indicate the end of a transaction.\n    output reg  [7:0]   prdata, // Read data bus for retrieving data from the module.\n    output reg          pslverr,  //Error signal, asserted on invalid addresses.\n    output reg          history_full, \n    output reg          history_empty,  \n    output reg          error_flag, \n    output reg          interrupt_full, \n    output reg          interrupt_error \n);\n\n    //---------------------------------------------\n    // Parameter Definitions\n    //---------------------------------------------\n    // Register address map\n    localparam ADDR_CTRL_REG     = 10'h0;  // 0x0\n    localparam ADDR_TRAIN_HIS    = 10'h1;  // 0x1\n    localparam ADDR_PREDICT_HIS  = 10'h2;  // 0x2\n\n    localparam WIDTH             = 8;\n\n    //---------------------------------------------\n    // Internal Registers (CSR)\n    //---------------------------------------------\n    reg [WIDTH-1:0] control_register;\n    reg [WIDTH-1:0] train_history;\n    reg [WIDTH-1:0] predict_history;\n    //---------------------------------------------\n    // Internal wires\n    //---------------------------------------------\n    wire        predict_valid;\n    wire        predict_taken;\n    wire        train_mispredicted;\n    wire        train_taken;\n    //---------------------------------------------\n    // APB Read/Write Logic\n    //---------------------------------------------\n    wire apb_valid;\n    assign apb_valid = pselx & penable;    // Indicates active APB transaction\n    assign pclk_gated = !clk_gate_en&pclk;\n    // By spec, no wait states => PREADY always high after reset\n    always @(posedge pclk_gated or negedge presetn) begin\n      if (!presetn) begin\n        pready   <= 1'b0;\n        pslverr  <= 1'b0;\n      end else begin\n        // PREADY is always asserted (no wait states) once out of reset\n        pready   <= 1'b1;\n        // If transaction is valid, check address range\n        if (apb_valid) begin\n          // Check if address is valid (0x0 through 0x2 are used, everything else => PSLVERR)\n          if (paddr > ADDR_PREDICT_HIS) begin\n            pslverr <= 1'b1;\n          end\n          else begin\n            pslverr  <= 1'b0;\n          end\n        end\n      end\n    end\n\n    // Handle writes to CSR or memory\n    // Note: The design writes immediately in the cycle when penable=1.\n    always @(posedge pclk_gated or negedge presetn) begin\n      if (!presetn) begin\n        // Reset all registers\n        control_register  <= 0;\n        train_history     <= 0;\n      end else begin\n        if (apb_valid && pwrite) begin\n          case (paddr)\n              ADDR_CTRL_REG:    control_register[3:0]  <= pwdata[3:0];\n              ADDR_TRAIN_HIS:   train_history[6:0]     <= pwdata[6:0];\n              // If the address is outside defined range => PSLVERR is set, no write\n          endcase\n        end\n      end\n    end\n\n    // Handle read from CSR or memory\n    always @(posedge pclk_gated or negedge presetn) begin\n      if (!presetn) begin\n        prdata <= 0;\n      end \n      else begin\n        if (apb_valid) begin\n          case (paddr)\n            ADDR_CTRL_REG:    prdata <= {4'b0,control_register[3:0]};\n            ADDR_TRAIN_HIS:   prdata <= {1'b0,train_history[6:0]};\n            ADDR_PREDICT_HIS: prdata <= predict_history;\n            default:          prdata <= 0; // Invalid => PSLVERR, but can set prdata to 0\n          endcase\n        end\n        else begin\n          // When no valid read, clear prdata\n          prdata <= 0;\n        end\n      end\n    end\n\n\n    //---------------------------------------------\n    // GHSR Behavior\n    //---------------------------------------------\n\n    assign  predict_valid       = control_register[0];     // valid branch prediction\n    assign  predict_taken       = control_register[1];     // predicted direction (1=taken, 0=not taken)\n    assign  train_mispredicted  = control_register[2];     // branch misprediction occurred\n    assign  train_taken         = control_register[3];     // actual branch direction for mispredicted branch\n\n\n\n    always @(posedge history_shift_valid or negedge presetn) begin\n      if (!presetn) begin\n        // 1) active low Asynchronous reset\n        //    Clear the entire history register.\n        predict_history <= 0;\n      end\n      else begin\n        // 2) Misprediction Handling (highest priority)\n        //    If a misprediction is flagged, restore the old history from train_history\n        //    and incorporate the correct outcome (train_taken) as the newest bit.\n        if (train_mispredicted) begin\n          predict_history <= {train_history[WIDTH-2:0], train_taken};\n        end\n        // 3) Normal Prediction Update\n        //    If the prediction is valid and there is no misprediction,\n        //    shift in predict_taken at the LSB (bit[0] is the youngest branch).\n        else if (predict_valid) begin\n          // \"Shifting in from the LSB\" while keeping the newest branch in predict_history[0]\n          // is typically done by moving predict_history[31:1] up one bit\n          // and placing predict_taken in bit[0].\n          predict_history <= {predict_history[WIDTH-2:0], predict_taken};\n        end\n      end\n    end\n    \n    always @(*) begin\n      error_flag=pslverr;\n      interrupt_error=pslverr;\n      if(predict_history==8'hff) begin\n        history_full=1'b1;\n        interrupt_full=1'b1;\n        history_empty=1'b0;\n      end\n      else if (predict_history==8'h00) begin\n        history_full=1'b0;\n        interrupt_full=1'b0;\n        history_empty=1'b1;\n      end\n      else begin\n        history_full=1'b0;\n        interrupt_full=1'b0;\n        history_empty=1'b0;\n      end\n    end\n\nendmodule"}, "patch": {"rtl/APBGlobalHistoryRegister.v": "", "rtl/APBGlobalHistoryRegister_secure_top.v": "", "rtl/security_module.v": ""}, "harness": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/APBGlobalHistoryRegister.v /code/rtl/security_module.v /code/rtl/APBGlobalHistoryRegister_secure_top.v\nTOPLEVEL        = APBGlobalHistoryRegister_secure_top\nMODULE          = test_APBGlobalHistoryRegister_secure_top\nPYTHONPATH      = /src\nHASH            = 1-code-modification", "src/test_APBGlobalHistoryRegister_secure_top.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nfrom cocotb.clock import Clock\n\n# -----------------------------------------------------------------------------\n# Helper assertion\n# -----------------------------------------------------------------------------\ndef assert_equal(actual, expected, msg=\"\"):\n    \"\"\"Custom assertion with an optional message.\"\"\"\n    assert actual == expected, f\"{msg}: Expected {hex(expected)}, got {hex(actual)}\"\n\n# -----------------------------------------------------------------------------\n# APB Read/Write Helpers\n# -----------------------------------------------------------------------------\nasync def apb_write(dut, addr, data):\n    \"\"\"Perform a single APB write transaction: Setup + Access phase.\"\"\"\n    # Setup phase\n    dut.pselx.value = 1\n    dut.pwrite.value = 1\n    dut.paddr.value  = addr\n    dut.pwdata.value = data\n    dut.penable.value = 0\n    await RisingEdge(dut.pclk)\n\n    # Access phase\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n\n    # De-assert\n    dut.pselx.value   = 0\n    dut.penable.value = 0\n    dut.pwrite.value  = 0\n    dut.paddr.value   = 0\n    dut.pwdata.value  = 0\n    await RisingEdge(dut.pclk)\n\nasync def apb_read(dut, addr):\n    \"\"\"Perform a single APB read transaction: Setup + Access phase. Returns the read data.\"\"\"\n    # Setup phase\n    dut.pselx.value   = 1\n    dut.pwrite.value  = 0\n    dut.paddr.value   = addr\n    dut.penable.value = 0\n    await RisingEdge(dut.pclk)\n\n    # Access phase\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    await Timer(1, units=\"ns\")  # small delay to allow prdata to settle\n    read_data = dut.prdata.value.integer\n\n    # De-assert\n    dut.pselx.value   = 0\n    dut.penable.value = 0\n    dut.paddr.value   = 0\n    await RisingEdge(dut.pclk)\n    return read_data\n\n# -----------------------------------------------------------------------------\n# Actual Test\n# -----------------------------------------------------------------------------\n@cocotb.test()\nasync def test_APBGlobalHistoryRegister_secure_top(dut):\n    \"\"\"Cocotb testbench for APBGlobalHistoryRegister.\"\"\"\n\n    # Create and start a clock on pclk\n    clock = Clock(dut.pclk, 10, units=\"ns\")  # 100 MHz\n    #cocotb.start_soon(clock.start())\n\n    # Initialize inputs\n    dut.pclk.value   = 0\n    dut.pselx.value   = 0\n    dut.penable.value = 0\n    dut.pwrite.value  = 0\n    dut.pwdata.value  = 0\n    dut.paddr.value   = 0\n    dut.presetn.value = 1\n    dut.history_shift_valid.value = 0\n    dut.clk_gate_en.value = 0   # clock gating disabled by default\n    dut.i_capture_pulse.value = 0\n    # Apply asynchronous reset\n    dut.presetn.value = 0\n    await Timer(5, units=\"ns\")\n    # one clock\n    dut.pclk.value   = 1\n    dut.i_capture_pulse.value = 1\n    await Timer(5, units=\"ns\")\n    dut.pclk.value   = 0\n    dut.i_capture_pulse.value = 0\n    # one clock\n    dut.presetn.value = 1\n    await Timer(5, units=\"ns\")\n    dut.pclk.value   = 1\n    dut.i_capture_pulse.value = 1\n    await Timer(5, units=\"ns\")\n    dut.pclk.value   = 0\n    dut.i_capture_pulse.value = 0\n    await Timer(5, units=\"ns\")\n    dut.pclk.value   = 1\n    dut.i_capture_pulse.value = 1\n    await Timer(5, units=\"ns\")\n    dut.pclk.value   = 0\n    dut.i_capture_pulse.value = 0\n    await Timer(5, units=\"ns\")\n\n\n    #unclocking sequence\n    # Enable the APBGlobalHistoryRegister and test state transitions\n\n    dut.i_capture_pulse.value = 1\n    await Timer(5, units=\"ns\")\n    dut.i_capture_pulse.value = 0\n\n    await Timer(5, units=\"ns\")  #stage one unlock\n    dut.paddr.value =0\n    dut.pwdata.value =171\n    dut.pwrite.value =1\n\n    dut.i_capture_pulse.value = 1\n    await Timer(5, units=\"ns\")\n    dut.i_capture_pulse.value = 0\n\n    await Timer(5, units=\"ns\") #stage two unlock\n    dut.paddr.value =1\n    dut.pwdata.value =205\n    dut.pwrite.value =1\n\n    dut.i_capture_pulse.value = 1\n    await Timer(5, units=\"ns\")\n    dut.i_capture_pulse.value = 0\n\n    await Timer(5, units=\"ns\") #unlocked\n    cocotb.start_soon(clock.start())\n    dut.paddr.value =0\n    dut.pwdata.value =0\n    dut.pwrite.value =0\n    await RisingEdge(dut.pclk)\n    await RisingEdge(dut.pclk)\n    await RisingEdge(dut.pclk)\n    #--------------------------------------------------------------------------\n    # Local constants (addresses)\n    # Match these to localparams in RTL if needed\n    #--------------------------------------------------------------------------\n    ADDR_CTRL_REG     = 0x0\n    ADDR_TRAIN_HIS    = 0x1\n    ADDR_PREDICT_HIS  = 0x2\n\n    #--------------------------------------------------------------------------\n    # 1) Check reset behavior\n    #--------------------------------------------------------------------------\n    ctrl_reg_val   = await apb_read(dut, ADDR_CTRL_REG)\n    train_his_val  = await apb_read(dut, ADDR_TRAIN_HIS)\n    predict_his_val= await apb_read(dut, ADDR_PREDICT_HIS)\n    await Timer(1, units=\"ns\")\n    assert_equal(ctrl_reg_val,   0x00, \"control_register not reset to 0\")\n    assert_equal(train_his_val,  0x00, \"train_history not reset to 0\")\n    assert_equal(predict_his_val,0x00, \"predict_history not reset to 0\")\n\n    # Confirm status signals are reset\n    assert dut.history_empty.value == 1, \"history_empty should be 1 after reset\"\n    assert dut.history_full.value  == 0, \"history_full should be 0 after reset\"\n    assert dut.interrupt_full.value == 0, \"interrupt_full should be 0 after reset\"\n    assert dut.interrupt_error.value == 0, \"interrupt_error should be 0 after reset\"\n\n    #--------------------------------------------------------------------------\n    # 2) Basic APB Write/Read to control_register\n    #--------------------------------------------------------------------------\n    # We only use bits [3:0].\n    # Bits: predict_valid=1 (LSB), predict_taken=1, train_mispredicted=0, train_taken=1 => 0b1011 = 0x0B\n    await apb_write(dut, ADDR_CTRL_REG, 0x0B)\n    await Timer(1, units=\"ns\")\n    ctrl_reg_val = await apb_read(dut, ADDR_CTRL_REG)\n    await Timer(1, units=\"ns\")\n    # Check only lower 4 bits\n    assert_equal(ctrl_reg_val & 0x0F, 0x0B, \"control_register readback mismatch\")\n\n    #--------------------------------------------------------------------------\n    # 3) Basic APB Write/Read to train_history\n    #--------------------------------------------------------------------------\n    # Bits [6:0] used, bit[7] reserved => if we write 0xAA => that is 10101010 in binary\n    # The upper bit [7] is reserved => should read back as 0 => resulting in 0x2A in decimal = 0b0101010\n    await apb_write(dut, ADDR_TRAIN_HIS, 0xAA)\n    train_his_val = await apb_read(dut, ADDR_TRAIN_HIS)\n    # train_his_val[7] should be 0 => so we expect 0x2A if the 7 bits are 1010101 = 0x55 >> but let's see:\n    #  0xAA = 10101010 => the top bit is 1 (bit7). That is reserved => read as 0 => real stored bits = 0x2A\n    await Timer(1, units=\"ns\")\n    assert_equal(train_his_val, 0x2A, \"train_history readback mismatch on reserved bit\")\n\n    #--------------------------------------------------------------------------\n    # 4) Read predict_history (should still be 0)\n    #--------------------------------------------------------------------------\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    assert_equal(predict_his_val, 0x00, \"predict_history not expected zero before any shifts\")\n\n    #--------------------------------------------------------------------------\n    # 5) Check error handling (invalid address => PSLVERR => interrupt_error)\n    #--------------------------------------------------------------------------\n    # Write to an invalid address, e.g., 0x3 or 0x100\n    await apb_write(dut, 0x3, 0x55)  # outside valid range 0x0..0x2\n    await Timer(1, units=\"ns\")\n    # Wait a cycle to see the effect\n    await RisingEdge(dut.pclk)\n\n    # PSLVERR => pslverr, error_flag, interrupt_error should be asserted\n    assert dut.pslverr.value == 1, \"pslverr not asserted on invalid address\"\n    assert dut.error_flag.value == 1, \"error_flag not asserted on invalid address\"\n    assert dut.interrupt_error.value == 1, \"interrupt_error not asserted on invalid address\"\n\n    #--------------------------------------------------------------------------\n    # Clear the error by writing a valid address\n    # (The design automatically clears PSLVERR next cycle when paddr is valid)\n    #--------------------------------------------------------------------------\n    await apb_write(dut, ADDR_CTRL_REG, 0x00)\n    await Timer(1, units=\"ns\")\n    assert dut.pslverr.value == 0, \"pslverr should be cleared after valid transaction\"\n    assert dut.error_flag.value == 0, \"error_flag should be cleared\"\n    assert dut.interrupt_error.value == 0, \"interrupt_error should be cleared\"\n\n    #--------------------------------------------------------------------------\n    # 6) Test normal shift update on rising edge of history_shift_valid\n    #--------------------------------------------------------------------------\n    # Let's set control_register => predict_valid=1 (bit0=1), predict_taken=1 (bit1=1)\n    await apb_write(dut, ADDR_CTRL_REG, 0x03)  # 0b0011 => mispredict=0, train_taken=0\n    await Timer(2, units=\"ns\")\n\n    # Toggle history_shift_valid\n    dut.history_shift_valid.value = 1\n    await Timer(2, units=\"ns\")  # rising edge\n    dut.history_shift_valid.value = 0\n\n    # Wait a bit so the GHSR can update (as it's asynchronous).\n    await Timer(5, units=\"ns\")\n\n    # Check updated predict_history\n    #   old=0x00 => shift in '1' => LSB=1 => new=0x01\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    assert_equal(predict_his_val, 0x01, \"predict_history should shift in bit=1 at LSB\")\n\n    #--------------------------------------------------------------------------\n    # 7) Shift repeatedly to fill up to 0xFF => check history_full and interrupt_full\n    #--------------------------------------------------------------------------\n    # We'll keep predict_valid=1, predict_taken=1 => each rising edge of history_shift_valid sets LSB=1\n    # So repeated shifts should eventually get 0xFF after enough toggles.\n    for _ in range(7):\n        dut.history_shift_valid.value = 1\n        await Timer(2, units=\"ns\")\n        dut.history_shift_valid.value = 0\n        await Timer(5, units=\"ns\")\n\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    assert_equal(predict_his_val, 0xFF, \"predict_history not 0xFF after 8 consecutive bits=1\")\n\n    assert dut.history_full.value == 1, \"history_full should be asserted at 0xFF\"\n    assert dut.interrupt_full.value == 1, \"interrupt_full should be asserted at 0xFF\"\n    assert dut.history_empty.value == 0, \"history_empty should not be set at 0xFF\"\n\n    #--------------------------------------------------------------------------\n    # 8) Test misprediction handling\n    #--------------------------------------------------------------------------\n    # Suppose we wrote train_history=0x55 earlier. Let's re-write it to confirm.\n    # For example, 0x55 => 0101_0101 => only bits [6:0] are used => 0x55 => 1010101 => plus bit7=0\n    await apb_write(dut, ADDR_TRAIN_HIS, 0x55)  # store 0x55 => which effectively 0x55 & 0x7F\n    # Then set train_mispredicted=1, train_taken=1 => bits => 0b1100 => predict_valid=0, predict_taken=0\n    await apb_write(dut, ADDR_CTRL_REG, 0x0C)\n    await Timer(2, units=\"ns\")\n\n    # Toggle shift valid => misprediction should have highest priority\n    dut.history_shift_valid.value = 1\n    await Timer(2, units=\"ns\")\n    dut.history_shift_valid.value = 0\n    await Timer(5, units=\"ns\")\n\n    # The GHSR should be restored from train_history[6:0] => which is 0x55 & 0x7F = 0x55 => plus train_taken=1 => => new GHSR=0xAB\n    # Explanation: train_history = 0x55 => 0b0101_0101 => ignoring bit7 => it's effectively 1010101 in bits [6:0]\n    # => {train_history[6:0], train_taken} => {0x55, 1} => 0x55 << 1 + 1 => 0xAA + 0x01 = 0xAB\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    assert_equal(predict_his_val, 0xAB, \"predict_history not restored properly on misprediction\")\n\n    # Check if full/empty changed\n    assert dut.history_full.value == 0, \"history_full incorrectly asserted after misprediction restore\"\n    assert dut.history_empty.value == 0, \"history_empty incorrectly asserted after misprediction restore\"\n    assert dut.interrupt_full.value == 0, \"interrupt_full incorrectly asserted\"\n\n    #--------------------------------------------------------------------------\n    # 9) Priority check: If predict_valid=1 and train_mispredicted=1 together => misprediction wins\n    #--------------------------------------------------------------------------\n    # Make control_register => predict_valid=1, predict_taken=1, train_mispredicted=1, train_taken=0 => 0b0111 => 0x07\n    # So if both are set, we should do the misprediction path.\n    # Let's re-store train_history=0x22 => 0b0010_0010 => ignoring bit7 => actually 0x22 => bits [6:0]=0x22\n    await apb_write(dut, ADDR_TRAIN_HIS, 0x22)\n    await apb_write(dut, ADDR_CTRL_REG, 0x07)\n    await Timer(2, units=\"ns\")\n\n    # Trigger shift\n    dut.history_shift_valid.value = 1\n    await Timer(2, units=\"ns\")\n    dut.history_shift_valid.value = 0\n    await Timer(5, units=\"ns\")\n\n    # We expect => predict_history = {train_history[6:0], train_taken} => 0x22 << 1 + 0 => 0x44\n    # 0x22 => 0010_0010 => ignoring bit7 => it's 0x22 in [6:0]\n    # appended train_taken=0 => => 0x44 in decimal\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    await Timer(1, units=\"ns\")\n    assert_equal(predict_his_val, 0x44,\n                 \"Priority fail: misprediction did not override normal predict_valid=1 condition\")\n\n    #--------------------------------------------------------------------------\n    # 10) Drive predict_history back to 0x00 => check empty/interrupt\n    #--------------------------------------------------------------------------\n    # We'll do this by writing a misprediction to restore 7 bits=0, plus train_taken=0\n    await apb_write(dut, ADDR_TRAIN_HIS, 0x00)\n    # train_mispredicted=1, train_taken=0 => 0b0100 => plus predict_valid=0 => 0x04\n    await apb_write(dut, ADDR_CTRL_REG, 0x04)\n    dut.history_shift_valid.value = 1\n    await Timer(2, units=\"ns\")\n    dut.history_shift_valid.value = 0\n    await Timer(5, units=\"ns\")\n\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    assert_equal(predict_his_val, 0x00, \"predict_history not reset to 0 via misprediction restore\")\n\n    assert dut.history_empty.value == 1, \"history_empty not asserted at 0x00\"\n    assert dut.history_full.value  == 0, \"history_full incorrectly asserted at 0x00\"\n\n    #--------------------------------------------------------------------------\n    # 11) Simple clock gating check\n    #--------------------------------------------------------------------------\n    # Toggle clk_gate_en => This will effectively 'stop' pclk_gated in the RTL,\n    # meaning no register updates. We'll do an APB write, then verify it didn't change.\n    dut.clk_gate_en.value = 1\n    await RisingEdge(dut.pclk)\n\n    # Attempt to write to ctrl_reg => should NOT update if gating is truly working\n    await apb_write(dut, ADDR_CTRL_REG, 0x0F)\n    # Read it back\n    await FallingEdge(dut.pclk)\n    dut.clk_gate_en.value = 0\n    reg_val = await apb_read(dut, ADDR_CTRL_REG)\n    # Because gating is conceptual in RTL, some synthesis flows might not simulate gating literally,\n    # but let's assume it does. If gating is real, the design's internal pclk is off, so no update => remains 0x04\n    # (the last value we wrote was 0x04).\n    # NOTE: The actual behavior depends on your gate logic. If your gating is purely structural,\n    # we might see 0x0F or 0x04. Adjust expectations accordingly.\n\n    # For a realistic test, let's expect no update:\n    expected_val = 0x04  \n    assert_equal(reg_val, expected_val,\n                 \"control_register changed despite clock gating\")\n\n    # Turn gating back off\n    dut.clk_gate_en.value = 0\n    await RisingEdge(dut.pclk)\n    await RisingEdge(dut.pclk)\n\n    # Write again => now it should succeed\n    await apb_write(dut, ADDR_CTRL_REG, 0x0F)\n    reg_val = await apb_read(dut, ADDR_CTRL_REG)\n    assert_equal(reg_val & 0x0F, 0x0F, \"control_register not updated when gating disabled\")\n\n    dut._log.info(\"All APBGlobalHistoryRegister tests completed successfully.\")\n\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}
{"id": "cvdp_agentic_thunder_compass_river_8383", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a few **sorting_engine** modules that sort the input data in ascending order. The **sorting_engine** modules are available at `rtl/` directory. Each module present in the folder implements a different sorting algorithm to perform the sorting operation. The sorting algorithm used by a module is mentioned in the name of the module.\n\nCan you implement the **`order_matching_engine.sv`** in the `rtl` folder? Details of the `order_matching_engine` module are as given below\n\n**Description - Order Matching Engine**\n\nThe goal is to build a module that efficiently processes and matches buy (bid) and sell (ask) orders. Here\u2019s what the design must accomplish:\n\n- **Input Handling:**  \n  The engine accepts two flat input vectors\u2014one for bid orders and one for ask orders. Following are the bid and ask order vectors:\nBid: 42,74,10,21,108,53,95,106\nAsk: 130,108,205,129,192,213,244,141\n\n- **Sorting:**  \n  Select the sorting_engine module that has the lowest latency for the provided input to sort each set of orders. Use the same sorting algorithm implementation for sorting both bid and ask orders.\n  - Bid orders are sorted in ascending order (so the highest bid is at the last position).\n  - Ask orders are sorted in ascending order (so the lowest ask is at the first position).\n\n- **Order Matching:**  \n  After sorting, extract the best bid (highest bid) and best ask (lowest ask). If the best bid is greater than or equal to the best ask, a match occurs. The matching price is taken as the best bid.\n\n- **Safeguarding:**\n   The design should have a safeguard to cap the total loss in the event this module is used for trading purpose. Use the input circuit breaker that should disable any successful matches irrespective of the incoming bid and ask orders.\n\n- **Latency:**\n   The order_matching_engine that is generated should add a latency of exactly 1 clock cycle on top of the latency of the sorting_engine module it uses.\n\n- **Port List:**\n```verilog\n   module order_matching_engine #(\n    parameter PRICE_WIDTH = 16  // width of the price field\n)(\n    input                      clk,\n    input                      rst,\n    input                      start,         // Active high. Start matching operation\n    input                      circuit_breaker, //Active high. Circuit breaker\n    input  [8*PRICE_WIDTH-1:0] bid_orders,    // 8 bid orders (flat vector)\n    input  [8*PRICE_WIDTH-1:0] ask_orders,    // 8 ask orders (flat vector)\n    output reg                 match_valid,   // High if a match occurs\n    output reg [PRICE_WIDTH-1:0] matched_price, // Matched price (best bid)\n    output reg                 done          // Active high. Matching engine done\n);\n```\n", "context": {"rtl/brick_sort.sv": "module brick_sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // ----------------------------------------------------------\n    // Internal Parameters and State Encoding\n    // ----------------------------------------------------------\n    localparam IDLE = 2'd0,\n               LOAD = 2'd1,\n               SORT = 2'd2,\n               DONE = 2'd3;\n\n    // ----------------------------------------------------------\n    // Internal Registers\n    // ----------------------------------------------------------\n    reg [1:0]  state, next_state;\n\n    // Store data in a register array for easy swapping\n    reg [WIDTH-1:0] data_array [0:N-1];\n\n    // Pass counter: we will run up to N passes\n    reg [$clog2(N+1)-1:0] pass_cnt;\n\n    // Pair index: on each pass, we compare-swap one pair per clock\n    reg [$clog2(N/2+1):0] pair_idx;\n\n    // ----------------------------------------------------------\n    // Next-State Logic\n    // ----------------------------------------------------------\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = LOAD;\n            end\n\n            LOAD: begin\n                // After loading input data, go to SORT state\n                next_state = SORT;\n            end\n\n            SORT: begin\n                // Once we've completed N passes, sorting is done\n                if (pass_cnt == N)\n                    next_state = DONE;\n            end\n\n            DONE: begin\n                // Optionally return to IDLE if desired\n                // For a one-shot, we can just stay in DONE unless reset\n                // Here, we return to IDLE if start is deasserted\n                if (!start)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // ----------------------------------------------------------\n    // Sequential State Update\n    // ----------------------------------------------------------\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // ----------------------------------------------------------\n    // Main Control: pass_cnt, pair_idx, and compare-swap\n    // ----------------------------------------------------------\n    integer i;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done      <= 1'b0;\n            pass_cnt  <= 0;\n            pair_idx  <= 0;\n        end\n        else begin\n            case (state)\n\n                //--------------------------------------\n                // IDLE: wait for start, clear signals\n                //--------------------------------------\n                IDLE: begin\n                    done     <= 1'b0;\n                    pass_cnt <= 0;\n                    pair_idx <= 0;\n                end\n\n                //--------------------------------------\n                // LOAD: capture input data into array\n                //--------------------------------------\n                LOAD: begin\n                    // Load all N elements from in_data\n                    for (i = 0; i < N; i = i + 1) begin\n                        data_array[i] <= in_data[i*WIDTH +: WIDTH];\n                    end\n                    // Initialize counters\n                    pass_cnt <= 0;\n                    pair_idx <= 0;\n                end\n\n                //--------------------------------------\n                // SORT: perform Brick Sort passes\n                //--------------------------------------\n                SORT: begin\n                    // Compare-swap the current pair\n                    // Check if we are within the valid pair range\n                    // Distinguish odd-even pass from even-odd pass\n                    if (pass_cnt[0] == 1'b0) begin\n                        // even-odd pass => pair = (2*pair_idx, 2*pair_idx+1)\n                        for(pair_idx=0; pair_idx<(N+1)/2; pair_idx=pair_idx+1) begin\n                            if (data_array[2*pair_idx] > data_array[2*pair_idx+1]) begin\n                                // Swap\n                                {data_array[2*pair_idx], data_array[2*pair_idx+1]} <= {data_array[2*pair_idx+1], data_array[2*pair_idx]};\n                            end\n                        end\n                    end\n                    else begin\n                        // odd-even pass => pair = (2*pair_idx+1, 2*pair_idx+2\n                        for(pair_idx=0; pair_idx<((N+1)/2) - 1; pair_idx=pair_idx+1) begin\n                            if ((2*pair_idx+2) < N) begin\n                                if (data_array[2*pair_idx+1] > data_array[2*pair_idx+2]) begin\n                                    // Swap\n                                    {data_array[2*pair_idx+1], data_array[2*pair_idx+2]} <= {data_array[2*pair_idx+2], data_array[2*pair_idx+1]};\n                                end\n                            end\n                        end\n                    end\n\n                    // Completed all pairs in this pass -> next pass\n                    pass_cnt <= pass_cnt + 1;\n\n                end // SORT\n\n                //--------------------------------------\n                // DONE: output final data, assert done\n                //--------------------------------------\n                DONE: begin\n                    done <= 1'b1;\n                    // Drive out_data from data_array\n                    for (i = 0; i < N; i = i + 1) begin\n                        out_data[i*WIDTH +: WIDTH] <= data_array[i];\n                    end\n                end\n\n            endcase\n        end\n    end\n\nendmodule", "rtl/bubble_sort.sv": "module bubble_sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal registers to hold the array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0]  state, next_state;\n\n    // Variables for bubble sort indexing\n    reg [$clog2(N)-1:0] i;  // Outer loop index\n    reg [$clog2(N)-1:0] j;  // Inner loop index\n\n    // Wires for comparison and swap\n    wire [WIDTH-1:0] val_j;\n    wire [WIDTH-1:0] val_j1;\n\n    assign val_j  = array[j];\n    assign val_j1 = array[j+1];\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Transition to DONE once all passes are complete\n                if (i == (N-1) && j == (N-2))\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM: Output and counter updates\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            i <= 0;\n            j <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load the array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 0;\n                        j <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform a single comparison and swap if needed\n                    if (val_j > val_j1) begin\n                        array[j]   <= val_j1;\n                        array[j+1] <= val_j;\n                    end\n\n                    // Update j\n                    if (j == N-2) begin\n                        // One pass completed, increment i\n                        j <= 0;\n                        i <= i + 1;\n                    end else begin\n                        j <= j + 1;\n                    end\n                end\n\n                DONE: begin\n                    // Sorting complete\n                    done <= 1;\n                    // Output the sorted data\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule", "rtl/merge_sort.sv": "module merge_sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    //-------------------------------------------------\n    // Local Parameters & Functions\n    //-------------------------------------------------\n    localparam IDLE  = 0;\n    localparam LOAD  = 1;\n    localparam SORT  = 2;\n    localparam MERGE = 3;\n    localparam DONE  = 4;\n\n    // Function to compute floor(log2(value)) at compile time\n    function integer clog2;\n        input integer value;\n        integer i;\n        begin\n            clog2 = 0;\n            for (i = 1; i < value; i = i << 1) begin\n                clog2 = clog2 + 1;\n            end\n        end\n    endfunction\n\n    // We choose ADDR_WIDTH big enough so we can store up to ~4*N in subarray_size\n    // For N=8, 4*N=32 => log2(32)=5 => plus 1 => 6 bits => can store up to 63 safely.\n    localparam ADDR_WIDTH = clog2(4 * N) + 1;\n\n    //-------------------------------------------------\n    // Internal Signals\n    //-------------------------------------------------\n    reg [2:0]                 state; // Enough for 5 states: IDLE..DONE\n\n    // Internal memory of N elements\n    reg [WIDTH-1:0]           data_mem [0:N-1];\n\n    // Indices and counters with widened bit-width\n    reg [ADDR_WIDTH-1:0]      base_idx;\n    reg [ADDR_WIDTH-1:0]      left_idx;\n    reg [ADDR_WIDTH-1:0]      right_idx;\n    reg [ADDR_WIDTH-1:0]      merge_idx;\n    reg [ADDR_WIDTH-1:0]      subarray_size;\n\n    // Temporary buffer for merged sub-array\n    reg [WIDTH-1:0]           tmp_merge [0:N-1];\n\n    // Temporary registers for current left/right values\n    reg [WIDTH-1:0]           left_val;\n    reg [WIDTH-1:0]           right_val;\n\n    integer i, k;\n    integer left_end, right_end;\n    integer l_addr,    r_addr;\n\n    //-------------------------------------------------\n    // State Machine\n    //-------------------------------------------------\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset\n            state         <= IDLE;\n            done          <= 1'b0;\n            out_data      <= {N*WIDTH{1'b0}};\n            base_idx      <= 0;\n            left_idx      <= 0;\n            right_idx     <= 0;\n            merge_idx     <= 0;\n            subarray_size <= 1;\n        end else begin\n            case (state)\n\n                //----------------------------------\n                // IDLE: Wait for start signal\n                //----------------------------------\n                IDLE: begin\n                    done <= 1'b0;\n                    if (start) begin\n                        state <= LOAD;\n                    end\n                end\n\n                //----------------------------------\n                // LOAD: Copy from in_data to data_mem\n                //----------------------------------\n                LOAD: begin\n                    for (i = 0; i < N; i = i + 1) begin\n                        data_mem[i] <= in_data[i*WIDTH +: WIDTH];\n                    end\n\n                    // Initialize for sorting\n                    base_idx      <= 0;\n                    left_idx      <= 0;\n                    right_idx     <= 0;\n                    merge_idx     <= 0;\n                    subarray_size <= 1;\n\n                    state <= SORT;\n                end\n\n                //----------------------------------\n                // SORT: Each pass merges sub-arrays of size subarray_size\n                //----------------------------------\n                SORT: begin\n                    // If subarray_size is strictly greater than N, we've fully sorted\n                    // (ensures we do a merge pass at subarray_size == N)\n                    if (subarray_size >= N) begin\n                        state <= DONE;\n                    end else begin\n                        // Prepare to merge pairs of sub-arrays\n                        base_idx  <= 0;\n                        merge_idx <= 0;\n                        left_idx  <= 0;\n                        right_idx <= 0;\n                        state     <= MERGE;\n                    end\n                end\n\n                //----------------------------------\n                // MERGE: Merge one pair of sub-arrays\n                //----------------------------------\n                MERGE: begin\n                    // Compare/pick smaller\n                    if ((l_addr <= left_end) && (r_addr <= right_end)) begin\n                        if (left_val <= right_val) begin\n                            tmp_merge[merge_idx] <= left_val;\n                            left_idx <= left_idx + 1;\n                        end else begin\n                            tmp_merge[merge_idx] <= right_val;\n                            right_idx <= right_idx + 1;\n                        end\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else if (l_addr <= left_end) begin\n                        // Only left sub-array has data\n                        tmp_merge[merge_idx] <= left_val;\n                        left_idx <= left_idx + 1;\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else if (r_addr <= right_end) begin\n                        // Only right sub-array has data\n                        tmp_merge[merge_idx] <= right_val;\n                        right_idx <= right_idx + 1;\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else begin\n                        // Both sub-arrays are exhausted => write back merged results\n                        for (k = 0; k < N; k = k + 1) begin\n                            if ( (k < merge_idx) && (k < (subarray_size << 1)) && ((base_idx + k) < N) )\n                            begin\n                                data_mem[base_idx + k] <= tmp_merge[k];\n                            end\n                        end\n\n                        // Move base_idx to next pair of sub-arrays\n                        base_idx  <= base_idx + (subarray_size << 1);\n                        left_idx  <= 0;\n                        right_idx <= 0;\n                        merge_idx <= 0;\n\n                        // If we merged all pairs in this pass, double subarray_size\n                        if ((base_idx + (subarray_size << 1)) >= N) begin\n                            subarray_size <= subarray_size << 1;\n                            state         <= SORT;\n                        end\n                    end\n                end\n\n                //----------------------------------\n                // DONE: Output the fully sorted array\n                //----------------------------------\n                DONE: begin\n                    for (i = 0; i < N; i = i + 1) begin\n                        out_data[i*WIDTH +: WIDTH] <= data_mem[i];\n                    end\n                    done  <= 1'b1;\n                    state <= IDLE;  // or remain in DONE, your preference\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nalways @ (*) begin\n    if(state == MERGE) begin\n        left_end  = base_idx + subarray_size - 1;\n        right_end = base_idx + (subarray_size << 1) - 1;\n\n        // Boundaries of left and right sub-arrays\n        if (left_end >= N) left_end = N - 1;\n        if (right_end >= N) right_end = N - 1;\n\n        // Calculate addresses\n        l_addr = base_idx + left_idx;\n        r_addr = base_idx + subarray_size + right_idx;\n\n        // Safe read for left_val\n        if ((l_addr <= left_end) && (l_addr < N))\n            left_val = data_mem[l_addr];\n        else\n            left_val = {WIDTH{1'b1}};  // or '0' if you prefer\n\n        // Safe read for right_val\n        if ((r_addr <= right_end) && (r_addr < N))\n            right_val = data_mem[r_addr];\n        else\n            right_val = {WIDTH{1'b1}};\n    end else begin\n        left_end = 0;\n        right_end = 0;\n        l_addr = 0;\n        r_addr = 0;\n        left_val = 0;\n        right_val = 0;\n    end\nend\n\nendmodule", "rtl/selection_sort.sv": "module selection_sorting_engine #(\n    parameter N = 8,\n    parameter WIDTH = 8\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    typedef enum logic [2:0] {\n        IDLE  = 3'd0,\n        LOAD  = 3'd1,\n        FIND  = 3'd2,\n        CHECK = 3'd3,\n        SWAP  = 3'd4,\n        NEXT  = 3'd5,\n        DONE  = 3'd6\n    } state_t;\n\n    state_t current_state, next_state;\n\n    reg [WIDTH-1:0] data_array [0:N-1];\n\n    reg [$clog2(N)-1:0] i;\n    reg [$clog2(N)-1:0] j;\n    reg [$clog2(N)-1:0] min_idx;\n\n    reg [WIDTH-1:0] min_val;\n    integer idx;\n    integer k;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (start)\n                    next_state = LOAD;\n            end\n\n            LOAD: begin\n                next_state = FIND;\n            end\n\n            FIND: begin\n                next_state = CHECK;\n            end\n\n            CHECK: begin\n                if (j == N-1)\n                    next_state = SWAP;\n                else\n                    next_state = CHECK;\n            end\n\n            SWAP: begin\n                next_state = NEXT;\n            end\n\n            NEXT: begin\n                if (i == N-2)\n                    next_state = DONE;\n                else\n                    next_state = FIND;\n            end\n\n            DONE: begin\n                next_state = IDLE;\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done     <= 1'b0;\n            out_data <= {N*WIDTH{1'b0}};\n        end\n        else begin\n            done <= (current_state == DONE);\n\n            if (current_state == DONE) begin\n                for (idx = 0; idx < N; idx = idx + 1) begin\n                    out_data[idx*WIDTH +: WIDTH] <= data_array[idx];\n                end\n            end\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            for (k = 0; k < N; k = k + 1) begin\n                data_array[k] <= {WIDTH{1'b0}};\n            end\n            i       <= 0;\n            j       <= 0;\n            min_idx <= 0;\n            min_val <= {WIDTH{1'b0}};\n        end\n        else begin\n            case (current_state)\n\n                IDLE: begin\n                end\n\n                LOAD: begin\n                    for (k = 0; k < N; k = k + 1) begin\n                        data_array[k] <= in_data[k*WIDTH +: WIDTH];\n                    end\n                    i       <= 0;\n                    j       <= 0;\n                    min_idx <= 0;\n                    min_val <= {WIDTH{1'b0}};\n                end\n\n                FIND: begin\n                    j          <= i + 1;\n                    min_idx    <= i;\n                    min_val    <= data_array[i];\n                end\n\n                CHECK: begin\n                    if (data_array[j] < min_val) begin\n                        min_val    <= data_array[j];\n                        min_idx    <= j;\n                    end\n\n                    if (j < N-1) begin\n                        j <= j + 1;\n                    end\n                end\n\n                SWAP: begin\n                    if (min_idx != i) begin\n                        data_array[i]        <= data_array[min_idx];\n                        data_array[min_idx]  <= data_array[i];\n                    end\n                end\n\n                NEXT: begin\n                    i <= i + 1;\n                end\n\n                DONE: begin\n                end\n\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule"}, "patch": {"rtl/order_matching_engine.sv": ""}, "harness": {"docker-compose.yml": "services:\n  \n direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command: pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/order_matching_engine.sv /code/rtl/brick_sort.sv /code/rtl/bubble_sort.sv /code/rtl/merge_sort.sv /code/rtl/selection_sort.sv\nTOPLEVEL        = order_matching_engine\nMODULE          = test_order_matching_engine\nPYTHONPATH      = /src\nHASH            = 26-order-matching-engine-hard\n", "src/test_order_matching_engine.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\ndef pack_vector(orders, width):\n    \"\"\"\n    Pack a list of integers (orders[0] ... orders[7]) into a flat integer.\n    The flat vector is constructed as {orders[7], orders[6], ..., orders[0]}\n    so that orders[0] occupies the least-significant bits.\n    \"\"\"\n    value = 0\n    for order in orders[::-1]:\n        value = (value << width) | (order & ((1 << width) - 1))\n    return value\n\ndef scale_orders(orders, max_val):\n    \"\"\"\n    Scale a list of order percentages (0-100) into the range [0, max_val].\n    \"\"\"\n    return [int(val * max_val / 100) for val in orders]\n\n@cocotb.test()\nasync def test_order_matching_engine(dut):\n    \"\"\"\n    Cocotb testbench for order_matching_engine.\n    This test applies several corner-case and random test vectors,\n    verifies that the matching result (match_valid and matched_price)\n    is correct, and checks that the overall latency from start to done\n    is exactly 10 cycles.\n    \"\"\"\n    # Create and start clock (10 ns period)\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Retrieve PRICE_WIDTH parameter from DUT (default to 16)\n    try:\n        price_width = int(dut.PRICE_WIDTH.value)\n    except Exception as e:\n        dut._log.warning(\"Unable to read PRICE_WIDTH parameter, defaulting to 16. Error: %s\", e)\n        price_width = 16\n\n    max_val = (1 << price_width) - 1\n    NUM_ELEMS = 8\n\n    # Helper: Measure latency from start pulse to when done is asserted.\n    async def measure_latency():\n        cycle_count = 0\n        while int(dut.done.value) == 0:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n        return cycle_count\n\n    # Define test cases.\n    tests = []\n\n    #-----------------------------------------------------------------------\n    # 1) Normal matching scenario (circuit_breaker=0)\n    #    bid: [42,74,10,21,108,53,95,106]\n    #    ask: [130,108,205,129,192,213,244,141]\n    #\n    #    Here we expect a valid match, with matched_price = 108\n    #    (assuming best bid >= best ask).\n    #-----------------------------------------------------------------------\n    tests.append({\n        \"description\": \"Matching scenario: valid match, circuit breaker off\",\n        \"bid\": scale_orders([42,74,10,21,108,53,95,106], 100),\n        \"ask\": scale_orders([130,108,205,129,192,213,244,141], 100),\n        \"circuit_breaker\": 0,\n        \"expected_match\": True,\n        \"expected_price\": 108\n    })\n\n    #-----------------------------------------------------------------------\n    # 2) Circuit breaker scenario\n    #    Even though best_bid >= best_ask, circuit_breaker=1 must block the match.\n    #\n    #    bid: [80,90,100,85,95,81,99,120]\n    #    ask: [70,75,60,65,64,68,66,72]\n    #\n    #    Normally, best_bid=120, best_ask=60 => match_valid=1, matched_price=120.\n    #    But with circuit_breaker=1, match_valid must be 0.\n    #-----------------------------------------------------------------------\n    tests.append({\n        \"description\": \"Circuit breaker scenario: best bid >= best ask but breaker is active\",\n        \"bid\": scale_orders([80,90,100,85,95,81,99,120], 100),\n        \"ask\": scale_orders([70,75,60,65,64,68,66,72], 100),\n        \"circuit_breaker\": 1,\n        \"expected_match\": False,\n        \"expected_price\": 0\n    })\n\n    #-----------------------------------------------------------------------\n    # Additional tests can be appended here if needed\n    #-----------------------------------------------------------------------\n\n    # Iterate through each test case.\n    for test in tests:\n        dut._log.info(\"---------------------------------------------------\")\n        dut._log.info(\"Starting test: %s\", test[\"description\"])\n\n        # Pack bid and ask orders.\n        bid_flat = pack_vector(test[\"bid\"], price_width)\n        ask_flat = pack_vector(test[\"ask\"], price_width)\n\n        # Drive the inputs.\n        dut.bid_orders.value = bid_flat\n        dut.ask_orders.value = ask_flat\n        dut.circuit_breaker.value = test[\"circuit_breaker\"]\n\n        # Apply a reset before starting the test.\n        dut.rst.value = 1\n        dut.start.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst.value = 0\n        await RisingEdge(dut.clk)\n\n        # Issue the start pulse.\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Measure latency.\n        latency = await measure_latency()\n        dut._log.info(\"Test '%s': Measured latency = %d cycles\", test[\"description\"], latency)\n        assert latency == 13, f\"Latency error in test '{test['description']}': expected 10 cycles, got {latency}\"\n\n        # Retrieve matching outputs.\n        match_valid = int(dut.match_valid.value)\n        matched_price = int(dut.matched_price.value)\n\n        # Compute expected matching result from test vector\n        exp_match_valid = 1 if test[\"expected_match\"] else 0\n        exp_matched_price = test[\"expected_price\"]\n\n        # Check matching result.\n        assert match_valid == exp_match_valid, \\\n            f\"Test '{test['description']}' failed: Expected match_valid {exp_match_valid}, got {match_valid}\"\n        if match_valid:\n            assert matched_price == exp_matched_price, \\\n                f\"Test '{test['description']}' failed: Expected matched_price {exp_matched_price}, got {matched_price}\"\n\n        dut._log.info(\"Test '%s' PASSED: match_valid=%d, matched_price=%d\",\n                      test[\"description\"], match_valid, matched_price)\n\n        # Wait a few cycles before the next test.\n        await Timer(20, units=\"ns\")\n\n    dut._log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner(PRICE_WIDTH: int=8):\n    \n    parameter = {\"PRICE_WIDTH\":PRICE_WIDTH}\n    # Debug information\n    print(f\"[DEBUG] Running simulation with PRICE_WIDTH={PRICE_WIDTH}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Parametrize test for different PRICE_WIDTH\n@pytest.mark.parametrize(\"PRICE_WIDTH\", [8])\n\ndef test_sort(PRICE_WIDTH):\n    # Run the simulation with specified parameters\n    test_runner(PRICE_WIDTH=PRICE_WIDTH)\n"}}
{"id": "cvdp_agentic_meadow_canyon_sunrise_0439", "categories": ["cid005", "medium"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a **swizzler** module that performs complex cross-correlation and energy computation over input I/Q data. This module handles the internal processing logic required for computing correlation with conjugate reference sequences. It unpacks the input data into individual lanes, applies a swizzle map for remapping the lanes, detects invalid mappings, computes parity errors (if enabled), and finally performs a bit reversal on each lane before packing the data back into a flat output vector. The **swizzler** module is available at `/rtl/swizzler.sv` and its detailed specification is provided in the `/docs` directory.\n\nCan you implement a top-level module called **`swizzler_supervisor`** ? The supervisor should integrate the **swizzler** module and augment its functionality with additional glue logic as described below.\n\nThe **swizzler_supervisor** module is designed to enhance the raw functionality of the **swizzler** subcomponent by:\n  \n- **Input Handling:**  \n  - Pre-processing the input I/Q data to ensure proper formatting and conditioning prior to processing by the swizzler.\n  - Applying potential reordering or scaling operations to align with the swizzler\u2019s processing requirements.\n\n- **Processing the Swizzler's Output:**  \n  - Performing post-processing on the swizzler\u2019s output, which includes computing a checksum across all lanes.\n  - Comparing the computed checksum with a pre-defined expected value.\n  - Generating error flags if a parity error, invalid mapping, or checksum mismatch is detected.\n  - Applying additional bit manipulations (such as inverting the least significant bit in each lane) to produce the final data output.\n\n- **Parameterization:**  \n  - The design must be fully parameterizable to adapt to various configurations. Key parameters include:\n    - **NUM_LANES**: Number of data lanes.\n    - **DATA_WIDTH**: Bit-width of each lane.\n    - **REGISTER_OUTPUT**: Option to pipeline outputs.\n    - **ENABLE_PARITY_CHECK**: Toggle for parity error computation.\n    - **OP_MODE_WIDTH**: Width of the operation mode signal.\n    - **SWIZZLE_MAP_WIDTH**: Derived width for swizzle mapping.\n    - **EXPECTED_CHECKSUM**: The checksum value against which the output is verified.\n\n- **Error Supervision:**  \n  - Integrate supervisory logic that validates the swizzler output by comparing the computed checksum with the expected value.\n  - Assert a top-level error signal if any discrepancies arise (i.e., parity errors, invalid mapping errors, or checksum mismatches).\n\n```verilog\nmodule swizzler_supervisor #(\n  parameter integer NUM_LANES           = 4,\n  parameter integer DATA_WIDTH          = 8,\n  parameter integer REGISTER_OUTPUT     = 1,\n  parameter integer ENABLE_PARITY_CHECK = 1,\n  parameter integer OP_MODE_WIDTH       = 2,\n  parameter integer SWIZZLE_MAP_WIDTH   = $clog2(NUM_LANES)+1,\n  parameter [DATA_WIDTH-1:0] EXPECTED_CHECKSUM = 8'hA5\n)(\n  input  wire                           clk,\n  input  wire                           rst_n,\n  input  wire                           bypass,\n  input  wire [NUM_LANES*DATA_WIDTH-1:0] data_in,\n  input  wire [NUM_LANES*SWIZZLE_MAP_WIDTH-1:0] swizzle_map_flat,\n  input  wire [OP_MODE_WIDTH-1:0]         operation_mode,\n  output reg  [NUM_LANES*DATA_WIDTH-1:0]  final_data_out,\n  output reg                            top_error\n);\n  // [Internal implementation...]\nendmodule\n```\n\nPlease refer to `docs/swizzler_specification.md` for detailed design requirements and specifications of the subcomponent swizzler. \n", "context": {"docs/swizzler_specification.md": "# Swizzler Specification Document\n\n## Introduction\n\nThe Swizzler module is a configurable hardware component designed to perform lane remapping (swizzling) on a multi-lane data bus. It allows for flexible data routing by rearranging the input data lanes according to an encoded swizzle map. This version of the Swizzler adds advanced features including an operation mode input for additional control, invalid mapping detection, a three-stage pipeline with bit reversal processing, and optional parity checking and output registering.\n\n## Functional Overview\n\n1. **Data Unpacking:**  \n   The flat input bus (`data_in`) is partitioned into individual data lanes. Each lane is extracted based on the defined data width.\n\n2. **Swizzle Map Unpacking:**  \n   The encoded flat swizzle map (`swizzle_map_flat`) is converted into an array of mapping values. The width of each element is defined as `$clog2(NUM_LANES)+1`, which provides extra bits for error detection.\n\n3. **Invalid Mapping Detection:**  \n   Each element of the swizzle map is compared against `NUM_LANES` to detect invalid mapping values. If any element is out of the valid range, an invalid mapping flag is raised and later captured by the pipeline.\n\n4. **Lane Remapping:**  \n   In normal operation, the module remaps the input lanes based on the swizzle map. When the `bypass` signal is asserted, the input lanes pass through unchanged. The lower bits of each mapping element are used as the valid index for lane selection.\n\n5. **Pipeline Stage 1:**  \n   The remapped (or bypassed) lanes are captured into a set of registers. This stage creates a buffered version of the swizzled lanes that can be further processed.\n\n6. **Pipeline Stage 2:**  \n   The current `operation_mode` is captured into a register along with the invalid mapping detection signal. This stage isolates control and error status information before final processing.\n\n7. **Bit Reversal:**  \n   A bit reversal function processes each lane. In the final pipeline stage, the bits of each captured lane are reversed to produce the final output data.\n\n8. **Pipeline Stage 3:**  \n   The bit-reversed lanes are stored in a final set of registers, which are then repacked into the flat output bus (`data_out`). Depending on the configuration, the final output may be registered or directly passed through combinational logic.\n\n9. **Optional Parity Checking:**  \n   When parity checking is enabled, the module calculates the parity for each final output lane. If any lane has nonzero parity, the `parity_error` output is asserted.\n\n10. **Invalid Mapping Error Output:**  \n    The result of invalid mapping detection is propagated to the top level via the `invalid_mapping_error` output, signaling if any swizzle map element is outside the allowed range.\n\n## Module Interface\n\n### Parameters\n\n- **NUM_LANES**  \n  Number of data lanes in the module.\n\n- **DATA_WIDTH**  \n  Width of each data lane in bits.\n\n- **REGISTER_OUTPUT**  \n  Determines whether the final output data is registered. If set to 1, data is clocked out; if 0, data is passed combinationally.\n\n- **ENABLE_PARITY_CHECK**  \n  Enables parity error detection across the output lanes when set to 1.\n\n- **OP_MODE_WIDTH**  \n  Defines the width of the operation mode input, used for auxiliary control purposes.\n\n- **SWIZZLE_MAP_WIDTH**  \n  Calculated as `$clog2(NUM_LANES)+1`, this defines the width of each element in the swizzle map, allowing for error detection by providing an extra bit.\n\n### Ports\n\n- **clk (input):**  \n  Clock signal for synchronizing operations.\n\n- **rst_n (input):**  \n  Active-low reset that initializes internal registers.\n\n- **bypass (input):**  \n  When asserted, the module bypasses the swizzling logic and forwards the input lanes directly to the output.\n\n- **data_in (input):**  \n  Flat data input bus with a width of `NUM_LANES * DATA_WIDTH`.\n\n- **swizzle_map_flat (input):**  \n  Flat swizzle map with a width of `NUM_LANES * SWIZZLE_MAP_WIDTH` which specifies the remapping of input lanes.\n\n- **operation_mode (input):**  \n  Input specifying the operational mode. Captured and used in pipeline stage 2 for additional control.\n\n- **data_out (output):**  \n  Flat data output bus with a width of `NUM_LANES * DATA_WIDTH` that carries the processed (remapped and bit-reversed) data.\n\n- **parity_error (output):**  \n  When parity checking is enabled, this output is asserted if any lane\u2019s computed parity is nonzero.\n\n- **invalid_mapping_error (output):**  \n  Indicates that one or more elements in the swizzle map contained an invalid mapping (i.e., a mapping value not less than NUM_LANES).\n\n```verilog\nmodule swizzler #(\n  parameter integer NUM_LANES           = 4,\n  parameter integer DATA_WIDTH          = 8,\n  parameter integer REGISTER_OUTPUT     = 0,\n  parameter integer ENABLE_PARITY_CHECK = 0,\n  parameter integer OP_MODE_WIDTH       = 2,\n  parameter integer SWIZZLE_MAP_WIDTH   = $clog2(NUM_LANES)+1\n)(\n  input  wire                           clk,\n  input  wire                           rst_n,\n  input  wire                           bypass,\n  input  wire [NUM_LANES*DATA_WIDTH-1:0]  data_in,\n  input  wire [NUM_LANES*SWIZZLE_MAP_WIDTH-1:0] swizzle_map_flat,\n  input  wire [OP_MODE_WIDTH-1:0]         operation_mode,\n  output reg  [NUM_LANES*DATA_WIDTH-1:0]  data_out,\n  output reg                            parity_error,\n  output reg                            invalid_mapping_error\n);\n  // Internal RTL implementation as described in the functional overview.\nendmodule", "rtl/swizzler.sv": "`timescale 1ns/1ps\n\nmodule swizzler #(\n  parameter integer NUM_LANES           = 4,\n  parameter integer DATA_WIDTH          = 8,\n  parameter integer REGISTER_OUTPUT     = 0,\n  parameter integer ENABLE_PARITY_CHECK = 0,\n  parameter integer OP_MODE_WIDTH       = 2,\n  parameter integer SWIZZLE_MAP_WIDTH   = $clog2(NUM_LANES)+1\n)(\n  input  wire                           clk,\n  input  wire                           rst_n,\n  input  wire                           bypass,\n  input  wire [NUM_LANES*DATA_WIDTH-1:0]  data_in,\n  input  wire [NUM_LANES*SWIZZLE_MAP_WIDTH-1:0] swizzle_map_flat,\n  input  wire [OP_MODE_WIDTH-1:0]         operation_mode,\n  output reg  [NUM_LANES*DATA_WIDTH-1:0]  data_out,\n  output reg                            parity_error,\n  output reg                            invalid_mapping_error\n);\n\n  // Unpack data_in into lanes\n  wire [DATA_WIDTH-1:0] lane_in [0:NUM_LANES-1];\n  genvar gi;\n  generate\n    for (gi = 0; gi < NUM_LANES; gi = gi + 1) begin : UNPACK_INPUT\n      assign lane_in[gi] = data_in[DATA_WIDTH*(gi+1)-1 : DATA_WIDTH*gi];\n    end\n  endgenerate\n\n  // Unpack swizzle_map_flat into swizzle_map array\n  wire [SWIZZLE_MAP_WIDTH-1:0] swizzle_map [0:NUM_LANES-1];\n  generate\n    for (gi = 0; gi < NUM_LANES; gi = gi + 1) begin : UNPACK_SWIZZLE\n      assign swizzle_map[gi] = swizzle_map_flat[SWIZZLE_MAP_WIDTH*(gi+1)-1 : SWIZZLE_MAP_WIDTH*gi];\n    end\n  endgenerate\n\n  // Invalid mapping detection\n  wire [NUM_LANES-1:0] invalid_map_flag;\n  generate\n    for (gi = 0; gi < NUM_LANES; gi = gi + 1) begin : INVALID_CHECK\n      assign invalid_map_flag[gi] = (swizzle_map[gi] >= NUM_LANES) ? 1'b1 : 1'b0;\n    end\n  endgenerate\n  wire invalid_mapping_detected = |invalid_map_flag;\n\n  // Remap lanes according to swizzle_map or bypass\n  wire [DATA_WIDTH-1:0] swizzled [0:NUM_LANES-1];\n  generate\n    for (gi = 0; gi < NUM_LANES; gi = gi + 1) begin : REMAP\n      // Use lower bits of swizzle_map to index valid lanes.\n      assign swizzled[gi] = bypass ? lane_in[gi] : lane_in[ swizzle_map[gi][$clog2(NUM_LANES)-1:0] ];\n    end\n  endgenerate\n\n  // Pipeline Stage 1: Capture swizzled lanes\n  reg [DATA_WIDTH-1:0] swizzle_reg [0:NUM_LANES-1];\n  integer i;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      for (i = 0; i < NUM_LANES; i = i + 1)\n        swizzle_reg[i] <= {DATA_WIDTH{1'b0}};\n    else\n      for (i = 0; i < NUM_LANES; i = i + 1)\n        swizzle_reg[i] <= swizzled[i];\n  end\n\n  // Pipeline Stage 2: Capture operation mode and invalid mapping status\n  reg [OP_MODE_WIDTH-1:0] op_reg;\n  reg op_invalid_reg;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      op_reg <= {OP_MODE_WIDTH{1'b0}};\n      op_invalid_reg <= 1'b0;\n    end else begin\n      op_reg <= operation_mode;\n      op_invalid_reg <= invalid_mapping_detected;\n    end\n  end\n\n  // Bit reversal function\n  function automatic [DATA_WIDTH-1:0] bit_reverse;\n    input [DATA_WIDTH-1:0] in;\n    integer k;\n    begin\n      bit_reverse = {DATA_WIDTH{1'b0}};\n      for (k = 0; k < DATA_WIDTH; k = k + 1)\n        bit_reverse[k] = in[DATA_WIDTH-1-k];\n    end\n  endfunction\n\n  // Pipeline Stage 3: Final output stage with bit reversal\n  reg [DATA_WIDTH-1:0] final_reg [0:NUM_LANES-1];\n  integer m;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      for (m = 0; m < NUM_LANES; m = m + 1)\n        final_reg[m] <= {DATA_WIDTH{1'b0}};\n    else\n      for (m = 0; m < NUM_LANES; m = m + 1)\n        final_reg[m] <= bit_reverse(swizzle_reg[m]);\n  end\n\n  // Pack final_reg into a flat output vector\n  wire [NUM_LANES*DATA_WIDTH-1:0] final_packed;\n  genvar q;\n  generate\n    for (q = 0; q < NUM_LANES; q = q + 1) begin : PACK_FINAL\n      assign final_packed[DATA_WIDTH*(q+1)-1 : DATA_WIDTH*q] = final_reg[q];\n    end\n  endgenerate\n\n  generate\n    if (REGISTER_OUTPUT) begin : REG_FINAL\n      always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n          data_out <= {NUM_LANES*DATA_WIDTH{1'b0}};\n        else\n          data_out <= final_packed;\n      end\n    end else begin : COMB_FINAL\n      always @* begin\n        data_out = final_packed;\n      end\n    end\n  endgenerate\n\n  // Updated parity error calculation using a generate block\n  generate\n    if (ENABLE_PARITY_CHECK) begin : GEN_PARITY\n      // Calculate parity from final_reg if parity check is enabled.\n      wire [NUM_LANES-1:0] final_parity;\n      genvar p;\n      for (p = 0; p < NUM_LANES; p = p + 1) begin : PARITY_CALC\n        assign final_parity[p] = ^final_reg[p];\n      end\n      wire computed_parity = |final_parity;\n      always @* begin\n        parity_error = computed_parity;\n      end\n    end else begin : NO_PARITY\n      // Drive parity_error to 0 when parity check is disabled.\n      always @* begin\n        parity_error = 1'b0;\n      end\n    end\n  endgenerate\n\n  // Pass the invalid mapping flag\n  always @* begin\n    invalid_mapping_error = op_invalid_reg;\n  end\n\nendmodule", "verif/swizzler_tb.sv": "`timescale 1ns/1ps\n\nmodule tb_swizzler;\n  parameter NUM_LANES = 4;\n  parameter DATA_WIDTH = 8;\n  parameter REGISTER_OUTPUT = 1;\n  parameter ENABLE_PARITY_CHECK = 0;\n  parameter OP_MODE_WIDTH = 2;\n  parameter SWIZZLE_MAP_WIDTH = 3;\n\n  reg clk;\n  reg rst_n;\n  reg bypass;\n  reg [NUM_LANES*DATA_WIDTH-1:0] data_in;\n  reg [NUM_LANES*SWIZZLE_MAP_WIDTH-1:0] swizzle_map_flat;\n  reg [OP_MODE_WIDTH-1:0] operation_mode;\n  wire [NUM_LANES*DATA_WIDTH-1:0] data_out;\n  wire parity_error;\n  wire invalid_mapping_error;\n\n  swizzler #(\n    .NUM_LANES(NUM_LANES),\n    .DATA_WIDTH(DATA_WIDTH),\n    .REGISTER_OUTPUT(REGISTER_OUTPUT),\n    .ENABLE_PARITY_CHECK(ENABLE_PARITY_CHECK),\n    .OP_MODE_WIDTH(OP_MODE_WIDTH),\n    .SWIZZLE_MAP_WIDTH(SWIZZLE_MAP_WIDTH)\n  ) dut (\n    .clk(clk),\n    .rst_n(rst_n),\n    .bypass(bypass),\n    .data_in(data_in),\n    .swizzle_map_flat(swizzle_map_flat),\n    .operation_mode(operation_mode),\n    .data_out(data_out),\n    .parity_error(parity_error),\n    .invalid_mapping_error(invalid_mapping_error)\n  );\n\n  reg [DATA_WIDTH-1:0] expected [0:NUM_LANES-1];\n  reg [DATA_WIDTH-1:0] out_lane [0:NUM_LANES-1];\n  integer i;\n\n  function [DATA_WIDTH-1:0] bit_reverse;\n    input [DATA_WIDTH-1:0] in;\n    integer j;\n    reg [DATA_WIDTH-1:0] out;\n    begin\n      out = 0;\n      for(j = 0; j < DATA_WIDTH; j = j + 1)\n        out[j] = in[DATA_WIDTH-1-j];\n      bit_reverse = out;\n    end\n  endfunction\n\n  function [DATA_WIDTH-1:0] get_lane;\n    input integer index;\n    begin\n      get_lane = data_out[DATA_WIDTH*(index+1)-1 -: DATA_WIDTH];\n    end\n  endfunction\n\n  initial begin\n    clk = 0;\n    forever #5 clk = ~clk;\n  end\n\n  initial begin\n    rst_n = 0;\n    bypass = 0;\n    data_in = 0;\n    swizzle_map_flat = 0;\n    operation_mode = 0;\n    #12;\n    rst_n = 1;\n    repeat (5) @(posedge clk);\n    // TEST 1: Bypass disabled, identity mapping with bit reversal.\n    data_in = {8'h04, 8'h03, 8'h02, 8'h01};\n    swizzle_map_flat = {3'b011, 3'b010, 3'b001, 3'b000};\n    bypass = 0;\n    operation_mode = 0;\n    repeat (5) @(posedge clk);\n    for(i = 0; i < NUM_LANES; i = i + 1)\n      out_lane[i] = get_lane(i);\n    expected[0] = bit_reverse(8'h01);\n    expected[1] = bit_reverse(8'h02);\n    expected[2] = bit_reverse(8'h03);\n    expected[3] = bit_reverse(8'h04);\n    if(out_lane[0]==expected[0] && out_lane[1]==expected[1] &&\n       out_lane[2]==expected[2] && out_lane[3]==expected[3])\n      $display(\"TEST 1 PASS\");\n    else\n      $display(\"TEST 1 FAIL: Expected %h %h %h %h, Got %h %h %h %h\",\n               expected[0], expected[1], expected[2], expected[3],\n               out_lane[0], out_lane[1], out_lane[2], out_lane[3]);\n    if(invalid_mapping_error==0)\n      $display(\"TEST 1 INVALID MAPPING PASS\");\n    else\n      $display(\"TEST 1 INVALID MAPPING FAIL\");\n\n    // TEST 2: Reverse mapping.\n    data_in = {8'hAA, 8'hBB, 8'hCC, 8'hDD};\n    swizzle_map_flat = {3'b000, 3'b001, 3'b010, 3'b011};\n    bypass = 0;\n    operation_mode = 0;\n    repeat (5) @(posedge clk);\n    for(i = 0; i < NUM_LANES; i = i + 1)\n      out_lane[i] = get_lane(i);\n    // Expected output is reversed compared to input lane order.\n    expected[0] = bit_reverse(8'hAA);\n    expected[1] = bit_reverse(8'hBB);\n    expected[2] = bit_reverse(8'hCC);\n    expected[3] = bit_reverse(8'hDD);\n    if(out_lane[0]==expected[0] && out_lane[1]==expected[1] &&\n       out_lane[2]==expected[2] && out_lane[3]==expected[3])\n      $display(\"TEST 2 PASS\");\n    else\n      $display(\"TEST 2 FAIL: Expected %h %h %h %h, Got %h %h %h %h\",\n               expected[0], expected[1], expected[2], expected[3],\n               out_lane[0], out_lane[1], out_lane[2], out_lane[3]);\n\n    // TEST 3: Bypass mode active.\n    data_in = {8'h11, 8'h22, 8'h33, 8'h44};\n    swizzle_map_flat = {3'b001, 3'b000, 3'b011, 3'b010};\n    bypass = 1;\n    operation_mode = 0;\n    repeat (5) @(posedge clk);\n    for(i = 0; i < NUM_LANES; i = i + 1)\n      out_lane[i] = get_lane(i);\n    expected[0] = bit_reverse(8'h44);\n    expected[1] = bit_reverse(8'h33);\n    expected[2] = bit_reverse(8'h22);\n    expected[3] = bit_reverse(8'h11);\n    if(out_lane[0]==expected[0] && out_lane[1]==expected[1] &&\n       out_lane[2]==expected[2] && out_lane[3]==expected[3])\n      $display(\"TEST 3 PASS\");\n    else\n      $display(\"TEST 3 FAIL: Expected %h %h %h %h, Got %h %h %h %h\",\n               expected[0], expected[1], expected[2], expected[3],\n               out_lane[0], out_lane[1], out_lane[2], out_lane[3]);\n\n    // TEST 4: Invalid mapping detection.\n    data_in = {8'h55, 8'h66, 8'h77, 8'h88};\n    swizzle_map_flat = {3'b011, 3'b010, 3'b001, 3'b100};\n    bypass = 0;\n    operation_mode = 0;\n    repeat (5) @(posedge clk);\n    if(invalid_mapping_error==1)\n      $display(\"TEST 4 PASS: Invalid mapping detected\");\n    else\n      $display(\"TEST 4 FAIL: Invalid mapping not detected\");\n    $finish;\n  end\n\nendmodule"}, "patch": {"rtl/swizzler_supervisor.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\nRUN pip install cocotb-bus", "docker-compose.yml": "services:\n\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/swizzler.sv /code/rtl/swizzler_supervisor.sv\nTOPLEVEL        = swizzler_supervisor\nMODULE          = test_swizzler_supervisor\nPYTHONPATH      = /src\nHASH            = 5-integration-of-swizzler-module-in-to-swizzler-based-processor", "src/test_runner.py": "import os\nfrom cocotb.runner import get_runner\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\", \"\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\", \"1\")\n\nbuild_clean     = os.getenv(\"BUILD_CLEAN\", \"1\") == \"1\"\nbuild_always    = os.getenv(\"BUILD_ALWAYS\", \"1\") == \"1\"\nbuild_verbose   = os.getenv(\"BUILD_VERBOSE\", \"1\") == \"1\"\ntimescale_env   = os.getenv(\"TIMESCALE\", \"1ns,1ns\").split(\",\")\nlog_file        = os.getenv(\"LOG_FILE\", \"build.log\")\n\ndef test_runner():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=build_always,\n        clean=build_clean,\n        waves=(wave==\"1\"),\n        verbose=build_verbose,\n        timescale=(timescale_env[0], timescale_env[1]),\n        log_file=log_file\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=(wave==\"1\"))\n\nif __name__ == \"__main__\":\n    test_runner()\n", "src/test_swizzler_supervisor.py": "import os\nos.environ[\"COCOTB_RESOLVE_X\"] = \"0\"\n\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_basic(dut):\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    dut.rst_n.value = 0\n    await Timer(20, units=\"ns\")\n    dut.rst_n.value = 1\n    await RisingEdge(dut.clk)\n    dut.bypass.value = 0\n    dut.data_in.value = int(\"55\" * 4, 16)\n    mapping = (3 << (3*3)) | (2 << (2*3)) | (1 << (1*3)) | (0 << (0*3))\n    dut.swizzle_map_flat.value = mapping\n    dut.operation_mode.value = 0\n    # Wait several clock cycles for pipelined state machine to update\n    for _ in range(5):\n        await RisingEdge(dut.clk)\n    value_str = dut.final_data_out.value.binstr.replace(\"x\", \"0\")\n    sw_out = int(value_str, 2)\n    checksum = 0\n    for i in range(4):\n        lane = (sw_out >> (i*8)) & 0xFF\n        checksum ^= lane\n    expected_top = 0 if (checksum == int(dut.EXPECTED_CHECKSUM.value)) else 1\n    assert int(dut.top_error.value) == expected_top, f\"Basic test failed: checksum={hex(checksum)} EXPECTED={hex(int(dut.EXPECTED_CHECKSUM.value))} top_error={dut.top_error.value}\"\n    dut._log.info(f\"Basic test passed: final_data_out={hex(sw_out)} checksum={hex(checksum)} top_error={dut.top_error.value}\")\n\n@cocotb.test()\nasync def test_random(dut):\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    dut.rst_n.value = 0\n    await Timer(20, units=\"ns\")\n    dut.rst_n.value = 1\n    await RisingEdge(dut.clk)\n    for i in range(10):\n        dut.bypass.value = random.randint(0,1)\n        data = 0\n        for j in range(4):\n            data = (data << 8) | random.randint(0,255)\n        dut.data_in.value = data\n        mapping = 0\n        for j in range(4):\n            mapping |= (random.randint(0,3) << (j*3))\n        dut.swizzle_map_flat.value = mapping\n        dut.operation_mode.value = random.randint(0,3)\n        await Timer(40, units=\"ns\")\n        # Wait an extra cycle for state machine update\n        await RisingEdge(dut.clk)\n        value_str = dut.final_data_out.value.binstr.replace(\"x\", \"0\")\n        sw_out = int(value_str, 2)\n        checksum = 0\n        for j in range(4):\n            lane = (sw_out >> (j*8)) & 0xFF\n            checksum ^= lane\n        exp_top = 0 if (checksum == int(dut.EXPECTED_CHECKSUM.value)) else 1\n        assert int(dut.top_error.value) == exp_top, f\"Random test iteration {i} failed: checksum={hex(checksum)} EXPECTED={hex(int(dut.EXPECTED_CHECKSUM.value))} top_error={dut.top_error.value}\"\n        dut._log.info(f\"Random test iteration {i} passed: final_data_out={hex(sw_out)} checksum={hex(checksum)} top_error={dut.top_error.value}\")\n\n@cocotb.test()\nasync def test_edge(dut):\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    dut.rst_n.value = 0\n    await Timer(20, units=\"ns\")\n    dut.rst_n.value = 1\n    await RisingEdge(dut.clk)\n    dut.bypass.value = 0\n    dut.data_in.value = int(\"AA\" * 4, 16)\n    mapping = (3 << (3*3)) | (3 << (2*3)) | (2 << (1*3)) | (4 << (0*3))\n    dut.swizzle_map_flat.value = mapping\n    dut.operation_mode.value = 0\n    await Timer(40, units=\"ns\")\n    # Wait an extra cycle for update\n    await RisingEdge(dut.clk)\n    assert int(dut.top_error.value) == 1, f\"Edge test failed: expected top_error=1, got {dut.top_error.value}\"\n    dut._log.info(f\"Edge test passed: final_data_out={hex(int(dut.final_data_out.value))} top_error={dut.top_error.value}\")\n"}}
{"id": "cvdp_agentic_breeze_crystal_zenith_1259", "categories": ["cid004", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a **thermostat** module located at `code/rtl/thermostat.v`. This module currently lacks access control and can operate without any restriction. I want to enhance the system to be **secure**, such that the thermostat only functions after a proper unlock sequence has been successfully completed.\n\n---\n\n### **Modification Goals**\n\nCreate a new module, named \"security_module\" in file \"security_module.v\" that acts as a **security gatekeeper**. This module must implement a finite state machine that enforces an **unlock sequence** before enabling the thermostat. The unlock sequence consists of two steps:\n1. First, the hexadecimal value `0xAB` must be written to internal address `0`.\n2. Next, the value `0xCD` must be written to internal address `1`.\n\nOnly when both steps are performed in sequence should the system be considered **secure**. Any deviation (incorrect value or incorrect order) should cause the state machine to reset, requiring the entire sequence to be redone. The secure module is resettable and must return to the locked state upon system reset.\n\nOnce the unlock is complete, the secure module should assert a signal that enables the thermostat. Until then, the thermostat must remain inactive.\n\n---\n\n### **Top-Level Integration**\n\nCreate a new top-level module named \"thermostat_secure_top.v\" that integrates both the security module and the thermostat. Ensure correct data flow and signal connection between them.\nBelow are the IOs.\n\n```verilog \nmodule thermostat_secure_top  #(\n    parameter p_address_width = 8,                \n    parameter p_data_width = 8,                  \n    parameter p_unlock_code_0 = 8'hAB,            \n    parameter p_unlock_code_1 = 8'hCD            \n) (\n    input wire [5:0] i_temp_feedback, \n    input wire i_fan_on,             \n    input wire i_fault,              \n    input wire i_clr,               \n    input wire i_clk,                \n    input wire i_rst,                \n    input wire [p_address_width-1:0]   i_addr,             \n    input wire [p_data_width-1:0]      i_data_in,          \n    input wire                         i_read_write_enable, \n    input wire                         i_capture_pulse,    \n\n    output reg o_heater_full,\n    output reg o_heater_medium,\n    output reg o_heater_low,\n    output reg o_aircon_full,\n    output reg o_aircon_medium,\n    output reg o_aircon_low,\n    output reg o_fan,\n    output reg [2:0] o_state         \n);\n```\n\n---\n\n### **Clocks and Reset**\n\nThe secure module operates on a clock derived from a **capture pulse** signal, while the thermostat runs on its own **thermostat clock**. These clocks are asynchronous. The reset signal is shared across both modules. The top-level module must handle **clock domain crossing** between the two domains in a safe and reliable manner.\n\n---\n\n### **Expected Deliverable**\n\nA complete design containing:\n1. The **modified thermostat** that responds to a secure-enable condition.\n2. A new **security module** enforcing the unlock logic.\n3. A **top-level module** instantiating and integrating both components, managing control flow and asynchronous clocks.\n\nThe system must ensure that the thermostat never functions unless the unlock sequence is properly followed.\n", "context": {"rtl/thermostat.v": "module thermostat (\n    input wire [5:0] i_temp_feedback, // Temperature feedback bits\n    input wire i_fan_on,             // Manual fan control\n    input wire i_enable,             // Enable thermostat\n    input wire i_fault,              // Fault signal\n    input wire i_clr,                // Clear fault signal\n    input wire i_clk,                // Clock input\n    input wire i_rst,                // Asynchronous reset (active-low)\n\n    output reg o_heater_full,\n    output reg o_heater_medium,\n    output reg o_heater_low,\n    output reg o_aircon_full,\n    output reg o_aircon_medium,\n    output reg o_aircon_low,\n    output reg o_fan,\n    output reg [2:0] o_state         // FSM state output\n);\n\n// State encoding\nlocalparam [2:0] HEAT_LOW  = 3'b000,\n                 HEAT_MED  = 3'b001,\n                 HEAT_FULL = 3'b010,\n                 AMBIENT   = 3'b011,\n                 COOL_LOW  = 3'b100,\n                 COOL_MED  = 3'b101,\n                 COOL_FULL = 3'b110;\n\n// Internal signals\nreg [2:0] current_state, next_state; // FSM state registers\nreg heater_full, heater_medium, heater_low;\nreg aircon_full, aircon_medium, aircon_low;\nreg fan;\n\nassign o_state = current_state;\n// Sequential logic for state transitions and registered outputs\nalways @(posedge i_clk or negedge i_rst) begin\n    if (!i_rst) begin\n        // Asynchronous reset\n        current_state <= AMBIENT;\n        o_heater_full <= 0;\n        o_heater_medium <= 0;\n        o_heater_low <= 0;\n        o_aircon_full <= 0;\n        o_aircon_medium <= 0;\n        o_aircon_low <= 0;\n        o_fan <= 0;\n    end else begin\n        // Normal state transition\n        current_state <= next_state;\n        // Update registered outputs\n        o_heater_full <= heater_full;\n        o_heater_medium <= heater_medium;\n        o_heater_low <= heater_low;\n        o_aircon_full <= aircon_full;\n        o_aircon_medium <= aircon_medium;\n        o_aircon_low <= aircon_low;\n        o_fan <= fan || i_fan_on;\n    end\nend\n\n// Combinational logic for next state and intermediate outputs\nalways @(*) begin\n    if (!i_enable || i_fault) begin\n        // Handle fault or disable\n        next_state = AMBIENT;\n        heater_full = 0;\n        heater_medium = 0;\n        heater_low = 0;\n        aircon_full = 0;\n        aircon_medium = 0;\n        aircon_low = 0;\n        fan = 0;\n    end else begin\n        case (current_state)\n            // Heating states\n            HEAT_LOW: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 1;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            HEAT_MED: begin\n                heater_full = 0;\n                heater_medium = 1;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            HEAT_FULL: begin\n                heater_full = 1;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            // Cooling states\n            COOL_LOW: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 1;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            COOL_MED: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 1;\n                aircon_low = 0;\n                fan = 1;\n                aircon_medium = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            COOL_FULL: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 1;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            // Ambient state\n            AMBIENT: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 0;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            default: next_state = AMBIENT; // Safety fallback\n        endcase\n    end\nend\n\nendmodule"}, "patch": {"rtl/security_module.v": "", "rtl/thermostat_secure_top.v": ""}, "harness": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/thermostat.v /code/rtl/security_module.v /code/rtl/thermostat_secure_top.v\nTOPLEVEL        = thermostat_secure_top\nMODULE          = test_thermostat_secure_top\nPYTHONPATH      = /src\nHASH            = 1-code-modification", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()", "src/test_thermostat_secure_top.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nfrom cocotb.clock import Clock\n\nasync def reset_dut(dut):\n    \"\"\"Reset the DUT\"\"\"\n\n    dut.i_temp_feedback.value =0\n    dut.i_fan_on.value =0\n    dut.i_fault.value =0\n    dut.i_clr.value =0\n    dut.i_clk.value =0\n    dut.i_rst.value =0\n    dut.i_addr.value =0\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =0\n    dut.i_capture_pulse.value =0\n\n    await FallingEdge(dut.i_clk)\n    dut.i_rst.value = 1\n    await RisingEdge(dut.i_clk)\n\n\ndef assert_equal(actual, expected, msg=\"\"):\n    \"\"\"Custom assertion with message.\"\"\"\n    assert actual == expected, f\"{msg}: Expected {expected}, but got {actual}\"\n\n@cocotb.test()\nasync def test_thermostat_secure_top(dut):\n    \"\"\"Testbench for thermostat FSM Verilog module.\"\"\"\n\n    # Setup clock: 10 ns period (100 MHz)\n    clock = Clock(dut.i_clk, 10, units=\"ns\")\n    cocotb.start_soon(Clock(dut.i_capture_pulse, 20, units='ns').start())  # timeperiod= 20ns\n    cocotb.start_soon(clock.start())\n    await Timer(1, units=\"ns\")\n    # Reset the DUT\n    await reset_dut(dut)\n\n    # Check initial state after reset\n    assert_equal(dut.o_state.value, 0b011, \"FSM should initialize to AMBIENT state\")\n    assert_equal(dut.o_heater_full.value, 0, \"Heater full output should be 0 after reset\")\n    assert_equal(dut.o_aircon_full.value, 0, \"Aircon full output should be 0 after reset\")\n    assert_equal(dut.o_fan.value, 0, \"Fan output should be 0 after reset\")\n\n    # Enable the thermostat and test state transitions\n    await FallingEdge(dut.i_capture_pulse)  #stage one unlock\n    dut.i_addr.value =0\n    dut.i_data_in.value =171\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #stage two unlock\n    dut.i_addr.value =1\n    dut.i_data_in.value =205\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #unlocked\n    dut.i_addr.value =2\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n\n    # Test heating states\n    dut.i_temp_feedback.value = 0b100000  # i_full_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b010, \"FSM should transition to HEAT_FULL\")\n    assert_equal(dut.o_heater_full.value, 1, \"Heater full output should be 1 in HEAT_FULL\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b010000  # i_medium_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b001, \"FSM should transition to HEAT_MED\")\n    assert_equal(dut.o_heater_medium.value, 1, \"Heater medium output should be 1 in HEAT_MED\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b001000  # i_low_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b000, \"FSM should transition to HEAT_LOW\")\n    assert_equal(dut.o_heater_low.value, 1, \"Heater low output should be 1 in HEAT_LOW\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    # Test cooling states\n    dut.i_temp_feedback.value = 0b000001  # i_full_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b110, \"FSM should transition to COOL_FULL\")\n    assert_equal(dut.o_aircon_full.value, 1, \"Aircon full output should be 1 in COOL_FULL\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b000010  # i_medium_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b101, \"FSM should transition to COOL_MED\")\n    assert_equal(dut.o_aircon_medium.value, 1, \"Aircon medium output should be 1 in COOL_MED\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b000100  # i_low_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b100, \"FSM should transition to COOL_LOW\")\n    assert_equal(dut.o_aircon_low.value, 1, \"Aircon low output should be 1 in COOL_LOW\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    # Test ambient state\n    dut.i_temp_feedback.value = 0b000000  # No temperature feedback\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b011, \"FSM should transition to AMBIENT\")\n    assert_equal(dut.o_fan.value, 0, \"Fan output should be 0 in AMBIENT\")\n\n    # Test fault handling\n    dut.i_fault.value = 1\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b011, \"FSM should remain in AMBIENT during fault\")\n    assert_equal(dut.o_heater_full.value, 0, \"All outputs should be 0 during fault\")\n    assert_equal(dut.o_aircon_full.value, 0, \"All outputs should be 0 during fault\")\n    assert_equal(dut.o_fan.value, 0, \"All outputs should be 0 during fault\")\n\n    # Clear fault\n    dut.i_fault.value = 0\n    dut.i_clr.value = 1\n    await RisingEdge(dut.i_clk)\n    dut.i_clr.value = 0\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b011, \"FSM should transition back to AMBIENT after fault is cleared\")\n\n    ##wrong data write in address. \n    await FallingEdge(dut.i_capture_pulse)\n    dut.i_addr.value =0\n    dut.i_data_in.value =170\n    dut.i_read_write_enable.value =0\n    #locked,\n    await FallingEdge(dut.i_capture_pulse)\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    assert_equal(dut.o_state.value, 0b011, \"FSM should remain in AMBIENT when disabled\")\n    assert_equal(dut.o_heater_full.value, 0, \"All outputs should be 0 when disabled\")\n    assert_equal(dut.o_aircon_full.value, 0, \"All outputs should be 0 when disabled\")\n    assert_equal(dut.o_fan.value, 0, \"All outputs should be 0 when disabled\")\n    \n\n    await reset_dut(dut)\n\n    # Test disable functionality\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b011, \"FSM should remain in AMBIENT when disabled\")\n    assert_equal(dut.o_heater_full.value, 0, \"All outputs should be 0 when disabled\")\n    assert_equal(dut.o_aircon_full.value, 0, \"All outputs should be 0 when disabled\")\n    assert_equal(dut.o_fan.value, 0, \"All outputs should be 0 when disabled\")\n\n    dut.i_addr.value =0\n    dut.i_data_in.value =170\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #in correct stage two unlock\n    dut.i_addr.value =1\n    dut.i_data_in.value =200\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #locked,\n\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b011, \"FSM should remain in AMBIENT when disabled\")\n    assert_equal(dut.o_heater_full.value, 0, \"All outputs should be 0 when disabled\")\n    assert_equal(dut.o_aircon_full.value, 0, \"All outputs should be 0 when disabled\")\n    assert_equal(dut.o_fan.value, 0, \"All outputs should be 0 when disabled\")\n\n    # Re-enable and verify transitions again\n    # Enable the thermostat and test state transitions\n    await FallingEdge(dut.i_capture_pulse)  #stage one unlock\n    dut.i_addr.value =0\n    dut.i_data_in.value =171\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #stage two unlock\n    dut.i_addr.value =1\n    dut.i_data_in.value =205\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #unlocked\n    dut.i_addr.value =2\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n\n    \n    dut.i_temp_feedback.value = 0b100000  # i_full_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b010, \"FSM should transition to HEAT_FULL after re-enabling\")\n    assert_equal(dut.o_heater_full.value, 1, \"Heater full output should be 1 after re-enabling\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    # Test priority when multiple hot inputs are set\n    dut.i_temp_feedback.value = 0b000101  # i_full_hot and i_low_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b110, \"FSM should prioritize COOL_FULL when multiple hot inputs are set\")\n    assert_equal(dut.o_aircon_full.value, 1, \"Aircon full output should be 1 in COOL_FULL\")\n    assert_equal(dut.o_aircon_low.value, 0, \"Aircon low output should be 0 when COOL_FULL is prioritized\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b000110  # i_medium_hot and i_low_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b101, \"FSM should prioritize COOL_MED when multiple hot inputs are set\")\n    assert_equal(dut.o_aircon_medium.value, 1, \"Aircon medium output should be 1 in COOL_MED\")\n    assert_equal(dut.o_aircon_low.value, 0, \"Aircon low output should be 0 when COOL_MED is prioritized\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b000111  # i_full_hot, i_medium_hot, and i_low_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b110, \"FSM should prioritize COOL_FULL over other hot inputs\")\n    assert_equal(dut.o_aircon_full.value, 1, \"Aircon full output should be 1 in COOL_FULL\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    # Test priority when multiple cold inputs are set\n    dut.i_temp_feedback.value = 0b101000  # i_full_cold and i_low_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b010, \"FSM should prioritize HEAT_FULL when multiple cold inputs are set\")\n    assert_equal(dut.o_heater_full.value, 1, \"Heater full output should be 1 in HEAT_FULL\")\n    assert_equal(dut.o_heater_low.value, 0, \"Heater low output should be 0 when HEAT_FULL is prioritized\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b011000  # i_medium_cold and i_low_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b001, \"FSM should prioritize HEAT_MED when multiple cold inputs are set\")\n    assert_equal(dut.o_heater_medium.value, 1, \"Heater medium output should be 1 in HEAT_MED\")\n    assert_equal(dut.o_heater_low.value, 0, \"Heater low output should be 0 when HEAT_MED is prioritized\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b111000  # i_full_cold, i_medium_cold, and i_low_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b010, \"FSM should prioritize HEAT_FULL over other cold inputs\")\n    assert_equal(dut.o_heater_full.value, 1, \"Heater full output should be 1 in HEAT_FULL\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n"}}
{"id": "cvdp_agentic_amber_eagle_lambda_0001", "categories": ["cid003", "medium"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Develop a SystemVerilog-based `csr_apb_interface` that supports read and write access to internal control, data, and interrupt registers. The module must handle APB transactions using standard protocol signals (`pselx`, `penable`, `pwrite`) and expose register data through a 32-bit bus. It should also support interrupt status flag handling, write protection for specific registers, and expose the current FSM state via a debug output.\n\n## **Key Functional Requirements**\n\n### 1. APB Protocol Compliance\nThe module must support the AMBA APB protocol, managing read and write operations through the standard `pselx`, `penable`, and `pwrite` signals.  \nAll transactions must follow the three-phase handshake:  \n**IDLE \u2192 SETUP \u2192 ACCESS**\n\n### 2. Register Map and Access\nThe controller provides access to four key registers via the APB interface:\n\n- DATA_REG (0x10):\n  Holds `data1` (bits 19:10), `data2` (bits 9:0), and 12 bits of reserved data (31:20).\n\n- CONTROL_REG (0x14): \n  Includes `enable`, `mode`, and 30 bits of reserved control fields.\n\n- INTERRUPT_REG (0x18): \n  Stores interrupt enable bits: `overflow_ie`, `sign_ie`, `parity_ie`, and `zero_ie`, along with 28 reserved bits.\n\n- ISR_REG (0x1C): \n  Holds interrupt status flags (`*_is`). These flags can be cleared by writing `1` to the corresponding enable bits in the `INTERRUPT_REG`.\n\n### 3. FSM State Management\nThe design uses a finite-state machine with four states:\n\n- IDLE:  \n  Waits for `pselx` to be asserted.\n\n- SETUP:\n  Accepts and processes transaction requests, transitions to `READ_STATE` or `WRITE_STATE`.\n\n- READ_STATE: \n  Outputs register data on `prdata` based on the address. Transitions back to `IDLE`.\n\n- WRITE_STATE: \n  Writes data into registers from `pwdata`, with a protection mechanism for `ISR_REG` (writes are blocked). Transitions back to `IDLE`.\n\n### 4. Write Protection Mechanism\nThe `ISR_REG` is write-protected. Any attempt to write to it should assert `pslverr`.  \nWrites to `INTERRUPT_REG` can clear corresponding ISR bits by writing `1` to the enable flags.\n", "context": {}, "patch": {"rtl/csr_apb_interface.sv": "", "verif/csr_apb_interface_tb.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    #image: __OSS_SIM_IMAGE__\n    image: __OSS_SIM_IMAGE__\n\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/csr_apb_interface.sv\nTOPLEVEL        = csr_apb_interface\nMODULE          = test_csr_apb_interface\nPYTHONPATH      = /src\nHASH            = af0e9268ed22aadf5b472e5ec068a2d628e2c014", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_csr_apb_interface.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, ClockCycles\nimport harness_library as hrs_lb\nimport random\n\n# Constants for register addresses\nDATA_REG       = 0x10\nCONTROL_REG    = 0x14\nINTERRUPT_REG  = 0x18\nISR_REG        = 0x1C\n\n\nasync def write_register(dut, addr, data):\n    \"\"\"Function to write data to a register.\"\"\"\n    dut.pselx.value = 1\n    dut.pwrite.value = 1\n    dut.pwdata.value = data\n    dut.paddr.value = addr\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 0\n    dut.pselx.value = 0\n    await ClockCycles(dut.pclk, 2)\n\nasync def read_register(dut, addr):\n    \"\"\"Function to read data from a register.\"\"\"\n    dut.pselx.value = 1\n    dut.pwrite.value = 0\n    dut.paddr.value = addr\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 0\n    dut.pselx.value = 0\n    await ClockCycles(dut.pclk, 2)\n    return dut.prdata.value.integer\n\n@cocotb.test()\nasync def test_csr_apb_interface(dut):\n    # Start the clock with a period of 10ns\n    cocotb.start_soon(Clock(dut.pclk, 10, units='ns').start())\n\n    # Initialize the DUT signals\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset to the DUT for 25ns, reset is active low\n    await hrs_lb.reset_dut(dut.presetn, duration_ns=10, active=False)\n\n    # Test Writing and Reading from DATA_REG\n    data_to_write = random.randint(0, 0xFFFFFFFF)\n    await write_register(dut, DATA_REG, data_to_write)\n    data_read_back = await read_register(dut, DATA_REG)\n    assert data_read_back == data_to_write, \"DATA_REG read/write mismatch.\"\n    dut._log.info(f\"Writing and Reading from DATA_REG : data_read_back = {data_read_back}, data_to_write = {data_to_write}\")\n\n    # Test Writing and Reading from CONTROL_REG\n    data_to_write = random.randint(0, 0xFFFFFFFF)\n    await write_register(dut, CONTROL_REG, data_to_write)\n    data_read_back = await read_register(dut, CONTROL_REG)\n    assert data_read_back == data_to_write, \"CONTROL_REG read/write mismatch.\"\n    dut._log.info(f\"Writing and Reading from CONTROL_REG : data_read_back = {data_read_back}, data_to_write = {data_to_write}\")\n\n    # Test Writing and Reading from INTERRUPT_REG\n    data_to_write = random.randint(0, 0xFFFFFFFF)\n    await write_register(dut, INTERRUPT_REG, data_to_write)\n    data_read_back = await read_register(dut, INTERRUPT_REG)\n    assert data_read_back == data_to_write, \"INTERRUPT_REG read/write mismatch.\"\n    dut._log.info(f\"Writing and Reading from INTERRUPT_REG : data_read_back = {data_read_back}, data_to_write = {data_to_write}\")\n    # -------------------------------------\n    # Test Case 5: Write-protected ISR_REG\n    # -------------------------------------\n    dut._log.info(\"Test Case 5: Write-protected ISR_REG\")\n    isr_write_value = 0xDEADBEEF\n    dut.pselx.value = 1\n    dut.pwrite.value = 1\n    dut.pwdata.value = isr_write_value\n    dut.paddr.value = ISR_REG\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 0\n    dut.pselx.value = 0\n    await ClockCycles(dut.pclk, 2)\n\n    # Check for write protection error\n    assert dut.pslverr.value == 1, \"ISR_REG write did not cause an error as expected\"\n    dut._log.info(\"Write to ISR_REG correctly caused error (Write-Protected Register)\")\n\n    # -------------------------------------\n    # Test Case 6: Read ISR_REG\n    # -------------------------------------\n    dut._log.info(\"Test Case 6: Read ISR_REG\")\n    dut.pselx.value = 1\n    dut.pwrite.value = 0\n    dut.paddr.value = ISR_REG\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 0\n    dut.pselx.value = 0\n    await ClockCycles(dut.pclk, 2)\n\n    # Validate ISR_REG read\n    isr_read_value = dut.prdata.value.integer\n    expected_isr_value = 0  # Assuming ISR_REG initializes to 0\n    assert isr_read_value == expected_isr_value, f\"ISR_REG mismatch: read {isr_read_value}, expected {expected_isr_value}\"\n    dut._log.info(f\"ISR_REG read successful: {isr_read_value}\")\n\n    # End simulation\n    await ClockCycles(dut.pclk, 10)\n    dut._log.info(\"All test cases passed!\")", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(plusargs=[], parameter={}):\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs)\n\n\n@pytest.mark.parametrize(\"test\", range(2))\ndef test_areg_param(test):\n        runner()"}}
{"id": "cvdp_agentic_echo_obsidian_lunar_0001", "categories": ["cid003", "medium"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Design a `signed_comparator` module in SystemVerilog within a file `signed_comparator.sv` at the location: `rtl/signed_comparator.sv`. Refer to the specification provided in `docs/signed_comparator_specification.md` and ensure you understand its content. The specification details the functionality of a configurable signed comparator with the following parameters:\n\n- **DATA_WIDTH**: Configurable bit width of the input values.\n- **REGISTER_OUTPUT**: Enables or disables registered output.\n- **ENABLE_TOLERANCE**: Allows approximate equality comparison by considering a tolerance range.\n- **TOLERANCE**: Defines the maximum absolute difference for approximate equality when `ENABLE_TOLERANCE` is enabled.\n- **SHIFT_LEFT**: Left-shift amount applied to both input values before comparison.\n\nThe module takes two signed input values, `a` and `b`, and compares them to determine greater-than (`gt`), less-than (`lt`), and equal (`eq`) conditions. If `ENABLE_TOLERANCE` is enabled, values within the specified `TOLERANCE` range are treated as equal. Additionally, an optional `bypass` mode forces the equality output (`eq = 1`) regardless of the input values.\n\n### Functional Behavior\n\n1. **Input Preprocessing:**  \n   - Both inputs `a` and `b` are left-shifted by `SHIFT_LEFT` bits before comparison.\n   - A signed subtraction computes the difference `diff = a_shifted - b_shifted`.\n\n2. **Equality with Tolerance:**  \n   - If `ENABLE_TOLERANCE` is enabled, the absolute difference `abs_diff` is compared to `TOLERANCE`.\n   - If `abs_diff <= TOLERANCE`, `eq` is asserted (`eq = 1`).\n\n3. **Comparison Logic:**  \n   - If `bypass` is active, `eq` is forced to `1`, and `gt` and `lt` are set to `0`.\n   - If `enable` is asserted:\n     - If `eq_tolerance` is met, `eq = 1`, `gt = 0`, `lt = 0`.\n     - Otherwise, normal signed comparison is performed to set `gt`, `lt`, and `eq` accordingly.\n\n4. **Registering Output (Optional):**  \n   - If `REGISTER_OUTPUT` is enabled, the comparison results (`gt`, `lt`, `eq`) are updated synchronously on the clock edge.\n   - If `REGISTER_OUTPUT` is disabled, the outputs are updated combinationally.\n\nGenerate the complete RTL code for the `signed_comparator`, ensuring optimized performance and compliance with the given specification.\n", "context": {"docs/signed_comparator_specification.md": "# Signed Comparator Specification Document\n\n## Introduction\n\nThe **Signed Comparator** is a configurable hardware module designed to perform signed comparisons between two input values. It determines whether one value is greater than, less than, or equal to another while supporting optional tolerance-based equality checks and left-shifting of inputs before comparison. The module also provides an optional output register for synchronous operation.\n\n---\n\n## Functional Overview\n\nThe Signed Comparator operates based on the following key conditions:\n\n1. **Input Preprocessing:**  \n   - Both inputs `a` and `b` are left-shifted by `SHIFT_LEFT` bits before comparison.\n   - The shifted values are used for all further computations.\n\n2. **Equality with Tolerance:**  \n   - If `ENABLE_TOLERANCE` is set, the module calculates the absolute difference between `a_shifted` and `b_shifted`.\n   - If the absolute difference is less than or equal to `TOLERANCE`, the module treats the inputs as equal (`eq = 1`).\n\n3. **Comparison Logic:**  \n   - If `bypass` is active, the module forces `eq = 1` while `gt` and `lt` are set to `0`.\n   - If `enable` is high:\n     - If tolerance-based equality is met, `eq = 1`, `gt = 0`, `lt = 0`.\n     - Otherwise, standard signed comparison is performed, setting `gt`, `lt`, and `eq` accordingly.\n\n4. **Registering Output (Optional):**  \n   - If `REGISTER_OUTPUT` is enabled, the comparison results (`gt`, `lt`, `eq`) are updated synchronously with `clk` and `rst_n`.\n   - If `REGISTER_OUTPUT` is disabled, the outputs are updated combinationally.\n\n---\n\n## Module Interface\n\nThe signed comparator module should be defined as follows:\n\n```verilog\nmodule signed_comparator #(\n  parameter integer DATA_WIDTH = 16,\n  parameter integer REGISTER_OUTPUT = 0,\n  parameter integer ENABLE_TOLERANCE = 0,\n  parameter integer TOLERANCE = 0,\n  parameter integer SHIFT_LEFT = 0\n)(\n  input  wire clk,\n  input  wire rst_n,\n  input  wire enable,\n  input  wire bypass,\n  input  wire signed [DATA_WIDTH-1:0] a,\n  input  wire signed [DATA_WIDTH-1:0] b,\n  output reg gt,\n  output reg lt,\n  output reg eq\n);\n```\n\n### Port Description\n\n- **clk:** Clock signal.\n- **rst_n:** Active-low asynchronous reset.\n- **enable:** Enables the comparator operation.\n- **bypass:** Forces `eq = 1`, ignoring input values.\n- **a:** First signed input value.\n- **b:** Second signed input value.\n- **gt:** High if `a > b` after processing.\n- **lt:** High if `a < b` after processing.\n- **eq:** High if `a == b` (considering optional tolerance).\n\n---\n\n## Internal Architecture\n\nThe internal architecture consists of the following key components:\n\n1. **Shift Logic:**  \n   - Both inputs `a` and `b` are left-shifted by `SHIFT_LEFT` bits before comparison.\n\n2. **Tolerance-Based Equality Check:**  \n   - If `ENABLE_TOLERANCE` is set, the module computes `abs_diff = |a_shifted - b_shifted|`.\n   - If `abs_diff <= TOLERANCE`, the values are considered equal.\n\n3. **Comparison Logic:**  \n   - If bypass is active, the module outputs `eq = 1`, `gt = 0`, and `lt = 0`.\n   - Otherwise, it compares `a_shifted` and `b_shifted`:\n     - If `a_shifted > b_shifted`, `gt = 1`, `lt = 0`, `eq = 0`.\n     - If `a_shifted < b_shifted`, `gt = 0`, `lt = 1`, `eq = 0`.\n     - If they are equal, `eq = 1`, `gt = 0`, `lt = 0`.\n\n4. **Registering Output (if enabled):**  \n   - If `REGISTER_OUTPUT` is enabled, outputs (`gt`, `lt`, `eq`) are updated on the rising clock edge.\n   - If disabled, outputs are updated immediately in combinational logic.\n\n---\n\n## Timing and Latency\n\n- When `REGISTER_OUTPUT` is disabled, outputs are computed combinationally with zero-cycle latency.\n- If `REGISTER_OUTPUT` is enabled, the comparison results are available one clock cycle after the input values are presented.\n\n---\n\n## Configuration Options\n\n- **DATA_WIDTH**: Configurable bit width of input values.\n- **REGISTER_OUTPUT**: Enables or disables registered output.\n- **ENABLE_TOLERANCE**: Allows approximate equality comparison.\n- **TOLERANCE**: Defines the tolerance range for equality.\n- **SHIFT_LEFT**: Left-shift amount applied before comparison.\n\nThis design ensures a flexible and configurable signed comparator suitable for various digital logic applications.", "verif/signed_comparator_tb.sv": "`timescale 1ns/1ps\n\nmodule tb_signed_comparator;\n\nreg clk;\nreg rst_n;\nreg enable;\nreg bypass;\nreg signed [15:0] a;\nreg signed [15:0] b;\nwire gt, lt, eq;\n\nlocalparam DATA_WIDTH       = 16;\nlocalparam REGISTER_OUTPUT  = 1;\nlocalparam ENABLE_TOLERANCE = 1;\nlocalparam TOLERANCE        = 2;\nlocalparam SHIFT_LEFT       = 1;\n\nsigned_comparator #(\n  .DATA_WIDTH(DATA_WIDTH),\n  .REGISTER_OUTPUT(REGISTER_OUTPUT),\n  .ENABLE_TOLERANCE(ENABLE_TOLERANCE),\n  .TOLERANCE(TOLERANCE),\n  .SHIFT_LEFT(SHIFT_LEFT)\n) dut (\n  .clk(clk),\n  .rst_n(rst_n),\n  .enable(enable),\n  .bypass(bypass),\n  .a(a),\n  .b(b),\n  .gt(gt),\n  .lt(lt),\n  .eq(eq)\n);\n\nalways #5 clk = ~clk;\n\ninitial begin\n  clk = 0;\n  rst_n = 0;\n  enable = 0;\n  bypass = 0;\n  a = 0;\n  b = 0;\n  repeat(2) @(posedge clk);\n  rst_n = 1;\n  repeat(2) @(posedge clk);\n\n  test_case( 100,  100, 0, 1);\n  test_case(  10,  -10, 0, 1);\n  test_case(  -5,    5, 0, 1);\n  test_case(  50,   52, 0, 1);  // near difference -> tolerance\n  test_case(  51,   52, 0, 1);  // difference 1 -> eq due to TOLERANCE=2\n  test_case(  53,   50, 0, 1);  // difference 3 -> not within tolerance\n  test_case( 123, -123, 1, 1);  // bypass => eq=1\n  test_case( 500, -500, 0, 0);  // enable=0 => eq=0,gt=0,lt=0\n  repeat(2) @(posedge clk);\n\n  integer i;\n  for (i = 0; i < 5; i = i + 1) begin\n    test_case($random, $random, $random%2, $random%2);\n  end\n\n  $finish;\nend\n\ntask test_case;\n  input signed [15:0] a_val;\n  input signed [15:0] b_val;\n  input bypass_val;\n  input enable_val;\nbegin\n  a = a_val;\n  b = b_val;\n  bypass = bypass_val;\n  enable = enable_val;\n  @(posedge clk);\n  @(posedge clk);\n\n  check_output(a_val, b_val, bypass_val, enable_val);\nend\nendtask\n\ntask check_output;\n  input signed [15:0] a_val;\n  input signed [15:0] b_val;\n  input bypass_val;\n  input enable_val;\n  reg signed [DATA_WIDTH-1:0] a_shift, b_shift;\n  reg signed [DATA_WIDTH:0] diff_abs;\n  reg exp_gt, exp_lt, exp_eq;\nbegin\n  a_shift = a_val <<< SHIFT_LEFT;\n  b_shift = b_val <<< SHIFT_LEFT;\n  diff_abs = (a_shift - b_shift);\n  if (diff_abs < 0) diff_abs = -diff_abs;\n\n  if (bypass_val) begin\n    exp_gt = 0; exp_lt = 0; exp_eq = 1;\n  end else if (!enable_val) begin\n    exp_gt = 0; exp_lt = 0; exp_eq = 0;\n  end else begin\n    if (ENABLE_TOLERANCE && (diff_abs <= TOLERANCE)) begin\n      exp_gt = 0; exp_lt = 0; exp_eq = 1;\n    end else if (a_shift > b_shift) begin\n      exp_gt = 1; exp_lt = 0; exp_eq = 0;\n    end else if (a_shift < b_shift) begin\n      exp_gt = 0; exp_lt = 1; exp_eq = 0;\n    end else begin\n      exp_gt = 0; exp_lt = 0; exp_eq = 1;\n    end\n  end\n\n  if (gt !== exp_gt || lt !== exp_lt || eq !== exp_eq) begin\n    $display(\"Time=%0t FAIL: a=%d b=%d bypass=%b en=%b SHIFT_LEFT=%0d TOL=%0d => gt=%b lt=%b eq=%b (exp: %b %b %b)\",\n      $time, a_val, b_val, bypass_val, enable_val, SHIFT_LEFT, TOLERANCE,\n      gt, lt, eq, exp_gt, exp_lt, exp_eq);\n  end else begin\n    $display(\"Time=%0t PASS: a=%d b=%d bypass=%b en=%b SHIFT_LEFT=%0d TOL=%0d => gt=%b lt=%b eq=%b\",\n      $time, a_val, b_val, bypass_val, enable_val, SHIFT_LEFT, TOLERANCE, gt, lt, eq);\n  end\nend\nendtask\n\nendmodule"}, "patch": {"rtl/signed_comparator.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\nRUN pip install cocotb-bus", "docker-compose.yml": "services:\n\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/signed_comparator.sv\nTOPLEVEL        = signed_comparator\nMODULE          = test_signed_comparator\nPYTHONPATH      = /src\nHASH            = 1-rtl-design-for-16-bit-signed-comparator", "src/test_runner.py": "import os\nfrom cocotb.runner import get_runner\n\ndef test_runner():\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    dw_str          = os.getenv(\"DATA_WIDTH\", \"16\")\n    ro_str          = os.getenv(\"REGISTER_OUTPUT\", \"0\")\n    et_str          = os.getenv(\"ENABLE_TOLERANCE\", \"0\")\n    tol_str         = os.getenv(\"TOLERANCE\", \"0\")\n    sh_str          = os.getenv(\"SHIFT_LEFT\", \"0\")\n\n    params = {\n        \"DATA_WIDTH\":       int(dw_str),\n        \"REGISTER_OUTPUT\":  int(ro_str),\n        \"ENABLE_TOLERANCE\": int(et_str),\n        \"TOLERANCE\":        int(tol_str),\n        \"SHIFT_LEFT\":       int(sh_str)\n    }\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=params,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\nif __name__ == \"__main__\":\n    test_runner()\n", "src/test_signed_comparator.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_basic(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, \"ns\").start())\n    dut.rst_n.value = 0\n    dut.enable.value = 0\n    dut.bypass.value = 0\n    dut.a.value = 0\n    dut.b.value = 0\n    await RisingEdge(dut.clk)\n    dut.rst_n.value = 1\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    dut.enable.value = 1\n    dut.a.value = 10\n    dut.b.value = -10\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    assert dut.gt.value == 1, f\"Expected gt=1 for a=10, b=-10\"\n\n    dut.a.value = -20\n    dut.b.value = -20\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    assert dut.eq.value == 1, f\"Expected eq=1 for a=-20, b=-20\"\n\n    dut.a.value = -30\n    dut.b.value = 1\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    assert dut.lt.value == 1, f\"Expected lt=1 for a=-30, b=1\"\n\n@cocotb.test()\nasync def test_random(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, \"ns\").start())\n    dut.rst_n.value = 0\n    dut.enable.value = 0\n    dut.bypass.value = 0\n    dut.a.value = 0\n    dut.b.value = 0\n    await RisingEdge(dut.clk)\n    dut.rst_n.value = 1\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    for _ in range(10):\n        a_val = random.randint(-32768, 32767)\n        b_val = random.randint(-32768, 32767)\n        dut.a.value = a_val & 0xFFFF\n        dut.b.value = b_val & 0xFFFF\n        dut.bypass.value = random.getrandbits(1)\n        dut.enable.value = random.getrandbits(1)\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def test_edge_cases(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, \"ns\").start())\n    dut.rst_n.value = 0\n    dut.enable.value = 0\n    dut.bypass.value = 0\n    dut.a.value = 0\n    dut.b.value = 0\n    await RisingEdge(dut.clk)\n    dut.rst_n.value = 1\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    pairs = [\n        (-32768, 32767),\n        (32767, -32768),\n        (32767, 32767),\n        (-32768, -32768),\n        (0, 0),\n    ]\n    for (val_a, val_b) in pairs:\n        dut.a.value = val_a & 0xFFFF\n        dut.b.value = val_b & 0xFFFF\n        dut.enable.value = 1\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n"}}
{"id": "cvdp_agentic_compass_breeze_obsidian_0016", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a **sorting_engine** module that sorts the input data in ascending order.\n\nThe **sorting_engine** module is available at `/rtl/sorting_engine.sv` and its' specification in the `/docs` directory.\nCan you implement the **`order_matching_engine.sv`** in the `/rtl` folder? Details of the `order_matching_engine` module is as given below\n\n**Description - Order Matching Engine**\n\nThe goal is to build a module that efficiently processes and matches buy (bid) and sell (ask) orders. Here\u2019s what the design must accomplish:\n\n- **Input Handling:**  \n  The engine accepts two flat input vectors\u2014one for bid orders and one for ask orders. Each vector contains 8 orders (prices) of configurable bit-width (`PRICE_WIDTH`).\n\n- **Sorting:**  \n  Use the provided sorting engine to sort each set of orders:\n  - Bid orders are sorted in ascending order (so the highest bid is at the last position).\n  - Ask orders are sorted in ascending order (so the lowest ask is at the first position).\n\n- **Order Matching:**  \n  After sorting, extract the best bid (highest bid) and best ask (lowest ask). If the best bid is greater than or equal to the best ask, a match occurs. The matching price is taken as the best ask.\n\n- **Latency Requirement:**  \n  The design must contain logic to measure and ensure that the total processing latency, from the issuance of a start signal to the output being valid, is exactly 21 clock cycles.\n\n- **Port List:**\n```verilog\n   module order_matching_engine #(\n    parameter PRICE_WIDTH = 16  // width of the price field\n)(\n    input                      clk,\n    input                      rst,\n    input                      start,         // start matching operation\n    input  [8*PRICE_WIDTH-1:0] bid_orders,    // 8 bid orders (flat vector)\n    input  [8*PRICE_WIDTH-1:0] ask_orders,    // 8 ask orders (flat vector)\n    output reg                 match_valid,   // high if a match occurs\n    output reg [PRICE_WIDTH-1:0] matched_price, // matched price (best ask)\n    output reg                 done,          // matching engine done\n    output reg                 latency_error  // asserted if latency \u2260 20 cycles\n);\n```\n", "context": {"docs/specification.md": "# Sorting Engine Specification Document\n\n## Introduction\n\nThe **Sorting Engine** should implement an **8-element parallel merge sort** algorithm. This module is designed to sort 8 inputs of configurable bit-width (parameterized by `WIDTH`) in ascending order (lowest value at LSB and highest at MSB). The design must leverage the parallelism inherent in the merge sort algorithm by dividing the sort process into multiple stages. Each stage performs compare\u2013swap and merging operations in a pipelined finite state machine (FSM) manner.\n\n---\n\n## Algorithm Overview\n\n**Merge Sort** is a well-known divide-and-conquer sorting algorithm. The basic idea is to divide the unsorted list into smaller sub-lists, sort each sub-list, and then merge them to produce a sorted list. The parallel merge sort algorithm to be implemented in this module works as follows:\n\n1. **Pair Sorting:**  \n   The input array is divided into 4 pairs. Each pair is independently sorted using a compare\u2013swap operation. This is the step where parallel operation happens for all pairs.\n\n2. **Merge Sorted Pairs:**  \n   Two consecutive sorted pairs are merged sequentially into a 4-element sorted group. This is done for both halves of the array, the first 4 pairs of elements and the last 4 elements.\n\n3. **Final Merge:**  \n   The two 4-element groups are merged to produce the final sorted 8-element array.\n\n### Example\n\nConsider the input array (from lowest index to highest):\n\n```\n[8, 7, 6, 5, 4, 3, 2, 1]\n```\n\n**Stage 1 \u2013 Pair Sorting:**  \n- Pairs are sorted:  \n  - Compare 8 and 7 \u2192 [7, 8]  \n  - Compare 6 and 5 \u2192 [5, 6]  \n  - Compare 4 and 3 \u2192 [3, 4]  \n  - Compare 2 and 1 \u2192 [1, 2]\n\n**Stage 2 \u2013 Merge Sorted Pairs:**  \n- Merge the first two pairs: [7, 8] and [5, 6] \u2192 [5, 6, 7, 8]  \n- Merge the next two pairs: [3, 4] and [1, 2] \u2192 [1, 2, 3, 4]\n\n**Stage 3 \u2013 Final Merge:**  \n- Merge the two 4-element groups: [5, 6, 7, 8] and [1, 2, 3, 4] \u2192 [1, 2, 3, 4, 5, 6, 7, 8]\n\nThe final output is the sorted list in ascending order.\n\n---\n\n## Module Interface\n\nThe module should be defined as follows:\n\n```verilog\nmodule sorting_engine #(parameter WIDTH = 8)(\n    input                     clk,\n    input                     rst,\n    input                     start,  \n    input  [8*WIDTH-1:0]      in_data,\n    output reg                done,   \n    output reg [8*WIDTH-1:0]  out_data\n);\n```\n\n### Port Description\n\n- **clk:** Clock signal.\n- **rst:** Active-high asynchronous reset to set the outputs to 0.\n- **start:** Active-high signal to initiate the sort operation. High for 1 clock cycle.\n- **in_data:** Flat input bus representing 8 data elements, each `WIDTH` bits wide.\n- **done:** Active-high signal indicating the completion of the sort operation. High for 1 clock cycle after sorting completes.\n- **out_data:** Flat output bus containing the sorted data. Updated along with done signal and remains stable until data from next sorting operation is updated.\n\n---\n\n## Internal Architecture\n\nThe internal architecture must be organized into several stages controlled by an FSM:\n\n1. **Data Loading:**  \n   The flat `in_data` vector should be unpacked into an internal array.\n\n2. **Stage 1 \u2013 Pair Compare\u2013Swap:**  \n   Four pairs of data must be compared and swapped in parallel if necessary. The sorted pairs should be stored for subsequent merging.\n\n3. **Stage 2 \u2013 Merging Sorted Pairs:**  \n   Two merge operations to be performed sequentially:\n   - The first merge combines pairs `[0,1]` with `[2,3]` into a sorted 4-element group.\n   - The second merge combines pairs `[4,5]` with `[6,7]` into another sorted 4-element group.\n\n4. **Stage 3 \u2013 Final Merge:**  \n   The two 4-element groups should be merged to produce the final sorted array.\n\nThe design should utilize sequential merging with pointer and counter logic, allowing the design to be pipelined and easily scalable for production.\n\n---\n\n## Timing and Latency\n\nThe design should be fully synchronous with a pipelined FSM. The expected latency from asserting the start signal to asserting the done signal is **20 clock cycles**. This includes:\n- A few cycles for data loading.\n- Cycles dedicated to the pair sorting and merging stages.\n- Final packaging of the sorted output into the flat bus.", "rtl/sorting_engine.sv": "module sorting_engine #(parameter WIDTH = 8)(\n    input                     clk,\n    input                     rst,\n    input                     start,      // Start the sort when start=1\n    input  [8*WIDTH-1:0]      in_data,    // 8 inputs, each WIDTH bits\n    output reg                done,\n    output reg [8*WIDTH-1:0]  out_data    // 8 outputs, sorted ascending\n);\n\n  // FSM state encoding\n  localparam IDLE      = 3'd0,\n             LOAD      = 3'd1,\n             SORT_PAIRS= 3'd2,\n             MERGE_2_1 = 3'd3,  // Merge first two sorted pairs into a 4-element group\n             MERGE_2_2 = 3'd4,  // Merge second two sorted pairs into a 4-element group\n             MERGE_4   = 3'd5,  // Merge the two 4-element groups into final 8-element sorted list\n             DONE      = 3'd6;\n\n  reg [2:0] state;\n\n  // Internal storage for data at different stages.\n  reg [WIDTH-1:0] stage0 [7:0];           // Loaded input data\n  reg [WIDTH-1:0] sorted_pairs [7:0];     // After pair compare\u2013swap\n  reg [WIDTH-1:0] merge4_right [3:0];      // First 4\u2013element sorted group (from indices 0\u20133)\n  reg [WIDTH-1:0] merge4_left [3:0];     // Second 4\u2013element sorted group (from indices 4\u20137)\n  reg [WIDTH-1:0] final_sorted [7:0];     // Final 8\u2013element sorted result\n\n  // Merge pointers and counter used for sequential merging\n  reg [3:0] merge_count;  // Counts how many outputs have been merged in current merge stage\n  reg [2:0] ptr1, ptr2;   // Pointers for the two arrays being merged\n\n  integer i; // loop variable for for\u2013loops\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      state      <= IDLE;\n      done       <= 0;\n      out_data   <= 0;\n      merge_count<= 0;\n      ptr1       <= 0;\n      ptr2       <= 0;\n    end else begin\n      case (state)\n        // Wait for the start signal.\n        IDLE: begin\n          done <= 0;\n          if (start)\n            state <= LOAD;\n        end\n\n        // Capture the 8 input elements from the flat bus into an array.\n        LOAD: begin\n          for (i = 0; i < 8; i = i + 1) begin\n            stage0[i] <= in_data[i*WIDTH +: WIDTH];\n          end\n          state <= SORT_PAIRS;\n        end\n\n        // Stage 1: Compare-swap each adjacent pair.\n        // The 8 numbers are divided into 4 pairs: indices {0,1}, {2,3}, {4,5}, {6,7}.\n        SORT_PAIRS: begin\n          // Pair 0\n          if (stage0[0] <= stage0[1]) begin\n            sorted_pairs[0] <= stage0[0];\n            sorted_pairs[1] <= stage0[1];\n          end else begin\n            sorted_pairs[0] <= stage0[1];\n            sorted_pairs[1] <= stage0[0];\n          end\n          // Pair 1\n          if (stage0[2] <= stage0[3]) begin\n            sorted_pairs[2] <= stage0[2];\n            sorted_pairs[3] <= stage0[3];\n          end else begin\n            sorted_pairs[2] <= stage0[3];\n            sorted_pairs[3] <= stage0[2];\n          end\n          // Pair 2\n          if (stage0[4] <= stage0[5]) begin\n            sorted_pairs[4] <= stage0[4];\n            sorted_pairs[5] <= stage0[5];\n          end else begin\n            sorted_pairs[4] <= stage0[5];\n            sorted_pairs[5] <= stage0[4];\n          end\n          // Pair 3\n          if (stage0[6] <= stage0[7]) begin\n            sorted_pairs[6] <= stage0[6];\n            sorted_pairs[7] <= stage0[7];\n          end else begin\n            sorted_pairs[6] <= stage0[7];\n            sorted_pairs[7] <= stage0[6];\n          end\n          // Initialize pointers for first merge stage (MERGE_2_1)\n          ptr1        <= 0;\n          ptr2        <= 0;\n          merge_count <= 0;\n          state       <= MERGE_2_1;\n        end\n\n        // Stage 2a: Merge the first two sorted pairs (indices 0\u20131 and 2\u20133)\n        MERGE_2_1: begin\n          // Use ptr1 for sorted_pairs[0:1] and ptr2 for sorted_pairs[2:3].\n          if ((ptr1 < 2) && (ptr2 < 2)) begin\n            if (sorted_pairs[ptr1] <= sorted_pairs[ptr2+2]) begin\n              merge4_right[merge_count] <= sorted_pairs[ptr1];\n              ptr1 <= ptr1 + 1;\n            end else begin\n              merge4_right[merge_count] <= sorted_pairs[ptr2+2];\n              ptr2 <= ptr2 + 1;\n            end\n          end else if (ptr1 < 2) begin\n            merge4_right[merge_count] <= sorted_pairs[ptr1];\n            ptr1 <= ptr1 + 1;\n          end else if (ptr2 < 2) begin\n            merge4_right[merge_count] <= sorted_pairs[ptr2+2];\n            ptr2 <= ptr2 + 1;\n          end\n          // Check if 4 elements have been merged.\n          if (merge_count == 3) begin\n            merge_count <= 0;\n            ptr1        <= 0;\n            ptr2        <= 0;\n            state       <= MERGE_2_2;\n          end else begin\n            merge_count <= merge_count + 1;\n          end\n        end\n\n        // Stage 2b: Merge the second two sorted pairs (indices 4\u20135 and 6\u20137)\n        MERGE_2_2: begin\n          // Use ptr1 for sorted_pairs[4:5] and ptr2 for sorted_pairs[6:7].\n          if ((ptr1 < 2) && (ptr2 < 2)) begin\n            if (sorted_pairs[ptr1+4] <= sorted_pairs[ptr2+6]) begin\n              merge4_left[merge_count] <= sorted_pairs[ptr1+4];\n              ptr1 <= ptr1 + 1;\n            end else begin\n              merge4_left[merge_count] <= sorted_pairs[ptr2+6];\n              ptr2 <= ptr2 + 1;\n            end\n          end else if (ptr1 < 2) begin\n            merge4_left[merge_count] <= sorted_pairs[ptr1+4];\n            ptr1 <= ptr1 + 1;\n          end else if (ptr2 < 2) begin\n            merge4_left[merge_count] <= sorted_pairs[ptr2+6];\n            ptr2 <= ptr2 + 1;\n          end\n          // Check if merge of 4 elements is complete.\n          if (merge_count == 3) begin\n            merge_count <= 0;\n            ptr1        <= 0;\n            ptr2        <= 0;\n            state       <= MERGE_4;\n          end else begin\n            merge_count <= merge_count + 1;\n          end\n        end\n\n        // Stage 3: Merge the two 4\u2013element groups (merge4_right and merge4_left)\n        MERGE_4: begin\n          if ((ptr1 < 4) && (ptr2 < 4)) begin\n            if (merge4_right[ptr1] <= merge4_left[ptr2]) begin\n              final_sorted[merge_count] <= merge4_right[ptr1];\n              ptr1 <= ptr1 + 1;\n            end else begin\n              final_sorted[merge_count] <= merge4_left[ptr2];\n              ptr2 <= ptr2 + 1;\n            end\n          end else if (ptr1 < 4) begin\n            final_sorted[merge_count] <= merge4_right[ptr1];\n            ptr1 <= ptr1 + 1;\n          end else if (ptr2 < 4) begin\n            final_sorted[merge_count] <= merge4_left[ptr2];\n            ptr2 <= ptr2 + 1;\n          end\n          // Check if all 8 elements have been merged.\n          if (merge_count == 7) begin\n            merge_count <= 0;\n            state       <= DONE;\n          end else begin\n            merge_count <= merge_count + 1;\n          end\n        end\n\n        // Final state: pack the final_sorted array back into out_data and assert done.\n        DONE: begin\n          for (i = 0; i < 8; i = i + 1) begin\n            out_data[i*WIDTH +: WIDTH] <= final_sorted[i];\n          end\n          done  <= 1;\n          // Optionally, return to IDLE (or hold in DONE) so a new sort can begin.\n          state <= IDLE;\n        end\n\n        default: state <= IDLE;\n      endcase\n    end\n  end\n    \nendmodule"}, "patch": {"rtl/order_matching_engine.sv": ""}, "harness": {"docker-compose.yml": "services:\n  \n direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command: pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/order_matching_engine.sv /code/rtl/sorting_engine.sv\nTOPLEVEL        = order_matching_engine\nMODULE          = test_order_matching_engine\nPYTHONPATH      = /src\nHASH            = 16-parallel-sorter-component-integration-2\n", "src/test_order_matching_engine.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\ndef pack_vector(orders, width):\n    \"\"\"\n    Pack a list of integers (orders[0] ... orders[7]) into a flat integer.\n    The flat vector is constructed as {orders[7], orders[6], ..., orders[0]}\n    so that orders[0] occupies the least-significant bits.\n    \"\"\"\n    value = 0\n    for order in orders[::-1]:\n        value = (value << width) | (order & ((1 << width) - 1))\n    return value\n\ndef scale_orders(orders, max_val):\n    \"\"\"\n    Scale a list of order percentages (0-100) into the range [0, max_val].\n    \"\"\"\n    return [int(val * max_val / 100) for val in orders]\n\n@cocotb.test()\nasync def test_order_matching_engine(dut):\n    \"\"\"\n    Cocotb testbench for order_matching_engine.\n    This test applies several corner-case and random test vectors,\n    verifies that the matching result (match_valid and matched_price)\n    is correct, and checks that the overall latency from start to done is exactly 20 cycles.\n    \"\"\"\n    # Create and start clock (10 ns period)\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Retrieve PRICE_WIDTH parameter from DUT (default to 16)\n    try:\n        price_width = int(dut.PRICE_WIDTH.value)\n    except Exception as e:\n        dut._log.warning(\"Unable to read PRICE_WIDTH parameter, defaulting to 16. Error: %s\", e)\n        price_width = 16\n\n    max_val = (1 << price_width) - 1\n    NUM_ELEMS = 8\n\n    # Helper: Measure latency from start pulse to when done is asserted.\n    async def measure_latency():\n        cycle_count = 0\n        while int(dut.done.value) == 0:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n        return cycle_count\n\n    # Define test cases.\n    tests = []\n\n    # Test 1: Matching scenario (bid >= ask)\n    # Original percentages for bid: [40, 80, 20, 70, 60, 30, 10, 50]\n    # and ask: [35, 15, 45, 55, 25, 65, 75, 78].\n    tests.append({\n        \"description\": \"Matching scenario: valid match\",\n        \"bid\": scale_orders([40, 80, 20, 70, 60, 30, 10, 50], max_val),\n        \"ask\": scale_orders([35, 15, 45, 55, 25, 65, 75, 78], max_val),\n        \"expected_match\": True,\n        \"expected_price\": int(15 * max_val / 100)  # 15% of max_val\n    })\n\n    # Test 2: No match scenario (bid < ask)\n    tests.append({\n        \"description\": \"No match scenario: no match\",\n        \"bid\": scale_orders([10, 20, 30, 40, 50, 60, 70, 75], max_val),\n        \"ask\": scale_orders([80, 90, 95, 85, 88, 82, 91, 87], max_val),\n        \"expected_match\": False,\n        \"expected_price\": 0\n    })\n\n    # Test 3: Extreme values at boundaries.\n    tests.append({\n        \"description\": \"Extreme values: match at boundary\",\n        \"bid\": [0, 0, 0, 0, 0, 0, 0, max_val],\n        \"ask\": [max_val] * NUM_ELEMS,\n        \"expected_match\": True,\n        \"expected_price\": max_val\n    })\n\n    # Test 4: Random stress tests (10 iterations)\n    for t in range(10):\n        bid_rand = [random.randint(0, max_val) for _ in range(NUM_ELEMS)]\n        ask_rand = [random.randint(0, max_val) for _ in range(NUM_ELEMS)]\n        best_bid = max(bid_rand)\n        best_ask = min(ask_rand)\n        expected_match = best_bid >= best_ask\n        expected_price = best_ask if expected_match else 0\n        tests.append({\n            \"description\": f\"Random stress test iteration {t+1}\",\n            \"bid\": bid_rand,\n            \"ask\": ask_rand,\n            \"expected_match\": expected_match,\n            \"expected_price\": expected_price\n        })\n\n    # Iterate through each test case.\n    for test in tests:\n        dut._log.info(\"---------------------------------------------------\")\n        dut._log.info(\"Starting test: %s\", test[\"description\"])\n\n        # Pack bid and ask orders.\n        bid_flat = pack_vector(test[\"bid\"], price_width)\n        ask_flat = pack_vector(test[\"ask\"], price_width)\n\n        # Drive the inputs.\n        dut.bid_orders.value = bid_flat\n        dut.ask_orders.value = ask_flat\n\n        # Apply a reset before starting the test.\n        dut.rst.value = 1\n        await RisingEdge(dut.clk)\n        dut.rst.value = 0\n        await RisingEdge(dut.clk)\n\n        # Issue the start pulse.\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Measure latency.\n        latency = await measure_latency()\n        dut._log.info(\"Test '%s': Measured latency = %d cycles\", test[\"description\"], latency)\n        assert latency == 21, f\"Latency error in test '{test['description']}': expected 20 cycles, got {latency}\"\n\n        # Check DUT's latency_error signal.\n        assert int(dut.latency_error.value) == 0, f\"Latency error flag is asserted in test '{test['description']}'\"\n\n        # Retrieve matching outputs.\n        match_valid = int(dut.match_valid.value)\n        matched_price = int(dut.matched_price.value)\n\n        # Compute expected matching result.\n        expected_best_bid = max(test[\"bid\"])\n        expected_best_ask = min(test[\"ask\"])\n        if expected_best_bid >= expected_best_ask:\n            exp_match_valid = 1\n            exp_matched_price = expected_best_ask\n        else:\n            exp_match_valid = 0\n            exp_matched_price = 0\n\n        # Alternatively, use the test case provided expected values.\n        exp_match_valid = 1 if test[\"expected_match\"] else 0\n        exp_matched_price = test[\"expected_price\"]\n\n        # Check matching result.\n        assert match_valid == exp_match_valid, f\"Test '{test['description']}' failed: Expected match_valid {exp_match_valid}, got {match_valid}\"\n        if match_valid:\n            assert matched_price == exp_matched_price, f\"Test '{test['description']}' failed: Expected matched_price {exp_matched_price}, got {matched_price}\"\n\n        dut._log.info(\"Test '%s' PASSED: Best bid = %d, Best ask = %d, Matched price = %d\", \n                      test[\"description\"], expected_best_bid, expected_best_ask, matched_price)\n\n        # Wait a few cycles before the next test.\n        await Timer(20, units=\"ns\")\n\n    dut._log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner(PRICE_WIDTH: int=4):\n    \n    parameter = {\"PRICE_WIDTH\":PRICE_WIDTH}\n    # Debug information\n    print(f\"[DEBUG] Running simulation with PRICE_WIDTH={PRICE_WIDTH}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Parametrize test for different PRICE_WIDTH\n@pytest.mark.parametrize(\"PRICE_WIDTH\", [4,5,8,12])\n\ndef test_sort(PRICE_WIDTH):\n    # Run the simulation with specified parameters\n    test_runner(PRICE_WIDTH=PRICE_WIDTH)\n"}}
{"id": "cvdp_agentic_diamond_orbit_valley_0001", "categories": ["cid004", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have an `traffic_controller_fsm` module that controls a traffic light, located at `/rtl/traffic_light_controller.sv`.  \nI want to modify the current design such that the light changes are driven by both short and long time intervals using the timer module, named `timer_module` in file `timer_module.sv` with below specification. Instantiate this timer module alongside the existing traffic-light FSM in a new top-level module, `traffic_light_controller_top` in file `traffic_light_controller_top.sv`.\nThe expected outcome is that short and long timing behaviors are cleanly separated into a new timer-based module, then integrated with the existing FSM in a new top-level design.\n\n---\n\n### **Timer Module Behavior**\n- The timer module tracks two different intervals, a \u201cshort\u201d duration and a \u201clong\u201d duration.  \n- When a short-timer trigger becomes active, the module counts cycles until it reaches the short duration limit. At that moment, it raises a signal indicating the short interval has expired.  \n- When a long-timer trigger becomes active, the module counts cycles until it reaches the long duration limit. At that moment, it raises a signal indicating the long interval has expired.  \n- If neither trigger is active, both timers are idle (or reset), and no expiration indication is set.  \n- When reset is asserted, all internal counters and any expired signals are cleared immediately.\n\n---\n\n### **Top-Level Integration**\n- Connect the timer\u2019s short and long triggers from the FSM, and feed the timer\u2019s expiration signals back into the FSM to drive state transitions.  \n- Pass the short and long duration thresholds (e.g., `SHORT_COUNT` and `LONG_COUNT`) from the top-level to the timer module.\n\n### **TOP LEVEL IOs**\n| **Port Name**             | **Direction** | **Bit Width**  | \n|---------------------------|---------------|----------------|\n| `i_clk`                   | Input         | 1              |\n| `i_rst_b`                 | Input         | 1              |\n| `i_vehicle_sensor_input`  | Input         | 1              |\n| `o_main`                  | Output        | 3              |\n| `o_side`                  | Output        | 3              |\n", "context": {"docs/Traffic_controller.md": "Design a **traffic controller finite state machine (FSM)** for a simple intersection in System Verilog names `traffic_controller_fsm`. Based on sensor inputs and timing signals, the FSM manages the traffic lights for both a main road and a side road. Your goal is to implement this FSM in System Verilog, adhering to the following specifications.\n\n#### Inputs and Outputs\n\n| Signal                        | Direction | Bit Width | Active Level | Description                                                                                |\n|-------------------------------|-----------|-----------|--------------|--------------------------------------------------------------------------------------------|\n| **`i_clk`**                   | Input     | 1         | \u2014            | System clock signal, with FSM transitions occurring on the rising edge.                    |\n| **`i_rst_b`**                 | Input     | 1         | Active-low   | Asynchronous reset signal. When asserted (`0`), FSM resets to its initial state.           |\n| **`i_vehicle_sensor_input`**  | Input     | 1         | Active-high  | Detects vehicle presence on the side road. High (`1`) when a vehicle is detected.          |\n| **`i_short_timer`**           | Input     | 1         | Active-high  | Indicates the expiration of the short timer. High (`1`) when the short timer expires.      |\n| **`i_long_timer`**            | Input     | 1         | Active-high  | Indicates the expiration of the long timer. High (`1`) when the long timer expires.        |\n| **`o_short_trigger`**         | Output    | 1         | Active-high  | Initiates the short timer. Set to high (`1`) to start the short timer.                     |\n| **`o_long_trigger`**          | Output    | 1         | Active-high  | Initiates the long timer. Set to high (`1`) to start the long timer.                       |\n| **`o_main[2:0]`**             | Output    | 3         | \u2014            | Controls main road traffic lights: Red (`3'b100`), Yellow (`3'b010`), Green (`3'b001`).    |\n| **`o_side[2:0]`**             | Output    | 3         | \u2014            | Controls side road traffic lights: Red (`3'b100`), Yellow (`3'b010`), Green (`3'b001`).    |\n\n#### FSM Output Table\n\n| State     | Description                           | `o_main`          | `o_side`          | `o_short_trigger`  | `o_long_trigger`  |\n|-----------|---------------------------------------|-------------------|-------------------|--------------------|-------------------|\n| **S1**    | Main road green, side road red        | `3'b001` (Green)  | `3'b100` (Red)    | 0                  | 1                 |\n| **S2**    | Main road yellow, side road red       | `3'b010` (Yellow) | `3'b100` (Red)    | 1                  | 0                 |\n| **S3**    | Main road red, side road green        | `3'b100` (Red)    | `3'b001` (Green)  | 0                  | 1                 |\n| **S4**    | Main road red, side road yellow       | `3'b100` (Red)    | `3'b010` (Yellow) | 1                  | 0                 |\n\n#### FSM Transition Logic\n- **S1 \u2192 S2**: Transition when a vehicle is detected (`i_vehicle_sensor_input = 1`) and the long timer expires (`i_long_timer = 1`).\n- **S2 \u2192 S3**: Transition upon short timer expiration (`i_short_timer = 1`).\n- **S3 \u2192 S4**: Transition when either vehicle is detected (`i_vehicle_sensor_input = 1`) or the long timer expires (`i_long_timer = 1`).\n- **S4 \u2192 S1**: Transition upon short timer expiration (`i_short_timer = 1`).\n\n#### Requirements\n1. **Reset Behavior**: When the reset signal is active (`i_rst_b = 0`), the FSM should reset to **State S1** with the following initial values:\n   - **`o_main`** set to `3'b000` (main road lights off).\n   - **`o_side`** set to `3'b000` (side road lights off).\n   - **`o_long_trigger`** set to `1'b0` (long timer trigger reset).\n   - **`o_short_trigger`** set to `1'b0` (short timer trigger reset).\n2. **Clocked Transitions**: The FSM should transition between states on the rising edge of the clock (`i_clk`).\n3. **Synchronized Outputs**: Ensure the traffic light outputs (`o_main` and `o_side`) and the timer triggers (`o_long_trigger`, `o_short_trigger`) are properly synchronized with state transitions.\n\n#### Additional Notes\n- Use local parameters for state encoding.\n- Implement a clean and efficient next-state logic and state-assignment logic based on the provided state descriptions.\n- Ensure the FSM behaves as expected in both typical and edge cases, including handling the reset signal and timer expirations correctly.", "rtl/traffic_light_controller.sv": "module traffic_controller_fsm ( \n    input i_clk,                     // System clock input\n    input i_rst_b,                   // Active-low reset signal\n    input i_vehicle_sensor_input,     // High when a vehicle is present on the side road\n    input i_short_timer,              // High when the short timer expires\n    input i_long_timer,               // High when the long timer expires\n    output reg o_short_trigger,       // Trigger for the short timer (active high)\n    output reg o_long_trigger,        // Trigger for the long timer (active high)\n    output reg [2:0] o_main,          // Main road traffic lights (3-bit: Red, Yellow, Green)\n    output reg [2:0] o_side           // Side road traffic lights (3-bit: Red, Yellow, Green)\n);\n    \n// State encoding for the FSM using local parameters\nlocalparam p_state_S1 = 2'd0 ;       // State S1: Main road green, side road red\nlocalparam p_state_S2 = 2'd1 ;       // State S2: Main road yellow, side road red\nlocalparam p_state_S3 = 2'd2 ;       // State S3: Main road red, side road green\nlocalparam p_state_S4 = 2'd3 ;       // State S4: Main road red, side road yellow\n\n// Registers for holding the current state and next state\nreg [1:0]   r_state;                 // Current state of the FSM\nreg [1:0]   r_next_state;            // Next state of the FSM\n\n//-----------------------------------------------------------------------------\n// Next State Logic\n//-----------------------------------------------------------------------------\n// This always block calculates the next state based on the current state and inputs\nalways @(*) begin\n    if (!i_rst_b) begin              // If reset is asserted (active-low)\n        r_next_state = p_state_S1;   // Go to initial state (S1) after reset\n    end else begin\n        case (r_state)\n        // State S1: Main road green, side road red\n        // Transition to S2 if a vehicle is detected and the long timer expires\n        p_state_S1: begin\n            if (i_vehicle_sensor_input & i_long_timer) begin\n                r_next_state = p_state_S2;  // Move to state S2 (main road yellow)\n            end else begin\n                r_next_state = p_state_S1;  // Remain in state S1 if no conditions met\n            end\n        end\n        // State S2: Main road yellow, side road red\n        // Transition to S3 when the short timer expires\n        p_state_S2: begin\n            if (i_short_timer) begin\n                r_next_state = p_state_S3;  // Move to state S3 (side road green)\n            end else begin\n                r_next_state = p_state_S2;  // Remain in state S2\n            end\n        end\n        // State S3: Main road red, side road green\n        // Transition to S4 if no vehicle is detected or the long timer expires\n        p_state_S3: begin\n            if ((!i_vehicle_sensor_input) | i_long_timer) begin\n                r_next_state = p_state_S4;  // Move to state S4 (side road yellow)\n            end else begin\n                r_next_state = p_state_S3;  // Remain in state S3\n            end\n        end\n        // State S4: Main road red, side road yellow\n        // Transition to S1 when the short timer expires\n        p_state_S4: begin\n            if (i_short_timer) begin\n                r_next_state = p_state_S1;  // Move to state S1 (main road green)\n            end else begin\n                r_next_state = p_state_S4;  // Remain in state S4\n            end\n        end\n        endcase\n    end\nend\n\n//-----------------------------------------------------------------------------\n// State Assignment Logic\n//-----------------------------------------------------------------------------\n// This always block updates the current state on the rising edge of the clock or reset\nalways @(posedge i_clk or negedge i_rst_b) begin\n    if (!i_rst_b) begin                  // If reset is asserted (active-low)\n        r_state <= p_state_S1;           // Initialize to state S1 after reset\n    end else begin\n        r_state <= r_next_state;         // Move to the next state on the clock edge\n    end\nend\n\n//-----------------------------------------------------------------------------\n// Output Logic\n//-----------------------------------------------------------------------------\n// This always block defines the output signals based on the current state\nalways @(posedge i_clk or negedge i_rst_b) begin\n    if (!i_rst_b) begin                  // If reset is asserted (active-low)\n        o_main <= 3'd0;                  // Reset main road lights\n        o_side <= 3'd0;                  // Reset side road lights\n        o_long_trigger <= 1'b0;          // Reset long timer trigger\n        o_short_trigger <= 1'b0;         // Reset short timer trigger\n    end else begin\n        case (r_state)\n        // State S1: Main road green, side road red, trigger long timer\n        p_state_S1: begin\n            o_main <= 3'b001;            // Main road green light\n            o_side <= 3'b100;            // Side road red light\n            o_long_trigger <= 1'b1;      // Trigger long timer\n            o_short_trigger <= 1'b0;     // Do not trigger short timer\n        end\n        // State S2: Main road yellow, side road red, trigger short timer\n        p_state_S2: begin\n            o_main <= 3'b010;            // Main road yellow light\n            o_side <= 3'b100;            // Side road red light\n            o_long_trigger <= 1'b0;      // Do not trigger long timer\n            o_short_trigger <= 1'b1;     // Trigger short timer\n        end\n        // State S3: Main road red, side road green, trigger long timer\n        p_state_S3: begin\n            o_main <= 3'b100;            // Main road red light\n            o_side <= 3'b001;            // Side road green light\n            o_long_trigger <= 1'b1;      // Trigger long timer\n            o_short_trigger <= 1'b0;     // Do not trigger short timer\n        end\n        // State S4: Main road red, side road yellow, trigger short timer\n        p_state_S4: begin\n            o_main <= 3'b100;            // Main road red light\n            o_side <= 3'b010;            // Side road yellow light\n            o_long_trigger <= 1'b0;      // Do not trigger long timer\n            o_short_trigger <= 1'b1;     // Trigger short timer\n        end\n        endcase\n    end\nend\n\nendmodule"}, "patch": {"rtl/timer_module.sv": "", "rtl/traffic_light_controller_top.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/traffic_light_controller.sv /code/rtl/timer_module.sv /code/rtl/traffic_light_controller_top.sv\nTOPLEVEL        = traffic_light_controller_top\nMODULE          = test_traffic_light_controller_top\nPYTHONPATH      = /src\nHASH            = 1-code-modification", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()", "src/test_traffic_light_controller_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge\n\nasync def reset_dut(dut):\n    await FallingEdge(dut.i_clk)\n    \"\"\"Apply an asynchronous reset to the DUT\"\"\"\n    dut.i_rst_b.value = 0\n    dut.i_vehicle_sensor_input.value = 0\n    \n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n\n    # Deassert reset\n    dut.i_rst_b.value = 1\n\n@cocotb.test()\nasync def test_traffic_light_controller_top(dut):\n    \"\"\"Full test of the traffic light controller (FSM + timer).\"\"\"\n\n    # Create and start a clock on i_clk\n    cocotb.start_soon(Clock(dut.i_clk, 10, units='ns').start())\n\n    # Reset the DUT\n    await reset_dut(dut)\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    #\n    # 1) Check initial state after reset: we expect S1 => (main=1, side=4).\n    #\n    # Because the FSM updates on the rising edge, we wait a bit:\n    await RisingEdge(dut.i_clk)\n    # Now check\n    assert dut.o_main.value == 1, f\"After reset, expected main=1 (green), got {dut.o_main.value}\"\n    assert dut.o_side.value == 4, f\"After reset, expected side=4 (red), got {dut.o_side.value}\"\n    dut._log.info(\"Starting in S1 (main=green, side=red) as expected.\")\n\n    #\n    # The FSM triggers the long timer in S1. By default, LONG_COUNT_PARAM=20.\n    # If no vehicle is present, S1 won't change, because S1 transitions only if:\n    #    (i_vehicle_sensor_input & i_long_timer) == 1\n    # So let's confirm that with no vehicle sensor, the FSM stays in S1 indefinitely.\n    #\n    # Wait a bit more than 20 cycles to see if it changes:\n    for i in range(25):\n        await RisingEdge(dut.i_clk)\n\n    assert dut.o_main.value == 1, (\n        \"No vehicle present -> we should STILL be in S1 (main=1) even though \"\n        \"the long timer expired. The FSM requires vehicle=1 to leave S1.\"\n    )\n    dut._log.info(\"Confirmed that with vehicle=0, the FSM remains in S1 after the timer expires.\")\n\n    #\n    # 2) Now introduce a vehicle sensor input => i_vehicle_sensor_input=1.\n    # Next time the long timer triggers (which will happen again after we re-enter S1?), \n    # the FSM will go from S1 -> S2.\n    #\n    dut.i_vehicle_sensor_input.value = 1\n    dut._log.info(\"Vehicle arrived -> i_vehicle_sensor_input=1. Waiting for next long timer expiration...\")\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    # Now we expect S2 => main=2 (yellow), side=4 (red).\n    assert dut.o_main.value == 2, f\"Expected S2 => main=2, got {dut.o_main.value}\"\n    assert dut.o_side.value == 4, f\"Expected side=4, got {dut.o_side.value}\"\n    dut._log.info(\"Transitioned to S2 (main=yellow, side=red).\")\n\n    #\n    # 3) In S2, the FSM triggers the short timer. The default SHORT_COUNT_PARAM=10.\n    # Wait ~10 cycles so that short timer expires, causing S2 -> S3.\n    #\n    for i in range(13):\n        await RisingEdge(dut.i_clk)\n\n    # Now we expect S3 => main=4 (red), side=1 (green).\n    assert dut.o_main.value == 4, f\"Expected S3 => main=4 (red), got {dut.o_main.value}\"\n    assert dut.o_side.value == 1, f\"Expected side=1 (green), got {dut.o_side.value}\"\n    dut._log.info(\"Transitioned to S3 (main=red, side=green).\")\n\n    #\n    # 4) In S3, the FSM triggers the long timer again. The default is 20 cycles.\n    # We remain in S3 until either no vehicle is detected or the long timer expires.\n    # We'll just let the long timer expire. \n    #\n    for i in range(25):\n        await RisingEdge(dut.i_clk)\n\n    # Once the long timer expires, we go to S4 => main=4 (red), side=2 (yellow).\n    assert dut.o_main.value == 4, f\"Expected S4 => main=4 (red), got {dut.o_main.value}\"\n    assert dut.o_side.value == 2, f\"Expected side=2 (yellow), got {dut.o_side.value}\"\n    dut._log.info(\"Transitioned to S4 (main=red, side=yellow).\")\n\n    #\n    # 5) Finally, in S4, the FSM triggers the short timer again (10 cycles).\n    # After it expires, we should return to S1 => main=1, side=4.\n    #\n    for i in range(12):\n        await RisingEdge(dut.i_clk)\n\n    assert dut.o_main.value == 1, f\"Expected S1 => main=1 (green), got {dut.o_main.value}\"\n    assert dut.o_side.value == 4, f\"Expected side=4 (red), got {dut.o_side.value}\"\n    dut._log.info(\"Returned to S1 (main=green, side=red). Test complete!\")\n    # Reset\n    await reset_dut(dut)\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n\n    # Confirm starting in S1 => main=1, side=4\n    assert dut.o_main.value == 1, \"Should be in S1 => main=green\"\n    assert dut.o_side.value == 4, \"Should be in S1 => side=red\"\n    dut._log.info(\"Start in S1 with no vehicle.\")\n\n    # We'll wait a very long time to confirm we never leave S1\n    for _ in range(200):  # e.g. 200 cycles\n        await RisingEdge(dut.i_clk)\n\n    # If no vehicle is present, FSM should STILL be in S1\n    # despite the long timer expiring repeatedly\n    assert dut.o_main.value == 1, \"Expected to remain in S1 (main=green)\"\n    assert dut.o_side.value == 4, \"Expected to remain in S1 (side=red)\"\n    dut._log.info(\"FSM stayed in S1 for a long time with no vehicle. Test passed.\")\n"}}
